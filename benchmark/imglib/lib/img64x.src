!<arch>
boundary.asm/   1066928952  0     0     0       14595     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:32:18 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       IMG_boundary -- Returns coordinates of IMG_boundary pixels.         *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and is called as follows:               *
*                                                                           *
*           void IMG_boundary                                               *
*           (                                                               *
*               const unsigned char *restrict i_data,                       *
*               int rows, int cols,                                         *
*               int *restrict o_coord,                                      *
*               int *restrict o_grey                                        *
*           );                                                              *
*                                                                           *
*       The arguments are defined as follows:                               *
*                                                                           *
*           i_data   Input images that is cols-by-rows in size.             *
*           rows     Height of the input image                              *
*           cols     Width of the input image                               *
*           o_coord  Array to write output coordinates to                   *
*           o_grey   Array to write output grey levels to                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine scans an image looking for non-zero pixels.            *
*       The locations of those pixels are stored out to the o_coord         *
*       as packed Y/X pairs, with Y in the upper half, and X in             *
*       the lower half.  The grey levels encountered are stored             *
*       in the o_grey array in parallel.                                    *
*                                                                           *
*       The following is a C code description of the kernel without         *
*       restrictions.  This implementation has restrictions as noted        *
*       in the assumptions below.                                           *
*                                                                           *
*         void IMG_boundary                                                 *
*         (                                                                 *
*             const unsigned char *restrict i_data,                         *
*             int rows, int cols,                                           *
*             int *restrict o_coord,                                        *
*             int *restrict o_grey                                          *
*         )                                                                 *
*         {                                                                 *
*             int x, y, p;                                                  *
*                                                                           *
*             for (y = 0; y < rows; y++)                                    *
*                 for (x = 0; x < cols; x++)                                *
*                     if ((p = i_data[x + y*cols] != 0)                     *
*                     {                                                     *
*                         *o_coord++ = ((y & 0xFFFF) << 16) |               *
*                                       (x & 0xFFFF);                       *
*                         *o_grey++  = p;                                   *
*                     }                                                     *
*         }                                                                 *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least one row is being processed.                                *
*                                                                           *
*       Input is word aligned.                                              *
*                                                                           *
*       Input is a multiple of 4 pixels wide.                               *
*                                                                           *
*       Output buffers o_coord and o_grey start in different banks          *
*       and are word-aligned.                                               *
*                                                                           *
*       No more than 32764 rows or 32764 columns are being processed.       *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer and inner loops are collapsed together.                       *
*       Inner loop is unrolled to process four pixels per iteration.        *
*       Packed coordinate value is updated directly, rather than            *
*       by repacking x, y every time it's needed.                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur as long as o_coord and o_grey start         *
*       in different banks.  If they start in the same bank, every          *
*       access to each array will cause a bank conflict.                    *
*                                                                           *
*   NOTES                                                                   *
*       This code blocks interrupts for nearly its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (5 * rows * cols) / 4 + 12.                                *
*                                                                           *
*   CODESIZE                                                                *
*       132 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_boundary"
        .global _IMG_boundary
_IMG_boundary: 
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_data
        .asg            B4,         B_rows
        .asg            A6,         A_cols
        .asg            B6,         B_o_coord
        .asg            A8,         A_o_grey
        .asg            A7,         A_c0
        .asg            A9,         A_c1
        .asg            A9,         A_c2
        .asg            A9,         A_c3
        .asg            B5,         B_p3210
        .asg            B0,         B_p3
        .asg            B0,         B_p2
        .asg            B0,         B_p1
        .asg            B0,         B_p0
        .asg            A1,         A_x
        .asg            A5,         A_r_step
        .asg            A3,         A_cols4
        .asg            A2,         A_i
        .asg            B3,         B_ret_addr
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,1]

        NEG     .L1     A_cols,     A_r_step
||      SHR     .S1     A_cols,     2,          A_cols4

        MVKLH   .S1     0,          A_r_step    ; r_step = 0x10000-cols
||      MPYU    .M1X    B_rows,     A_cols4,    A_i

        ZERO    .L1     A_c0

        MV      .L1     A_cols4,    A_x

  [ A_i]BDEC    .S1     loop,       A_i                         ;[ 6,1]
||      EXTU    .S2     B_p3210,    24, 24,     B_p0            ;[ 6,1]
||      LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,2]

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_p0]STW    .D2T1   A_c0,       *B_o_coord++                ;[ 7,1]
||[ B_p0]STW    .D1T2   B_p0,       *A_o_grey++                 ;[ 7,1]
||      EXTU    .S2     B_p3210,    16, 24,     B_p1            ;[ 7,1]
||      ADD     .S1     A_c0,       1,          A_c1            ;[ 7,1]
||      SUB     .L1     A_i,        1,          A_i

        SUB     .S1     A_x,        1,          A_x             ;[ 8,1]
||[ B_p1]STW    .D2T1   A_c1,       *B_o_coord++                ;[ 8,1]
||[ B_p1]STW    .D1T2   B_p1,       *A_o_grey++                 ;[ 8,1]
||      EXTU    .S2     B_p3210,    8,  24,     B_p2            ;[ 8,1]
||      ADD     .L1     A_c0,       2,          A_c2            ;[ 8,1]

        ADD     .S1     A_c0,       4,          A_c0            ;[ 9,1]
||[ B_p2]STW    .D2T1   A_c2,       *B_o_coord++                ;[ 9,1]
||[ B_p2]STW    .D1T2   B_p2,       *A_o_grey++                 ;[ 9,1]
||      SHRU    .S2     B_p3210,    24,         B_p3            ;[ 9,1]
||      ADD     .L1     A_c0,       3,          A_c3            ;[ 9,1]

  [!A_x]MV      .S1     A_cols4,    A_x                         ;[10,1]
||[!A_x]ADD     .L1     A_c0,       A_r_step,   A_c0            ;[10,1]
||[ B_p3]STW    .D2T1   A_c3,       *B_o_coord++                ;[10,1]
||[ B_p3]STW    .D1T2   B_p3,       *A_o_grey++                 ;[10,1]
||[!A_i]RET     .S2     B_ret_addr                              ; return

  [ A_i]BPOS    .S1     loop,       A_i                         ;[ 6,2]
||      EXTU    .S2     B_p3210,    24, 24,     B_p0            ;[ 6,2]
||[ A_i]LDW     .D1T2   *A_i_data++,            B_p3210         ;[ 1,3]
* ========================================================================= *

* ========================================================================= *
*   End of file:  img_boundary.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

conv_3x3.asm/   1066928952  0     0     0       31833     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Sep 29 03:32:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_conv_3x3    -- 3x3 convolution                                  *
*                                                                           *
*   REVISION DATE                                                           *
*       19-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_conv_3x3   (    const unsigned char *restrict inptr,       *
*                                  unsigned char *restrict outptr,          *
*                                           int            x_dim,           *
*                            const          char *restrict mask,            *
*                                           int            shift)           *
*                                                                           *
*      The convolution routine accepts three rows of 'x_dim' input points   *
*      and performs some operation on each.  A total of 'x_dim' outputs     *
*      are written to the output array. The 'mask' array has the 3 by 3     *
*      array of coefficients.                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      The convolution kernel accepts three rows of 'x_dim' input points    *
*      and produces one output row of 'x_dim' points using the input mask   *
*      of 3 by 3. The user defined shift value is used to shift the convo-  *
*      lution value, down to the byte range. The convolution sum is also    *
*      range limited to 0..255. The shift amount is non-zero for low pass   *
*      filters, and zero for high pass and sharpening filters.              *
*                                                                           *
*                                                                           *
*      The following is the C code model for the algorithm:                 *
*                                                                           *
*                                                                           *
*      void IMG_conv_3x3(   const unsigned char *restrict inptr,            *
*                                unsigned char *restrict outptr,            *
*                                         int            x_dim,             *
*                          const          char *restrict mask,              *
*                                         int            shift)             *
*      {                                                                    *
*           const   unsigned char   *IN1,*IN2,*IN3;                         *
*           unsigned char           *OUT;                                   *
*                                                                           *
*           short    pix10,  pix20,  pix30;                                 *
*           short    mask10, mask20, mask30;                                *
*                                                                           *
*           int      sum,      sum00,  sum11;                               *
*           int      i;                                                     *
*           int      sum22,    j;                                           *
*                                                                           *
*           IN1      =   inptr;                                             *
*           IN2      =   IN1 + x_dim;                                       *
*           IN3      =   IN2 + x_dim;                                       *
*           OUT      =   outptr;                                            *
*                                                                           *
*           for (j = 0; j < x_dim ; j++)                                    *
*           {                                                               *
*               sum = 0;                                                    *
*                                                                           *
*               for (i = 0; i < 3; i++)                                     *
*               {                                                           *
*                   pix10  =   IN1[i];                                      *
*                   pix20  =   IN2[i];                                      *
*                   pix30  =   IN3[i];                                      *
*                                                                           *
*                   mask10 =   mask[i];                                     *
*                   mask20 =   mask[i + 3];                                 *
*                   mask30 =   mask[i + 6];                                 *
*                                                                           *
*                   sum00  =   pix10 * mask10;                              *
*                   sum11  =   pix20 * mask20;                              *
*                   sum22  =   pix30 * mask30;                              *
*                                                                           *
*                   sum   +=   sum00 + sum11+ sum22;                        *
*               }                                                           *
*                                                                           *
*               IN1++;                                                      *
*               IN2++;                                                      *
*               IN3++;                                                      *
*                                                                           *
*               sum = (sum >> shift);                                       *
*               if ( sum <  0  )       sum = 0;                             *
*               if ( sum > 255 )       sum = 255;                           *
*               *OUT++   =       sum;                                       *
*           }                                                               *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*      The inner loop that computes the convolution sum is completely       *
*      unrolled and 8 output pixels are computed together. The mask         *
*      values are loaded and packed as double words.                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*      x_dim must be a multiple of 8.                                       *
*                                                                           *
*   NOTES                                                                   *
*      None                                                                 *
*                                                                           *
*   CYCLES                                                                  *
*      33 + x_dim/8 * 9                                                     *
*                                                                           *
*   CODESIZE                                                                *
*      724 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_conv_3x3"
        .global _IMG_conv_3x3
_IMG_conv_3x3:  ; A_INPTR, B_OUTPTR, A_inputcols, B_mask, A_shift 
                ; A4,      B4,       A6,          B6,     A8

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_h01word
        .asg            A0,         A_mask01
        .asg            A0,         A_mask20
        .asg            A1,         A_h20word
        .asg            A10,        A_line00
        .asg            A11,        A_line01
        .asg            A16,        A_pixel45
        .asg            A16,        A_prodA6
        .asg            A16,        A_sum1d
        .asg            A16,        A_sum2g
        .asg            A16,        A_SP
        .asg            A17,        A_pixel67a
        .asg            A17,        A_prodA7
        .asg            A17,        A_sum3b
        .asg            A18,        A_line04
        .asg            A18,        A_line14
        .asg            A18,        A_prodC8
        .asg            A18,        A_sum0g
        .asg            A18,        A_sum2h
        .asg            A19,        A_line05
        .asg            A19,        A_line15
        .asg            A19,        A_prodC9
        .asg            A19,        A_sum0e
        .asg            A19,        A_sum1a
        .asg            A2,         A_h02word
        .asg            A20,        A_line02
        .asg            A20,        A_pixel23a
        .asg            A20,        A_prodA4
        .asg            A21,        A_line03
        .asg            A21,        A_prodA5
        .asg            A22,        A_outword0
        .asg            A22,        A_pixel01a
        .asg            A22,        A_prodA10
        .asg            A22,        A_prodA8
        .asg            A23,        A_outword1
        .asg            A23,        A_prodA11
        .asg            A23,        A_prodA9
        .asg            A23,        A_sum0f
        .asg            A24,        A_pixel45a
        .asg            A24,        A_prodC2
        .asg            A25,        A_prodC3
        .asg            A26,        A_prodC0
        .asg            A26,        A_sum3a
        .asg            A27,        A_prodC1
        .asg            A28,        A_line13
        .asg            A28,        A_prodA2
        .asg            A29,        A_prodA3
        .asg            A3,         A_h22word
        .asg            A30,        A_prodA0
        .asg            A30,        A_sum1c
        .asg            A31,        A_mask
        .asg            A31,        A_mask00
        .asg            A31,        A_mask02
        .asg            A31,        A_prodA1
        .asg            A4,         A_INPTR
        .asg            A4,         A_sum0h
        .asg            A4,         A_sum1b
        .asg            A4,         A_sum2f
        .asg            A4,         A_sum3c
        .asg            A5,         A_IN1
        .asg            A6,         A_inputcols
        .asg            A6,         A_pixel01
        .asg            A7,         A_OPTR
        .asg            A8,         A_shift
        .asg            A9,         A_h00word
        .asg            B0,         B_h21word
        .asg            B0,         B_mask21
        .asg            B0,         B_roundval1
        .asg            B1,         B_h12word
        .asg            B1,         B_mask12
        .asg            B10,        B_h10word
        .asg            B15,        B_SP
        .asg            B16,        B_line22
        .asg            B16,        B_prodC4
        .asg            B16,        B_sum1g
        .asg            B16,        B_sum2a
        .asg            B16,        B_sum3e
        .asg            B17,        B_line23
        .asg            B17,        B_prodC5
        .asg            B17,        B_sum0b
        .asg            B17,        B_sum0d
        .asg            B18,        B_line12
        .asg            B18,        B_line24
        .asg            B18,        B_prodB4
        .asg            B19,        B_line25
        .asg            B19,        B_prodB5
        .asg            B19,        B_sum0a
        .asg            B2,         B_h11word
        .asg            B2,         B_mask11
        .asg            B20,        B_line20
        .asg            B20,        B_prodC10
        .asg            B20,        B_sum0c
        .asg            B21,        B_line21
        .asg            B21,        B_prodC11
        .asg            B22,        B_line10
        .asg            B22,        B_sum1h
        .asg            B23,        B_line11
        .asg            B23,        B_sum2d
        .asg            B23,        B_sum2e
        .asg            B23,        B_sum3f
        .asg            B24,        B_prodB0
        .asg            B24,        B_prodC6
        .asg            B24,        B_sum1f
        .asg            B24,        B_sum3d
        .asg            B25,        B_prodB1
        .asg            B25,        B_prodC7
        .asg            B26,        B_prodB8
        .asg            B26,        B_sum2c
        .asg            B27,        B_pixel23
        .asg            B27,        B_prodB9
        .asg            B28,        B_prodB2
        .asg            B28,        B_prodB6
        .asg            B28,        B_sum1e
        .asg            B29,        B_prodB3
        .asg            B29,        B_prodB7
        .asg            B30,        B_inputcols
        .asg            B30,        B_prodB10
        .asg            B31,        B_mask10
        .asg            B31,        B_mask22
        .asg            B31,        B_prodB11
        .asg            B31,        B_sum2b
        .asg            B4,         B_h22word
        .asg            B4,         B_h22word
        .asg            B4,         B_OUTPTR
        .asg            B5,         B_roundval
        .asg            B6,         B_count1
        .asg            B6,         B_mask
        .asg            B6,         B_pixel67
        .asg            B6,         B_sum3g
        .asg            B6,         B_sum3h
        .asg            B7,         B_IN3
        .asg            B8,         B_IN2
        .asg            B9,         B_count
        .asg            B9,         B_csr
        .asg            B9,         B_no_gie
* ========================================================================= *

        MVC     .S2     CSR,        B_csr
||      STW     .D2T1   A11,        *B_SP--[4]
||      MV      .L1X    B_SP,       A_SP
||      MV      .S1     A_INPTR,    A_IN1                       ;[10,0]
||      MV      .L2X    A_inputcols,            B_inputcols     ;[ 7,0]

        AND     .L2     B_csr,      -2,         B_no_gie
||      STW     .D2T2   B_csr,      *+B_SP[2]
||      STW     .D1T1   A10,        *-A_SP[1]
||      ADD     .S2X    A_IN1,      B_inputcols,B_IN2           ;[12,0]

        MVC     .S2     B_no_gie,   CSR
||      STW     .D2T2   B10,        *+B_SP[1]
||      ADD     .L2     B_IN2,      B_inputcols,B_IN3           ;[13,0]

        LDB     .D2T2   *+B_mask[8],            B_mask22        ;[ 3,0]
||      MV      .L1X    B_mask,     A_mask                      ;[ 3,0]

        LDB     .D2T2   *+B_mask[7],            B_mask21        ;[ 4,0]
||      LDB     .D1T1   *+A_mask[6],            A_mask20        ;[ 4,0]

        LDB     .D2T2   *+B_mask[5],            B_mask12        ;[ 5,0]
||      LDB     .D1T1   *+A_mask[2],            A_mask02        ;[ 5,0]

        MVK     .S2     0,          B_roundval1                 ;[ 6,0]
||      LDB     .D2T2   *+B_mask[4],            B_mask11        ;[ 6,0]
||      LDB     .D1T1   *+A_mask[1],            A_mask01        ;[ 6,0]

        PACK2   .L2     B_roundval1,B_roundval1,B_roundval      ;[ 7,0]
||      LDB     .D2T2   *+B_mask[3],            B_mask10        ;[ 7,0]
||      LDB     .D1T1   *+A_mask[0],            A_mask00        ;[ 7,0]

        SHRU    .S2     B_inputcols,3,          B_count1        ;[ 8,0]
||      PACK2   .L2     B_mask22,   B_mask22,   B_h22word       ;[ 8,0]
||      MV      .D1X    B_OUTPTR,   A_OPTR                      ;[12,0]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line21:B_line20       ;[ 1,1]

        PACKL4  .L2     B_h22word,  B_h22word,  B_h22word       ;[ 9,0]
||      PACK2   .S2     B_mask21,   B_mask21,   B_h21word       ;[ 9,0]
||      PACK2   .L1     A_mask20,   A_mask20,   A_h20word       ;[ 9,0]
||      LDNDW   .D2T2   *B_IN2++(2),            B_line11:B_line10       ;[ 2,1]

        PACKL4  .L2     B_h21word,  B_h21word,  B_h21word       ;[10,0]
||      PACKL4  .L1     A_h20word,  A_h20word,  A_h20word       ;[10,0]
||      PACK2   .S2     B_mask12,   B_mask12,   B_h12word       ;[10,0]
||      PACK2   .S1     A_mask02,   A_mask02,   A_h02word       ;[10,0]
||      LDNDW   .D2T1   *B_IN2++(6),            A_line15:A_line14       ;[ 3,1]

        PACKL4  .L2     B_h12word,  B_h12word,  B_h12word       ;[11,0]
||      PACK2   .S2     B_mask11,   B_mask11,   B_h11word       ;[11,0]
||      PACKL4  .L1     A_h02word,  A_h02word,  A_h02word       ;[11,0]
||      PACK2   .S1     A_mask01,   A_mask01,   A_h01word       ;[11,0]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line23:B_line22       ;[ 4,1]

        PACKL4  .L2     B_h11word,  B_h11word,  B_h11word       ;[12,0]
||      PACK2   .S2     B_mask10,   B_mask10,   B_h10word       ;[12,0]
||      PACKL4  .L1     A_h01word,  A_h01word,  A_h01word       ;[12,0]
||      PACK2   .S1     A_mask00,   A_mask00,   A_h00word       ;[12,0]
||      LDNDW   .D1T1   *A_IN1++(1),            A_line01:A_line00       ;[ 5,1]

        SUB     .S2     B_count1,   2,          B_count         ;[13,0]
||      MV      .S1X    B_h22word,  A_h22word                   ;[13,0]
||      PACKL4  .L2     B_h10word,  B_h10word,  B_h10word       ;[13,0]
||      PACKL4  .L1     A_h00word,  A_h00word,  A_h00word       ;[13,0]
||      LDNDW   .D1T1   *A_IN1++(1),            A_line03:A_line02       ;[ 6,1]

* =========================== PIPE LOOP PROLOG ============================ *
        MPYUS4  .M2     B_line11,   B_h10word,  B_prodB3:B_prodB2       ;[ 7,1]

        MPYSU4  .M1X    A_h20word,  B_line20,   A_prodC1:A_prodC0       ;[ 8,1]
||      MPYSU4  .M2X    B_h12word,  A_line15,   B_prodB11:B_prodB10     ;[ 8,1]
||      SHLMB   .S1     A_line14,   A_line15,   A_line13        ;[ 8,1]
||      SHRMB   .S2     B_line11,   B_line10,   B_line12        ;[ 8,1]
||      LDNDW   .D1T1   *A_IN1++(6),            A_line05:A_line04       ;[ 8,1]

; -
        MPYUS4  .M2     B_line23,   B_h21word,  B_prodC7:B_prodC6       ;[ 9,1]
||      MPYSU4  .M1X    A_h20word,  B_line21,   A_prodC3:A_prodC2       ;[ 9,1]
||      LDNDW   .D2T2   *B_IN3++(6),            B_line25:B_line24       ;[ 9,1]
||      B       .S1     L7

        MPYSU4  .M2X    B_h12word,  A_line14,   B_prodB9:B_prodB8       ;[10,1]
||      MPYUS4  .M1     A_line00,   A_h00word,  A_prodA1:A_prodA0       ;[10,1]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line21:B_line20       ;[ 1,2]
||      B       .S1     L8 + 12

        MPYUS4  .M2     B_line22,   B_h21word,  B_prodC5:B_prodC4       ;[11,1]
||      MPYUS4  .M1     A_line01,   A_h00word,  A_prodA3:A_prodA2       ;[11,1]
||      LDNDW   .D2T2   *B_IN2++(2),            B_line11:B_line10       ;[ 2,2]
||      B       .S1     L9

        MPYUS4  .M2     B_line10,   B_h10word,  B_prodB1:B_prodB0       ;[12,1]
||      MPYUS4  .M1     A_line02,   A_h01word,  A_prodA5:A_prodA4       ;[12,1]
||      LDNDW   .D2T1   *B_IN2++(6),            A_line15:A_line14       ;[ 3,2]
||      B       .S1     L1

        ADD2    .L2     B_roundval, B_prodC6,   B_sum2a         ;[13,1]
||      MPYUS4  .M2     B_line12,   B_h11word,  B_prodB5:B_prodB4       ;[13,1]
||      MPYUS4  .M1     A_line04,   A_h02word,  A_prodA9:A_prodA8       ;[13,1]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line23:B_line22       ;[ 4,2]
||      B       .S1     L2_P

        ADD2    .S2     B_prodB11,  B_roundval, B_sum3d         ;[14,1]
||      ADD2    .D2     B_sum2a,    B_prodB2,   B_sum2b         ;[14,1]
||      ADD2    .L2     B_prodB9,   B_roundval, B_sum1e         ;[14,1]
||      MPYUS4  .M2X    A_line13,   B_h11word,  B_prodB7:B_prodB6       ;[14,1]
||      MPYUS4  .M1     A_line03,   A_h01word,  A_prodA7:A_prodA6       ;[14,1]
||      LDNDW   .D1T1   *A_IN1++(1),            A_line01:A_line00       ;[ 5,2]
||      B       .S1     L3

;   L7, L8+12, L9, L1

L2_P:   ADD2    .S2     B_sum3f,    B_prodB7,   B_sum3g         ;[19,1]
||      ADD2    .D1     A_prodA11,  A_prodA7,   A_sum3a         ;[19,1]
||      ADD2    .L2     B_sum2c,    B_prodB10,  B_sum2d         ;[19,1]
||      ADD2    .L1     A_sum0e,    A_prodC0,   A_sum0f         ;[19,1]
||      MPYSU4  .M2X    B_h12word,  A_line14,   B_prodB9:B_prodB8       ;[10,2]
||      MPYUS4  .M1     A_line00,   A_h00word,  A_prodA1:A_prodA0       ;[10,2]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line21:B_line20       ;[ 1,3]
||      B       .S1     L8 + 4

;   L3, L4, L5, L6, L7, L8+4, L9

* =========================== PIPE LOOP KERNEL ============================ *
loop:
L1:     ADD2    .D1     A_sum2f,    A_prodA6,   A_sum2g         ;[18,2]
||      ADD2    .L2     B_sum2b,    B_prodB6,   B_sum2c         ;[18,2]
||      ADD2    .L1     A_sum1a,    A_prodC1,   A_sum1b         ;[18,2]
||      ADD2    .S1     A_prodA4,   A_prodA8,   A_sum0e         ;[18,2]
||      ADD2    .S2     B_sum0c,    B_prodB8,   B_sum0d         ;[18,2]
||      MPYUS4  .M2     B_line23,   B_h21word,  B_prodC7:B_prodC6       ;[ 9,3]
||      MPYSU4  .M1X    A_h20word,  B_line21,   A_prodC3:A_prodC2       ;[ 9,3]
||      LDNDW   .D2T2   *B_IN3++(6),            B_line25:B_line24       ;[ 9,3]

        SHR2    .S1X    B_pixel67,  A_shift,    A_pixel67a      ;[28,1]
||      ADD2    .S2     B_sum3f,    B_prodB7,   B_sum3g         ;[19,2]
||      ADD2    .D1     A_prodA11,  A_prodA7,   A_sum3a         ;[19,2]
||      ADD2    .L2     B_sum2c,    B_prodB10,  B_sum2d         ;[19,2]
||      ADD2    .L1     A_sum0e,    A_prodC0,   A_sum0f         ;[19,2]
||      MPYSU4  .M2X    B_h12word,  A_line14,   B_prodB9:B_prodB8       ;[10,3]
||      MPYUS4  .M1     A_line00,   A_h00word,  A_prodA1:A_prodA0       ;[10,3]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line21:B_line20       ;[ 1,4]

L3:     SPACKU4 .S1     A_pixel67a, A_pixel45a, A_outword1      ;[29,1]
||      ADD2    .L2     B_sum3g,    B_prodC11,  B_sum3h         ;[20,2]
||      ADD2    .L1     A_sum3a,    A_prodC3,   A_sum3b         ;[20,2]
||      ADD2    .S2     B_sum2d,    B_prodC10,  B_sum2e         ;[20,2]
||      ADD2    .D1     A_sum0f,    A_prodC8,   A_sum0g         ;[20,2]
||      MPYUS4  .M2     B_line22,   B_h21word,  B_prodC5:B_prodC4       ;[11,3]
||      MPYUS4  .M1     A_line01,   A_h00word,  A_prodA3:A_prodA2       ;[11,3]
||      LDNDW   .D2T2   *B_IN2++(2),            B_line11:B_line10       ;[ 2,4]

        BDEC    .S2     loop,       B_count                     ;[30,1]
||      SHR2    .S1X    B_pixel23,  A_shift,    A_pixel23a      ;[30,1]
||      ADD2    .L2     B_sum1f,    B_prodB1,   B_sum1g         ;[21,2]
||      ADD2    .D1     A_sum1b,    A_prodC9,   A_sum1c         ;[21,2]
||      ADD2    .L1     A_sum0g,    A_prodA0,   A_sum0h         ;[21,2]
||      MPYUS4  .M2     B_line10,   B_h10word,  B_prodB1:B_prodB0       ;[12,3]
||      MPYUS4  .M1     A_line02,   A_h01word,  A_prodA5:A_prodA4       ;[12,3]
||      LDNDW   .D2T1   *B_IN2++(6),            A_line15:A_line14       ;[ 3,4]

        SHR2    .S1     A_pixel01,  A_shift,    A_pixel01a      ;[31,1]
||      ADD2    .D1     A_sum2g,    A_prodA10,  A_sum2h         ;[22,2]
||      ADD2    .S2     B_sum1g,    B_prodB5,   B_sum1h         ;[22,2]
||      ADD2    .L1     A_sum1c,    A_prodA1,   A_sum1d         ;[22,2]
||      ADD2    .L2     B_roundval, B_prodC6,   B_sum2a         ;[13,3]
||      MPYUS4  .M2     B_line12,   B_h11word,  B_prodB5:B_prodB4       ;[13,3]
||      MPYUS4  .M1     A_line04,   A_h02word,  A_prodA9:A_prodA8       ;[13,3]
||      LDNDW   .D2T2   *B_IN3++(1),            B_line23:B_line22       ;[ 4,4]

        ADD2    .S1     A_sum3b,    A_prodA3,   A_sum3c         ;[23,2]
||      ADD2    .L1X    B_sum0d,    A_sum0h,    A_pixel01       ;[23,2]
||      ADD2    .S2     B_prodB11,  B_roundval, B_sum3d         ;[14,3]
||      ADD2    .D2     B_sum2a,    B_prodB2,   B_sum2b         ;[14,3]
||      ADD2    .L2     B_prodB9,   B_roundval, B_sum1e         ;[14,3]
||      MPYUS4  .M2X    A_line13,   B_h11word,  B_prodB7:B_prodB6       ;[14,3]
||      MPYUS4  .M1     A_line03,   A_h01word,  A_prodA7:A_prodA6       ;[14,3]
||      LDNDW   .D1T1   *A_IN1++(1),            A_line01:A_line00       ;[ 5,4]

L7:     SPACKU4 .S1     A_pixel23a, A_pixel01a, A_outword0      ;[33,1]
||      ADD2    .L1X    A_sum2h,    B_sum2e,    A_pixel45       ;[24,2]
||      ADD2    .S2X    B_sum1h,    A_sum1d,    B_pixel23       ;[24,2]
||      ADD2    .L2     B_sum3d,    B_prodC7,   B_sum3e         ;[15,3]
||      ADD2    .D2     B_roundval, B_prodC4,   B_sum0a         ;[15,3]
||      MPYSU4  .M2     B_h22word,  B_line25,   B_prodC11:B_prodC10     ;[15,3]
||      MPYUS4  .M1     A_line05,   A_h02word,  A_prodA11:A_prodA10     ;[15,3]
||      LDNDW   .D1T1   *A_IN1++(1),            A_line03:A_line02       ;[ 6,4]
L8:
        STNDW   .D1T1   A_outword1:A_outword0,  *A_OPTR++(8)    ;[34,1]
||      SHR2    .S1     A_pixel45,  A_shift,    A_pixel45a      ;[25,2]
||      ADD2    .L2X    B_sum3h,    A_sum3c,    B_pixel67       ;[25,2]
||      ADD2    .L1     A_prodC2,   A_prodA2,   A_sum2f         ;[16,3]
||      ADD2    .S2     B_sum1e,    B_prodC5,   B_sum1f         ;[16,3]
||      ADD2    .D2     B_sum0a,    B_prodB0,   B_sum0b         ;[16,3]
||      MPYSU4  .M1X    A_h22word,  B_line24,   A_prodC9:A_prodC8       ;[16,3]
||      MPYUS4  .M2     B_line11,   B_h10word,  B_prodB3:B_prodB2       ;[ 7,4]

L9:     ADD2    .D2     B_sum3e,    B_prodB3,   B_sum3f         ;[17,3]
||      ADD2    .L1     A_prodA9,   A_prodA5,   A_sum1a         ;[17,3]
||      ADD2    .L2     B_sum0b,    B_prodB4,   B_sum0c         ;[17,3]
||      MPYSU4  .M1X    A_h20word,  B_line20,   A_prodC1:A_prodC0       ;[ 8,4]
||      MPYSU4  .M2X    B_h12word,  A_line15,   B_prodB11:B_prodB10     ;[ 8,4]
||      SHLMB   .S1     A_line14,   A_line15,   A_line13        ;[ 8,4]
||      SHRMB   .S2     B_line11,   B_line10,   B_line12        ;[ 8,4]
||      LDNDW   .D1T1   *A_IN1++(6),            A_line05:A_line04       ;[ 8,4]

* =========================== PIPE LOOP EPILOG ============================ *
        SHR2    .S1X    B_pixel67,  A_shift,    A_pixel67a      ;[28,4]
||      LDW     .D2T2   *+B_SP[2],  B_csr

        SPACKU4 .S1     A_pixel67a, A_pixel45a, A_outword1      ;[29,4]
||      RET     .S2     B3
||      LDW     .D2T1   *+B_SP[3],  A10
||      MV      .L1X    B_SP,       A_SP

        SHR2    .S1X    B_pixel23,  A_shift,    A_pixel23a      ;[30,4]
||      LDW     .D2T1   *++B_SP[4], A11
||      LDW     .D1T2   *+A_SP[1],  B10

        SHR2    .S1     A_pixel01,  A_shift,    A_pixel01a      ;[31,4]

        MVC     .S2     B_csr,      CSR

        SPACKU4 .S1     A_pixel23a, A_pixel01a, A_outword0      ;[33,4]

        STNDW   .D1T1   A_outword1:A_outword0,  *A_OPTR++(8)    ;[34,4]


* ========================================================================= *
*   End of file:  img_conv_3x3.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

corr_3x3.asm/   1066928952  0     0     0       20527     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:32:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       corr_3x3: 3x3 correlation with rounding for 8 bit data              *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_corr_3x3                                               *
*           (                                                               *
*               const unsigned char *i_data,       // input image       //  *
*               int        *restrict o_data,       // output image      //  *
*               const unsigned char  mask[3][3],   // convolution mask  //  *
*               int                  x_dim,        // width of image    //  *
*               int                  n_out         // number of outputs //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The correlation performs a point by point multiplication of the     *
*       3 by 3 mask with the input image.  The result of the nine           *
*       multiplications are then summed up together to produce a            *
*       convolution sum.  This sum is then stored to the output array.      *
*                                                                           *
*       The image mask to be correlated is typically part of the input      *
*       image and indicates the area of the best match between the          *
*       input image and mask.  The mask is moved one column at a time,      *
*       advancing the mask over the portion of the row specified by         *
*       'n_out'.  When 'n_out' is larger than 'x_dim', multiple rows        *
*       will be processed.                                                  *
*                                                                           *
*       An application may call this kernel once per row to calculate       *
*       the correlation for an entire image:                                *
*                                                                           *
*           for (i = 0; i < rows; i++)                                      *
*           {                                                               *
*               IMG_corr_3x3(&i_data[i * x_dim], &o_data[i * n_out],        *
*                           mask, x_dim, n_out);                            *
*           }                                                               *
*                                                                           *
*       Alternately, the kernel may be invoked for multiple rows at         *
*       a time, although the two outputs at the end of each row will        *
*       have meaningless values.  For example:                              *
*                                                                           *
*           IMG_corr_3x3(i_data, o_data, mask, x_dim, 2 * x_dim);           *
*                                                                           *
*       This will produce two rows of outputs into 'o_data'.  The           *
*       outputs at locations o_data[x_dim - 2], o_data[x_dim - 1],          *
*       o_data[2*x_dim - 2] and o_data[2*x_dim - 1] will have               *
*       meaningless values.  This is harmless, although the application     *
*       will have to account for this when interpreting the results.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The array pointed to by o_data does not alias with the array        *
*       pointed to by i_data or mask.                                       *
*                                                                           *
*       The number of outputs 'n_out' must be a multiple of 8.  In cases    *
*       where 'n_out' is not a multiple of 8, most applications can safely  *
*       round 'n_out' up to the next multiple of 8 and ignore the extra     *
*       outputs.  This kernel does not round 'n_out' up for the user.       *
*                                                                           *
*   NOTE                                                                    *
*       This kernel is fully interruptible.                                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This kernel places no restrictions on the alignment of its input.   *
*                                                                           *
*       No bank conflicts occur.                                            *
*                                                                           *
*       This code assumes a LITTLE ENDIAN configuration.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loops are unrolled completely, and the outer loop is      *
*       unrolled 8 times.                                                   *
*                                                                           *
*       We use 3 DOTPU4s to calculate the 3 rows of each output pixel.      *
*       We then accumulate the 3 DOTPU4s to a 32-bit result and store       *
*       them out.  (Note that only 3 of every 4 8-bit MPYs in the DOTPU4    *
*       is actually used.  The fourth MPY is unused.)                       *
*                                                                           *
*       We use non-aligned loads and stores to avoid alignment issues.      *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 1.5 * n_out + 22                                           *
*       For n_out = 248, cycles = 394.                                      *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       296 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_corr_3x3_32"
        .global _IMG_corr_3x3
_IMG_corr_3x3:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_row0
        .asg            B4,         B_o_ptr
        .asg            A6,         A_mask
        .asg            B6,         B_x_dim
        .asg            A8,         A_n_out
        .asg            B3,         B_ret_addr

        .asg            A1,         A_i
        .asg            A16,        A_o0_r2
        .asg            A2,         A_h3210
        .asg            A3,         A_h7654
        .asg            A5,         A_h8
        .asg            A7,         A_h6543
        .asg            A8,         A_h8765
        .asg            A16,        A_o1_r1
        .asg            A17,        A_o1_r2
        .asg            A17,        A_o1_r21
        .asg            A17,        A_o2_r2
        .asg            A17,        A_o2_r21
        .asg            A18,        A_o0_r0
        .asg            A18,        A_o2_r1
        .asg            A19,        A_o3_r1
        .asg            A19,        A_o3_r21
        .asg            A20,        A_row2
        .asg            A21,        A_row1
        .asg            A22,        A_h2_210_
        .asg            A23,        A_h2__210
        .asg            A24,        A_h1_210_
        .asg            A25,        A_h1__210
        .asg            A26,        A_h0_210_
        .asg            A27,        A_h0__210
        .asg            A28,        A_o2
        .asg            A28,        A_o2_r0
        .asg            A29,        A_o3
        .asg            A29,        A_o3_r0
        .asg            A30,        A_o0
        .asg            A30,        A_o0_r1
        .asg            A30,        A_o0_r21
        .asg            A31,        A_o1
        .asg            A31,        A_o1_r0
        .asg            A31,        A_o3_r2
        .asg            B1,         B_p
        .asg            B6,         B_o4_r1
        .asg            B6,         B_o4_r21
        .asg            B7,         B_o5_r2
        .asg            B7,         B_o7_r0
        .asg            B8,         B_o4_r0
        .asg            B9,         B_o4_r2
        .asg            B9,         B_o5_r0
        .asg            B16,        B_o5_r1
        .asg            B16,        B_o7_r2
        .asg            B17,        B_o7_r1
        .asg            B18,        B_o6
        .asg            B18,        B_o6_r0
        .asg            B19,        B_o6_r1
        .asg            B19,        B_o7
        .asg            B20,        B_l1_5432
        .asg            B20,        B_o4
        .asg            B21,        B_l1_9876
        .asg            B21,        B_o5
        .asg            B21,        B_o5_r21
        .asg            B22,        B_l2_5432
        .asg            B23,        B_l2_9876
        .asg            B23,        B_o6_r2
        .asg            B24,        B_l0_5432
        .asg            B25,        B_l0_9876
        .asg            B26,        B_l0_3210
        .asg            B26,        B_o6_r21
        .asg            B27,        B_l0_7654
        .asg            B28,        B_l2_3210
        .asg            B29,        B_l2_7654
        .asg            B30,        B_l1_3210
        .asg            B31,        B_l1_7654
        .asg            B31,        B_o7_r21
* ========================================================================= *

        LDNDW   .D1T1   *A_mask(0), A_h7654:A_h3210

        LDBU    .D1T1   *A_mask(8), A_h8

        ADD     .L1X    A_row0,     B_x_dim,    A_row1

        ADD     .L1X    A_row1,     B_x_dim,    A_row2

        SHR     .S1     A_n_out,    3,          A_i
||      B               loop_6                  ; prolog collapse
* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D1T2   *+A_row1(2),            B_l1_9876:B_l1_5432 ;[ 1,1]
||      SHLMB   .L1     A_h3210,    A_h7654,    A_h6543

        LDNDW   .D1T2   *+A_row0(2),            B_l0_9876:B_l0_5432 ;[ 2,1]
||      SHRMB   .L1     A_h8,       A_h7654,    A_h8765
||      CLR     .S1     A_h6543,    24, 31,     A_h1__210

        LDNDW   .D1T2   *+A_row2(2),            B_l2_9876:B_l2_5432 ;[ 3,1]
||      CLR     .S1     A_h8765,    0,  7,      A_h2_210_
||      ROTL    .M1     A_h1__210,  8,          A_h1_210_

        LDNDW   .D1T2   *A_row2++(8),           B_l2_7654:B_l2_3210 ;[ 4,1]
||      ROTL    .M1     A_h2_210_,  24,         A_h2__210
||      CLR     .S1     A_h3210,    24, 31,     A_h0__210

        LDNDW   .D1T2   *A_row1++(8),           B_l1_7654:B_l1_3210 ;[ 5,1]
||      ROTL    .M1     A_h0__210,  8,          A_h0_210_
||      MVK     .D2     1,          B_p         ; prolog collapse

; ===== 6 cycles of prolog collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        DOTPU4  .M2X    B_l0_9876,  A_h0_210_,  B_o7_r0             ;[12,1]
||      DOTPU4  .M1X    B_l1_3210,  A_h1__210,  A_o0_r1             ;[12,1]
||[ A_i]SUB             A_i,        1,          A_i

        DOTPU4  .M2X    B_l1_7654,  A_h1__210,  B_o4_r1             ;[13,1]
||      DOTPU4  .M1X    B_l2_3210,  A_h2__210,  A_o0_r2             ;[13,1]
||[ A_i]LDNDW   .D1T2   *+A_row1(2),            B_l1_9876:B_l1_5432 ;[ 1,2]

        ADD     .L1     A_o2_r2,    A_o2_r1,    A_o2_r21            ;[14,1]
||      ADD     .D2     B_o7_r2,    B_o7_r1,    B_o7_r21            ;[14,1]
||      DOTPU4  .M1X    B_l0_3210,  A_h0__210,  A_o0_r0             ;[14,1]
||      DOTPU4  .M2X    B_l1_7654,  A_h1_210_,  B_o5_r1             ;[14,1]
||[ A_i]LDNDW   .D1T2   *+A_row0(2),            B_l0_9876:B_l0_5432 ;[ 2,2]

        ADD     .L1     A_o2_r21,   A_o2_r0,    A_o2                ;[15,1]
||      ADD     .S1     A_o3_r2,    A_o3_r1,    A_o3_r21            ;[15,1]
||      ADD     .D2     B_o6_r2,    B_o6_r1,    B_o6_r21            ;[15,1]
||      DOTPU4  .M1X    B_l0_3210,  A_h0_210_,  A_o1_r0             ;[15,1]
||      DOTPU4  .M2X    B_l0_7654,  A_h0__210,  B_o4_r0             ;[15,1]
||[ A_i]LDNDW   .D1T2   *+A_row2(2),            B_l2_9876:B_l2_5432 ;[ 3,2]

        ADD     .S1     A_o3_r21,   A_o3_r0,    A_o3                ;[16,1]
||      ADD     .D2     B_o7_r21,   B_o7_r0,    B_o7                ;[16,1]
||      DOTPU4  .M1X    B_l2_3210,  A_h2_210_,  A_o1_r2             ;[16,1]
||      DOTPU4  .M2X    B_l2_7654,  A_h2_210_,  B_o5_r2             ;[16,1]
||[ A_i]LDNDW   .D1T2   *A_row2++(8),           B_l2_7654:B_l2_3210 ;[ 4,2]

        ADD     .S2     B_o6_r21,   B_o6_r0,    B_o6                ;[17,1]
||      ADD     .L1     A_o0_r2,    A_o0_r1,    A_o0_r21            ;[17,1]
||      ADD     .D2     B_o4_r2,    B_o4_r1,    B_o4_r21            ;[17,1]
||      DOTPU4  .M2X    B_l0_7654,  A_h0_210_,  B_o5_r0             ;[17,1]
||      DOTPU4  .M1X    B_l1_3210,  A_h1_210_,  A_o1_r1             ;[17,1]
||[ A_i]LDNDW   .D1T2   *A_row1++(8),           B_l1_7654:B_l1_3210 ;[ 5,2]
loop_6:
  [!A_i]RET     .S2     B_ret_addr
||[ A_i]B       .S1     loop                                        ;[18,1]
||[!B_p]ADD     .L1     A_o0_r21,   A_o0_r0,    A_o0                ;[18,1]
||[ A_i]DOTPU4  .M1X    B_l1_5432,  A_h1_210_,  A_o3_r1             ;[ 6,2]
||[ A_i]DOTPU4  .M2X    B_l1_9876,  A_h1_210_,  B_o7_r1             ;[ 6,2]
||[ A_i]LDNDW   .D1T2   *A_row0++(8),           B_l0_7654:B_l0_3210 ;[ 6,2]

  [!B_p]STNDW   .D2T2   B_o7:B_o6,  *+B_o_ptr[3]                    ;[19,1]
||[!B_p]ADD     .S2     B_o4_r21,   B_o4_r0,    B_o4                ;[19,1]
||[ A_i]DOTPU4  .M1X    B_l1_5432,  A_h1__210,  A_o2_r1             ;[ 7,2]
||[ A_i]DOTPU4  .M2X    B_l1_9876,  A_h1__210,  B_o6_r1             ;[ 7,2]

  [!B_p]STNDW   .D2T1   A_o3:A_o2,  *+B_o_ptr[1]                    ;[20,1]
||[!B_p]ADD     .L2     B_o5_r2,    B_o5_r1,    B_o5_r21            ;[20,1]
||[ A_i]DOTPU4  .M1X    B_l0_5432,  A_h0__210,  A_o2_r0             ;[ 8,2]
||[ A_i]DOTPU4  .M2X    B_l2_9876,  A_h2_210_,  B_o7_r2             ;[ 8,2]

  [!B_p]ADD     .L2     B_o5_r21,   B_o5_r0,    B_o5                ;[21,1]
||[!B_p]ADD     .D1     A_o1_r2,    A_o1_r1,    A_o1_r21            ;[21,1]
||[ A_i]DOTPU4  .M1X    B_l0_5432,  A_h0_210_,  A_o3_r0             ;[ 9,2]
||[ A_i]DOTPU4  .M2X    B_l0_9876,  A_h0__210,  B_o6_r0             ;[ 9,2]

  [!B_p]STNDW   .D2T2   B_o5:B_o4,  *+B_o_ptr[2]                    ;[22,1]
||[!B_p]ADD     .D1     A_o1_r21,   A_o1_r0,    A_o1                ;[22,1]
||[ A_i]DOTPU4  .M1X    B_l2_5432,  A_h2__210,  A_o2_r2             ;[10,2]
||[ A_i]DOTPU4  .M2X    B_l2_9876,  A_h2__210,  B_o6_r2             ;[10,2]

  [!B_p]STNDW   .D2T1   A_o1:A_o0,  *B_o_ptr++[4]                   ;[23,1]
||[ A_i]DOTPU4  .M1X    B_l2_5432,  A_h2_210_,  A_o3_r2             ;[11,2]
||[ A_i]DOTPU4  .M2X    B_l2_7654,  A_h2__210,  B_o4_r2             ;[11,2]
||      ZERO    .S2     B_p
* =========================== PIPE LOOP EPILOG ============================ *
; ===== epilog collapsed completely
* ========================================================================= *
*   End of file:  img_corr_3x3.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

corr_gen.asm/   1066928952  0     0     0       32284     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.13    Sun Sep 29 03:32:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*           IMG_corr_gen                                                    *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       24-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_corr_gen                                                   *
*       (                                                                   *
*           short   *x,                                                     *
*           short   *h,                                                     *
*           short   *y,                                                     *
*           int     m,                                                      *
*           int     x_dim                                                   *
*       );                                                                  *
*                                                                           *
*       x[]   : Input pixel array.                                          *
*               Must be word aligned.                                       *
*       h[M]  : Input 1xM mask array                                        *
*       y[]   : Output array of correlation sum                             *
*               Must be double-word aligned.                                *
*       M     : Length of filter.                                           *
*       x_dim : Width of input image                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The routine performs a generalized correlation with a 1 by M tap    *
*       filter. It can be called repetitively to form an arbitrary MxN 2D   *
*       generalized correlation kernel. The correlation sum is stored as    *
*       half words. The input pixel, and mask data is assumed to come in    *
*       as shorts.  No restrictions apply to x_dim and M.                   *
*                                                                           *
*       If the width of the input image is x_dim and the mask is M then     *
*       the output array must have at-least a dimension of (x_dim - m + 8). *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_corr_gen(short *x, short *h, short *y, int M, int x_dim)   *
*       {                                                                   *
*           iters = x_dim - M;                                              *
*           for (j = 0; j < iters; j++)                                     *
*           {                                                               *
*               sum =  y[j];                                                *
*               for (i = 0; i < M; i++)                                     *
*               {                                                           *
*                   sum += xptr[i + j] * hptr[i];                           *
*               }                                                           *
*               y[j] = sum;                                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       It is advisable to software pipeline the loop that is expected to   *
*       iterate the most number of times. In the case of generalized        *
*       correlation since the number of filter taps M is not known          *
*       a priori the loop order interchange optimization is used and the    *
*       inner and outer loops of the natural C code are exchanged. If the   *
*       # of taps M is even then it is completely computed by using an      *
*       optimal 2 tap filter implementation. If M is odd then upto M - 1    *
*       even taps are computed using the 2 tap filter section and then a    *
*       1 tap filter section is used for odd tap.                           *
*                                                                           *
*       2 tap filter section:                                               *
*       The 2 tap filter section assumes that the input array is word       *
*       aligned. In order to minimize the load bandwidth the first word     *
*       is pre-loaded. Four words are read in and the last read is then     *
*       moved in as the new data allowing for data re-use. The dotp2        *
*       instructions allow for the first four even output samples to be     *
*       computed. Pack instructions then re-align  the input data so that   *
*       odd samples may be computed without re-loading data using           *
*       non-aligned loads.                                                  *
*                                                                           *
*       1 tap filter case and odd M filter case:                            *
*       For the 1 tap filter case the code jumps to the start of the 1 tap  *
*       filter case, and for the odd tap filter case the 2 tap filter       *
*       section is iterated for as many times as possible and the last odd  *
*       tap is computed using the 1 tap section.                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Array x[] must be word aligned, array y[ ] must be double-word      *
*       aligned, and array h[ ] must be half-word aligned.                  *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL.                                        *
*       The code is interrupt-tolerant, but not interruptible.              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occurr.                                           *
*                                                                           *
*   CYCLES                                                                  *
*       when M is even:                                                     *
*       M * [floor[(x_dim - M + 8)/4] + 11] + 38                            *
*                                                                           *
*       when M is odd:                                                      *
*       (M-1)*[floor[(x_dim - E + 8)/4] + 11] + 3 * (x_dim - E + 4)/4 + 48  *
*       with E = M + 1                                                      *
*                                                                           *
*       For M = 8, x_dim = 720, cycles = 1566                               *
*       For M = 9, x_dim = 720, cycles = 2102                               *
*                                                                           *
*   CODE SIZE                                                               *
*       636 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_corr_gen"
        .global _IMG_corr_gen
_IMG_corr_gen: 

*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            B6,         B_m
        .asg            B2,         B_jmp

*==============================================================================*
;-
        STW     .D2T1   A15,        *B_SP--[14]                 ; Save A15
||      MVC     .S2     CSR,        B_csr                       ; Capture CSR's state

        AND             B_csr,      -2,         B_no_gie        ; Clear GIE
||      MV              B_SP,       A_SP                        ; Twin Stack Pointer

        MV              B_csr,      A_csr                       ; Partitioning MV

        MVC     .S2     B_no_gie,   CSR                         ; Disable interrupts
||      STW     .D1T1   A_csr,      *+A_SP[ 2]                  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]                  ; return address

        SUB     .L2     B_m,        1,          B_jmp           ; if (m==1) jmp = 0


; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_x
        .asg            B4,         B_h
        .asg            A6,         A_y
        .asg            B6,         B_m
        .asg            A8,         A_x_dim
        .asg            B19,        B_xptr
        .asg            A20,        A_xptr
        .asg            A3,         A_h1h0
        .asg            B3,         B_h1h0
        .asg            B9,         B_yptr
        .asg            A17,        A_yptr
        .asg            B2,         B_p
        .asg            B7,         B_zptr
        .asg            A16,        A_zptr
        .asg            A9,         A_x1x0
        .asg            A7,         A_j
        .asg            B26,        B_hptr
        .asg            A28,        A_k
        .asg            A29,        A_iters
        .asg            B1,         B_i
        .asg            A30,        A_hptr
        .asg            A31,        A_h1
        .asg            B27,        B_h0
        .asg            A0,         A_tmp1
        .asg            A31,        A_tmp0
        .asg            B2,         B_jmp
; ============================================================================

  [!B_jmp]B     .S2     SKIP                            ;[19,0] if (!jmp) B END

        SUB     .D1X    A_x_dim,    B_m,        A_tmp0  ;[21,0] tmp0 = x - m

        AND     .D1     A_tmp0,     1,          A_tmp1  ;[22,0] odd/even
||      ADD     .L1X    B_h,        2,          A_hptr  ;[24,0]
||      MV      .D2     B_h,        B_hptr              ;[24,0] Copy filter ptr

;--

        LDH     .D1T1   *A_hptr++[2],           A_h1    ;[26,0] h1 = *hptr++
||      LDH     .D2T2   *B_hptr++[2],           B_h0    ;[26,0] h0 = *hptr++
||      ZERO    .L1     A_k                             ;[24,0] k = 0
||      SUB     .S2X    B_m,        A_tmp1,     B_i     ;[24,0] i = m - 1
||      SUB     .S1     A_tmp0,     A_tmp1,     A_iters ;[24,0] deduct 1 if odd

        SHR     .S2     B_i,        1,          B_i     ;[30,0] 2 filter coeffs
||      ADD     .D1     A_iters,    8,          A_iters ;[30,0] 8 outputs

LOOPI:
        ADDAH   .D1     A_x,        A_k,        A_xptr  ;[32,0] x[0], x[2]...

        ;==== Branch occurs

        LDW     .D1T1   *A_xptr++,  A_x1x0              ;[33,0] x1x0 first word

LOOPNI:

        MV      .L2X    A_y,        B_zptr              ;[34,0]
||      LDH     .D2T2   *B_hptr++[2],           B_h0    ;[34,0] h0 = *hptr++
||      LDH     .D1T1   *A_hptr++[2],           A_h1    ;[34,0] h1 = *hptr++


        MV      .D2X    A_y,        B_yptr              ;[35,0] yptr = y
||      PACK2   .S1X    A_h1,       B_h0,       A_h1h0  ;[34,0] h1h0

        SHR     .S1     A_iters,    3,          A_j     ;[36,0] j >> 3
||      ADD     .D1X    B_zptr,     8,          A_zptr  ;[36,0] zptr = z
||      MV      .L2X    A_xptr,     B_xptr              ;[36,0] xptr

;--
        SUB     .L1     A_j,        0,          A_j     ;[37,0]
||      ADD     .D1X    B_yptr,     8,          A_yptr  ;[37,0] yptr = &y[8]

        ADD     .L1     A_k,        2,          A_k     ;[38,0] k += 2
||      SUB     .S1     A_j,        1,          A_j     ;[38,0]
||      MVK     .L2     2,          B_p                 ;[38,0]
||      MV      .S2X    A_h1h0,     B_h1h0              ;[38,0] copy
||      ADD     .D1X    B_xptr,     4,          A_xptr  ;[38,0] xptr

;---
        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B19,        B_xptr
        .asg            A20,        A_xptr
        .asg            A3,         A_h1h0
        .asg            B3,         B_h1h0
        .asg            B9,         B_yptr
        .asg            A17,        A_yptr
        .asg            B2,         B_p
        .asg            B7,         B_zptr
        .asg            A16,        A_zptr
        .asg            A9,         A_x1x0
        .asg            A7,         A_j
        .asg            B5,         B_x3x2
        .asg            A19,        A_x5x4
        .asg            B21,        B_x7x6
        .asg            A21,        A_x9x8
        .asg            A22,        A_sum0
        .asg            B22,        B_sum2
        .asg            A5,         A_sum4
        .asg            B18,        B_sum6
        .asg            B22,        B_x2x1
        .asg            A18,        A_x4x3
        .asg            B21,        B_x6x5
        .asg            A21,        A_x8x7
        .asg            B20,        B_sum1
        .asg            B20,        B_sum3
        .asg            A22,        A_sum5
        .asg            A19,        A_sum7
        .asg            B18,        B_sum10
        .asg            B16,        B_sum32
        .asg            A18,        A_sum54
        .asg            A21,        A_sum76
        .asg            B17,        B_word1
        .asg            B16,        B_word0
        .asg            A25,        A_word3
        .asg            A24,        A_word2
        .asg            B24,        B_stor0
        .asg            B25,        B_stor1
        .asg            A26,        A_stor2
        .asg            A27,        A_stor3
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDW     .D1T1   *A_xptr++[2],           A_x5x4          ;[ 1,1] x5x4
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2          ;[ 1,1] x3x2

        LDW     .D1T1   *A_xptr++[2],           A_x9x8          ;[ 2,1] x9x8
||      LDW     .D2T2   *B_xptr++[2],           B_x7x6          ;[ 2,1] x7x6

        NOP             2

        LDW     .D1T1   *A_xptr++[2],           A_x5x4          ;[ 1,2] x5x4
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2          ;[ 1,2] x3x2
||      BDEC    .S1      LOOPJ,                 A_j

        LDW     .D1T1   *A_xptr++[2],           A_x9x8          ;[ 2,2] x9x8
||      LDW     .D2T2   *B_xptr++[2],           B_x7x6          ;[ 2,2] x7x6

; ============================ PIPE LOOP KERNEL ==============================
LOOPJ:
        ADD2    .L1     A_word2,    A_sum54,    A_stor2         ;[15,1] prev54 + sum54
||      ADD2    .L2     B_word1,    B_sum32,    B_stor1         ;[15,1] prev32 + sum32
||      LDDW    .D1T1   *A_yptr++[2],           A_word3:A_word2 ;[ 7,3] prev3:prev2
||      LDDW    .D2T2   *B_yptr++[2],           B_word1:B_word0 ;[ 7,3] prev1:prev0
||      PACKLH2 .S1X    A_x5x4,     B_x3x2,     A_x4x3          ;[ 7,3] x4x3
||      PACKLH2 .S2X    B_x3x2,     A_x1x0,     B_x2x1          ;[ 7,3] x2x1
||      DOTP2   .M2     B_h1h0,     B_x7x6,     B_sum6          ;[ 7,3] h0x6 + h1x7
||      DOTP2   .M1     A_h1h0,     A_x5x4,     A_sum4          ;[ 7,3] h0x4 + h1x5

  [!B_p]STDW    .D1T1   A_stor3:A_stor2,        *A_zptr++[2]    ;[16,1] zptr[1]= stor3:stor2
||[!B_p]STDW    .D2T2   B_stor1:B_stor0,        *B_zptr++[2]    ;[16,1] zptr[0]= stor1:stor0
||[ B_p]SUB     .S2     B_p,        1,          B_p             ;[12,2] if p p--
||      MV      .S1     A_x9x8,     A_x1x0                      ;[ 8,3] x1x0 = x9x8
||      DOTP2   .M2     B_h1h0,     B_x2x1,     B_sum1          ;[ 8,3] h0x1 + h1x2
||      PACKLH2 .L1X    A_x9x8,     B_x7x6,     A_x8x7          ;[ 8,3] x8x7
||      PACKLH2 .L2X    B_x7x6,     A_x5x4,     B_x6x5          ;[ 8,3] x6x5
||      DOTP2   .M1     A_h1h0,     A_x1x0,     A_sum0          ;[ 8,3] h0x0 + h1x1

        BDEC    .S1     LOOPJ,      A_j                         ;[13,2]
||      PACK2   .L1X    A_sum7,     B_sum6,     A_sum76         ;[13,2] sum7:sum6
||      PACK2   .L2X    B_sum1,     A_sum0,     B_sum10         ;[13,2] sum1:sum0
||      DOTP2   .M1     A_h1h0,     A_x8x7,     A_sum7          ;[ 9,3] h0x7 + h1x8
||      DOTP2   .M2     B_h1h0,     B_x3x2,     B_sum2          ;[ 9,3] h0x2 + h1x3
||      LDW     .D1T1   *A_xptr++[2],           A_x5x4          ;[ 1,5] x5x4
||      LDW     .D2T2   *B_xptr++[2],           B_x3x2          ;[ 1,5] x3x2

        ADD2    .L1     A_word3,    A_sum76,    A_stor3         ;[14,2] prev76 + sum76
||      ADD2    .S2     B_word0,    B_sum10,    B_stor0         ;[14,2] prev10 + sum10
||      PACK2   .S1     A_sum5,     A_sum4,     A_sum54         ;[14,2] sum5:sum4
||      PACK2   .L2     B_sum3,     B_sum2,     B_sum32         ;[14,2] sum3:sum2
||      DOTP2   .M1X    A_h1h0,     B_x6x5,     A_sum5          ;[10,3] h0x5 + h1x6
||      DOTP2   .M2X    B_h1h0,     A_x4x3,     B_sum3          ;[10,3] h0x3 + h1x4
||      LDW     .D1T1   *A_xptr++[2],           A_x9x8          ;[ 2,5] x9x8
||      LDW     .D2T2   *B_xptr++[2],           B_x7x6          ;[ 2,5] x7x6

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

        ADD2    .L1     A_word2,    A_sum54,    A_stor2         ;[15,5] prev54 + sum54
||      ADD2    .L2     B_word1,    B_sum32,    B_stor1         ;[15,5] prev32 + sum32
||[B_i] SUB     .D2     B_i,        1,          B_i             ;[25,0] if (i) i--

  [!B_p]STDW    .D1T1   A_stor3:A_stor2,        *A_zptr++[2]    ;[16,5] zptr[1]= stor3:stor2
||[!B_p]STDW    .D2T2   B_stor1:B_stor0,        *B_zptr++[2]    ;[16,5] zptr[0]= stor1:stor0
||[B_i] B       .S2     LOOPNI                                  ;[26,0] if (i) B LOOPI

; ============================================================================
; END:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B1,         B_i
        .asg            A0,         A_tmp1
        .asg            B6,         B_m
        .asg            A4,         A_x
        .asg            B4,         B_h
        .asg            A6,         A_y
        .asg            A29,        A_iters
        .asg            A20,        A_xptr
        .asg            B4,         B_hptr
        .asg            B3,         B_h0
        .asg            A1,         A_h0
        .asg            B19,        B_xptr
        .asg            A17,        A_yiptr
        .asg            B7,         B_ziptr
        .asg            A2,         A_od
        .asg            B2,         B_p
        .asg            B17,        B_yiptr
        .asg            A7,         A_ziptr
        .asg            A0,         A_tmp
; ============================================================================

        NOP             3

        ADDAH   .D1     A_x,        A_k,        A_xptr          ;[32,0] x[0], x[2]...
;--

         ;==== Branch occurs                                    ;[25,0]

        LDW     .D1T1   *A_xptr++,  A_x1x0                      ;[33,0] x1x0 first word


        ;==== Branch occurs                                     ;[32,0]

  [!A_tmp1]B    .S1     END                                     ;[33,0] if (even) end

        ;==== Branch occurs                                     ;[39,0]
SKIP:
                                                                ;[40,0]
        SUB     .L1X    B_m,        1,          A_tmp           ;[41,0] tmp = m - 1

        MPY     .M1     A_tmp,      2,          A_tmp           ;[42,0] Scale for HWORD

        NOP             2

        ADD     .L2X    B_h,        A_tmp,      B_hptr          ;[45,0] hptr = &h[m-1]

        LDH     .D2T2   *B_hptr,    B_h0                        ;[46,0] h0 = h[m-1]

        SUB     .L1     A_iters,    4,          A_od            ;[49,0] Iterate 4M times

        SHRU    .S1     A_od,       2,          A_od            ;[50,0] od >> 2
||      ADD     .D1     A_x,        A_tmp,      A_xptr          ;[50,0] xptr = &x[m-1]

        MV      .D1     A_y,        A_ziptr                     ;[51,0] A_ziptr = &y[0]
||      ADD     .L2X    A_y,        4,          B_yiptr         ;[51,0] B_yiptr = &y[2]
||      SUB     .L1     A_od,       1,          A_od            ;[51,0]
||      ADD     .S2X    A_y,        4,          B_ziptr         ;[51,0] B_ziptr = &y[2]

        MVK     .D2     3,          B_p                         ;[52,0]
||      MV      .L1     A_y,        A_yiptr                     ;[52,0] A_yiptr = &y[0]
||      MV      .L2X    A_xptr,     B_xptr                      ;[52,0] Make xptr copy
||      ADD     .D1     A_xptr,     4,          A_xptr          ;[52,0] A_xptr = &x[2]

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B19,        B_xptr
        .asg            A20,        A_xptr
        .asg            B3,         B_h0
        .asg            A1,         A_h0
        .asg            A17,        A_yiptr
        .asg            B7,         B_ziptr
        .asg            A2,         A_od
        .asg            B17,        B_yiptr
        .asg            A7,         A_ziptr
        .asg            B2,         B_p
        .asg            B5,         B_xword0
        .asg            A3,         A_xword1
        .asg            A16,        A_h0x0
        .asg            A9,         A_h0x1
        .asg            B18,        B_h0x2
        .asg            B16,        B_h0x3
        .asg            A9,         A_sum1_s
        .asg            A9,         A_sum_zero
        .asg            B16,        B_sum3_s
        .asg            B16,        B_sum_one
        .asg            A5,         A_y1y0
        .asg            B9,         B_y3y2
        .asg            A5,         A_z1z0
        .asg            B9,         B_z3z2
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDW     .D2T2   *B_xptr++[2],           B_xword0        ;[ 1,1] x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1        ;[ 1,1] x3x2 load
||      B       .S1      LOOPOD
||      MV      .L1X    B_h0,       A_h0                        ;[52,0] Make h0 copy

        NOP             1

        LDW     .D2T2   *B_xptr++[2],           B_xword0        ;[ 1,2] x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1        ;[ 1,2] x3x2 load


; ============================ PIPE LOOP KERNEL ==============================
LOOPOD:
  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[11,1]
||      ADD2    .L1     A_y1y0,     A_sum_zero, A_z1z0          ;[11,1] add2 to prev0
||      ADD2    .S2     B_y3y2,     B_sum_one,  B_z3z2          ;[11,1] add2 to prev1
||[ A_od]B      .S1     LOOPOD                                  ;[ 8,2] if (od) B LOOPOD
||      MPY     .M1X    A_h0,       B_xword0,   A_h0x0          ;[ 8,2] h0x0 = h0 * x0
||      MPY     .M2X    B_h0,       A_xword1,   B_h0x2          ;[ 8,2] h0x2 = h0 * x2
||      LDW     .D1T1   *A_yiptr++[2],          A_y1y0          ;[ 5,3] prev0
||      LDW     .D2T2   *B_yiptr++[2],          B_y3y2          ;[ 5,3] prev1

  [!B_p]STW     .D1T1   A_z1z0,     *A_ziptr++[2]               ;[12,1] pres0 store
||[!B_p]STW     .D2T2   B_z3z2,     *B_ziptr++[2]               ;[12,1] pres1 store
||      SHL     .S1     A_h0x1,     16,         A_sum1_s        ;[ 9,2] h0x1 << 16
||      SHL     .S2     B_h0x3,     16,         B_sum3_s        ;[ 9,2] h0x3 << 16

        ADD     .S1     A_sum1_s,   A_h0x0,     A_sum_zero      ;[10,2] h0x1 | h0x0
||      ADD     .L2     B_sum3_s,   B_h0x2,     B_sum_one       ;[10,2] h0x3 | h0x2
||[ A_od]SUB    .L1     A_od,       1,          A_od            ;[ 7,3] if (od) od--
||      MPYLH   .M1X    A_h0,       B_xword0,   A_h0x1          ;[ 7,3] h0x1 = h0 * x1
||      MPYLH   .M2X    B_h0,       A_xword1,   B_h0x3          ;[ 7,3] h0x3 = h0 * x3
||      LDW     .D2T2   *B_xptr++[2],           B_xword0        ;[ 1,5] x1x0 load
||      LDW     .D1T1   *A_xptr++[2],           A_xword1        ;[ 1,5] x3x2 load

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[11,5]
||      ADD2    .L1     A_y1y0,     A_sum_zero, A_z1z0          ;[11,5] add2 to prev0
||      ADD2    .S2     B_y3y2,     B_sum_one,  B_z3z2          ;[11,5] add2 to prev1

  [!B_p]STW     .D1T1   A_z1z0,     *A_ziptr++[2]               ;[12,5] pres0 store
||[!B_p]STW     .D2T2   B_z3z2,     *B_ziptr++[2]               ;[12,5] pres1 store

; ============================================================================

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A8,         A_x_dim
        .asg            B6,         B_m
        .asg            A6,         A_y
        .asg            A0,         A_xptr
        .asg            B0,         B_xptr
        .asg            A2,         A_z1z0
        .asg            A3,         A_z3z2
        .asg            A0,         A_h0
; ============================================================================

END
        SUB     .L1X    A_x_dim,    B_m,        A_h0            ;[ 3,0] x_dim - m

        ADDAH   .D1     A_y,        A_h0,       A_xptr          ;[ 4,0] y[x_dim - m]

        ZERO    .S1     A_z1z0                                  ;[ 5,0] z1z0 = 0
||      ZERO    .L1     A_z3z2                                  ;[ 5,0] z3z2 = 0

        ADD     .L2X    A_xptr,     2,          B_xptr          ;[ 6,0] odd/even
||      STNDW   .D      A_z3z2:A_z1z0,          *A_xptr++       ;[ 6,0]

        STNDW   .D      A_z3z2:A_z1z0,          *A_xptr++       ;[ 7,0]

        ;==== Branch occurs

        MV              B_SP,       A_SP        ; Twin Stack Pointer

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        NOP               4

        RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15

*====== Interruptibility state restored here ==================================*

        NOP             4
;====== Branch Occurs =====
*==============================================================================*
*=  End of file:  img_corr_gen.asm                                          =*
*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*
dilate_bin.asm/ 1066928952  0     0     0       20588     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sun Sep 29 03:32:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_dilate_bin--This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       19-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_dilate_bin                                                 *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_dilate_bin() implements binary dilation using an   *
*       arbitrary 3x3 mask.  The dilation operator generates output pixels  *
*       by ORing the pixels under the input mask together to generate       *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 0;                                                     *
*           if (mask[0][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the dilation operation.       *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 dilation mask is applied to 32 output pixels                *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           dilation operation.                                             *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (cols / 8) * 7 + 25  (Note: Number of pixels = 8*cols)     *
*       For 640 pixels, cols = 80 and cycles = 95.                          *
*       This corresponds to 0.14844 cycles/pixel.                           *
*                                                                           *
*   CODESIZE                                                                *
*       328 bytes.                                                          *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_dilate_bin"
        .global _IMG_dilate_bin
_IMG_dilate_bin:
* =============== SYMBOLIC REGISTER ASSIGNMENTS: ARGUMENTS ================ *
        .asg            A4,         A_in_data
        .asg            B4,         B_out_data
        .asg            A6,         A_mask
        .asg            B6,         B_cols
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_m4
        .asg            A1,         A_m2
        .asg            A2,         A_m1
        .asg            A2,         A_m3210
        .asg            A3,         A_m7654
        .asg            A4,         A_ir0
        .asg            A8,         A_ir2
        .asg            A9,         A_rC
        .asg            A16,        A_out_data
        .asg            A17,        A_ir1
        .asg            A18,        A_p2
        .asg            A19,        A_q2
        .asg            A19,        A_rB
        .asg            A20,        A_m0
        .asg            A21,        A_m3
        .asg            A22,        A_p4
        .asg            A22,        A_p7
        .asg            A22,        A_p8
        .asg            A23,        A_q4
        .asg            A23,        A_q7
        .asg            A23,        A_q8
        .asg            A23,        A_rslt
        .asg            A24,        A_p1
        .asg            A24,        A_p5
        .asg            A25,        A_q1
        .asg            A25,        A_q5
        .asg            A25,        A_rA
        .asg            A25,        A_rD
        .asg            A26,        A_p6
        .asg            A27,        A_p6h
        .asg            A28,        A_p3
        .asg            A29,        A_p3h
        .asg            A30,        A_p0
        .asg            A31,        A_p0h
        .asg            B0,         B_m8
        .asg            B1,         B_m7
        .asg            B2,         B_m5
        .asg            B5,         B_m7654
        .asg            B5,         B_m4
        .asg            B6,         B_rA
        .asg            B7,         B_ir2
        .asg            B8,         B_rB
        .asg            B9,         B_m6
        .asg            B16,        B_p1
        .asg            B16,        B_p2
        .asg            B16,        B_p5
        .asg            B17,        B_q1
        .asg            B17,        B_q2
        .asg            B17,        B_q5
        .asg            B18,        B_ir1
        .asg            B19,        B_i
        .asg            B20,        B_ir0
        .asg            B21,        B_m3
        .asg            B22,        B_p4
        .asg            B23,        B_q4
        .asg            B23,        B_rC
        .asg            B24,        B_p7
        .asg            B24,        B_p8
        .asg            B24,        B_rD
        .asg            B24,        B_rslt
        .asg            B25,        B_q7
        .asg            B25,        B_q8
        .asg            B25,        B_rslt_
        .asg            B26,        B_p6
        .asg            B27,        B_p6h
        .asg            B28,        B_p3
        .asg            B29,        B_p3h
        .asg            B30,        B_p0
        .asg            B31,        B_p0h
* ========================================================================= *

        LDB     .D1T2   *A_mask[8], B_m8

        LDNDW   .D1T1   *A_mask,    A_m7654:A_m3210

        ADD     .L2X    A_ir0,      B_cols,     B_ir1

        ADD     .D2X    A_ir0,      4,          B_ir0

        ADD     .L2     B_ir1,      B_cols,     B_ir2

        ADD     .L1X    B_ir1,      4,          A_ir1

* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D      *B_ir0++(8),            A_p0h:A_p0      ;[ 1,1]
||      SHR     .S2     B_m8,       31,         B_m8
||      MV      .L2X    A_m7654,    B_m7654

        LDNDW   .D      *A_ir1++(8),            A_p3h:A_p3      ;[ 2,1]
||      SHR     .S2     B_m7654,    31,         B_m7
||      SHR     .S1     A_m3210,    31,         A_m3

        LDNDW   .D      *B_ir1++(8),            B_p3h:B_p3      ;[ 3,1]
||      ADD             B_ir2,      4,          A_ir2
||      EXT     .S2     B_m7654,    8,  31,     B_m6
||      EXT     .S1     A_m3210,    8,  31,     A_m2

        LDNDW   .D      *A_ir2++(8),            A_p6h:A_p6      ;[ 4,1]
||      EXT     .S2     B_m7654,    16, 31,     B_m5
||      EXT     .S1     A_m3210,    24, 31,     A_m0

        LDNDW   .D      *A_ir0++(8),            B_p0h:B_p0      ;[ 5,1]
||      EXT     .S2     B_m7654,    24, 31,     B_m4
||      EXT     .S1     A_m3210,    16, 31,     A_m1

        SHR     .S1     A_p0h:A_p0, 2,          A_q2:A_p2       ;[ 6,1]
||      MV      .L1X    B_out_data,             A_out_data
||      SHR     .S2     B_cols,     3,          B_i

        ANDN    .D1     A_p3,       A_m3,       A_rB            ;[ 7,1]
||      SHR     .S1     A_p3h:A_p3, 2,          A_q5:A_p5       ;[ 7,1]
||      LDNDW   .D2T2   *B_ir2++(8),            B_p6h:B_p6      ;[ 7,1]
||      MV      .L1X    B_m4,       A_m4
||      ROTL    .M2X    A_m3,       0,          B_m3
||      SUB     .L2     B_i,        2,          B_i
||      B               loop_5 + 4

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_m7]OR     .L2     B_p7,       B_rA,       B_rA            ;[15,1]
||[!B_m5]OR     .L1     A_p5,       A_rB,       A_rB            ;[ 8,2]
||      ANDN    .D1     A_p0,       A_m0,       A_rC            ;[ 8,2]
||      SHR     .S1     A_p0h:A_p0, 1,          A_q1:A_p1       ;[ 8,2]
||      SHR     .S2     B_p3h:B_p3, 2,          B_q5:B_p5       ;[ 8,2]
||      LDNDW   .D      *B_ir0++(8),            A_p0h:A_p0      ;[ 1,3]

;loop_1:
        BDEC    .S2     loop,       B_i                         ;[16,1]
||      ROTL    .M2X    A_rslt,     0,          B_rslt_         ;[16,1]
||      OR      .L2     B_rA,       B_rB,       B_rD            ;[16,1]
||      ANDN    .L1X    A_p6,       B_m6,       A_rA            ;[ 9,2]
||      SHR     .S1     A_p3h:A_p3, 1,          A_q4:A_p4       ;[ 9,2]
||      ANDN    .D2     B_p3,       B_m3,       B_rB            ;[ 9,2]
||      LDNDW   .D      *A_ir1++(8),            A_p3h:A_p3      ;[ 2,3]

;loop_2:
        OR      .L2     B_rC,       B_rD,       B_rslt          ;[17,1]
||[!A_m2]OR     .D1     A_p2,       A_rC,       A_rC            ;[10,2]
||[!A_m4]OR     .L1     A_p4,       A_rB,       A_rB            ;[10,2]
||      SHR     .S1     A_p6h:A_p6, 2,          A_q8:A_p8       ;[10,2]
||      SHR     .S2     B_p3h:B_p3, 1,          B_q4:B_p4       ;[10,2]
||      LDNDW   .D      *B_ir1++(8),            B_p3h:B_p3      ;[ 3,3]

;loop_3:
  [!B_m8]OR     .L1     A_p8,       A_rA,       A_rA            ;[11,2]
||      SHR     .S1     A_p6h:A_p6, 1,          A_q7:A_p7       ;[11,2]
||[!B_m5]OR     .L2     B_p5,       B_rB,       B_rB            ;[11,2]
||      ANDN    .D2X    B_p0,       A_m0,       B_rC            ;[11,2]
||      SHR     .S2     B_p0h:B_p0, 2,          B_q2:B_p2       ;[11,2]
||      LDNDW   .D      *A_ir2++(8),            A_p6h:A_p6      ;[ 4,3]

;loop_4:
  [!A_m1]OR     .L1     A_p1,       A_rC,       A_rC            ;[12,2]
||[!B_m7]OR     .S1     A_p7,       A_rA,       A_rA            ;[12,2]
||[!A_m2]OR     .L2     B_p2,       B_rC,       B_rC            ;[12,2]
||      ANDN    .D2     B_p6,       B_m6,       B_rA            ;[12,2]
||      SHR     .S2     B_p0h:B_p0, 1,          B_q1:B_p1       ;[12,2]
||      LDNDW   .D      *A_ir0++(8),            B_p0h:B_p0      ;[ 5,3]

loop_5:
        STNDW   .D      B_rslt_:B_rslt,         *A_out_data++(8);[20,1]
||      OR      .L1     A_rA,       A_rB,       A_rD            ;[13,2]
||[!A_m1]OR     .D2     B_p1,       B_rC,       B_rC            ;[13,2]
||[!A_m4]OR     .L2     B_p4,       B_rB,       B_rB            ;[13,2]
||      SHR     .S2     B_p6h:B_p6, 2,          B_q8:B_p8       ;[13,2]
||      SHR     .S1     A_p0h:A_p0, 2,          A_q2:A_p2       ;[ 6,3]

;loop_6:
        OR      .L1     A_rC,       A_rD,       A_rslt          ;[14,2]
||[!B_m8]OR     .L2     B_p8,       B_rA,       B_rA            ;[14,2]
||      SHR     .S2     B_p6h:B_p6, 1,          B_q7:B_p7       ;[14,2]
||      ANDN    .D1     A_p3,       A_m3,       A_rB            ;[ 7,3]
||      SHR     .S1     A_p3h:A_p3, 2,          A_q5:A_p5       ;[ 7,3]
||      LDNDW   .D      *B_ir2++(8),            B_p6h:B_p6      ;[ 7,3]

* =========================== PIPE LOOP EPILOG ============================ *
        RET             B3

 [!B_m7]OR      .L2     B_p7,       B_rA,       B_rA            ;[15,3]

        ROTL    .M2X    A_rslt,     0,          B_rslt_         ;[16,3]

        OR      .L2     B_rA,       B_rB,       B_rD            ;[16,3]

        OR      .L2     B_rC,       B_rD,       B_rslt          ;[17,3]

        STNDW   .D      B_rslt_:B_rslt,         *A_out_data     ;[20,3]

* ========================================================================= *
*   End of file:  img_dilate_bin.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
erode_bin.asm/  1066928952  0     0     0       20586     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Sun Sep 29 03:32:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_erode_bin-- This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       19-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_erode_bin                                                  *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_erode_bin() implements binary erosion using an     *
*       arbitrary 3x3 mask.  The erosion operator generates output pixels   *
*       by ANDing the pixels under the input mask together to generate      *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 1;                                                     *
*           if (mask[0][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the erosion operation.        *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 erosion mask is applied to 32 output pixels                 *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           erosion operation.                                              *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (cols / 8) * 7 + 25  (Note: Number of pixels = 8*cols)     *
*       For 640 pixels, cols = 80 and cycles = 95.                          *
*       This corresponds to 0.14844 cycles/pixel.                           *
*                                                                           *
*   CODESIZE                                                                *
*       328 bytes.                                                          *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_erode_bin"
        .global _IMG_erode_bin
_IMG_erode_bin: 
* =============== SYMBOLIC REGISTER ASSIGNMENTS: ARGUMENTS ================ *
        .asg            A4,         A_in_data
        .asg            B4,         B_out_data
        .asg            A6,         A_mask
        .asg            B6,         B_cols
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_m4
        .asg            A1,         A_m2
        .asg            A2,         A_m1
        .asg            A2,         A_m3210
        .asg            A3,         A_m7654
        .asg            A4,         A_ir0
        .asg            A8,         A_ir2
        .asg            A9,         A_rC
        .asg            A16,        A_out_data
        .asg            A17,        A_ir1
        .asg            A18,        A_p2
        .asg            A19,        A_q2
        .asg            A19,        A_rB
        .asg            A20,        A_m0
        .asg            A21,        A_m3
        .asg            A22,        A_p4
        .asg            A22,        A_p7
        .asg            A22,        A_p8
        .asg            A23,        A_q4
        .asg            A23,        A_q7
        .asg            A23,        A_q8
        .asg            A23,        A_rslt
        .asg            A24,        A_p1
        .asg            A24,        A_p5
        .asg            A25,        A_q1
        .asg            A25,        A_q5
        .asg            A25,        A_rA
        .asg            A25,        A_rD
        .asg            A26,        A_p6
        .asg            A27,        A_p6h
        .asg            A28,        A_p3
        .asg            A29,        A_p3h
        .asg            A30,        A_p0
        .asg            A31,        A_p0h
        .asg            B0,         B_m8
        .asg            B1,         B_m7
        .asg            B2,         B_m5
        .asg            B5,         B_m7654
        .asg            B5,         B_m4
        .asg            B6,         B_rA
        .asg            B7,         B_ir2
        .asg            B8,         B_rB
        .asg            B9,         B_m6
        .asg            B16,        B_p1
        .asg            B16,        B_p2
        .asg            B16,        B_p5
        .asg            B17,        B_q1
        .asg            B17,        B_q2
        .asg            B17,        B_q5
        .asg            B18,        B_ir1
        .asg            B19,        B_i
        .asg            B20,        B_ir0
        .asg            B21,        B_m3
        .asg            B22,        B_p4
        .asg            B23,        B_q4
        .asg            B23,        B_rC
        .asg            B24,        B_p7
        .asg            B24,        B_p8
        .asg            B24,        B_rD
        .asg            B24,        B_rslt
        .asg            B25,        B_q7
        .asg            B25,        B_q8
        .asg            B25,        B_rslt_
        .asg            B26,        B_p6
        .asg            B27,        B_p6h
        .asg            B28,        B_p3
        .asg            B29,        B_p3h
        .asg            B30,        B_p0
        .asg            B31,        B_p0h
* ========================================================================= *

        LDB     .D1T2   *A_mask[8], B_m8

        LDNDW   .D1T1   *A_mask,    A_m7654:A_m3210

        ADD     .L2X    A_ir0,      B_cols,     B_ir1

        ADD     .D2X    A_ir0,      4,          B_ir0

        ADD     .L2     B_ir1,      B_cols,     B_ir2

        ADD     .L1X    B_ir1,      4,          A_ir1

* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D      *B_ir0++(8),            A_p0h:A_p0      ;[ 1,1]
||      SHR     .S2     B_m8,       31,         B_m8
||      MV      .L2X    A_m7654,    B_m7654

        LDNDW   .D      *A_ir1++(8),            A_p3h:A_p3      ;[ 2,1]
||      SHR     .S2     B_m7654,    31,         B_m7
||      SHR     .S1     A_m3210,    31,         A_m3

        LDNDW   .D      *B_ir1++(8),            B_p3h:B_p3      ;[ 3,1]
||      ADD             B_ir2,      4,          A_ir2
||      EXT     .S2     B_m7654,    8,  31,     B_m6
||      EXT     .S1     A_m3210,    8,  31,     A_m2

        LDNDW   .D      *A_ir2++(8),            A_p6h:A_p6      ;[ 4,1]
||      EXT     .S2     B_m7654,    16, 31,     B_m5
||      EXT     .S1     A_m3210,    24, 31,     A_m0

        LDNDW   .D      *A_ir0++(8),            B_p0h:B_p0      ;[ 5,1]
||      EXT     .S2     B_m7654,    24, 31,     B_m4
||      EXT     .S1     A_m3210,    16, 31,     A_m1

        SHR     .S1     A_p0h:A_p0, 2,          A_q2:A_p2       ;[ 6,1]
||      MV      .L1X    B_out_data,             A_out_data
||      SHR     .S2     B_cols,     3,          B_i

        OR      .D1     A_p3,       A_m3,       A_rB            ;[ 7,1]
||      SHR     .S1     A_p3h:A_p3, 2,          A_q5:A_p5       ;[ 7,1]
||      LDNDW   .D2T2   *B_ir2++(8),            B_p6h:B_p6      ;[ 7,1]
||      MV      .L1X    B_m4,       A_m4
||      ROTL    .M2X    A_m3,       0,          B_m3
||      SUB     .L2     B_i,        2,          B_i
||      B               loop_5 + 4

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_m7]AND    .L2     B_p7,       B_rA,       B_rA            ;[15,1]
||[!B_m5]AND    .L1     A_p5,       A_rB,       A_rB            ;[ 8,2]
||      OR      .D1     A_p0,       A_m0,       A_rC            ;[ 8,2]
||      SHR     .S1     A_p0h:A_p0, 1,          A_q1:A_p1       ;[ 8,2]
||      SHR     .S2     B_p3h:B_p3, 2,          B_q5:B_p5       ;[ 8,2]
||      LDNDW   .D      *B_ir0++(8),            A_p0h:A_p0      ;[ 1,3]

;loop_1:
        BDEC    .S2     loop,       B_i                         ;[16,1]
||      ROTL    .M2X    A_rslt,     0,          B_rslt_         ;[16,1]
||      AND     .L2     B_rA,       B_rB,       B_rD            ;[16,1]
||      OR      .L1X    A_p6,       B_m6,       A_rA            ;[ 9,2]
||      SHR     .S1     A_p3h:A_p3, 1,          A_q4:A_p4       ;[ 9,2]
||      OR      .D2     B_p3,       B_m3,       B_rB            ;[ 9,2]
||      LDNDW   .D      *A_ir1++(8),            A_p3h:A_p3      ;[ 2,3]

;loop_2:
        AND     .L2     B_rC,       B_rD,       B_rslt          ;[17,1]
||[!A_m2]AND    .D1     A_p2,       A_rC,       A_rC            ;[10,2]
||[!A_m4]AND    .L1     A_p4,       A_rB,       A_rB            ;[10,2]
||      SHR     .S1     A_p6h:A_p6, 2,          A_q8:A_p8       ;[10,2]
||      SHR     .S2     B_p3h:B_p3, 1,          B_q4:B_p4       ;[10,2]
||      LDNDW   .D      *B_ir1++(8),            B_p3h:B_p3      ;[ 3,3]

;loop_3:
  [!B_m8]AND    .L1     A_p8,       A_rA,       A_rA            ;[11,2]
||      SHR     .S1     A_p6h:A_p6, 1,          A_q7:A_p7       ;[11,2]
||[!B_m5]AND    .L2     B_p5,       B_rB,       B_rB            ;[11,2]
||      OR      .D2X    B_p0,       A_m0,       B_rC            ;[11,2]
||      SHR     .S2     B_p0h:B_p0, 2,          B_q2:B_p2       ;[11,2]
||      LDNDW   .D      *A_ir2++(8),            A_p6h:A_p6      ;[ 4,3]

;loop_4:
  [!A_m1]AND    .L1     A_p1,       A_rC,       A_rC            ;[12,2]
||[!B_m7]AND    .S1     A_p7,       A_rA,       A_rA            ;[12,2]
||[!A_m2]AND    .L2     B_p2,       B_rC,       B_rC            ;[12,2]
||      OR      .D2     B_p6,       B_m6,       B_rA            ;[12,2]
||      SHR     .S2     B_p0h:B_p0, 1,          B_q1:B_p1       ;[12,2]
||      LDNDW   .D      *A_ir0++(8),            B_p0h:B_p0      ;[ 5,3]

loop_5:
        STNDW   .D      B_rslt_:B_rslt,         *A_out_data++(8);[20,1]
||      AND     .L1     A_rA,       A_rB,       A_rD            ;[13,2]
||[!A_m1]AND    .D2     B_p1,       B_rC,       B_rC            ;[13,2]
||[!A_m4]AND    .L2     B_p4,       B_rB,       B_rB            ;[13,2]
||      SHR     .S2     B_p6h:B_p6, 2,          B_q8:B_p8       ;[13,2]
||      SHR     .S1     A_p0h:A_p0, 2,          A_q2:A_p2       ;[ 6,3]

;loop_6:
        AND     .L1     A_rC,       A_rD,       A_rslt          ;[14,2]
||[!B_m8]AND    .L2     B_p8,       B_rA,       B_rA            ;[14,2]
||      SHR     .S2     B_p6h:B_p6, 1,          B_q7:B_p7       ;[14,2]
||      OR      .D1     A_p3,       A_m3,       A_rB            ;[ 7,3]
||      SHR     .S1     A_p3h:A_p3, 2,          A_q5:A_p5       ;[ 7,3]
||      LDNDW   .D      *B_ir2++(8),            B_p6h:B_p6      ;[ 7,3]

* =========================== PIPE LOOP EPILOG ============================ *
        RET             B3

 [!B_m7]AND     .L2     B_p7,       B_rA,       B_rA            ;[15,3]

        ROTL    .M2X    A_rslt,     0,          B_rslt_         ;[16,3]

        AND     .L2     B_rA,       B_rB,       B_rD            ;[16,3]

        AND     .L2     B_rC,       B_rD,       B_rslt          ;[17,3]

        STNDW   .D      B_rslt_:B_rslt,         *A_out_data     ;[20,3]

* ========================================================================= *
*   End of file:  img_erode_bin.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
errdif_bin.asm/ 1066928952  0     0     0       26921     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:32:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_errdif_bin -- Binary Floyd-Steinberg Error Diffusion.           *
*                                                                           *
*   REVISION DATE                                                           *
*       23-May-2002                                                         *
*                                                                           *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*               void IMG_errdif_bin                                         *
*               (                                                           *
*                   unsigned char *restrict errdif_data,                    *
*                   int           cols,                                     *
*                   int           rows,                                     *
*                   short         *restrict err_buf,                        *
*                   unsigned char thresh                                    *
*               )                                                           *
*                                                                           *
*       errdif_data:     Input/Output image ptr                             *
*       cols:            Number of columns (Width). Must be >= 2.           *
*       rows:            Number of rows    (Height)                         *
*       err_buf:         Buffer where one row of errors is to be saved      *
*       thresh:          Threshold in the range [0x00, 0xFF]                *
*                                                                           *
*       errdif_data[] is used for both input and output and the number      *
*       of colums, cols, must be at least 2.  No restriction on number      *
*       of rows.                                                            *
*                                                                           *
*       err_buf[], additional buffer, should be provided with               *
*       initialized to all-zero's for the first call with an image.         *
*       The subsequent call with the same image should provide this         *
*       kernel the returned err_buf The size of err_buf should be           *
*       (cols+1)*Half-Word.                                                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code implements the Binary Floyd-Steinberg error diffusion      *
*       filter.  The filter kernel used is this one:                        *
*                                                                           *
*                                   +---+                                   *
*                                 P | 7 |                                   *
*                           +---+---+---+                                   *
*                           | 3 | 5 | 1 |                                   *
*                           +---+---+---+                                   *
*                                                                           *
*                                                                           *
*       Pixels are processed from left-to-right, top-to-bottom.  Each       *
*       pixel is compared against a user-defined threshold.  Pixels         *
*       that are larger than the threshold are set to 255, and pixels       *
*       that are smaller or equal to the threshold are set to 0.  The       *
*       error value for the pixel (eg. the difference between the           *
*       thresholded pixel and its original grey level) is propagated to     *
*       the neighboring pixels according to the filter above.  This         *
*       error propagation diffuses the error over a larger area, hence      *
*       the term "error diffusion."                                         *
*                                                                           *
*       The following C code illustrates the algorithm.  The C code is      *
*       a general implementation without restrictions.  This version        *
*       may have restriction as noted in the ASSUMPTIONS below.             *
*                                                                           *
*       void IMG_errdif_bin                                                 *
*       (                                                                   *
*          unsigned char *restrict                                          *
*                        errdif_data,    /* Input/Output image ptr      */  *
*          int           cols,           /* Number of columns (Width)   */  *
*          int           rows,           /* Number of rows    (Height)  */  *
*          short         *restrict                                          *
*                        err_buf,        /* row-to-row error buffer.    */  *
*          unsigned char thresh          /* Threshold from [0x00, 0xFF] */  *
*       )                                                                   *
*       {                                                                   *
*          int   x, i, y;        /* Loop counters                       */  *
*          int   F;              /* Current pixel value at [x,y]        */  *
*          int   errA;           /* Error value at [x-1, y-1]           */  *
*          int   errB;           /* Error value at [  x, y-1]           */  *
*          int   errC;           /* Error value at [x+1, y-1]           */  *
*          int   errE;           /* Error value at [x-1,   y]           */  *
*          int   errF;           /* Error value at [  x,   y]           */  *
*                                                                           *
*          /* --------------------------------------------------------- */  *
*          /*  Step through rows of pixels.                             */  *
*          /* --------------------------------------------------------- */  *
*          for (y = 0, i = 0; y < rows; y++)                                *
*          {                                                                *
*             /* ------------------------------------------------------ */  *
*             /*  Start off with our initial errors set to zero at      */  *
*             /*  the start of the line since we do not have any        */  *
*             /*  pixels to the left of the row.  These error terms     */  *
*             /*  are maintained within the inner loop.                 */  *
*             /* ------------------------------------------------------ */  *
*             errA = 0; errE = 0;                                           *
*             errB = err_buf[0];                                            *
*                                                                           *
*             /* ------------------------------------------------------ */  *
*             /*  Step through pixels in each row.                      */  *
*             /* ------------------------------------------------------ */  *
*             for (x = 0; x < cols; x++, i++)                               *
*             {                                                             *
*                /* --------------------------------------------------- */  *
*                /*  Load the error being propagated from pixel 'C'     */  *
*                /*  from our error buffer.  This was calculated        */  *
*                /*  during the previous line.                          */  *
*                /* --------------------------------------------------- */  *
*                errC = err_buf[x+1];                                       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Load our pixel value to quantize.                  */  *
*                /* --------------------------------------------------- */  *
*                F = errdif_data[i];                                        *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Calculate our resulting pixel.  If we assume       */  *
*                /*  that this pixel will be set to zero, this also     */  *
*                /*  doubles as our error term.                         */  *
*                /* --------------------------------------------------- */  *
*                errF = F + ((errE*7 + errA + errB*5 + errC*3) >> 4);       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Set pixels that are larger than the threshold to   */  *
*                /*  255, and pixels that are smaller than the          */  *
*                /*  threshold to 0.                                    */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  errdif_data[i] = 0xFF;                 *
*                else                errdif_data[i] = 0;                    *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  If the pixel was larger than the threshold, then   */  *
*                /*  we need subtract 255 from our error.  In any       */  *
*                /*  case, store the error to the error buffer.         */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  err_buf[x] = errF = errF - 0xFF;       *
*                else                err_buf[x] = errF;                     *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Propagate error terms for the next pixel.          */  *
*                /* --------------------------------------------------- */  *
*                errE = errF;                                               *
*                errA = errB;                                               *
*                errB = errC;                                               *
*             }                                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Constants, 7, 5, 3, 1 for multiplication are shifted left 12 to     *
*       avoid 'SHR 4' operation in the critical path.                       *
*                                                                           *
*       The processing of the filter itself is inverted so that the         *
*       errors from previous pixels "propagate into" a given pixel at       *
*       the time the pixel is processed, rather than "accumulate into"      *
*       a pixel as its neighbors are processed.  This allows us to          *
*       keep our image as an 8-bit image, and reduces the number of         *
*       accesses to the image array.  The inverted filter kernel            *
*       performs identically to the kernel's original form.  In this        *
*       form, the weights specify the weighting assigned to the errors      *
*       coming from the neighboring pixels.                                 *
*                                                                           *
*                           +---+---+---+                                   *
*                           | 1 | 5 | 3 |                                   *
*                           +---+---+---+                                   *
*                           | 7 | P                                         *
*                           +---+                                           *
*                                                                           *
*       The inner loop is software-pipelined.                               *
*                                                                           *
*       The outer loop has been interleaved with the prolog and epilog      *
*       of the inner loop.                                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of columns must be at least 2.                           *
*                                                                           *
*       err_buf[] must be initialized to zeros for the first call and       *
*       the returned err_buf should be provided for the next call.          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur, regardless of the relative orientation     *
*       of errdif_data[] and err_buf[].                                     *
*                                                                           *
*   NOTES                                                                   *
*       This function is Endian neutral.                                    *
*       This function is interruptible.                                     *
*       Max interrupt delay is 4*cols + 9 cycles.                           *
*       No checking is performed on the input arguments for correctness.    *
*       No special alignment of data arrays is expected.                    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (4*cols + 11)*rows + 5                                     *
*                                                                           *
*       For an image of cols = 720, rows = 480, cycles = 1,387,687          *
*                                                                           *
*   CODESIZE                                                                *
*       276 Bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       Floyd-Steinberg Error Diffusion.                                    *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_errdif_bin"
        .global _IMG_errdif_bin
_IMG_errdif_bin:   ; A_rgb_r, B_w, A_y, B_errbuf0, A_thrsh
                   ; A4,      B4,  A6,  B6,        A8

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_x
        .asg            A1,         A_y1
        .asg            A16,        A_errC
        .asg            A2,         B_p
        .asg            A3,         A_k3
        .asg            A4,         A_rgb_r
        .asg            A5,         A_rgb_w
        .asg            A6,         A_errbuf_w
        .asg            A6,         A_y
        .asg            A7,         A_errbuf_r
        .asg            A8,         A_eC3
        .asg            A8,         A_eC3F7
        .asg            A8,         A_errE_
        .asg            A8,         A_thrsh
        .asg            A9,         A_out
        .asg            B0,         B_big
        .asg            B1,         B_errAll
        .asg            B16,        B_rgb_r
        .asg            B17,        B_F7
        .asg            B18,        B_eB5
        .asg            B18,        B_errEA
        .asg            B18,        B_errEAC
        .asg            B19,        B_errSft
        .asg            B19,        B_outX
        .asg            B2,         B_thrsh
        .asg            B20,        B_F
        .asg            B21,        B_errB
        .asg            B23,        B_neg
        .asg            B24,        B_k5
        .asg            B4,         B_w
        .asg            B5,         B_k7
        .asg            B6,         B_errbuf0
        .asg            B7,         B_errE
        .asg            B8,         B_eE7
        .asg            B8,         B_F_
        .asg            B9,         B_errA
* ------------------------------------------------------------------------- *

        SUB     .L1     A_y,        1,          A_y1            ; setup
||      MV      .S1     A_rgb_r,    A_rgb_w                     ; setup
||      MVK     .S2     -1785,      B_neg                       ; setup
||      LDH     .D2T2   *B_errbuf0, B_errB                      ; outer loop

        MV      .L2X    A_rgb_r,    B_rgb_r                     ; setup
||      SHL     .S2     B_neg,      12,         B_neg           ; setup
||      MVK     .S1     3000h,      A_k3                        ; setup
||      LDH     .D2T1   *B_errbuf0[1],          A_errC          ;[ 1,1]

        ADD     .L1X    B_errbuf0,  4,          A_errbuf_r      ; outer loop
||      MV      .L2X    A_thrsh,    B_thrsh                     ; setup
||      LDBU    .D2T2   *B_rgb_r++, B_F                         ;[ 1,1]

* =========================== PIPE LOOP PROLOG ============================ *

        MVK     .S2     5000h,      B_k5                        ; setup

        MVK     .S2     7000h,      B_k7                        ; setup

y_start1:
        LDH     .D1T1   *A_errbuf_r++,          A_errC          ;[ 1,2]
||      MVK     .S1     3,          B_p                         ; outer loop
||      SUB     .L1X    B_w,        1,          A_x             ; outer loop

        MPY     .M1     A_errC,     A_k3,       A_eC3           ;[ 6,1]
||      MPY     .M2     B_errB,     B_k5,       B_eB5           ;[ 6,1]
||      LDBU    .D2T2   *B_rgb_r++, B_F                         ;[ 1,2]
||[ A_x]BDEC    .S1     x_start,    A_x                         ;[14,1]
||      ZERO    .L2     B_errA:B_F_                             ; outer loop
||      MV      .L1X    B_errbuf0,              A_errbuf_w      ; outer loop
||      ZERO    .S2     B_F7                                    ; outer loop

        MPY     .M2     B_F,        B_k7,       B_F7            ;[ 7,1]
||      ZERO    .L2     B_errAll:B_big                          ; outer loop

* =========================== PIPE LOOP KERNEL ============================ *
x_start:
  [ B_big]ADD   .L2     B_neg,      B_errAll,   B_errAll        ;[12,2]
||      SHL     .S2     B_errB,     12,         B_errA          ;[ 8,3]
||      MVD     .M2     B_F,        B_F_                        ;[ 8,3]
||      ADD     .D1X    A_eC3,      B_F7,       A_eC3F7         ;[ 8,3]
||      ADD     .D2     B_eB5,      B_errA,     B_errEA         ;[ 8,3]
||[B_p] SUB     .L1     B_p,        1,          B_p

        SHRU    .S1X    B_outX,     24,         A_out           ;[17,1]
||      SHR     .S2     B_errAll,   16,         B_errSft        ;[13,2]
||      MV      .L2X    A_errC,     B_errB                      ;[ 9,3]
||      MPYHL   .M2     B_errAll,   B_k7,       B_eE7           ;[ 9,3]
||      LDH     .D1T1   *A_errbuf_r++,          A_errC          ;[ 1,5]

  [!B_p]STB     .D1T1   A_out,      *A_rgb_w++                  ;[18,1]
||      SUB     .L1X    B_errE,     A_out,      A_errE_         ;[18,1]
||[ A_x]BDEC    .S1     x_start,    A_x                         ;[14,2]
||      ADD     .L2     B_errSft,   B_F_,       B_errE          ;[14,2]
||      ADD     .S2X    B_errEA,    A_eC3F7,    B_errEAC        ;[10,3]
||      MPY     .M1     A_errC,     A_k3,       A_eC3           ;[ 6,4]
||      MPY     .M2     B_errB,     B_k5,       B_eB5           ;[ 6,4]
||      LDBU    .D2T2   *B_rgb_r++, B_F                         ;[ 1,5]

  [!B_p]STH     .D1T1   A_errE_,    *A_errbuf_w++               ;[19,1]
||      SUB     .S2     B_thrsh,    B_errE,     B_outX          ;[15,2]
||      CMPGT   .L2     B_errE,     B_thrsh,    B_big           ;[15,2]
||      ADD     .D2     B_errEAC,   B_eE7,      B_errAll        ;[11,3]
||      MPY     .M2     B_F,        B_k7,       B_F7            ;[ 7,4]

* =========================== PIPE LOOP EPILOG ============================ *
  [ B_big]ADD   .L2     B_neg,      B_errAll,   B_errAll        ;[12,3]

        SHRU    .S1X    B_outX,     24,         A_out           ;[17,2]
||      SHR     .S2     B_errAll,   16,         B_errSft        ;[13,3]
||      SUB     .D2     B_rgb_r,    2,          B_rgb_r         ; adjust ptr

        STB     .D1T1   A_out,      *A_rgb_w++                  ;[18,2]
||      SUB     .L1X    B_errE,     A_out,      A_errE_         ;[18,2]
||      ADD     .D2     B_errSft,   B_F_,       B_errE          ;[14,3]
||[A_y1]BDEC    .S1     y_start1,   A_y1                        ; outer loop
||[!A_y1]RET    .S2     B3                                      ; return

        STH     .D1T1   A_errE_,    *A_errbuf_w++               ;[19,2]
||      SUB     .S2     B_thrsh,    B_errE,     B_outX          ;[15,3]
||      CMPGT   .L2     B_errE,     B_thrsh,    B_big           ;[15,3]
||      ADD     .L1X    B_errbuf0,  2,          A_errbuf_r      ; outer loop
||      LDH     .D2T2   *B_errbuf0, B_errB                      ; outer loop

        LDH     .D1T1   *A_errbuf_r++,          A_errC          ;[ 1,1]

        SHRU    .S1X    B_outX,     24,         A_out           ;[17,3]
||      LDBU    .D2T2   *B_rgb_r++, B_F                         ;[ 1,1]

        STB     .D1T1   A_out,      *A_rgb_w++                  ;[18,3]
||      SUB     .L1X    B_errE,     A_out,      A_errE_         ;[18,3]

        STH     .D1T1   A_errE_,    *A_errbuf_w                 ;[19,3]

* ========================================================================= *
*   End of file:  errdiff_bin_h.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fdct_8x8.asm/   1066928952  0     0     0       69070     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Sun Sep 29 03:32:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_fdct_8x8 -- 8x8 Block FDCT With Rounding, Little Endian         *
*                                                                           *
*   REVISION DATE                                                           *
*       23-May-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_fdct_8x8(short fdct_data[], unsigned num_fdcts)        *
*                                                                           *
*       The fdct routine accepts a list of 8x8 pixel blocks and performs    *
*       FDCTs on each.  The array should be laid out identically to         *
*       "fdct_data[num_fdcts][8][8]".  All operations in this array are     *
*       performed entirely in-place.                                        *
*                                                                           *
*       Input values are stored in shorts, and may be in the range          *
*       [-512,511].  Larger input values may result in overflow.            *
*                                                                           *
*       This code requires '50 + 76 * num_fdcts' cycles to process          *
*       'num_fdcts' blocks, including function call overhead.  When         *
*       'num_fdcts' is zero, an early exit is taken and the function        *
*       runs for only 13 cycles (again, including call overhead).           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_fdct_8x8 function implements a Chen FDCT. Output values are *
*       rounded, providing improved accuracy.  Input terms are expected     *
*       to be signed 11Q0 values, producing signed 15Q0 results.  (A        *
*       smaller dynamic range may be used on the input, producing a         *
*       correspondingly smaller output range.  Typical applications         *
*       include processing signed 9Q0 and unsigned 8Q0 pixel data,          *
*       producing signed 13Q0 or 12Q0 outputs, respectively.)  No           *
*       saturation is performed.                                            *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_fdcts == 0'.  In this case, the function runs for only    *
*       13 cycles (counting 6 cycles of function-call overhead), due to     *
*       early-exit code.  The early-exit case performs one access to the    *
*       fdct_data[] array and no access to the stack.                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)              *
*       {                                                                   *
*           /* ---------------------------------------------------- */      *
*           /*  Set up the cosine coefficients.                     */      *
*           /* ---------------------------------------------------- */      *
*           const unsigned short c1 = 0x1F62;   /* Q13   coeff      */      *
*           const unsigned short c3 = 0x1A9B;   /* Q13   coeff      */      *
*           const unsigned short c5 = 0x11C7;   /* Q13   coeff      */      *
*           const unsigned short c7 = 0x063E;   /* Q13   coeff      */      *
*           const unsigned short c2 = 0x29CF;   /* Q13.5 coeff      */      *
*           const unsigned short c6 = 0x1151;   /* Q13.5 coeff      */      *
*           const unsigned short C1 = 0xFB15;   /* Q16   coeff      */      *
*           const unsigned short C3 = 0xD4DB;   /* Q16   coeff      */      *
*           const unsigned short C5 = 0x8E3A;   /* Q16   coeff      */      *
*           const unsigned short C7 = 0x31F1;   /* Q16   coeff      */      *
*           const unsigned short C2 = 0xA73D;   /* Q15.5 coeff      */      *
*           const unsigned short C6 = 0x4546;   /* Q15.5 coeff      */      *
*           const unsigned short C4 = 0xB505;   /* Q16   coeff      */      *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Intermediate calculations.                          */      *
*           /* ---------------------------------------------------- */      *
*           short f0, f1, f2, f3;   /* Spatial domain samples.      */      *
*           short f4, f5, f6, f7;   /* Spatial domain samples.      */      *
*           short g0, g1, h0, h1;   /* Even-half intermediate.      */      *
*           short p0, p1;           /* Even-half intermediate.      */      *
*           short r0, r1, r0_,r1_;  /* Even-half intermediate.      */      *
*           short P0, P1, R0, R1;   /* Even-half intermediate.      */      *
*           short g2, g3, h2, h3;   /* Odd-half intermediate.       */      *
*           short q1a,s1a,q0, q1;   /* Odd-half intermediate.       */      *
*           short s0, s1;           /* Odd-half intermediate.       */      *
*           short Q0, Q1, S0, S1;   /* Odd-half intermediate.       */      *
*           short F0, F1, F2, F3;   /* Freq. domain results.        */      *
*           short F4, F5, F6, F7;   /* Freq. domain results.        */      *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Input and output pointers, loop control.            */      *
*           /* ---------------------------------------------------- */      *
*           unsigned i, j;                                                  *
*           short    *dct_io_ptr;                                           *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Outer vertical loop -- Process each 8x8 block.      */      *
*           /* ---------------------------------------------------- */      *
*           dct_io_ptr = dct_data;                                          *
*           for (i = 0; i < num_fdcts; i++)                                 *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Perform Vertical 1-D FDCT on columns within     */      *
*               /*  each block.  The inputs to this pass are in Q0  */      *
*               /*  and the outputs are in Q1.5.                    */      *
*               /* ------------------------------------------------ */      *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Load the spatial-domain samples.            */      *
*                   /*  The incoming terms start at Q0 precision.   */      *
*                   /* -------------------------------------------- */      *
*                   f0 = dct_io_ptr[ 0];                                    *
*                   f1 = dct_io_ptr[ 8];                                    *
*                   f2 = dct_io_ptr[16];                                    *
*                   f3 = dct_io_ptr[24];                                    *
*                   f4 = dct_io_ptr[32];                                    *
*                   f5 = dct_io_ptr[40];                                    *
*                   f6 = dct_io_ptr[48];                                    *
*                   f7 = dct_io_ptr[56];                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 1:  Separate into even & odd halves.  */      *
*                   /*                                              */      *
*                   /*  The results of this stage are implicitly    */      *
*                   /*  in Q1, since we do not explicitly multiply  */      *
*                   /*  by 0.5.                                     */      *
*                   /* -------------------------------------------- */      *
*                   g0 = f0 + f7;               /*  Results in Q1   */      *
*                   g1 = f1 + f6;               /*  Results in Q1   */      *
*                   h1 = f2 + f5;               /*  Results in Q1   */      *
*                   h0 = f3 + f4;               /*  Results in Q1   */      *
*                   g2 = f3 - f4;               /*  Results in Q1   */      *
*                   g3 = f2 - f5;               /*  Results in Q1   */      *
*                   h3 = f1 - f6;               /*  Results in Q1   */      *
*                   h2 = f0 - f7;               /*  Results in Q1   */      *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 2                                     */      *
*                   /*                                              */      *
*                   /*  Note, on the odd-half, the results are in   */      *
*                   /*  Q1.5 since those values are scaled upwards  */      *
*                   /*  by sqrt(2) at this point.                   */      *
*                   /* -------------------------------------------- */      *
*                   p0 = g0 + h0;               /*  Results in Q1   */      *
*                   p1 = g1 + h1;               /*  Results in Q1   */      *
*                   r0 = g0 - h0;               /*  Results in Q1   */      *
*                   r1 = g1 - h1;               /*  Results in Q1   */      *
*                                                                           *
*                   q1a = g2 + g2;              /*  q1a is now Q2   */      *
*                   s1a = h2 + h2;              /*  s1a is now Q2   */      *
*                   q1  = (q1a * C4 + 0x8000) >> 16; /*  .. in Q1.5 */      *
*                   s1  = (s1a * C4 + 0x8000) >> 16; /*  .. in Q1.5 */      *
*                                                                           *
*                   s0 = h3 + g3;               /*  Results in Q1.5 */      *
*                   q0 = h3 - g3;               /*  Results in Q1.5 */      *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 3                                     */      *
*                   /*                                              */      *
*                   /*  Now, the even-half ends up in Q1.5.  On P0  */      *
*                   /*  and P1, this happens because the multiply-  */      *
*                   /*  by-C4 was canceled with an upward scaling   */      *
*                   /*  by sqrt(2).  On R0 and R1, this happens     */      *
*                   /*  because C2 and C6 are at Q15.5, and we      */      *
*                   /*  scale r0 and r1 to Q2 before we multiply.   */      *
*                   /* -------------------------------------------- */      *
*                   P0 = p0 + p1;               /*  Results in Q1.5 */      *
*                   P1 = p0 - p1;               /*  Results in Q1.5 */      *
*                                                                           *
*                   r0_= r0 + r0;               /*  r0_ is now Q2   */      *
*                   r1_= r1 + r1;               /*  r1_ is now Q2   */      *
*                   R1 = (C6 * r1_+ C2 * r0_+ 0x8000) >>16; /* Q1.5 */      *
*                   R0 = (C6 * r0_- C2 * r1_+ 0x8000) >>16; /* Q1.5 */      *
*                                                                           *
*                   Q1 = q1 + q0;               /*  Results in Q1.5 */      *
*                   S1 = s1 + s0;               /*  Results in Q1.5 */      *
*                   Q0 = q1 - q0;               /*  Results in Q1.5 */      *
*                   S0 = s1 - s0;               /*  Results in Q1.5 */      *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 4                                     */      *
*                   /*  No further changes in Q-point happen here.  */      *
*                   /* -------------------------------------------- */      *
*                   F0 = P0;                    /*  Results in Q1.5 */      *
*                   F4 = P1;                    /*  Results in Q1.5 */      *
*                   F2 = R1;                    /*  Results in Q1.5 */      *
*                   F6 = R0;                    /*  Results in Q1.5 */      *
*                                                                           *
*                   F1 = (C7 * Q1 + C1 * S1 + 0x8000) >>16; /* Q1.5 */      *
*                   F7 = (C7 * S1 - C1 * Q1 + 0x8000) >>16; /* Q1.5 */      *
*                   F5 = (C3 * Q0 + C5 * S0 + 0x8000) >>16; /* Q1.5 */      *
*                   F3 = (C3 * S0 - C5 * Q0 + 0x8000) >>16; /* Q1.5 */      *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the frequency domain results.         */      *
*                   /*  These values are all at Q1.5 precision.     */      *
*                   /* -------------------------------------------- */      *
*                   dct_io_ptr[ 0] = F0;                                    *
*                   dct_io_ptr[ 8] = F1;                                    *
*                   dct_io_ptr[16] = F2;                                    *
*                   dct_io_ptr[24] = F3;                                    *
*                   dct_io_ptr[32] = F4;                                    *
*                   dct_io_ptr[40] = F5;                                    *
*                   dct_io_ptr[48] = F6;                                    *
*                   dct_io_ptr[56] = F7;                                    *
*                                                                           *
*                   dct_io_ptr++;                                           *
*               }                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Update pointer to next 8x8 FDCT block.          */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr += 56;                                           *
*           }                                                               *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Perform Horizontal 1-D FDCT on each 8x8 block.      */      *
*           /* ---------------------------------------------------- */      *
*           dct_io_ptr = dct_data;                                          *
*           for (i = 0; i < 8 * num_fdcts; i++)                             *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Load the spatial-domain samples.                */      *
*               /*  The incoming terms are at Q1.5 precision from   */      *
*               /*  the first pass.                                 */      *
*               /* ------------------------------------------------ */      *
*               f0 = dct_io_ptr[0];                                         *
*               f1 = dct_io_ptr[1];                                         *
*               f2 = dct_io_ptr[2];                                         *
*               f3 = dct_io_ptr[3];                                         *
*               f4 = dct_io_ptr[4];                                         *
*               f5 = dct_io_ptr[5];                                         *
*               f6 = dct_io_ptr[6];                                         *
*               f7 = dct_io_ptr[7];                                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 1:  Separate into even and odd halves.    */      *
*               /*                                                  */      *
*               /*  The results of this stage are implicitly in     */      *
*               /*  Q2.5, since we do not explicitly multiply by    */      *
*               /*  0.5.                                            */      *
*               /* ------------------------------------------------ */      *
*               g0 = f0 + f7;                   /*  Results in Q2.5 */      *
*               g1 = f1 + f6;                   /*  Results in Q2.5 */      *
*               h1 = f2 + f5;                   /*  Results in Q2.5 */      *
*               h0 = f3 + f4;                   /*  Results in Q2.5 */      *
*               g2 = f3 - f4;                   /*  Results in Q2.5 */      *
*               g3 = f2 - f5;                   /*  Results in Q2.5 */      *
*               h3 = f1 - f6;                   /*  Results in Q2.5 */      *
*               h2 = f0 - f7;                   /*  Results in Q2.5 */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 2                                         */      *
*               /*                                                  */      *
*               /*  Note, on the odd-half, the results are in Q3    */      *
*               /*  since those values are scaled upwards by        */      *
*               /*  sqrt(2) at this point.  The order of operations */      *
*               /*  differs in this pass as compared to the first   */      *
*               /*  due to overflow concerns.                       */      *
*               /*                                                  */      *
*               /*  We also inject a rounding term into the DC      */      *
*               /*  term which will also round the Nyquist term,    */      *
*               /*  F4.  This trick works despite the fact that we  */      *
*               /*  are technically still at Q2.5 here, since       */      *
*               /*  the step from Q2.5 to Q3 later is done          */      *
*               /*  implicitly, rather than with a multiply. (This  */      *
*               /*  is due to the sqrt(2) terms cancelling on the   */      *
*               /*  P0/P1 butterfly.)                               */      *
*               /* ------------------------------------------------ */      *
*               p0 = g0 + h0 + 4;               /*  Results in Q2.5 */      *
*               p1 = g1 + h1;                   /*  Results in Q2.5 */      *
*               r0 = g0 - h0;                   /*  Results in Q2.5 */      *
*               r1 = g1 - h1;                   /*  Results in Q2.5 */      *
*                                                                           *
*               q1a= (g2 * C4 + 0x8000) >> 16;  /*  q1a now in Q2   */      *
*               s1a= (h2 * C4 + 0x8000) >> 16;  /*  s1a now in Q2   */      *
*               q1 = q1a + q1a;                 /*  Results in Q3   */      *
*               s1 = s1a + s1a;                 /*  Results in Q3   */      *
*                                                                           *
*               s0 = h3 + g3;                   /*  Results in Q3   */      *
*               q0 = h3 - g3;                   /*  Results in Q3   */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 3                                         */      *
*               /*                                                  */      *
*               /*  Now, the even-half becomes Q0.  This happens    */      *
*               /*  on P0 and P1 because the multiply-by-c4 was     */      *
*               /*  canceled with an upward scaling by sqrt(2),     */      *
*               /*  yielding Q3 intermediate values.  The final     */      *
*               /*  >> 3 leaves these at Q0.  On R0 and R1, this    */      *
*               /*  happens because c2 and c6 are at Q13.5,         */      *
*               /*  yielding Q16 intermediate values.  The final    */      *
*               /*  >> 16 then leaves those values at Q0.           */      *
*               /* ------------------------------------------------ */      *
*               P0 = ((short)(p0 + p1)) >> 3;   /*  Results in Q0   */      *
*               P1 = ((short)(p0 - p1)) >> 3;   /*  Results in Q0   */      *
*               R1 = (c6 * r1 + c2 * r0 + 0x8000) >> 16; /* .. Q0   */      *
*               R0 = (c6 * r0 - c2 * r1 + 0x8000) >> 16; /* .. Q0   */      *
*                                                                           *
*               Q1 = q1 + q0;                   /*  Results in Q3   */      *
*               Q0 = q1 - q0;                   /*  Results in Q3   */      *
*               S1 = s1 + s0;                   /*  Results in Q3   */      *
*               S0 = s1 - s0;                   /*  Results in Q3   */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 4                                         */      *
*               /*                                                  */      *
*               /*  Next, the odd-half ends up in Q0. This happens  */      *
*               /*  because our values are in Q3 and our cosine     */      *
*               /*  terms are in Q13, giving us Q16 intermediate    */      *
*               /*  values. The final >> 16 leaves us a Q0 result.  */      *
*               /* ------------------------------------------------ */      *
*               F0 = P0;                        /*  Results in Q0   */      *
*               F4 = P1;                        /*  Results in Q0   */      *
*               F2 = R1;                        /*  Results in Q0   */      *
*               F6 = R0;                        /*  Results in Q0   */      *
*                                                                           *
*               F1 = (c7 * Q1 + c1 * S1 + 0x8000) >> 16; /* .. Q0   */      *
*               F7 = (c7 * S1 - c1 * Q1 + 0x8000) >> 16; /* .. Q0   */      *
*               F5 = (c3 * Q0 + c5 * S0 + 0x8000) >> 16; /* .. Q0   */      *
*               F3 = (c3 * S0 - c5 * Q0 + 0x8000) >> 16; /* .. Q0   */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Store the results                               */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr[0] = F0;                                         *
*               dct_io_ptr[1] = F1;                                         *
*               dct_io_ptr[2] = F2;                                         *
*               dct_io_ptr[3] = F3;                                         *
*               dct_io_ptr[4] = F4;                                         *
*               dct_io_ptr[5] = F5;                                         *
*               dct_io_ptr[6] = F6;                                         *
*               dct_io_ptr[7] = F7;                                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Update pointer to next FDCT row.                */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr += 8;                                            *
*           }                                                               *
*                                                                           *
*           return;                                                         *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop nest in the vertical pass has been collapsed into a        *
*       single-level loop.  Both vertical and horizontal loops have         *
*       been software pipelined.                                            *
*                                                                           *
*       For performance, portions of the code outside the loops have been   *
*       inter-scheduled with the prolog and epilog code of the loops.       *
*       Also, twin stack-pointers are used to accelerate stack accesses.    *
*       Finally, pointer values and cosine term registers are reused        *
*       between the horizontal and vertical loops to reduce the impact of   *
*       pointer and constant reinitialization.                              *
*                                                                           *
*       To save codesize, prolog and epilog collapsing have been performed  *
*       to the extent that it does not impact performance.                  *
*                                                                           *
*       To reduce register pressure and save some code, the horizontal      *
*       loop uses the same pair of pointer register for both reading and    *
*       writing.  The pointer increments are on the LDs to permit prolog    *
*       and epilog collapsing, since LDs can be speculated.                 *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Stack is aligned to a double-word boundary.                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*                                                                           *
*       The "fdct_data[]" array must be aligned on a double-word (8 byte)   *
*       boundary.                                                           *
*                                                                           *
*       The code requires 4 words of stack space to save Save-On-Entry      *
*       (SOE) registers.                                                    *
*                                                                           *
*       Nearly every cycle of this function performs at least one           *
*       memory access.                                                      *
*                                                                           *
*   NOTES                                                                   *
*       This code is fully interruptible.  Interrupts are blocked only      *
*       branch delay slots.                                                 *
*                                                                           *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*       The code is LITTLE ENDIAN.                                          *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 50 + 76 * num_fdcts                                        *
*                                                                           *
*       For num_fdcts =  6, cycles = 506.                                   *
*       For num_fdcts = 24, cycles = 1848.                                  *
*                                                                           *
*   CODESIZE                                                                *
*       980 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       Chen FDCT.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_fdct_8x8"
        .global _IMG_fdct_8x8
_IMG_fdct_8x8:
* ================= SYMBOLIC REGISTER ASSIGNMENTS: ARGS. ================== *
        ;;                                      ; void IMG_fdct_8x8(
        .asg            A4,         A_dct_data  ;   short dct_data[],
        .asg            B4,         B_num_dcts  ;   unsigned num_dcts
        ;;                                      ; );
* ================= SYMBOLIC REGISTER ASSIGNMENTS: MISC. ================== *
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A2,         A_SP        ; Twin Stack ptr, A datapath
        .asg            B3,         B_ret       ; Return address
        .asg            A11,        A_ret_sv    ; Return address copy
* ===================== SYMBOLIC CONSTANT ASSIGNMENTS ===================== *
        .asg            0xFB15,     cst_C1      ; Cosine term C1
        .asg            0xA73D,     cst_C2      ; Cosine term C2
        .asg            0xD4DB,     cst_C3      ; Cosine term C3
        .asg            0xB505,     cst_C4      ; Cosine term C4
        .asg            0x8E3A,     cst_C5      ; Cosine term C5
        .asg            0x4546,     cst_C6      ; Cosine term C6
        .asg            0x31F1,     cst_C7      ; Cosine term C7
* ================== SYMBOLIC REGISTER ASSIGNMENTS: V_LOOP ================ *
        ;; Cosine terms
        .asg            A21,        A_C1C7      ; Packed terms C1, C7
        .asg            B0,         B_C1C7      ; Packed terms C1, C7
        .asg            B2,         B_C2C6      ; Packed terms C2, C6
        .asg            A23,        A_C3C5      ; Packed terms C3, C5
        .asg            B4,         B_C3C5      ; Packed terms C3, C5
        .asg            A18,        A_C4__      ; Packed terms C4, zero
        .asg            A28,        A___C4      ; Packed terms zero, C4
        .asg            A24,        A_C5C3      ; Packed terms C5, C3
        .asg            A20,        A_C6C2      ; Packed terms C6, C2
        .asg            B10,        B_C7C1      ; Packed terms C7, C1

        ;; Input and output pointers
        .asg            A4,         A_i_ptr     ; Input pointer
        .asg            B26,        B_o_ptr     ; Output pointer
        .asg            B28,        B_fix       ; Pointer fixup constant
        .asg            B23,        B_fix_      ; Pointer fixup offset
        .asg            A29,        A_fix_      ; Pointer fixup offset

        ;; Incoming spatial-domain samples
        .asg            A9,         A_f0f0      ; Packed f0 terms, both cols
        .asg            B24,        B_f1f1      ; Packed f1 terms, both cols
        .asg            B25,        B_f2f2      ; Packed f2 terms, both cols
        .asg            A22,        A_f3f3      ; Packed f3 terms, both cols
        .asg            A26,        A_f4f4      ; Packed f4 terms, both cols
        .asg            B19,        B_f5f5      ; Packed f5 terms, both cols
        .asg            B9,         B_f6f6      ; Packed f6 terms, both cols
        .asg            A5,         A_f7f7      ; Packed f7 terms, both cols

        ;; Initial add/subtract butterflies
        .asg            A17,        A_g0g0      ; g0 = f7 + f0, both columns
        .asg            B29,        B_g1g1      ; g1 = f6 + f1, both columns
        .asg            B16,        B_h1h1      ; h1 = f5 + f2, both columns
        .asg            A1,         A_h0h0      ; h0 = f4 + f3, both columns
        .asg            A31,        A_g2g2      ; g2 = f3 - f4, both columns
        .asg            B9,         B_g3g3      ; g3 = f2 - f5, both columns
        .asg            B8,         B_h3h3      ; h3 = f1 - f6, both columns
        .asg            A31,        A_h2h2      ; h2 = f0 - f7, both columns
        .asg            B9,         B_s0s0      ; s0 = h3 + g3, both columns
        .asg            B8,         B_q0q0      ; q0 = h3 - g3, both columns
        .asg            A10,        A_p0p0      ; p0 = g0 + h0, both columns
        .asg            B16,        B_p1p1      ; p1 = g1 + h1, both columns
        .asg            B21,        B_r1r1      ; r1 = g1 - h1, both columns
        .asg            A7,         A_r0r0      ; r0 = g0 - h0, both columns
        .asg            B20,        B_r1r1_     ; r1, q-point adjusted
        .asg            A3,         A_r0r0_     ; r0, q-point adjusted
        .asg            A27,        A_r0r1_     ; r0, r1 packed, "A" column
        .asg            B29,        B_r1r0_     ; r1, r0 packed, "B" column
        .asg            B31,        B_r0r1_     ; r0, r1 packed, "B" column
        .asg            A9,         A_g2g2_     ; g2, q-point adjusted
        .asg            A3,         A_h2h2_     ; h2, q-point adjusted
        .asg            A30,        A_g2h2      ; g2, h2 packed, "A" column
        .asg            A8,         Axg2h2      ; g2, h2 packed, "B" column
        .asg            B7,         B_g2h2      ; g2, h2 packed, "B" column

        ;; Remaining FDCT butterflies.
        .asg            A5,         A_q1        ; q1 = C4 * g2
        .asg            A11,        A_s1        ; s1 = C4 * h2
        .asg            A5,         A_s1q1      ; s1, q1 packed
        .asg            B5,         Bxs0q0      ; s0, q0 packed
        .asg            A12,        A_S1Q1      ; S1 = s1 + s0, Q1 = q1 + q0
        .asg            A2,         A_S0Q0      ; S0 = s1 - s0, Q0 = q1 - q0

        .asg            B25,        B_q1        ; q1 = C4 * g2
        .asg            B7,         B_s1        ; s1 = C4 * h2
        .asg            B18,        B_s1q1      ; s1, q1 packed
        .asg            B8,         B_s0q0      ; s0, q0 packed
        .asg            B6,         B_S0Q0      ; S1 = s1 + s0, Q1 = q1 + q0
        .asg            B20,        B_S1Q1      ; S0 = s1 - s0, Q0 = q1 - q0

        ;; Final frequency-domain terms.
        .asg            A3,         A_F4F4_     ; F4 terms, both columns
        .asg            A2,         A_F1        ; Freq domain F1, "A" column
        .asg            A19,        A_F2        ; Freq domain F2, "A" column
        .asg            A7,         A_F3        ; Freq domain F3, "A" column
        .asg            A8,         A_F5        ; Freq domain F5, "A" column
        .asg            A31,        A_F6        ; Freq domain F6, "A" column
        .asg            A6,         A_F7        ; Freq domain F7, "A" column
        .asg            B30,        B_F1        ; Freq domain F1, "B" column
        .asg            B21,        B_F2        ; Freq domain F2, "B" column
        .asg            B6,         B_F3        ; Freq domain F3, "B" column
        .asg            B18,        B_F5        ; Freq domain F5, "B" column
        .asg            B17,        B_F6        ; Freq domain F6, "B" column
        .asg            B27,        B_F7        ; Freq domain F7, "B" column
        .asg            A16,        A_F0F0      ; Packed F0 terms, both cols
        .asg            B16,        B_F1F1      ; Packed F1 terms, both cols
        .asg            A19,        A_F2F2      ; Packed F2 terms, both cols
        .asg            B8,         B_F3F3      ; Packed F3 terms, both cols
        .asg            A25,        A_F4F4      ; Packed F4 terms, both cols
        .asg            B7,         B_F5F5      ; Packed F5 terms, both cols
        .asg            A31,        A_F6F6      ; Packed F6 terms, both cols
        .asg            B21,        B_F7F7      ; Packed F7 terms, both cols

        ;; Loop control
        .asg            A0,         Ap          ; Prolog collapse predicate
        .asg            B1,         B_i         ; Loop counter
        .asg            B22,        B_i_horiz   ; Loop ctr copy for h_loop
* ========================================================================= *

* ========================================================================= *
*  V_LOOP:  VERTICAL PASS LOOP                                              *
* ========================================================================= *

* ==================== SETUP CODE AND PIPE LOOP PROLOG ==================== *
        LDW     .D1T1   *+A_i_ptr  [16],        A_f4f4          ;[ 1,1]
||      ADDK    .S1     32,         A_i_ptr                     ; offset i_ptr
||      SHL     .S2     B_num_dcts, 2,          B_i             ; i = 4*num

  [ B_i]LDW     .D1T1   *+A_i_ptr  [ 4],        A_f3f3          ;[ 2,1]
||[ B_i]ZERO    .L1     A_C4__                                  ; set up cst 0
||[!B_i]RET     .S2     B_ret                                   ; early abort

  [ B_i]LDW     .D1T1   *-A_i_ptr  [ 8],        A_f0f0          ;[ 3,1]
||[ B_i]MVKLH   .S1     cst_C4,     A_C4__                      ; const C4
||[ B_i]MV      .L2X    A_i_ptr,    B_o_ptr

  [ B_i]LDW     .D1T1   *+A_i_ptr  [20],        A_f7f7          ;[ 4,1]
||[ B_i]MVKL    .S1     cst_C5,     A_C3C5                      ; const C5
||[ B_i]MV      .L1X    B_SP,       A_SP

  [ B_i]LDW     .D1T2   *-A_i_ptr  [ 4],        B_f1f1          ;[ 5,1]
||[ B_i]MVKL    .S1     cst_C2,     A_C6C2                      ; const C2
||[ B_i]MVK     .L1     1,          A_fix_                      ; init fixup

  [ B_i]LDW     .D1T2   *+A_i_ptr  [12],        B_f5f5          ;[ 6,1]
||[ B_i]MVKLH   .S1     cst_C6,     A_C6C2                      ; const C6
||[ B_i]MVKL    .S2     cst_C7,     B_C1C7                      ; const C7
||[ B_i]SWAP2   .L1     A_C4__,     A___C4                      ; swapped pair
||[ B_i]ADDAW   .D2     B_o_ptr,    20,         B_o_ptr         ; offset o_ptr

  [ B_i]LDW     .D1T2   *+A_i_ptr  [16],        B_f6f6          ;[ 7,1]
||[ B_i]MVK     .L1     2,          Ap                          ; pro. collapse
||[ B_i]MVKLH   .S2     cst_C1,     B_C1C7                      ; const C1
||[ B_i]MVKLH   .S1     cst_C3,     A_C3C5                      ; const C3
||[ B_i]SUBU    .L2X    B_i,        A_fix_,     B_fix_:B_i_horiz; 2nd loop copy

        SUB2    .L1     A_f3f3,     A_f4f4,     A_g2g2          ;[ 8,1]
||      ADD2    .S1     A_f3f3,     A_f4f4,     A_h0h0          ;[ 8,1]
||      MVKL    .S2     0x0101011D, B_fix                       ; ptr fix cst.
||      ROTL    .M2X    A_C6C2,     16,         B_C2C6          ; swapped pair
||      ROTL    .M1     A_C3C5,     16,         A_C5C3          ; swapped pair
||      STW     .D1T1   A12,        *-A_SP[3]                   ; Save A12
||      STW     .D2T2   B10,        * B_SP--[4]                 ; Save B10

        ADD2    .L1     A_g2g2,     A_g2g2,     A_g2g2_         ;[ 9,1]
||      SUB2    .S1     A_f0f0,     A_f7f7,     A_h2h2          ;[ 9,1]
||      ADD2    .D1     A_f0f0,     A_f7f7,     A_g0g0          ;[ 9,1]
||      MVKH    .S2     0x0101011D, B_fix                       ; ptr fix cst.
||      SWAP2   .L2     B_C1C7,     B_C7C1                      ; swapped pair
||      ROTL    .M2X    A_C3C5,     0,          B_C3C5          ; swapped pair
||      ROTL    .M1X    B_C1C7,     0,          A_C1C7          ; swapped pair
||      STDW    .D2T1   A11:A10,    *+B_SP[1]                   ; Save A11, A10

; Collapsed 2 prolog stages.
; ============================ PIPE LOOP KERNEL =========================== *
v_loop:
  [!Ap] STW     .D2T1   A_F0F0,     *-B_o_ptr  [28]             ;[30,1]
||      PACK2   .S2X    B_F5,       A_F5,       B_F5F5          ;[30,1]
||      DOTPNRSU2.M1    A_r0r1_,    A_C6C2,     A_F6            ;[30,1]
||      PACK2   .L2     B_s1,       B_q1,       B_s1q1          ;[20,2]
||      ROTL    .M2     B_r1r0_,    16,         B_r0r1_         ;[20,2]
||      PACKH2  .S1X    A_r0r0_,    B_r1r1_,    A_r0r1_         ;[20,2]
||      ADD2    .L1     A_h2h2,     A_h2h2,     A_h2h2_         ;[10,3]
||[B_i] LDW     .D1T2   * A_i_ptr++[A_fix_],    B_f2f2          ;[10,3]

        PACK2   .S2X    B_F3,       A_F3,       B_F3F3          ;[31,1]
||      DOTPNRSU2.M1X   A_S1Q1,     B_C7C1,     A_F7            ;[31,1]
||      SUB2    .D2     B_s1q1,     B_s0q0,     B_S0Q0          ;[21,2]
||      ADD2    .L2     B_s1q1,     B_s0q0,     B_S1Q1          ;[21,2]
||      PACK2   .L1     A_g2g2_,    A_h2h2_,    Axg2h2          ;[11,3]
||      PACKH2  .S1     A_g2g2_,    A_h2h2_,    A_g2h2          ;[11,3]
||[B_i] LDW     .D1T1   *+A_i_ptr  [ 8],        A_f4f4          ;[ 1,4]
||      ROTL    .M2     B_fix,      8,          B_fix           ;[ 1,4]

  [!Ap] STW     .D2T2   B_F3F3,     *-B_o_ptr  [16]             ;[32,1]
||      SUB2    .L1X    A_p0p0,     B_p1p1,     A_F4F4          ;[22,2]
||      DOTPRSU2.M2X    B_S0Q0,     A_C5C3,     B_F5            ;[22,2]
||      ROTL    .M1     A_F4F4,     0,          A_F4F4_         ;[22,2]
||      SUB2    .S1     A_g0g0,     A_h0h0,     A_r0r0          ;[12,3]
||      SUB2    .S2     B_f1f1,     B_f6f6,     B_h3h3          ;[12,3]
||      ADD2    .L2     B_f1f1,     B_f6f6,     B_g1g1          ;[12,3]
||[B_i] LDW     .D1T1   *+A_i_ptr  [ 4],        A_f3f3          ;[ 2,4]

  [!Ap] STW     .D2T2   B_F5F5,     *-B_o_ptr  [ 8]             ;[33,1]
||      PACK2   .L2X    B_F1,       A_F1,       B_F1F1          ;[33,1]
||      ADD2    .S1X    A_p0p0,     B_p1p1,     A_F0F0          ;[23,2]
||      DOTPNRSU2.M2    B_S0Q0,     B_C3C5,     B_F3            ;[23,2]
||      PACK2   .L1     A_s1,       A_q1,       A_s1q1          ;[23,2]
||      DOTPRSU2.M1     A_g2h2,     A___C4,     A_s1            ;[13,3]
||[B_i] LDW     .D1T1   *-A_i_ptr  [ 8],        A_f0f0          ;[ 3,4]
||[!Ap] EXT     .S2     B_fix,      8,  24,     B_fix_          ;[ 3,4]

  [B_i] BDEC    .S2     v_loop,     B_i                         ;[34,1]
||[!Ap] STW     .D2T2   B_F1F1,     *-B_o_ptr  [24]             ;[34,1]
||      DOTPRSU2.M2     B_S1Q1,     B_C1C7,     B_F1            ;[24,2]
||      SUB2    .L1X    A_s1q1,     Bxs0q0,     A_S0Q0          ;[24,2]
||      ADD2    .S1X    A_s1q1,     Bxs0q0,     A_S1Q1          ;[24,2]
||      MV      .L2X    Axg2h2,     B_g2h2                      ;[14,3]
||[B_i] LDW     .D1T1   *+A_i_ptr  [20],        A_f7f7          ;[ 4,4]

        PACK2   .L1X    A_F6,       B_F6,       A_F6F6          ;[35,1]
||[!Ap] STW     .D2T1   A_F4F4_,    *-B_o_ptr  [12]             ;[35,1]
||      DOTPRSU2.M1     A_S0Q0,     A_C5C3,     A_F5            ;[25,2]
||      DOTPRSU2.M2X    B_g2h2,     A_C4__,     B_q1            ;[15,3]
||      ADD2    .S1     A_r0r0,     A_r0r0,     A_r0r0_         ;[15,3]
||      SUB2    .S2     B_f2f2,     B_f5f5,     B_g3g3          ;[15,3]
||      ADD2    .L2     B_f2f2,     B_f5f5,     B_h1h1          ;[15,3]
||[B_i] LDW     .D1T2   *-A_i_ptr  [ 4],        B_f1f1          ;[ 5,4]

        PACK2   .L1X    A_F2,       B_F2,       A_F2F2          ;[36,1]
||      DOTPNRSU2.M1    A_S0Q0,     A_C3C5,     A_F3            ;[26,2]
||      DOTPRSU2.M2X    B_g2h2,     A___C4,     B_s1            ;[16,3]
||      SUB2    .S2     B_g1g1,     B_h1h1,     B_r1r1          ;[16,3]
||      SUB2    .L2     B_h3h3,     B_g3g3,     B_q0q0          ;[16,3]
||      ADD2    .D2     B_h3h3,     B_g3g3,     B_s0s0          ;[16,3]
||[B_i] LDW     .D1T2   *+A_i_ptr  [12],        B_f5f5          ;[ 6,4]

  [!Ap] STW     .D2T1   A_F2F2,     *-B_o_ptr  [20]             ;[37,1]
||      DOTPNRSU2.M2X   B_r0r1_,    A_C6C2,     B_F6            ;[27,2]
||      DOTPRSU2.M1     A_S1Q1,     A_C1C7,     A_F1            ;[27,2]
||      PACK2   .S2     B_s0s0,     B_q0q0,     B_s0q0          ;[17,3]
||      PACKH2  .L2     B_s0s0,     B_q0q0,     Bxs0q0          ;[17,3]
||      ADD2    .L1     A_g0g0,     A_h0h0,     A_p0p0          ;[17,3]
||[B_i] LDW     .D1T2   *+A_i_ptr  [16],        B_f6f6          ;[ 7,4]
||      SHR     .S1X    B_fix,      24,         A_fix_          ;[ 7,4]

  [!Ap] STW     .D2T1   A_F6F6,     *-B_o_ptr  [ 4]             ;[38,1]
||      PACK2   .L2X    B_F7,       A_F7,       B_F7F7          ;[38,1]
||      DOTPNRSU2.M2    B_S1Q1,     B_C7C1,     B_F7            ;[28,2]
||      DOTPRSU2.M1X    A_r0r1_,    B_C2C6,     A_F2            ;[28,2]
||      ADD2    .S2     B_r1r1,     B_r1r1,     B_r1r1_         ;[18,3]
||      SUB2    .L1     A_f3f3,     A_f4f4,     A_g2g2          ;[ 8,4]
||      ADD2    .D1     A_f3f3,     A_f4f4,     A_h0h0          ;[ 8,4]
||[ Ap] SUB     .S1     Ap,         1,          Ap

  [!Ap] STW     .D2T2   B_F7F7,     * B_o_ptr++[B_fix_]         ;[39,1]
||      DOTPRSU2.M2     B_r0r1_,    B_C2C6,     B_F2            ;[29,2]
||      DOTPRSU2.M1     A_g2h2,     A_C4__,     A_q1            ;[19,3]
||      PACK2   .S2X    B_r1r1_,    A_r0r0_,    B_r1r0_         ;[19,3]
||      ADD2    .L2     B_g1g1,     B_h1h1,     B_p1p1          ;[19,3]
||      ADD2    .L1     A_g2g2,     A_g2g2,     A_g2g2_         ;[ 9,4]
||      SUB2    .S1     A_f0f0,     A_f7f7,     A_h2h2          ;[ 9,4]
||      ADD2    .D1     A_f0f0,     A_f7f7,     A_g0g0          ;[ 9,4]
* ========================================================================= *


* ================== SYMBOLIC REGISTER ASSIGNMENTS: H_LOOP ================ *
        ;; Cosine terms and rounding constant
        .asg            A21,        A_c1c7      ; Packed c1, c7
        .asg            A3,         A_c2c6      ; Packed c2, c6
        .asg            A23,        A_c3c5      ; Packed c3, c5
        .asg            A18,        A_C4__      ; Packed c4, zero
        .asg            B28,        B_C4__      ; Packed c4, zero
        .asg            A24,        A_c5c3      ; Packed c5, c3
        .asg            A20,        A_c6c2      ; Packed c6, c2
        .asg            A22,        A_c7c1      ; Packed c7, c1
        .asg            A25,        A_dc_rnd    ; Packed DC rounding terms

        ;; Input and output pointers
        .asg            A4,         A_io_ptr    ; Twin Input/Output pointer
        .asg            B26,        B_io_ptr    ; Twin Input/Output pointer

        ;; Incoming spatial-domain samples
        .asg            A17,        A_f7f6      ; Packed f7, f6, "A" row
        .asg            A16,        A_f5f4      ; Packed f5, f4, "A" row
        .asg            A1,         A_f4f5      ; Packed f4, f5, "A" row
        .asg            A29,        A_f3f2      ; Packed f3, f2, "A" row
        .asg            A28,        A_f1f0      ; Packed f1, f0, "A" row
        .asg            A6,         A_f0f1      ; Packed f0, f1, "A" row

        .asg            A2,         Axf7f6      ; Packed f7, f6, "B" row
        .asg            B5,         B_f7f6      ; Packed f7, f6, "B" row
        .asg            B25,        B_f6f7      ; Packed f6, f7, "B" row
        .asg            B24,        B_f4f5      ; Packed f4, f5, "B" row
        .asg            B6,         B_f3f2      ; Packed f3, f2, "B" row
        .asg            B1,         B_f2f3      ; Packed f2, f3, "B" row
        .asg            B0,         B_f0f1      ; Packed f0, f1, "B" row

        ;; Initial add/subtract butterflies
                                                ; "A" row:
        .asg            A7,         A_g0g1      ; g0 = f0 + f7, g1 = f1 + f6
        .asg            A19,        A_h2h3      ; h2 = f0 - f7, h3 = f1 - f6
        .asg            A1,         A_h0h1      ; h0 = f3 + f4, h1 = f2 + f5
        .asg            A5,         A_g2g3      ; g2 = f3 - f4, g3 = f2 - f5
        .asg            A9,         A_p0p1      ; p0 = g0 + h0, p1 = g1 + h1
        .asg            A0,         A_r0r1      ; r0 = g0 - h0, r1 = g1 - h1

                                                ; "B" row:
        .asg            B5,         B_g0g1      ; g0 = f0 + f7, g1 = f1 + f6
        .asg            B24,        B_h2h3      ; h2 = f0 - f7, h3 = f1 - f6
        .asg            B7,         B_h0h1      ; h0 = f3 + f4, h1 = f2 + f5
        .asg            B6,         B_g2g3      ; g2 = f3 - f4, g3 = f2 - f5
        .asg            B9,         B_p0p1      ; p0 = g0 + h0, p1 = g1 + h1
        .asg            B29,        B_r0r1      ; r0 = g0 - h0, r1 = g1 - h1

        ;; DC and Nyquist term butterflies, which straddle both datapaths
        .asg            A7,         A_p0p0_     ; Packed p0's, pre-round.
        .asg            A30,        A_p0p0      ; Packed p0's, rounded.
        .asg            A9,         A_p1p1      ; Packed p1's.

        .asg            A9,         A_F0F0_     ; Packed F0's, Q3
        .asg            A16,        A_F4F4_     ; Packed F4's, Q3
        .asg            B19,        B_F0F0      ; Packed F0's, Q0 (final)
        .asg            B8,         B_F4F4      ; Packed F0's, Q0 (final)

        ;; Remaining FDCT butterflies
                                                ; "A" row:
        .asg            A27,        A_q1_       ; q1_= C4 * g2
        .asg            A26,        A_s1_       ; s1_= C4 * h2
        .asg            A1,         A_s1q1_     ; Packed s1_, q1_
        .asg            A30,        A_s1q1      ; s1 = s1_ << 1, q1 = q1_ << 1
        .asg            A5,         A_q0        ; q0 = h3 + g3
        .asg            A6,         A_s0        ; s0 = h3 - g3
        .asg            A5,         A_s0q0      ; Packed s0, q0
        .asg            A12,        A_S1Q1      ; S1 = s1 + s0, Q1 = q1 + q0
        .asg            A30,        A_S0Q0      ; S0 = s1 - s0, Q0 = q1 - q0

                                                ; "B" row:
        .asg            B4,         B_q1_       ; q1_= C4 * g2
        .asg            B3,         B_s1_       ; s1_= C4 * h2
        .asg            B3,         B_s1q1_     ; Packed s1_, q1_
        .asg            B3,         B_s1q1      ; s1 = s1_ << 1, q1 = q1_ << 1
        .asg            B6,         B_q0        ; q0 = h3 + g3
        .asg            B0,         B_s0        ; s0 = h3 - g3
        .asg            B10,        B_s0q0      ; Packed s0, q0
        .asg            B20,        B_S1Q1      ; S1 = s1 + s0, Q1 = q1 + q0
        .asg            B1,         B_S0Q0      ; S0 = s1 - s0, Q0 = q1 - q0

        ;; Final frequency-domain results.
                                                ; "A" row:
        .asg            A2,         A_F1        ; Freq. domain F1 term.
        .asg            A19,        A_F2        ; Freq. domain F2 term.
        .asg            A7,         A_F3        ; Freq. domain F3 term.
        .asg            A8,         A_F5        ; Freq. domain F5 term.
        .asg            A31,        A_F6        ; Freq. domain F6 term.
        .asg            A6,         A_F7        ; Freq. domain F7 term.

        .asg            A27,        A_F7F6      ; Packed F7, F6
        .asg            A26,        A_F5F4      ; Packed F5, F4
        .asg            A29,        A_F3F2      ; Packed F3, F2
        .asg            A28,        A_F1F0      ; Packed F1, F0

                                                ; "B" row:
        .asg            B30,        B_F1        ; Freq. domain F1 term.
        .asg            B21,        B_F2        ; Freq. domain F2 term.
        .asg            B6,         B_F3        ; Freq. domain F3 term.
        .asg            B18,        B_F5        ; Freq. domain F5 term.
        .asg            B17,        B_F6        ; Freq. domain F6 term.
        .asg            B27,        B_F7        ; Freq. domain F7 term.

        .asg            B17,        B_F7F6      ; Packed F7, F6
        .asg            B16,        B_F5F4      ; Packed F5, F4
        .asg            B31,        B_F3F2      ; Packed F3, F2
        .asg            B30,        B_F1F0      ; Packed F1, F0

        ;; Loop control
        .asg            B2,         Bp          ; Prolog collapse counter.
        .asg            B22,        B_i         ; Loop trip counter.
* ========================================================================= *

* ========================================================================= *
*  H_LOOP: HORIZONTAL PASS LOOP                                             *
*                                                                           *
*  Note:  2 cycles of this code have been "relocated" to the end so that    *
*  the h_loop branch target does not span two fetch packets.  The net       *
*  result is that this function has NO execute packet padding.              *
* ========================================================================= *

* ====================== PIPE LOOP EPILOG AND PROLOG ====================== *
; Collapsed 2 epilog stages.
        LDNDW   .D2T2   *--B_io_ptr(12),        B_f2f3:B_f0f1   ;[ 2,1]
||      PACK2   .S2X    B_F5,       A_F5,       B_F5F5          ;[30,4]
||      DOTPNRSU2.M1X   A_S1Q1,     B_C7C1,     A_F7            ;[31,4]
||      B               reloc

        LDW     .D1T2   *-A_io_ptr  [10],       B_f4f5          ;
||      DOTPNRSU2.M1    A_r0r1_,    A_C6C2,     A_F6            ;[30,4]
||      STW     .D2T1   A_F0F0,     *-B_io_ptr [25]             ;[30,4]
||      ADDK    .S2     -20,        B_io_ptr

        SHRU2   .S1     A_C6C2,     2,          A_c6c2
||      PACK2   .L2X    B_F3,       A_F3,       B_F3F3          ;[31,4]
||      STW     .D2T2   B_F5F5,     *B_io_ptr--[ 8]             ;[33,4]
||      B               h_loop

        SHRU2   .S1     A_C5C3,     3,          A_c5c3
||      STW     .D2T2   B_F3F3,     *B_io_ptr--[ 8]             ;[32,4]
||      PACK2   .L2X    B_F1,       A_F1,       B_F1F1          ;[33,4]
||      MV      .L1X    B_ret,      A_ret_sv

        SHRU2   .S1     A_C3C5,     3,          A_c3c5
||      MVK     .L2     3,          Bp
||      STW     .D2T2   B_F1F1,     *B_io_ptr++[12]             ;[34,4]
||      PACK2   .L1X    A_F7,       B_F7,       Axf7f6          ;

        SWAP2   .L2     B_f2f3,     B_f3f2                      ;[ 7,1]
||      MV      .S2X    A_C4__,     B_C4__
||      SHRU2   .S1     A_C1C7,     3,          A_c1c7
||      PACK2   .L1X    A_F2,       B_F2,       A_F2F2          ;[36,4]
||      STW     .D2T1   A_F4F4,     *B_io_ptr--[ 8]             ;[35,4]
||      MVK     .D1     4,          A_dc_rnd
* ========================== RELOC. BRANCH OCCURS ========================= *

; Collapsed 2 prolog stages.
* ============================ PIPE LOOP KERNEL ============================ *
h_loop:
        DOTPNRSU2.M1    A_S1Q1,     A_c7c1,     A_F7            ;[28,1]
||      ADD2    .S2     B_s1q1,     B_s0q0,     B_S1Q1          ;[19,2]
||      PACK2   .L1     A_s0,       A_q0,       A_s0q0          ;[19,2]
||      ADD2    .S1     A_g0g1,     A_h0h1,     A_p0p1          ;[19,2]
||      SUB     .L2     B_h2h3,     B_g2g3,     B_q0            ;[10,3]
||      DOTPRSU2.M2     B_h2h3,     B_C4__,     B_s1_           ;[10,3]
||      LDDW    .D1T1   * A_io_ptr--[4],        A_f3f2:A_f1f0   ;[10,3]
||      LDDW    .D2T2   *+B_io_ptr  [1],        B_f6f7:B_f4f5   ;[ 1,4]

        DOTPRSU2.M1     A_S1Q1,     A_c1c7,     A_F1            ;[29,1]
||      PACK2   .L1X    A_p0p1,     B_p0p1,     A_p1p1          ;[20,2]
||      PACKH2  .S1X    A_p0p1,     B_p0p1,     A_p0p0_         ;[20,2]
||      DOTPNRSU2.M2X   B_S0Q0,     A_c3c5,     B_F3            ;[20,2]
||      SUB2    .D1     A_g0g1,     A_h0h1,     A_r0r1          ;[20,2]
||      PACK2   .L2     B_s0,       B_q0,       B_s0q0          ;[11,3]
||      ADD2    .S2     B_g0g1,     B_h0h1,     B_p0p1          ;[11,3]
||      LDDW    .D2T2   * B_io_ptr--[4],        B_f2f3:B_f0f1   ;[ 2,4]

        PACK2   .S2     B_F1,       B_F0F0,     B_F1F0          ;[30,1]
||      PACK2   .L2     B_F7,       B_F6,       B_F7F6          ;[30,1]
||      PACKLH2 .L1X    A_F5,       B_F4F4,     A_F5F4          ;[30,1]
||      DOTPNRSU2.M1    A_S0Q0,     A_c3c5,     A_F3            ;[30,1]
||      ADD2    .D1     A_p0p0_,    A_dc_rnd,   A_p0p0          ;[21,2]
||      DOTPNRSU2.M2X   B_S1Q1,     A_c7c1,     B_F7            ;[21,2]
||      PACK2   .S1     A_s1_,      A_q1_,      A_s1q1_         ;[21,2]
||[ Bp] SUB     .D2     Bp,         1,          Bp              ;pro. collapse

        BDEC    .S2     h_loop,     B_i                         ;[31,1]
||[!Bp] STDW    .D2T2   B_F3F2:B_F1F0,          *+B_io_ptr[16]  ;[31,1]
||      SUB2    .D1     A_p0p0,     A_p1p1,     A_F4F4_         ;[22,2]
||      ADD2    .S1     A_p0p0,     A_p1p1,     A_F0F0_         ;[22,2]
||      DOTPRSU2.M2X    B_S1Q1,     A_c1c7,     B_F1            ;[22,2]
||      ADD2    .L1     A_s1q1_,    A_s1q1_,    A_s1q1          ;[22,2]
||      ROTL    .M1     A_f5f4,     16,         A_f4f5          ;[13,3]

  [!Bp] STDW    .D2T2   B_F7F6:B_F5F4,          *+B_io_ptr[17]  ;[32,1]
||      PACK2   .L1     A_F7,       A_F6,       A_F7F6          ;[32,1]
||      DOTPNRSU2.M2X   B_r0r1,     A_c6c2,     B_F6            ;[23,2]
||      SUB2    .S1     A_s1q1,     A_s0q0,     A_S0Q0          ;[23,2]
||      ADD2    .D1     A_s1q1,     A_s0q0,     A_S1Q1          ;[23,2]
||      DOTPNRSU2.M1    A_r0r1,     A_c6c2,     A_F6            ;[23,2]
||      PACK2   .L2     B_s1_,      B_q1_,      B_s1q1_         ;[14,3]
||      SUB2    .S2     B_g0g1,     B_h0h1,     B_r0r1          ;[14,3]

        PACK2   .L2     B_F3,       B_F2,       B_F3F2          ;[24,2]
||      SHR2    .S2X    A_F4F4_,    3,          B_F4F4          ;[24,2]
||      DOTPRSU2.M1     A_S0Q0,     A_c5c3,     A_F5            ;[24,2]
||      ADD2    .D2     B_s1q1_,    B_s1q1_,    B_s1q1          ;[15,3]
||      SUB2    .D1     A_f3f2,     A_f4f5,     A_g2g3          ;[15,3]
||      ADD2    .S1     A_f3f2,     A_f4f5,     A_h0h1          ;[15,3]
||      SWAP2   .L1     A_f1f0,     A_f0f1                      ;[15,3]
||      ROTL    .M2     B_f6f7,     16,         B_f7f6          ;[ 6,4]

  [!Bp] STDW    .D1T1   A_F7F6:A_F5F4,          *+A_io_ptr[13]  ;[34,1]
||      PACK2   .S1     A_F3,       A_F2,       A_F3F2          ;[34,1]
||      PACK2   .S2     B_F5,       B_F4F4,     B_F5F4          ;[25,2]
||      SUB2    .D2     B_s1q1,     B_s0q0,     B_S0Q0          ;[16,3]
||      DOTPRSU2.M2X    B_r0r1,     A_c2c6,     B_F2            ;[16,3]
||      DOTPRSU2.M1     A_g2g3,     A_C4__,     A_q1_           ;[16,3]
||      SUB2    .L1     A_f0f1,     A_f7f6,     A_h2h3          ;[16,3]
||      SWAP2   .L2     B_f2f3,     B_f3f2                      ;[ 7,4]

        PACKLH2 .S1X    A_F1,       B_F0F0,     A_F1F0          ;[35,1]
||      DOTPRSU2.M2X    B_S0Q0,     A_c5c3,     B_F5            ;[17,3]
||      DOTPRSU2.M1     A_h2h3,     A_C4__,     A_s1_           ;[17,3]
||      ADD2    .L1     A_f0f1,     A_f7f6,     A_g0g1          ;[17,3]
||      SUB2    .D2     B_f3f2,     B_f4f5,     B_g2g3          ;[ 8,4]
||      ADD2    .L2     B_f3f2,     B_f4f5,     B_h0h1          ;[ 8,4]
||      SUB2    .S2     B_f0f1,     B_f7f6,     B_h2h3          ;[ 8,4]
||      LDDW    .D1T1   *+A_io_ptr  [1],        A_f7f6:A_f5f4   ;[ 8,4]

  [!Bp] STDW    .D1T1   A_F3F2:A_F1F0,          *+A_io_ptr[12]  ;[36,1]
||      SHR2    .S2X    A_F0F0_,    3,          B_F0F0          ;[27,2]
||      DOTPRSU2.M1     A_r0r1,     A_c2c6,     A_F2            ;[27,2]
||      SUB     .S1     A_h2h3,     A_g2g3,     A_q0            ;[18,3]
||      ADD     .L1     A_h2h3,     A_g2g3,     A_s0            ;[18,3]
||      ADD     .D2     B_h2h3,     B_g2g3,     B_s0            ;[ 9,4]
||      DOTPRSU2.M2     B_g2g3,     B_C4__,     B_q1_           ;[ 9,4]
||      ADD2    .L2     B_f0f1,     B_f7f6,     B_g0g1          ;[ 9,4]

* ============================ PIPE LOOP EPILOG ============================ *
; Collapsed 2 epilog stages.
        DOTPNRSU2.M1    A_S1Q1,     A_c7c1,     A_F7            ;[28,4]
||      PACK2   .L2     B_F7,       B_F6,       B_F7F6          ;[30,4]
||      PACK2   .S2     B_F1,       B_F0F0,     B_F1F0          ;[30,4]

        DOTPRSU2.M1     A_S1Q1,     A_c1c7,     A_F1            ;[29,4]
||      LDW     .D2T1   *+B_SP[1],  A12                         ; get A12

        PACKLH2 .L1X    A_F5,       B_F4F4,     A_F5F4          ;[30,4]
||      DOTPNRSU2.M1    A_S0Q0,     A_c3c5,     A_F3            ;[30,4]
||      RET     .S2X    A_ret_sv
||      LDDW    .D2T1   *+B_SP[1],  A11:A10                     ; get A11,A10

        LDW     .D2T2   *++B_SP[4], B10                         ; get B10

        PACK2   .L1     A_F7,       A_F6,       A_F7F6          ;[32,4]

        PACKLH2 .S1X    A_F1,       B_F0F0,     A_F1F0          ;[35,4]

        PACK2   .L1     A_F3,       A_F2,       A_F3F2          ;[34,4]
||      STDW    .D1T1   A_F7F6:A_F5F4,          *+A_io_ptr[ 9]  ;[34,4]
||      STDW    .D2T2   B_F3F2:B_F1F0,          *+B_io_ptr[12]  ;[31,4]

        STDW    .D1T1   A_F3F2:A_F1F0,          *+A_io_ptr[ 8]  ;[36,4]
||      STDW    .D2T2   B_F7F6:B_F5F4,          *+B_io_ptr[13]  ;[32,4]
* ========================== RETURN BRANCH OCCURS ========================= *

* ================ RELOCATED CODE (BRANCH TARGET ALIGNMENT) =============== *
reloc:
        SUB2    .D2     B_f3f2,     B_f4f5,     B_g2g3          ;[ 8,1]
||      ADD2    .L2     B_f3f2,     B_f4f5,     B_h0h1          ;[ 8,1]
||      SUB2    .S2X    B_f0f1,     Axf7f6,     B_h2h3          ;[ 8,1]
||      LDW     .D1T1   *--A_io_ptr[14],        A_f5f4          ;
||      ROTL    .M1     A_c1c7,     16,         A_c7c1
||      PACK2   .S1     A_dc_rnd,   A_dc_rnd,   A_dc_rnd        ; 0x00040004

        ADD     .S2     B_h2h3,     B_g2g3,     B_s0            ;[ 9,1]
||      DOTPRSU2.M2     B_g2g3,     B_C4__,     B_q1_           ;[ 9,1]
||      ADD2    .L2X    B_f0f1,     Axf7f6,     B_g0g1          ;[ 9,1]
||      ROTL    .M1     A_c6c2,     16,         A_c2c6
||      PACK2   .L1X    A_F6,       B_F6,       A_f7f6          ;[35,4]
||      STW     .D2T1   A_F2F2,     *B_io_ptr++[ 9]             ;[37,4]
||      ADDK    .S1     -8,         A_io_ptr
* ========================== H_LOOP BRANCH OCCURS ========================= *


* ========================================================================= *
*   End of file:  img_fdct_8x8.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
histogram.asm/  1066928952  0     0     0       31419     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Sun Sep 29 03:32:23 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_histogram                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       26-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_histogram                                                  *
*       (                                                                   *
*           const unsigned char *restrict img,  /* incoming image   */      *
*           int   n,                            /* number of pixels */      *
*           short accumulate,                   /* weighting factor */      *
*           short *restrict t_hist,             /* temporary array  */      *
*           short *restrict hist                /* IMG_histogram.       */  *
*       );                                                                  *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code takes a IMG_histogram of an array of n, 8 bit inputs. It  *
*       returns the IMG_histogram of 256 bins at 16 bit precision. It can   *
*       either add  or subtract to an existing IMG_histogram, using the     *
*       'accumulate' control.                                               *
*                                                                           *
*       It requires some temporary storage for 4 temporary histograms,      *
*       which are later summed together.                                    *
*                                                                           *
*       void IMG_histogram                                                  *
*       (                                                                   *
*           const unsigned char *restrict img,  /* incoming image   */      *
*           int   n,                            /* number of pixels */      *
*           short accumulate,                   /* weighting factor */      *
*           short *restrict t_hist,             /* temporary array  */      *
*           short *restrict hist                /* IMG_histogram.       */  *
*       )                                                                   *
*       {                                                                   *
*           int pixel, j;                                                   *
*           for (j = 0; j < n; j++)                                         *
*           {                                                               *
*               pixel = (int) img[j];                                       *
*               hist[pixel] += accumulate;                                  *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has various restrictions, as       *
*       noted below.                                                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       It is assumed that the temporary array of data, t_hist is           *
*       initialised to zero.  The input array of image data must be         *
*       aligned to a 4 byte boundary and n must be a multiple of 8.  The    *
*       maximum number of pixels that can be profiled in each bin is        *
*       65535 in the main IMG_histogram.                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*                                                                           *
*       The main IMG_histogram loop accesses two banks on 8 of 9 cycles,    *
*       and four banks on the 9th cycle.  The summing loop accesses         *
*       128 bits every cycle.                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       This code operates on four interleaved IMG_histogram bins. The loop *
*       is divided into two halves:  The "even" half operates on the        *
*       even-numbered words from the input image, and the "odd" half        *
*       operates on odd words.  Each half processes four pixels at a        *
*       time, and both halves operate on the same four sets of IMG_histogram *
*       bins.  This introduces a memory dependency on the IMG_histogram bins *
*       which ordinarily would degrade performance.  To break the memory    *
*       depenencies, the two halves forward their results to each other     *
*       via the register file, bypassing memory.                            *
*                                                                           *
*       Exact memory access ordering obviates the need to predicate         *
*       stores The algorithm is ordered as follows:                         *
*                                                                           *
*       1.  Load from IMG_histogram for even half                           *
*       2.  Store odd_bin to IMG_histogram for odd half (previous itn.)     *
*       3.  if data_even == previous data_odd increment even_bin by 2       *
*           else increment even_bin by 1, forward to odd                    *
*       4.  Load from IMG_histogram for odd half (current itn.)             *
*       5.  Store even_bin to IMG_histogram for even half                   *
*       6.  if data_odd == previous data_even increment odd_bin by 2        *
*           else increment odd_bin by 1, forward to even                    *
*       7.  goto 1.                                                         *
*                                                                           *
*       With this particular ordering, forwarding is necessary between      *
*       even/odd halves when pixels in adjacent halves need to be           *
*       placed in the same bin.                                             *
*                                                                           *
*       The store is never predicated and occurs speculatively              *
*       as it will be overwritten by the next value containing the          *
*       extra forwarded value.                                              *
*                                                                           *
*       The four histograms are interleaved with each bin spaced four       *
*       half-words apart and each IMG_histogram starting in a different     *
*       memory bank. This allows the four IMG_histogram accesses to proceed *
*       in any order without worrying about bank conflicts.  The            *
*       diagram below illustrates this:  (addresses are halfword            *
*       offsets)                                                            *
*                                                                           *
*           0       1       2       3       4       5       6   ...         *
*       | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...         *
*       | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...         *
*                                                                           *
*       These are then summed together at the end in blocks of 4            *
*                                                                           *
*   CYCLES                                                                  *
*       9 * n/8 + 228                                                       *
*                                                                           *
*   CODESIZE                                                                *
*       552 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_histogram"
        .global _IMG_histogram
_IMG_histogram: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg    B31,    B_csr      ;CSR's value
        .asg    B30,    B_no_gie   ;CSR w/ GIE bit cleared
        .asg    B3,     B_ret      ;Return address
        .asg    A4,     A_image    ;called image pont
        .asg    B4,     B_n        ;number of pixels in image line
        .asg    B6,     B_t_hist   ;redundent IMG_histogram x4
        .asg    A2,     A_1023     ;constant 1023
        .asg    A2,     A_pro      ;prologue selector for codesize
        .asg    A0,     A_i        ;loop count
        .asg    A4,     A_img      ;even image pointer
        .asg    B1,     B_img      ;odd image pointer
        .asg    A25,    A_hst0     ;pntr to IMG_histogram[4*i]
        .asg    A24,    A_hst1     ;pntr to IMG_histogram[4*i+1]
        .asg    B28,    B_hst2     ;pntr to IMG_histogram[4*i+2]
        .asg    B27,    B_hst3     ;pntr to IMG_histogram[4*i+3]
        .asg    A17,    A_ha0o     ;hist 0 value for "odd" half after accumltn
        .asg    A18,    A_ha1o     ;hist 1 value for "odd" half after accumltn
        .asg    B6,     B_ha2o     ;hist 2 value for "odd" half after accumltn
        .asg    B7,     B_ha3o     ;hist 3 value for "odd" half after accumltn
        .asg    A20,    A_bc0o     ;bin copy for pixel 0 in "odd" half of hist
        .asg    A5,     A_bc1o     ;bin copy for pixel 1 in "odd" half of hist
        .asg    B21,    B_bc2o     ;bin copy for pixel 2 in "odd" half of hist
        .asg    B30,    B_bc3o     ;bin copy for pixel 3 in "odd" half of hist
        .asg    A21,    A_pix      ;4 packed even pixles
        .asg    B23,    B_pix      ;4 packed odd pixles
        .asg    A22,    A_px0e     ;pixel 0 in "even" half of IMG_histogram proc
        .asg    A9,     A_px1e     ;pixel 1 in "even" half of IMG_histogram proc
        .asg    A19,    A_px2e     ;pixel 2 in "even" half of IMG_histogram proc
        .asg    B17,    B_px3e     ;pixel 3 in "even" half of IMG_histogram proc
        .asg    A23,    A_bn0e     ;bin for pixel 0 in "even" half of hist proc
        .asg    A16,    A_bn1e     ;bin for pixel 1 in "even" half of hist proc
        .asg    B8,     B_bn2e     ;bin for pixel 2 in "even" half of hist proc
        .asg    B9,     B_bn3e     ;bin for pixel 3 in "even" half of hist proc
        .asg    A19,    A_eq0e     ;equal detect for hist 0 odd->even forward
        .asg    A16,    A_eq1e     ;equal detect for hist 1 odd->even forward
        .asg    B22,    B_eq2e     ;equal detect for hist 2 odd->even forward
        .asg    B17,    B_eq3e     ;equal detect for hist 3 odd->even forward
        .asg    A23,    A_hs0e     ;hist 0 value for "even" half
        .asg    A9,     A_hs1e     ;hist 1 value for "even" half
        .asg    B8,     B_hs2e     ;hist 2 value for "even" half
        .asg    B19,    B_hs3e     ;hist 3 value for "even" half
        .asg    A19,    A_hf0e     ;hist 0 val "even" half with forward added
        .asg    A22,    A_hf1e     ;hist 1 val "even" half with forward added
        .asg    B19,    B_hf2e     ;hist 2 val "even" half with forward added
        .asg    B16,    B_hf3e     ;hist 3 val "even" half with forward added
        .asg    A20,    A_ha0e     ;hist 0 val for "even" half after accumulate
        .asg    A19,    A_ha1e     ;hist 1 val for "even" half after accumulate
        .asg    B16,    B_ha2e     ;hist 2 val for "even" half after accumulate
        .asg    B16,    B_ha3e     ;hist 3 val for "even" half after accumulate
        .asg    A23,    A_bc0e     ;bin copy for pixel 0 in "even" half of hist
        .asg    A3,     A_bc1e     ;bin copy for pixel 1 in "even" half of hist
        .asg    B26,    B_bc2e     ;bin copy for pixel 2 in "even" half of hist
        .asg    B18,    B_bc3e     ;bin copy for pixel 3 in "even" half of hist
        .asg    B5,     B_px0o     ;pixel 0 in "odd" half of IMG_histogram process
        .asg    B9,     B_px1o     ;pixel 1 in "odd" half of IMG_histogram process
        .asg    B24,    B_px2o     ;pixel 2 in "odd" half of IMG_histogram process
        .asg    B9,     B_px3o     ;pixel 3 in "odd" half of IMG_histogram process
        .asg    A21,    A_bn0o     ;bin for pixel 0 in "odd" half of hist proc.
        .asg    A5,     A_bn1o     ;bin for pixel 1 in "odd" half of hist proc.
        .asg    B19,    B_bn2o     ;bin for pixel 2 in "odd" half of hist proc.
        .asg    B20,    B_bn3o     ;bin for pixel 3 in "odd" half of hist proc.
        .asg    A9,     A_eq0o     ;equal detect for hist 0 even->odd forward
        .asg    A7,     A_eq1o     ;equal detect for hist 1 even->odd forward
        .asg    B29,    B_eq2o     ;equal detect for hist 2 even->odd forward
        .asg    B25,    B_eq3o     ;equal detect for hist 3 even->odd forward
        .asg    A7,     A_hs0o     ;hist 0 value for "odd" half
        .asg    A20,    A_hs1o     ;hist 1 value for "odd" half
        .asg    B8,     B_hs2o     ;hist 2 value for "odd" half
        .asg    B8,     B_hs3o     ;hist 3 value for "odd" half
        .asg    A7,     A_hf0o     ;hist 0 val for "odd" half with forward added
        .asg    A5,     A_hf1o     ;hist 1 val for "odd" half with forward added
        .asg    B5,     B_hf2o     ;hist 2 val for "odd" half with forward added
        .asg    B8,     B_hf3o     ;hist 3 val for "odd" half with forward added
; ============================ PIPE LOOP PROLOG1==============================
        MVC     .S2     CSR,        B_csr          ; Capture CSR's state
||      ADD     .L2X    A_img,      4,      B_img  ;[18,0]

        AND     .L2     B_csr,  -2, B_no_gie       ; Clear GIE
||      MV      .L1X    B_t_hist,   A_hst0         ;[13,0]
||      LDW     .D2T2   *B_img++[2],        B_pix  ;[ 1,1]
||      LDW     .D1T1   *A_img++[2],        A_pix  ;[ 1,1]

        MVC     .S2     B_no_gie,   CSR            ; Disable interrupts
||      ADD     .L2     B_t_hist,   6,      B_hst3 ;[12,0]
||      ADD     .L1X    B_t_hist,   2,      A_hst1 ;[12,0]
; ===== Interrupts masked here =====

        LDH     .D2T2   *B_hst3[1],         B_ha3o ;[13,0]
||      LDH     .D1T1   *A_hst1[1],         A_ha1o ;[13,0]
||      ADD     .S2     B_t_hist,   4,      B_hst2 ;[13,0]
||      MVK     .L2     1,          B_bc3o
||      MVK     .L1     1,          A_bc1o

        ADD     .L1X    B_n,        8,      A_i    ;[18,0]
||      LDH     .D2T2   *B_hst2[1],         B_ha2o ;[14,0]
||      LDH     .D1T1   *A_hst0[1],         A_ha0o ;[14,0]
||      B       .S1     LOOP_H8+8                  ;branch into end of kernel

        MVK     .S1     0,          A_pro          ;enable prolgue select
||      MVK     .D2     1,          B_bc2o
||      MVK     .D1     1,          A_bc0o
||      B       .S2     LOOP_H                     ; start loop pipeline

        SHRU    .S2     B_pix,      24,     B_px3o ;[ 6,1] Extract pixel 3
||      EXTU    .S1     A_pix,      24, 24, A_px0e ;[ 6,1] Extract pixel 0

        SHRU    .S2X    A_pix,      24,     B_px3e ;[ 7,1] Extract pixel 3
||      EXTU    .S1     A_pix,      16, 24, A_px1e ;[ 7,1] Extract pixel 1

        EXTU    .S2     B_pix,      8,  24, B_px2o ;[ 8,1] Extract pixel 2

        MPY     .M2     4,          B_px3e, B_bn3e ;[ 9,1] Set offset into hist3
; ============================ PIPE LOOP KERNEL ==============================
LOOP_H:
  [A_pro]ADD    .S2     B_hs3o,     B_eq3o, B_hf3o ;[20,2] forwarding for hist3
||[A_pro]LDH    .D1T1   *A_hst0[A_bn0o],    A_hs0o ;[20,2]
||[A_pro]CMPEQ  .L1     A_bn0o,     A_bc0e, A_eq0o ;[20,2] Even->Odd fwd comp 0
||[A_pro]ADD    .S1     A_hs1e,     A_eq1e, A_hf1e ;[20,2] forwarding for hist1
||      MPY     .M2     1,          B_bn3e, B_bc3e ;[11,3] copy of bin 3 (l2l)
||      LDH     .D2T2   *B_hst3[B_bn3e],    B_hs3e ;[11,3]
||      CMPEQ   .L2     B_bn3e,     B_bc3o, B_eq3e ;[11,3] Odd->Even fwd comp 3
||      MPY     .M1     4,          A_px0e, A_bn0e ;[11,3] Set offset into hist0

  [ A_i]SUB     .L1     A_i,        8,      A_i    ;[31,1] Loop control.
||[A_pro]MPY    .M1     1,          A_bn0o, A_bc0o ;[21,2] copy of bin 0 (l2l)
||[A_pro]ADD    .L2     B_hf3o,     1,      B_ha3o ;[21,2] Accumulate for hist3
||[A_pro]STH    .D1T1   A_ha0e,     *A_hst0[A_bc0e];[21,2]
||[A_pro]ADD    .S1     A_hf1e,     1,      A_ha1e ;[21,2] Accumulate for hist1
||[A_pro]STH    .D2T2   B_ha2o,     *B_hst2[B_bc2o];[21,2]
||      EXTU    .S2     B_pix,      16, 24, B_px1o ;[12,3] Extract pixel 1
||      MPY     .M2X    4,          A_px2e, B_bn2e ;[12,3] Set offset into hist2

  [A_pro]MPY    .M2     1,          B_bn2o, B_bc2o ;[22,2] copy of bin 2 (l2l)
||[A_pro]MPY    .M1     1,          A_bn1o, A_bc1o ;[22,2] copy of bin 1 (l2l)
||[A_pro]ADD    .S1     A_hs1o,     A_eq1o, A_hf1o ;[22,2] forwarding for hist1
||[A_pro]LDH    .D2T2   *B_hst2[B_bn2o],    B_hs2o ;[22,2]
||[A_pro]ADD    .S2     B_hs2e,     B_eq2e, B_hf2e ;[22,2] forwarding for hist2
||[A_i] CMPEQ   .L2     B_bn3o,     B_bc3e, B_eq3o ;[13,3] Even->Odd fwd comp 3
||[A_i] LDH     .D1T1   *A_hst0[A_bn0e],    A_hs0e ;[13,3]

  [ A_i]B       .S2     LOOP_H                     ;[32,1]
||[A_pro]ADD    .S1     A_hf1o,     1,      A_ha1o ;[23,2] Accumulate for hist1
||[A_pro]STH    .D1T1   A_ha1e,     *A_hst1[A_bc1e];[23,2]
||[A_pro]ADD    .L2     B_hf2e,     1,      B_ha2e ;[23,2] Accumulate for hist2
||[A_i] MPY     .M1     1,          A_bn1e, A_bc1e ;[14,3] copy of bin 1 (l2l)
||[A_i] STH     .D2T2   B_ha3o,     *B_hst3[B_bc3o];[14,3]
||[A_i] CMPEQ   .L1     A_bn0e,     A_bc0o, A_eq0e ;[14,3] Odd->Even fwd comp 0

  [A_i] LDH     .D2T2   *B_hst3[B_bn3o],    B_hs3o ;[15,3]
||[A_i] MPY     .M2     4,          B_px2o, B_bn2o ;[15,3] Set offset into hist2
||[A_i] MPY     .M1X    4,          B_px1o, A_bn1o ;[15,3] Set offset into hist1
||[A_i] LDH     .D1T1   *A_hst1[A_bn1e],    A_hs1e ;[15,3]
||[A_i] CMPEQ   .L2     B_bn2e,     B_bc2o, B_eq2e ;[15,3] Odd->Even fwd comp 2
||[A_i] CMPEQ   .L1     A_bn1e,     A_bc1o, A_eq1e ;[15,3] Odd->Even fwd comp 1
||[A_i] SHRU    .S2     B_pix,      24,     B_px3o ;[ 6,4] Extract pixel 3
||[A_i] EXTU    .S1     A_pix,      24, 24, A_px0e ;[ 6,4] Extract pixel 0

 [A_pro]ADD     .L1     A_hs0o,     A_eq0o, A_hf0o ;[25,2] forwarding for hist0
||[A_pro]STH    .D2T2   B_ha2e,     *B_hst2[B_bc2e];[25,2]
||[A_i] MPY     .M2     1,          B_bn2e, B_bc2e ;[16,3] copy of bin 2 (l2l)
||[A_i] ADD     .L2     B_hs3e,     B_eq3e, B_hf3e ;[16,3] forwarding for hist3
||[A_i] STH     .D1T1   A_ha1o,     *A_hst1[A_bc1o];[16,3]
||[A_i] SHRU    .S2X    A_pix,      24,     B_px3e ;[ 7,4] Extract pixel 3
||[A_i] EXTU    .S1     A_pix,      16, 24, A_px1e ;[ 7,4] Extract pixel 1
||      MVD     .M1     A_i,        A_pro          ;enable kernel of loop_h

 [A_pro]ADD     .S1     A_hf0o,     1,      A_ha0o ;[26,2] Accumulate for hist0
||[A_i] MPY     .M2     1,          B_bn3o, B_bc3o ;[17,3] copy of bin 3 (l2l)
||[A_i] LDH     .D1T1   *A_hst1[A_bn1o],    A_hs1o ;[17,3]
||[A_i] CMPEQ   .L1     A_bn1o,     A_bc1e, A_eq1o ;[17,3] Even->Odd fwd comp 1
||[A_i] MPY     .M1     1,          A_bn0e, A_bc0e ;[17,3] copy of bin 0 (l2l)
||[A_i] ADD     .L2     B_hf3e,     1,      B_ha3e ;[17,3] Accumulate for hist3
||[A_i] LDH     .D2T2   *B_hst2[B_bn2e],    B_hs2e ;[17,3]
||[A_i] EXTU    .S2     B_pix,      8,  24, B_px2o ;[ 8,4] Extract pixel 2

 [A_pro]ADD     .S2     B_hs2o,     B_eq2o, B_hf2o ;[27,2] forwarding for hist2
||[A_i] STH     .D2T2   B_ha3e,     *B_hst3[B_bc3e];[18,3]
||[A_i] CMPEQ   .L2     B_bn2o,     B_bc2e, B_eq2o ;[18,3] Even->Odd fwd comp 2
||[A_i] MPY     .M1X    4,          B_px0o, A_bn0o ;[18,3] Set offset into hist0
||[A_i] ADD     .L1     A_hs0e,     A_eq0e, A_hf0e ;[18,3] forwarding for hist0
||[A_i] STH     .D1T1   A_ha0o,     *A_hst0[A_bc0o];[18,3]
||[A_i] MPY     .M2     4,          B_px3e, B_bn3e ;[ 9,4] Set offset into hist3
LOOP_H8:
  [A_pro]ADD    .L2     B_hf2o,     1,      B_ha2o ;[28,2] Accumulate for hist2
||[A_i] ADD     .L1     A_hf0e,     1,      A_ha0e ;[19,3] Accumulate for hist0
||[A_i] MPY     .M2     4,          B_px3o, B_bn3o ;[10,4] Set offset into hist3
||[A_i] EXTU    .S2     B_pix,      24, 24, B_px0o ;[10,4] Extract pixel 0
||[A_i] EXTU    .S1     A_pix,      8,  24, A_px2e ;[10,4] Extract pixel 2
||[A_i] MPY     .M1     4,          A_px1e, A_bn1e ;[10,4] Set offset into hist1
||[A_i] LDW     .D2T2   *B_img++[2],        B_pix  ;[ 1,5]
||[A_i] LDW     .D1T1   *A_img++[2],        A_pix  ;[ 1,5]
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg    A6,     A_accumulate ;add or subtract to total IMG_histogram
        .asg    A8,     A_hist       ;even main IMG_histogram 256 bins
        .asg    B9,     B_hist       ;odd main IMG_histogram 256 bins
        .asg    A0,     A_i          ;loop count
        .asg    A3,     A_1010       ;constant to sum within register
       ;.asg    B8,     B_1010       ;constant to sum within register
        .asg    A25,    A_th_ptr     ;redundent IMG_histogram even
        .asg    B18,    B_th_ptr     ;redundent IMG_histogram odd
        .asg    A17,    A_ha0o       ;final hist 0 val for "odd" half after acc
        .asg    A18,    A_ha1o       ;final hist 1 val for "odd" half after acc
        .asg    B6,     B_ha2o       ;final hist 2 val for "odd" half after acc
        .asg    B7,     B_ha3o       ;final hist 3 val for "odd" half after acc
        .asg    A25,    A_hst0       ;final pointer to interleaved IMG_histogram 0
        .asg    A24,    A_hst1       ;final pointer to interleaved IMG_histogram 1
        .asg    B28,    B_hst2       ;final pointer to interleaved IMG_histogram 2
        .asg    B27,    B_hst3       ;final pointer to interleaved IMG_histogram 3
        .asg    A20,    A_bc0o       ;final bin copy for pixel 0 in "odd" half
        .asg    A5,     A_bc1o       ;final bin copy for pixel 1 in "odd" half
        .asg    B21,    B_bc2o       ;final bin copy for pixel 2 in "odd" half
        .asg    B30,    B_bc3o       ;final bin copy for pixel 3 in "odd" half

        .asg    B1,     B_r
        .asg    A1,     A_r
        .asg    B0,     B_c
        .asg    B7,     B_t_fe
        .asg    B6,     B_t_dc
        .asg    B7,     B_t_ba
        .asg    B6,     B_t_98
        .asg    A7,     A_t_76
        .asg    A6,     A_t_54
        .asg    A5,     A_t_32
        .asg    A4,     A_t_10
        .asg    B7,     B_s_fedc
        .asg    B5,     B_s_ba98
        .asg    A16,    A_s_7654
        .asg    A5,     A_s_3210
        .asg    B16,    B_s_Z
        .asg    B6,     B_s_Y
        .asg    A16,    A_s_X
        .asg    A17,    A_s_W
        .asg    B17,    B_s_ZY
        .asg    A7,     A_s_XW
        .asg    B5,     B_h_ZY
        .asg    B4,     B_h_XW
        .asg    B17,    B_h_ZY_
        .asg    A4,     A_h_XW
        .asg    A5,     A_h_ZY

*============================= PIPE LOOP PROLOG2===============================*
        STH     .D2T2   B_ha3o,     *B_hst3[B_bc3o]        ;[ 5,0]
||      STH     .D1T1   A_ha1o,     *A_hst1[A_bc1o]        ;[ 5,0]

        STH     .D2T2   B_ha2o,     *B_hst2[B_bc2o]        ;[ 6,0]
||      STH     .D1T1   A_ha0o,     *A_hst0[A_bc0o]        ;[ 6,0]
||      ADD     .L2     B_hst3,     10,         B_th_ptr

; ============================ PIPE LOOP PROLOG ==============================
        LDDW    .D2T2   *B_th_ptr[1],           B_t_fe:B_t_dc   ;[ 1,1]
||      PACK2   .L1     A_accumulate, A_accumulate, A_1010 ;[ 2,0]add/subtract
||      B               LOOP_S

        MVK     .D1     1,          A_r
||      MVK     .S1     65,         A_i
||      MVK     .D2     1,          B_r
||      MVC     .S2     B_csr,      CSR

        LDDW    .D1T1   *A_th_ptr[1],           A_t_76:A_t_54   ;[ 3,1]
||      LDDW    .D2T2   *B_th_ptr++[4],         B_t_ba:B_t_98   ;[ 3,1]
||      MV      .L2X    A_hist,     B_hist
||      ADDK    .S1     -8,         A_hist
||      MVK     .S2     5,          B_c
; collapsed 4 prolog stages
; ============================ PIPE LOOP KERNEL ==============================
LOOP_S:
  [ B_c]SUB     .S2     B_c,        1,          B_c             ; collapse
||      MV      .L1X    B_h_ZY_,    A_h_ZY                      ;[16,1]
||      BDEC    .S1     LOOP_S,     A_i                         ;[13,2]
||      PACK2   .L2     B_s_Z,      B_s_Y,      B_s_ZY          ;[13,2]
||[ B_r]DOTP2   .M1     A_1010,     A_s_3210,   A_s_W           ;[10,3]
||[ B_r]DOTP2   .M2X    A_1010,     B_s_fedc,   B_s_Z           ;[ 7,4]
||[ B_r]LDDW    .D1T1   *A_th_ptr++[4],         A_t_32:A_t_10   ;[ 4,5]
||[ B_r]LDDW    .D2T2   *B_th_ptr[1],           B_t_fe:B_t_dc   ;[ 1,6]

  [!B_c]STDW    .D2T1   A_h_ZY:A_h_XW,          *B_hist++[1]    ;[17,1]
||      ADD2    .S2     B_s_ZY,     B_h_ZY,     B_h_ZY_         ;[14,2]
||      PACK2   .L1     A_s_X,      A_s_W,      A_s_XW          ;[14,2]
||[ B_r]LDDW    .D1T2   *A_hist++[1],           B_h_ZY:B_h_XW   ;[ 8,4]
||      ADD2    .S1     A_t_76,     A_t_54,     A_s_7654        ;[ 8,4]
||      ADD2    .L2     B_t_ba,     B_t_98,     B_s_ba98        ;[ 8,4]
||[ B_r]ROTL    .M1     A_i,        0,          A_r
||[!A_i]MVD     .M2     B_c,                    B_r

        ADD2    .S1X    A_s_XW,     B_h_XW,     A_h_XW          ;[15,2]
||[!A_r]RET     .S2     B_ret                                   ;[19,0] return
||[ B_r]DOTP2   .M1     A_1010,     A_s_7654,   A_s_X           ;[ 9,4]
||[ B_r]DOTP2   .M2X    A_1010,     B_s_ba98,   B_s_Y           ;[ 9,4]
||      ADD2    .L1     A_t_32,     A_t_10,     A_s_3210        ;[ 9,4]
||      ADD2    .L2     B_t_fe,     B_t_dc,     B_s_fedc        ;[ 6,5]
||[ B_r]LDDW    .D1T1   *A_th_ptr[1],           A_t_76:A_t_54   ;[ 3,6]
||[ B_r]LDDW    .D2T2   *B_th_ptr++[4],         B_t_ba:B_t_98   ;[ 3,6]

; ============================ PIPE LOOP EPILOG ==============================
; collapsed 5 epilog stages


* ========================================================================= *
*   End of file:  img_histogram.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

idct_8x8_0.asm/ 1066928952  0     0     0       68864     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:32:23 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_idct_8x8_12q4 -- IEEE-1180/1990 Compliant IDCT, Little Endian.  *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Nov-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_idct_8x8_12q4(short idct_data[], unsigned num_idcts)   *
*                                                                           *
*       The IMG_idct_8x8_12q4 routine accepts a list of 8x8 DCT coeffient blocks *
*       and performs IDCTs on each.  The array should be aligned to a       *
*       64-bit boundary, and be laid out equivalently to the C array        *
*       idct_data[num_idcts][8][8].  The input data should be in 12Q4       *
*       format.                                                             *
*                                                                           *
*       The routine operates entirely in-place, requiring no additional     *
*       storage for intermediate results.                                   *
*                                                                           *
*       This code requires '62 + 92 * num_idcts' cycles to process          *
*       'num_idcts' blocks, including 6 cycles of function call overhead.   *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_idct_8x8_12q4 algorithm performs an IEEE-1180 compliant IDCT, *
*       complete with rounding and saturation to signed 9-bit quantities.   *
*       The input coefficients are assumed to be signed 16-bit DCT          *
*       coefficients in 12Q4 format.                                        *
*                                                                           *
*       void IMG_idct_8x8_12q4(short idct_data[], unsigned num_idcts)       *
*       {                                                                   *
*           /* -------------------------------------------------------- */  *
*           /*  Cosine Constants (Q16, scaled down by sqrt(2)).         */  *
*           /* -------------------------------------------------------- */  *
*           const unsigned short C0 = 0xB505;                               *
*           const unsigned short C1 = 0xB18B, C2 = 0xA73D;                  *
*           const unsigned short C3 = 0x9683, C5 = 0x6492;                  *
*           const unsigned short C6 = 0x4546, C7 = 0x2351;                  *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Intermediate values (used in both loops).               */  *
*           /* -------------------------------------------------------- */  *
*           short F0, F1, F2, F3, F4, F5, F6, F7;  /* stage 0           */  *
*           short P0, P1, R0, R1, Q0, Q1, S0, S1;  /* stage 1           */  *
*           short p0, p1, r0, r1, q0, q1, s0, s1;  /* stage 2           */  *
*           short g0, g1, g2, g3, h0, h1, h2, h3;  /* stage 3           */  *
*           short f0, f1, f2, f3, f4, f5, f6, f7;  /* stage 4           */  *
*           short f0r,f1r,f2r,f3r,f4r,f5r,f6r,f7r; /* rounded           */  *
*           int   f0s,f1s,f2s,f3s,f4s,f5s,f6s,f7s; /* saturated         */  *
*           int   f0t,f1t,f2t,f3t,f4t,f5t,f6t,f7t; /* truncated         */  *
*           int   i, j;                            /* loop counts       */  *
*           short (*idct)[8][8] = (short (*)[8][8])idct_data;               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Vertical Pass                                           */  *
*           /*                                                          */  *
*           /*  This pass performs a single 8-pt IDCT per iteration.    */  *
*           /*  Inputs are in 12Q4 format, and results of this pass     */  *
*           /*  are in 11Q5 format. (Actually, the results are halfway  */  *
*           /*  between 11Q5 and 12Q4 due to the scaling by sqrt(2).)   */  *
*           /*                                                          */  *
*           /*  The outer loop steps between IDCT blocks, whereas the   */  *
*           /*  inner loop focuses on columns within each IDCT block.   */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < num_idcts; i++)                                 *
*           {                                                               *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 0:  Load in freq-domain coefficients.     */  *
*                   /* ------------------------------------------------ */  *
*                   F0 = idct[i][0][j];                                     *
*                   F1 = idct[i][1][j];                                     *
*                   F2 = idct[i][2][j];                                     *
*                   F3 = idct[i][3][j];                                     *
*                   F4 = idct[i][4][j];                                     *
*                   F5 = idct[i][5][j];                                     *
*                   F6 = idct[i][6][j];                                     *
*                   F7 = idct[i][7][j];                                     *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 1 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   P0 = F0;                P1 = F4;                        *
*                   R1 = F2;                R0 = F6;                        *
*                                                                           *
*                   Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;                    *
*                   Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;                    *
*                   S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;                    *
*                   S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 2 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   p0 = ((int)P0 + (int)P1 + 1 ) >> 1;                     *
*                   p1 = ((int)P0 - (int)P1     ) >> 1;                     *
*                   r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;                    *
*                   r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;                    *
*                                                                           *
*                   s1 = (S1 + S0);         q1 = (Q1 + Q0);                 *
*                   s0 = (S1 - S0);         q0 = (Q1 - Q0);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 3 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   g0 = (p0 + r0);         g1 = (p1 + r1);                 *
*                   h0 = (p0 - r0);         h1 = (p1 - r1);                 *
*                                                                           *
*                   h2 = s1;                g2 = q1;                        *
*                   g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;                    *
*                   h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   f0 = (g0 + h2);         f7 = (g0 - h2);                 *
*                   f1 = (g1 + h3);         f6 = (g1 - h3);                 *
*                   f2 = (h1 + g3);         f5 = (h1 - g3);                 *
*                   f3 = (h0 + g2);         f4 = (h0 - g2);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 5:  Write sample-domain results.          */  *
*                   /* ------------------------------------------------ */  *
*                   idct[i][0][j] = f0;                                     *
*                   idct[i][1][j] = f1;                                     *
*                   idct[i][2][j] = f2;                                     *
*                   idct[i][3][j] = f3;                                     *
*                   idct[i][4][j] = f4;                                     *
*                   idct[i][5][j] = f5;                                     *
*                   idct[i][6][j] = f6;                                     *
*                   idct[i][7][j] = f7;                                     *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Horizontal Pass                                         */  *
*           /*                                                          */  *
*           /*  This performs one IDCT per iteration on the 11Q5        */  *
*           /*  results from the previous pass.  Both horizontal and    */  *
*           /*  vertical passes are scaled down by sqrt(2) -- the net   */  *
*           /*  effect of which is that the IDCT results generated by   */  *
*           /*  this pass (prior to saturation) are also 11Q5 results,  */  *
*           /*  only with no sqrt(2) factors remaining.                 */  *
*           /*                                                          */  *
*           /*  The IDCT butterflies in this pass are identical to the  */  *
*           /*  ones in the vertical pass, except for an additional     */  *
*           /*  rounding value which is added into the DC term early    */  *
*           /*  in the flow graph.                                      */  *
*           /*                                                          */  *
*           /*  The 11Q5 sample-domain terms are saturated to 9Q7       */  *
*           /*  values, and then truncated to 9Q0 results before        */  *
*           /*  storing.                                                */  *
*           /*                                                          */  *
*           /*  The outer loop steps between IDCT blocks, whereas the   */  *
*           /*  inner loop focuses on rows within each IDCT block.      */  *
*           /* -------------------------------------------------------- */  *
*           for (i = num_idcts - 1; i >= 0; i--)                            *
*           {                                                               *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 0:  Load in freq.-domain coefficients.    */  *
*                   /* ------------------------------------------------ */  *
*                   F0 = idct[i][j][0];                                     *
*                   F1 = idct[i][j][1];                                     *
*                   F2 = idct[i][j][2];                                     *
*                   F3 = idct[i][j][3];                                     *
*                   F4 = idct[i][j][4];                                     *
*                   F5 = idct[i][j][5];                                     *
*                   F6 = idct[i][j][6];                                     *
*                   F7 = idct[i][j][7];                                     *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 1 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   P0 = F0;                P1 = F4;                        *
*                   R1 = F2;                R0 = F6;                        *
*                                                                           *
*                   Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;                    *
*                   Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;                    *
*                   S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;                    *
*                   S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 2 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   p0 = (((int)P0 + (int)P1 + 1) >> 1) + 15;               *
*                   p1 = (((int)P0 - (int)P1    ) >> 1) + 16;               *
*                   r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;                    *
*                   r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;                    *
*                                                                           *
*                   s1 = (S1 + S0);         q1 = (Q1 + Q0);                 *
*                   s0 = (S1 - S0);         q0 = (Q1 - Q0);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 3 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   g0 = (p0 + r0);         g1 = (p1 + r1);                 *
*                   h0 = (p0 - r0);         h1 = (p1 - r1);                 *
*                                                                           *
*                   h2 = s1;                g2 = q1;                        *
*                   g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;                    *
*                   h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   f0 = (g0 + h2);         f7 = (g0 - h2);                 *
*                   f1 = (g1 + h3);         f6 = (g1 - h3);                 *
*                   f2 = (h1 + g3);         f5 = (h1 - g3);                 *
*                   f3 = (h0 + g2);         f4 = (h0 - g2);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.1:  Q-pt adjust: Bit 15 is don't-care.  */  *
*                   /* ------------------------------------------------ */  *
*                   f0r = f0 + f0;          f7r = f7 + f7;                  *
*                   f1r = f1 + f1;          f6r = f6 + f6;                  *
*                   f2r = f2 + f2;          f5r = f5 + f5;                  *
*                   f3r = f3 + f3;          f4r = f4 + f4;                  *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.2:  Saturate results to 9Q6.            */  *
*                   /* ------------------------------------------------ */  *
*                   f0s = f0r>0x3FFF?0x3FFF: f0r<-0x4000?-0x4000 : f0r;     *
*                   f1s = f1r>0x3FFF?0x3FFF: f1r<-0x4000?-0x4000 : f1r;     *
*                   f2s = f2r>0x3FFF?0x3FFF: f2r<-0x4000?-0x4000 : f2r;     *
*                   f3s = f3r>0x3FFF?0x3FFF: f3r<-0x4000?-0x4000 : f3r;     *
*                   f4s = f4r>0x3FFF?0x3FFF: f4r<-0x4000?-0x4000 : f4r;     *
*                   f5s = f5r>0x3FFF?0x3FFF: f5r<-0x4000?-0x4000 : f5r;     *
*                   f6s = f6r>0x3FFF?0x3FFF: f6r<-0x4000?-0x4000 : f6r;     *
*                   f7s = f7r>0x3FFF?0x3FFF: f7r<-0x4000?-0x4000 : f7r;     *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.3:  Truncate results to 9Q0.            */  *
*                   /* ------------------------------------------------ */  *
*                   f0t = f0s >> 6;         f7t = f7s >> 6;                 *
*                   f1t = f1s >> 6;         f6t = f6s >> 6;                 *
*                   f2t = f2s >> 6;         f5t = f5s >> 6;                 *
*                   f3t = f3s >> 6;         f4t = f4s >> 6;                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 5:  Store sample-domain results.          */  *
*                   /* ------------------------------------------------ */  *
*                   idct[i][j][0] = f0t;                                    *
*                   idct[i][j][1] = f1t;                                    *
*                   idct[i][j][2] = f2t;                                    *
*                   idct[i][j][3] = f3t;                                    *
*                   idct[i][j][4] = f4t;                                    *
*                   idct[i][j][5] = f5t;                                    *
*                   idct[i][j][6] = f6t;                                    *
*                   idct[i][j][7] = f7t;                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return;                                                         *
*       }                                                                   *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_idcts == 0'.  In that case, the function runs for only    *
*       13 cycles (counting 6 cycles of function-call overhead), due to     *
*       early-exit code.  Also, the assembly code imposes additional data   *
*       alignment restrictions that are not present in the C code above.    *
*                                                                           *
*   TECHNIQUES                                                              *
*       All levels of looping are collapsed into single loops which are     *
*       pipelined.  The outer loop focuses on 8-pt IDCTs, whereas the       *
*       inner loop controls the column-pointer to handle jumps between      *
*       IDCT blocks.  (The column-pointer adjustment is handled by a        *
*       four-phase rotating "fixup" constant which takes the place of       *
*       the original inner-loop.)                                           *
*                                                                           *
*       For performance, portions of the outer-loop code have been          *
*       inter-scheduled with the prologs and epilogs of both loops.         *
*       Finally, cosine term registers are reused between the horizontal    *
*       and vertical loops to save the need for reinitialization.           *
*                                                                           *
*       To save codesize, prolog and epilog collapsing have been performed  *
*       to the extent that performance is not affected.  The remaining      *
*       prolog and epilog code has been interscheduled with code outside    *
*       the loops to improve performance.                                   *
*                                                                           *
*       Additional section-specific optimization notes are provided below.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       The input array must be aligned on a double-word boundary.          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       The input array must be aligned on a double-word boundary.          *
*                                                                           *
*       Bank usage for N 32-bit banks:                                      *
*                                                                           *
*           Vert loop accesses:  2 of N banks for 54% of cycles             *
*                                1 of N banks for 36% of cycles             *
*                                0 of N banks for  9% of cycles             *
*                                                                           *
*           Horiz loop accesses: 4 of N banks for 16% of cycles             *
*                                2 of N banks for 33% of cycles             *
*                                0 of N banks for 50% of cycles             *
*                                                                           *
*       The code may perform speculative reads of up to 128 bytes           *
*       beyond the end or before the start of the IDCT array.  The          *
*       speculatively accessed data is ignored.                             *
*                                                                           *
*   NOTES                                                                   *
*       This is fully interruptable and fully reentrant.                    *
*                                                                           *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 62 + 92 * num_idcts, for num_idcts > 0                     *
*       cycles = 13,                  for num_idcts == 0.                   *
*                                                                           *
*       For num_idcts =  6, cycles = 614.                                   *
*       For num_idcts = 24, cycles = 2270.                                  *
*                                                                           *
*   CODESIZE                                                                *
*       968 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_h"

        .sect ".text:_idct_8x8"
        .global _IMG_idct_8x8_12q4
_IMG_idct_8x8_12q4:
; ====================== SYMBOLIC CONSTANT ASSIGNMENTS =======================
        .asg            0xB505,     cst_c0  ; cos term c0 (scaled by sqrt(2))
        .asg            0xB18B,     cst_c1  ; cos term c1 (scaled by sqrt(2))
        .asg            0xA73D,     cst_c2  ; cos term c2 (scaled by sqrt(2))
        .asg            0x9683,     cst_c3  ; cos term c3 (scaled by sqrt(2))
        .asg            0x8000,     cst_c4  ; cos term c4 (scaled by sqrt(2))
        .asg            0x6492,     cst_c5  ; cos term c5 (scaled by sqrt(2))
        .asg            0x4546,     cst_c6  ; cos term c6 (scaled by sqrt(2))
        .asg            0x2351,     cst_c7  ; cos term c7 (scaled by sqrt(2))
        .asg            0x01011D01, cst_fix ; Pointer fixup constant (v_loop)
        .asg            0x000F0010, cst_rnd ; Rounding constant (h_loop)
; =================== SYMBOLIC REGISTER ASSIGNMENTS: MISC ====================
        .asg            B3,         B_ret   ; Return address from function
        .asg            A30,        A_cnt   ; Loop trip count
        .asg            A16,        A_C00   ; Cosine term c0 packed twice
        .asg            A17,        A_C17   ; Cosine terms c1, c7 (packed)
        .asg            A18,        A_C26   ; Cosine terms c2, c6 (packed)
        .asg            A19,        A_C35   ; Cosine terms c3, c5 (packed)
        .asg            B19,        B_C35   ; Cosine terms c3, c5 (packed)
        .asg            A20,        A_C53   ; Cosine terms c5, c3 (packed)
        .asg            A21,        A_C62   ; Cosine terms c6, c2 (packed)
        .asg            A22,        A_C71   ; Cosine terms c7, c1 (packed)
; ================== SYMBOLIC REGISTER ASSIGNMENTS: V_LOOP ===================
        ; Constants held in registers
        .asg            A27,        A_k_neg ; Negation cst: 0x0000FFFF
        .asg            B21,        B_k_fix ; Pointer fixup cst: 0x01011D01
        .asg            A6,         A_fx2   ; Pointer fixup, output pointer
        .asg            B16,        B_fx1   ; Pointer fixup, input pointer

        ; Pointers and loop control
        .asg            B23,        B_i_ptr ; Input pointer
        .asg            A4,         A_o_ptr ; Output pointer
        .asg            B4,         B_i     ; Loop counter
        .asg            B0,         B_c     ; Prolog collapse predicate

        ; Inputs (common to both IDCTs)
        .asg            B29,        B_F00   ; Freq domain term F0 (two cols)
        .asg            B9,         B_F11   ; Freq domain term F1 (two cols)
        .asg            B2,         B_F22   ; Freq domain term F2 (two cols)
        .asg            B31,        B_F33   ; Freq domain term F3 (two cols)
        .asg            B22,        B_F44   ; Freq domain term F4 (two cols)
        .asg            B18,        B_F55   ; Freq domain term F5 (two cols)
        .asg            B8,         B_F66   ; Freq domain term F6 (two cols)
        .asg            B17,        B_F77   ; Freq domain term F7 (two cols)

        ; Symbolic names for IDCTs in even-numbered columns.
        .asg            B19,        B_F04   ; Freq terms F0, F4 (packed)
        .asg            B9,         B_F17   ; Freq terms F1, F7 (packed)
        .asg            B9,         B_F26   ; Freq terms F2, F6 (packed)
        .asg            B19,        B_F40   ; Freq terms F4, F0 (packed)
        .asg            B18,        B_F53   ; Freq terms F5, F3 (packed)
        .asg            B6,         B_F0n4  ; F04, with term F4 'negated'
        .asg            B6,         B_p0p1  ; Nodes p0, p1 (packed)
        .asg            B26,        B_r0    ; Node r0 in signal flow graph
        .asg            B27,        B_r1    ; Node r1 in signal flow graph
        .asg            B16,        B_r0r1  ; Nodes r0, r1 (packed)
        .asg            B30,        B_g0g1  ; Nodes g0, g1 (packed)
        .asg            B5,         B_h0h1  ; Nodes h0, h1 (packed)
        .asg            B8,         B_Q1    ; Node Q1 in signal flow graph
        .asg            B28,        B_Q0    ; Node Q0 in signal flow graph
        .asg            B25,        B_S0    ; Node S0 in signal flow graph
        .asg            B7,         B_S1    ; Node S1 in signal flow graph
        .asg            B25,        B_S0Q0  ; Nodes S0, Q0 (packed)
        .asg            B7,         B_S1Q1  ; Nodes S1, Q1 (packed)
        .asg            B28,        B_s0q0  ; Nodes s0, q0 (packed)
        .asg            B20,        B_h2g2  ; Nodes h2, g2 (packed)
        .asg            B19,        B_g3    ; Node g3 in signal flow graph
        .asg            B24,        B_h3    ; Node h3 in signal flow graph
        .asg            B24,        B_h2h3  ; Nodes h2, h3 (packed)
        .asg            B20,        B_g2g3  ; Nodes g2, g3 (packed)
        .asg            B26,        B_f01   ; Sample domain f0, f1 (packed)
        .asg            B17,        B_f32   ; Sample domain f3, f2 (packed)
        .asg            B1,         B_f45   ; Sample domain f4, f5 (packed)
        .asg            B27,        B_f76   ; Sample domain f7, f6 (packed)

        ; Symbolic names for IDCTs in odd-numbered columns.
        .asg            B29,        B_F04x  ; Freq terms F0, F4 (packed)
        .asg            B31,        B_F17x  ; Freq terms F1, F7 (packed)
        .asg            B6,         B_F26x  ; Freq terms F2, F6 (packed)
        .asg            B1,         B_F53x  ; Freq terms F5, F3 (packed)
        .asg            A24,        A_F17   ; Freq terms F1, F7 (packed)
        .asg            A1,         A_F26   ; Freq terms F2, F6 (packed)
        .asg            A8,         A_F40   ; Freq terms F4, F0 (packed)
        .asg            A9,         A_F53   ; Freq terms F5, F3 (packed)
        .asg            A31,        A_F0n4  ; F04, with term F4 'negated'
        .asg            A0,         A_p0p1  ; Nodes p0, p1 (packed)
        .asg            A3,         A_r0    ; Node r0 in signal flow graph
        .asg            A28,        A_r1    ; Node r1 in signal flow graph
        .asg            A7,         A_r0r1  ; Nodes r0, r1 (packed)
        .asg            A0,         A_g0g1  ; Nodes g0, g1 (packed)
        .asg            A5,         A_h0h1  ; Nodes h0, h1 (packed)
        .asg            A7,         A_Q1    ; Node Q1 in signal flow graph
        .asg            A23,        A_Q0    ; Node Q0 in signal flow graph
        .asg            A31,        A_S0    ; Node S0 in signal flow graph
        .asg            A28,        A_S1    ; Node S1 in signal flow graph
        .asg            A23,        A_S0Q0  ; Nodes S0, Q1 (packed)
        .asg            A6,         A_S1Q1  ; Nodes S0, Q1 (packed)
        .asg            A7,         A_s0q0  ; Nodes s0, q1 (packed)
        .asg            A6,         A_h2g2  ; Nodes h0, g1 (packed)
        .asg            A8,         A_g3    ; Node g3 in signal flow graph
        .asg            A3,         A_h3    ; Node h3 in signal flow graph
        .asg            A6,         A_h2h3  ; Nodes h2, h3 (packed)
        .asg            A9,         A_g2g3  ; Nodes g2, g3 (packed)
        .asg            A8,         A_f01   ; Sample domain f0, f1 (packed)
        .asg            A29,        A_f32   ; Sample domain f3, f2 (packed)
        .asg            A26,        A_f45   ; Sample domain f4, f5 (packed)
        .asg            A5,         A_f76   ; Sample domain f7, f6 (packed)

        ; Final output/recombination step
        .asg            A25,        A_f00   ; Sample domain term f0 (two cols)
        .asg            A9,         A_f11   ; Sample domain term f1 (two cols)
        .asg            A9,         A_f22   ; Sample domain term f2 (two cols)
        .asg            A29,        A_f33   ; Sample domain term f3 (two cols)
        .asg            A7,         A_f44   ; Sample domain term f4 (two cols)
        .asg            A24,        A_f55   ; Sample domain term f5 (two cols)
        .asg            A23,        A_f66   ; Sample domain term f6 (two cols)
        .asg            A5,         A_f77   ; Sample domain term f7 (two cols)
; ============================================================================

* ========================================================================= *
*  Vertical loop setup                                                      *
*                                                                           *
*  Here, the first stage of the prolog is interscheduled with the setup     *
*  code which sets up the cosine terms for the function.  Additionally, we  *
*  perform the "abort" test here, since it doesn't cost us anything,        *
*  except possibly codesize.                                                *
*                                                                           *
*  To save some superfluous MVs, A_o_ptr and B_i have been allocated to     *
*  A4 and B4 respectively.  Also, since A_o_ptr and B_i_ptr start out       *
*  pointing to the same location, the LDWs in the prolog have been          *
*  rewritten to use A_o_ptr, so that we can start loading DCT inputs        *
*  right in the first cycle of the function.                                *
*                                                                           *
*  In the vertical loop, the input and output pointers need to alternate    *
*  through four separate column positions, and then jump between DCT        *
*  blocks.  This is achieved by adding a repeating sequence of pointer      *
*  fixup values to the pointers.  The sequence rotates through the values   *
*  1, 1, 1 and 29, thus providing the following pointer motion:             *
*  cols 0/1 -> 2/3, cols 2/3 -> 4/5, cols 4/5 -> 6/7, and then              *
*  cols 6/7 -> 0/1 (next block).  Since each fixup value is small enough    *
*  to fit in a byte, the four fixup values are stored in a 32-bit constant  *
*  which is rotated 8 bits each iteration.  The upper 8 bits are extracted  *
*  to provide the fixup value.                                              *
*                                                                           *
*  Finally, the starting pointer value and loop trip count calculated       *
*  here are saved in registers for the horizontal loop that follows this.   *
* ========================================================================= *

; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:
;-
        LDW     .D1T2   *+A_o_ptr[12],          B_F33        ;[ 1,1] read F3
||      MVKL    .S1     cst_c0,     A_C00                    ; Constant c0 (lo)
||      MVKL    .S2     cst_c5,     B_C35                    ; Constant c5 (lo)
||      MV      .L2     B_i,        B_c                      ; Early abort flag

  [ B_c]LDW     .D1T2   *+A_o_ptr[20],          B_F55        ;[ 2,1] read F5
||[ B_c]MVKL    .S1     cst_c1,     A_C71                    ; Constant c1 (lo)
||[!B_c]RET     .S2     B_ret       ; abort if num_idcts == 0
;-
  [ B_c]LDW     .D1T2   *+A_o_ptr[28],          B_F77        ;[ 3,1] read F7
||[ B_c]SHL     .S2     B_i,        2,          B_i          ; 4*num_idct iters
||[ B_c]MVKL    .S1     cst_c2,     A_C62                    ; Constant c2 (lo)
||[ B_c]MVK     .D2     1,          B_fx1                    ; Init ptr fixup

  [ B_c]LDW     .D1T2   *+A_o_ptr[4],           B_F11        ;[ 4,1] read F1
||[ B_c]MVKLH   .S2     cst_c3,     B_C35                    ; Constant c3 (hi)
||[ B_c]MVKLH   .S1     cst_c6,     A_C62                    ; Constant c6 (hi)
||[ B_c]PACK2   .L1     A_C00,      A_C00,      A_C00        ; Constant c0 (hi)
;-
  [ B_c]LDW     .D1T2   *+A_o_ptr[8],           B_F22        ;[ 5,1] read F2
||[ B_c]XPND2   .M1     A_C62,      A_k_neg                  ; Constant 0xFFFF

  [ B_c]LDW     .D1T2   *+A_o_ptr[16],          B_F44        ;[ 6,1] read F4
||[ B_c]MVKLH   .S1     cst_c7,     A_C71                    ; Constant c7 (hi)
||[ B_c]MVKL    .S2     cst_fix,    B_k_fix                  ; Ptr fixup const
||[ B_c]ROTL    .M1     A_C62,      16,         A_C26        ; Swap c6, c2
||[ B_c]MV      .D2X    A_o_ptr,    B_i_ptr                  ; Init B_i_ptr
||[ B_c]MV      .L1X    B_C35,      A_C35                    ; Partitioning MV.
;-
  [ B_c]LDW     .D1T2   *+A_o_ptr[24],          B_F66        ;[ 7,1] read F6
||[ B_c]PACKH2  .L2     B_F55,      B_F33,      B_F53x       ;[ 7,1]
||[ B_c]PACKLH2 .L1     A_C71,      A_C71,      A_C17        ; Swap c1, c7
||[ B_c]MV      .S1X    B_i,        A_cnt                    ; h_loop counter
||[ B_c]MPY     .M2     B_fx1,      3,          B_c          ; Prolog collapse
||[ B_c]ROTL    .M1     A_C35,      16,         A_C53        ; Swap c6, c2
||[ B_c]MVKH    .S2     cst_fix,    B_k_fix                  ; Ptr fixup (hi)
;-
; Collapsed 3 stages of prolog
; ============================ PIPE LOOP KERNEL ==============================
v_loop:
        ADD2    .D1     A_h0h1,     A_g2g3,     A_f32        ;[30,2]
||      PACKHL2 .L1     A_h2g2,     A_h3,       A_h2h3       ;[30,2]
||      ADD2    .L2     B_g0g1,     B_h2h3,     B_f01        ;[30,2]
||      ROTL    .M1X    B_F04x,     16,         A_F40        ;[19,3]
||      XOR     .S1X    B_F04x,     A_k_neg,    A_F0n4       ;[19,3] negate F4
||      PACK2   .S2     B_r0,       B_r1,       B_r0r1       ;[19,3]
||      DOTPNRSU2.M2X   B_s0q0,     A_C00,      B_g3         ;[19,3]
||      LDW     .D2T2   *B_i_ptr++[B_fx1],      B_F00        ;[ 8,4] read F0
;-
        SUB2    .D1     A_g0g1,     A_h2h3,     A_f76        ;[31,2]
||      SUB2    .S1     A_h0h1,     A_g2g3,     A_f45        ;[31,2]
||      SUB2    .D2     B_g0g1,     B_h2h3,     B_f76        ;[31,2]
||      DOTPRSU2.M1     A_F26,      A_C26,      A_r0         ;[20,3]
||      DOTPRSU2.M2X    B_s0q0,     A_C00,      B_h3         ;[20,3]
||      MV      .L1X    B_F53x,     A_F53                    ;[ 9,4] part. MV
||      PACK2   .L2     B_F55,      B_F33,      B_F53        ;[ 9,4]
||      PACKH2  .S2     B_F11,      B_F77,      B_F17x       ;[ 9,4]
;-
  [!B_c]STW     .D1T1   A_f55,      *+A_o_ptr[20]            ;[43,1] write f0
||      SHR     .S1X    B_k_fix,    24,         A_fx2        ;[43,1] ptr fixup
||      ADD2    .L1     A_g0g1,     A_h2h3,     A_f01        ;[32,2]
||      SUB2    .S2     B_h0h1,     B_g2g3,     B_f45        ;[32,2]
||      AVG2    .M1     A_F40,      A_F0n4,     A_p0p1       ;[21,3]
||      ADD2    .D2     B_p0p1,     B_r0r1,     B_g0g1       ;[21,3]
||      PACK2   .L2     B_F11,      B_F77,      B_F17        ;[10,4]
||      DOTPNRSU2.M2X   B_F53,      A_C35,      B_Q0         ;[10,4]
;-
  [!B_c]STW     .D1T1   A_f00,      *A_o_ptr++[A_fx2]        ;[44,1] write f0
||      ADD2    .S2     B_h0h1,     B_g2g3,     B_f32        ;[33,2]
||      PACK2   .S1     A_S1,       A_Q1,       A_S1Q1       ;[22,3]
||      DOTPNRSU2.M1    A_F26,      A_C62,      A_r1         ;[22,3]
||      ADD2    .L2     B_S1Q1,     B_S0Q0,     B_h2g2       ;[22,3]
||      SUB2    .D2     B_p0p1,     B_r0r1,     B_h0h1       ;[22,3]
||      MV      .L1X    B_F17x,     A_F17                    ;[11,4] part. MV
||      DOTPRSU2.M2X    B_F53,      A_C53,      B_S0         ;[11,4]
;-
  [ B_c]SUB     .S2     B_c,        1,          B_c          ; prolog collapse
||      PACK2   .L1X    A_f76,      B_f76,      A_f66        ;[34,2]
||      SUB2    .D1     A_S1Q1,     A_S0Q0,     A_s0q0       ;[23,3]
||      ADD2    .S1     A_S1Q1,     A_S0Q0,     A_h2g2       ;[23,3]
||      DOTPRSU2.M1     A_F53,      A_C53,      A_S0         ;[12,4]
||      PACKH2  .L2     B_F22,      B_F66,      B_F26x       ;[12,4]
||      DOTPRSU2.M2X    B_F17,      A_C17,      B_S1         ;[12,4]
||      LDW     .D2T2   *+B_i_ptr[12],          B_F33        ;[ 1,5] read F3
;-
        BDEC    .S2     v_loop,     B_i                      ;[47,1] iterate
||[!B_c]STW     .D1T1   A_f66,      *+A_o_ptr[24]            ;[35,2] write f6
||      PACKH2  .S1X    A_f32,      B_f32,      A_f33        ;[35,2]
||      PACK2   .L1X    A_f32,      B_f32,      A_f22        ;[35,2]
||      DOTPNRSU2.M1    A_F53,      A_C35,      A_Q0         ;[13,4]
||      PACK2   .L2     B_F22,      B_F66,      B_F26        ;[13,4]
||      DOTPNRSU2.M2X   B_F17,      A_C71,      B_Q1         ;[13,4]
||      LDW     .D2T2   *+B_i_ptr[20],          B_F55        ;[ 2,5] read F5
;-
  [!B_c]STW     .D1T1   A_f22,      *+A_o_ptr[8]             ;[36,2] write f2
||      PACKH2  .L1X    A_f01,      B_f01,      A_f00        ;[36,2]
||      PACK2   .S1X    A_f01,      B_f01,      A_f11        ;[36,2]
||      PACKHL2 .L2     B_h2g2,     B_h3,       B_h2h3       ;[25,3]
||      DOTPNRSU2.M1    A_s0q0,     A_C00,      A_g3         ;[25,3]
||      DOTPRSU2.M2X    B_F26,      A_C26,      B_r0         ;[14,4]
||      SHR     .S2     B_k_fix,    24,         B_fx1        ;[ 3,5] ptr fixup
||      LDW     .D2T2   *+B_i_ptr[28],          B_F77        ;[ 3,5]
;-
  [!B_c]STW     .D1T1   A_f11,      *+A_o_ptr[4]             ;[37,2] write f1
||      PACKH2  .S1X    A_f76,      B_f76,      A_f77        ;[37,2]
||      PACK2   .L1     A_r0,       A_r1,       A_r0r1       ;[26,3]
||      DOTPRSU2.M1     A_s0q0,     A_C00,      A_h3         ;[26,3]
||      PACK2   .L2     B_h2g2,     B_g3,       B_g2g3       ;[26,3]
||      DOTPNRSU2.M2X   B_F26,      A_C62,      B_r1         ;[15,4]
||      PACK2   .S2     B_F00,      B_F44,      B_F04        ;[15,4]
||      LDW     .D2T2   *+B_i_ptr[4],           B_F11        ;[ 4,5] read F1
;-
  [!B_c]STW     .D1T1   A_f77,      *+A_o_ptr[28]            ;[38,2] write f7
||      ADD2    .S1     A_p0p1,     A_r0r1,     A_g0g1       ;[27,3]
||      SUB2    .L1     A_p0p1,     A_r0r1,     A_h0h1       ;[27,3]
||      ROTL    .M1X    B_F26x,     0,          A_F26        ;[16,4]
||      XOR     .S2X    B_F04,      A_k_neg,    B_F0n4       ;[16,4] negate F4
||      PACK2   .L2     B_S0,       B_Q0,       B_S0Q0       ;[16,4]
||      ROTL    .M2     B_F04,      16,         B_F40        ;[16,4]
||      LDW     .D2T2   *+B_i_ptr[8],           B_F22        ;[ 5,5] read F2
;-
  [!B_c]STW     .D1T1   A_f33,      *+A_o_ptr[12]            ;[39,2] write f3
||      PACKH2  .S1X    A_f45,      B_f45,      A_f44        ;[39,2]
||      PACKH2  .L2     B_F00,      B_F44,      B_F04x       ;[17,4]
||      PACK2   .L1     A_S0,       A_Q0,       A_S0Q0       ;[17,4]
||      DOTPRSU2.M1     A_F17,      A_C17,      A_S1         ;[17,4]
||      PACK2   .S2     B_S1,       B_Q1,       B_S1Q1       ;[17,4]
||      LDW     .D2T2   *+B_i_ptr[16],          B_F44        ;[ 6,5] read F4
||      ROTL    .M2     B_k_fix,    8,          B_k_fix      ;[ 6,5] ptr fixup
;-
  [!B_c]STW     .D1T1   A_f44,      *+A_o_ptr[16]            ;[40,2] write f4
||      PACK2   .S1X    A_f45,      B_f45,      A_f55        ;[40,2]
||      PACK2   .L1     A_h2g2,     A_g3,       A_g2g3       ;[29,3]
||      DOTPNRSU2.M1    A_F17,      A_C71,      A_Q1         ;[18,4]
||      SUB2    .S2     B_S1Q1,     B_S0Q0,     B_s0q0       ;[18,4]
||      AVG2    .M2     B_F40,      B_F0n4,     B_p0p1       ;[18,4]
||      PACKH2  .L2     B_F55,      B_F33,      B_F53x       ;[ 7,5]
||      LDW     .D2T2   *+B_i_ptr[24],          B_F66        ;[ 7,5] read F6
;-
; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:
; Collapsed 3 stages of epilog

; ================== SYMBOLIC REGISTER ASSIGNMENTS: H_LOOP ===================
        ; Constants held in registers
        .asg            B24,        B_k_neg ; Negation cst: 0x0000FFFF
        .asg            B25,        B_rnd   ; Rounding cst: 0x000F0010

        ; Pointers and loop control
        .asg            B23,        B_i_ptr ; Input (and output) pointer
        .asg            A2,         A_i_ptr ; Input (and output) pointer
        .asg            B22,        B_i     ; Loop counter
        .asg            A0,         A_c     ; Prolog collapse predicate

        ; Symbolic names for IDCTs in even-numbered rows
        .asg            B29,        B_F76   ; Freq domain terms F7, F6 (packed)
        .asg            B28,        B_F54   ; Freq domain terms F5, F4 (packed)
        .asg            B27,        B_F32   ; Freq domain terms F3, F2 (packed)
        .asg            B26,        B_F10   ; Freq domain terms F1, F0 (packed)
        .asg            B8,         B_F17   ; Freq domain terms F1, F7 (packed)
        .asg            B7,         B_F53   ; Freq domain terms F5, F3 (packed)
        .asg            B20,        B_F26   ; Freq domain terms F2, F6 (packed)
        .asg            B21,        B_F40   ; Freq domain terms F4, F0 (packed)
        .asg            B8,         B_F04   ; Freq domain terms F0, F4 (packed)
        .asg            B20,        B_F0n4  ; F04, with F4 'negated'
        .asg            B17,        B_p0p1_t; Nodes p0, p1, temp. (packed)
        .asg            B17,        B_p0p1  ; Nodes p0, p1
        .asg            B4,         B_r0    ; Node r0 in signal flow graph
        .asg            B6,         B_r1    ; Node r1 in signal flow graph
        .asg            B16,        B_r0r1  ; Nodes r0, r1 (packed)
        .asg            B6,         B_g0g1  ; Nodes g0, g1 (packed)
        .asg            B16,        B_h0h1  ; Nodes h0, h1 (packed)
        .asg            B18,        B_Q1    ; Node Q1 in signal flow graph
        .asg            B17,        B_Q0    ; Node Q0 in signal flow graph
        .asg            B7,         B_S0    ; Node S0 in signal flow graph
        .asg            B0,         B_S1    ; Node S1 in signal flow graph
        .asg            B9,         B_S0Q0  ; Nodes S0, Q0 (packed)
        .asg            B18,        B_S1Q1  ; Nodes S1, Q1 (packed)
        .asg            B6,         B_s0q0  ; Nodes s0, q0 (packed)
        .asg            B19,        B_h2g2  ; Nodes h2, g2 (packed)
        .asg            B4,         B_g3    ; Node g3 in signal flow graph
        .asg            B5,         B_h3    ; Node h3 in signal flow graph
        .asg            B5,         B_h2h3  ; Nodes h2, h3 (packed)
        .asg            B9,         B_g2g3  ; Nodes g2, g3 (packed)
        .asg            B19,        B_f01   ; Sample domain f0, f1 (packed)
        .asg            B8,         B_f32   ; Sample domain f3, f2 (packed)
        .asg            B20,        B_f45   ; Sample domain f4, f5 (packed)
        .asg            B5,         B_f76   ; Sample domain f7, f6 (packed)
        .asg            B16,        B_f10r  ; f1, f0 rounded
        .asg            B17,        B_f32r  ; f3, f2 rounded
        .asg            B7,         B_f54r  ; f5, f4 rounded
        .asg            B5,         B_f76r  ; f7, f6 rounded
        .asg            B4,         B_f10s  ; f1, f0 saturated
        .asg            B31,        B_f32s  ; f3, f2 saturated
        .asg            B8,         B_f54s  ; f3, f2 saturated
        .asg            B9,         B_f76s  ; f3, f2 saturated
        .asg            B30,        B_f10t  ; f1, f0 truncated
        .asg            B31,        B_f32t  ; f3, f2 truncated
        .asg            B30,        B_f54t  ; f5, f4 truncated
        .asg            B31,        B_f76t  ; f7, f6 truncated

        ; Symbolic names for IDCTs in odd-numbered rows
        .asg            A27,        A_F76   ; Freq domain terms F7, F6 (packed)
        .asg            A26,        A_F54   ; Freq domain terms F5, F4 (packed)
        .asg            A29,        A_F32   ; Freq domain terms F3, F2 (packed)
        .asg            A28,        A_F10   ; Freq domain terms F1, F0 (packed)
        .asg            A8,         A_F17   ; Freq domain terms F1, F7 (packed)
        .asg            A3,         A_F53   ; Freq domain terms F5, F3 (packed)
        .asg            A8,         A_F26   ; Freq domain terms F2, F6 (packed)
        .asg            A24,        A_F40   ; Freq domain terms F4, F0 (packed)
        .asg            A9,         A_F04   ; Freq domain terms F0, F4 (packed)
        .asg            A6,         A_F0n4  ; F04, with F4 'negated'
        .asg            A6,         A_p0p1_t; Nodes p0, p1, temp. (packed)
        .asg            A6,         A_p0p1  ; Nodes p0, p1 (packed)
        .asg            A30,        A_r0    ; Node r0 in signal flow graph
        .asg            A7,         A_r1    ; Node r1 in signal flow graph
        .asg            A30,        A_r0r1  ; Nodes r0, r1 (packed)
        .asg            A9,         A_g0g1  ; Nodes g0, g1 (packed)
        .asg            A7,         A_h0h1  ; Nodes h0, h1 (packed)
        .asg            A6,         A_Q1    ; Node Q1 in signal flow graph
        .asg            A25,        A_Q0    ; Node Q0 in signal flow graph
        .asg            A23,        A_S0    ; Node S0 in signal flow graph
        .asg            A4,         A_S1    ; Node S1 in signal flow graph
        .asg            A3,         A_S0Q0  ; Nodes S0, Q0 (packed)
        .asg            A4,         A_S1Q1  ; Nodes S1, Q1 (packed)
        .asg            A1,         A_s0q0  ; Nodes s0, q0 (packed)
        .asg            A5,         A_h2g2  ; Nodes h2, g2 (packed)
        .asg            A23,        A_g3    ; Node g3 in signal flow graph
        .asg            A1,         A_h3    ; Node h3 in signal flow graph
        .asg            A7,         A_h2h3  ; Nodes h2, h3 (packed)
        .asg            A30,        A_g2g3  ; Nodes g2, g3 (packed)
        .asg            A8,         A_f01   ; Sample domain f0, f1 (packed)
        .asg            A7,         A_f32   ; Sample domain f3, f2 (packed)
        .asg            A3,         A_f45   ; Sample domain f4, f5 (packed)
        .asg            A9,         A_f76   ; Sample domain f7, f6 (packed)
        .asg            A8,         A_f10r  ; f1, f0 rounded
        .asg            A5,         A_f32r  ; f3, f2 rounded
        .asg            A5,         A_f54r  ; f5, f4 rounded
        .asg            A5,         A_f76r  ; f7, f6 rounded
        .asg            A9,         A_f10s  ; f1, f0 saturated
        .asg            A5,         A_f32s  ; f3, f2 saturated
        .asg            A4,         A_f54s  ; f5, f4 saturated
        .asg            A6,         A_f76s  ; f7, f6 saturated
        .asg            A30,        A_f10t  ; f1, f0 truncated
        .asg            A31,        A_f32t  ; f3, f2 truncated
        .asg            A24,        A_f54t  ; f5, f4 truncated
        .asg            A25,        A_f76t  ; f7, f6 truncated
; ============================================================================

* ========================================================================= *
*  Horizontal loop setup                                                    *
*                                                                           *
*  The horizontal loop needs very little setup in order to get rolling,     *
*  since it shares most of its incoming registers with the vertical loop.   *
*  For instance, all of the cosine terms are allocated to the same regs     *
*  in both loops.                                                           *
*                                                                           *
*  The horizontal loop processes DCT blocks in reverse order, starting      *
*  at the end of the list of DCTs, working towards the beginning.  As a     *
*  result, the input pointers for the horizontal loop are initialized from  *
*  the vertical pointer values left over from the vertical loop by adding   *
*  a fixed offset to each of the pointers.  This works regardless of the    *
*  number of DCT blocks.  This also allows us to perform the next small     *
*  optimization safely.                                                     *
*                                                                           *
*  For speed, the remaining two STWs from the vertical loop fill in the     *
*  delay after the initial LDDWs for the horizonal loop.  Also, some        *
*  rescheduling of the prolog has been performed to further speed things    *
*  up.                                                                      *
*                                                                           *
*  To save registers, the same pointer register is used for loading and     *
*  storing in each datapath.  This is possible since the LDDWs and STDWs    *
*  are close enough in the pipeline, and all pointers are traversing        *
*  linearly through memory.                                                 *
* ========================================================================= *

; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:
        LDDW    .D2T1   *-B_i_ptr  [4],         A_F76:A_F54  ;[ 2,1] get F7..F4
||      ADDAW   .D1     A_o_ptr,    21,         A_i_ptr      ; point @ row 6

        LDDW    .D2T2   *-B_i_ptr  [2],         B_F76:B_F54  ;[ 3,1] get F7..F4
||      LDDW    .D1T1   * A_i_ptr--[4],         A_F32:A_F10  ;[ 3,1] get F3..F0

        MVKL    .S2     cst_rnd,    B_rnd                    ; rounding const.
||      LDDW    .D2T2   *-B_i_ptr  [3],         B_F32:B_F10  ;[ 4,1] get F3..F0

        MVKH    .S2     cst_rnd,    B_rnd                    ; round cst (hi)
||      XPND2   .M2X    A_C62,      B_k_neg                  ;[ 5,1]
;-
        STW     .D1T1   A_f55,      *+A_o_ptr[20]            ;v_loop: write f5
||      SUBAW   .D2     B_i_ptr,    14,         B_i_ptr      ; point @ row 7

        STW     .D1T1   A_f00,      * A_o_ptr                ;v_loop: write f0

        PACKH2  .L1     A_F54,      A_F32,      A_F53        ;[ 8,1]
||      PACKH2  .S1     A_F10,      A_F76,      A_F17        ;[ 8,1]

        PACKH2  .S2     B_F10,      B_F76,      B_F17        ;[ 9,1]
||      DOTPRSU2.M1     A_F17,      A_C17,      A_S1         ;[ 9,1]
||      SUB     .L2X    A_cnt,      1,          B_i          ; init loop cnt
;-
        DOTPNRSU2.M2X   B_F17,      A_C71,      B_Q1         ;[10,1]
||      DOTPNRSU2.M1    A_F17,      A_C71,      A_Q1         ;[10,1]
||      PACK2   .L2     B_F32,      B_F76,      B_F26        ;[10,1]
||      PACK2   .L1     A_F32,      A_F76,      A_F26        ;[10,1]
||      PACK2   .S1     A_F54,      A_F10,      A_F40        ;[10,1]
||      MVK     .D1     2,          A_c                      ; prolog collapse
;-
; Collapsed 2 stages of prolog
; ============================ PIPE LOOP KERNEL ==============================
h_loop:
        SADD2   .S2     B_f54r,     B_f54r,     B_f54s       ;[36,1] sat f5, f4
||[!A_c]STDW    .D1T1   A_f32t:A_f10t,          *+A_i_ptr[12];[36,1] put f3..f0
||      ADD2    .D2     B_p0p1_t,   B_rnd,      B_p0p1       ;[24,2] round DC
||      PACK2   .S1     A_h2g2,     A_g3,       A_g2g3       ;[24,2]
||      PACK2   .L2     B_F54,      B_F10,      B_F40        ;[12,3]
||      DOTPRSU2.M2X    B_F17,      A_C17,      B_S1         ;[12,3]
||      DOTPNRSU2.M1    A_F53,      A_C35,      A_Q0         ;[12,3]
;-
        SHR2    .S2     B_f10s,     7,          B_f10t       ;[37,1] trnc f1,f0
||      DOTPNRSU2.M2X   B_s0q0,     A_C00,      B_g3         ;[25,2]
||      ADD2    .L1     A_h0h1,     A_g2g3,     A_f32        ;[25,2]
||      SUB2    .S1     A_h0h1,     A_g2g3,     A_f45        ;[25,2]
||      PACKH2  .L2     B_F54,      B_F32,      B_F53        ;[13,3]
||      DOTPRSU2.M1     A_F53,      A_C53,      A_S0         ;[13,3]
||      LDDW    .D1T1   *+A_i_ptr  [1],         A_F76:A_F54  ;[ 1,4] get F7..F4
||      LDDW    .D2T2   * B_i_ptr--[4],         B_F32:B_F10  ;[ 1,4] get F3..F0
;-
        SADD2   .S2     B_f76r,     B_f76r,     B_f76s       ;[38,1] sat f7, f6
||      ADD2    .L2     B_p0p1,     B_r0r1,     B_g0g1       ;[26,2]
||      DOTPRSU2.M2X    B_s0q0,     A_C00,      B_h3         ;[26,2]
||      ADD     .S1     A_f32,      A_f32,      A_f32r       ;[26,2] qpt f3..f2
||      PACKHL2 .L1     A_h2g2,     A_h3,       A_h2h3       ;[26,2]
||      DOTPRSU2.M1     A_F26,      A_C26,      A_r0         ;[14,3]
||      LDDW    .D2T2   *+B_i_ptr  [5],         B_F76:B_F54  ;[ 2,4] get F7..F4
||      LDDW    .D1T1   * A_i_ptr--[4],         A_F32:A_F10  ;[ 2,4] get F3..F0
;-
        SHR2    .S2     B_f32s,     7,          B_f32t       ;[39,1] trnc f3,f2
||      SUB2    .L2     B_p0p1,     B_r0r1,     B_h0h1       ;[27,2]
||      SUB2    .L1     A_g0g1,     A_h2h3,     A_f76        ;[27,2]
||      ADD2    .D1     A_g0g1,     A_h2h3,     A_f01        ;[27,2]
||      SADD2   .S1     A_f32r,     A_f32r,     A_f32s       ;[27,2] sat  f3,f2
||      DOTPNRSU2.M1    A_F26,      A_C62,      A_r1         ;[15,3]
||      DOTPNRSU2.M2X   B_F53,      A_C35,      B_Q0         ;[15,3]
;-
        SHR2    .S2     B_f54s,     7,          B_f54t       ;[40,1] trnc f5,f4
||[!A_c]STDW    .D2T2   B_f32t:B_f10t,          *+B_i_ptr[16];[40,1] put f3..f0
||      SHR2    .S1     A_f32s,     7,          A_f32t       ;[28,2] trnc f3,f2
||      ADD     .D1     A_f76,      A_f76,      A_f76r       ;[28,2] qpt f7..f6
||      PACK2   .L2     B_S1,       B_Q1,       B_S1Q1       ;[16,3]
||      DOTPRSU2.M2X    B_F53,      A_C53,      B_S0         ;[16,3]
||      ROTL    .M1     A_F40,      16,         A_F04        ;[16,3]
||      PACK2   .L1     A_S1,       A_Q1,       A_S1Q1       ;[16,3]
;-
        SHR2    .S2     B_f76s,     7,          B_f76t       ;[41,1] trnc f7,f6
||      PACK2   .L2     B_h2g2,     B_g3,       B_g2g3       ;[29,2]
||      SADD2   .S1     A_f76r,     A_f76r,     A_f76s       ;[29,2] sat  f7,f6
||      ROTL    .M1     A_f45,      17,         A_f54r       ;[29,2] q-pt f5,f4
||      PACK2   .L1     A_S0,       A_Q0,       A_S0Q0       ;[17,3]
||      ROTL    .M2     B_F40,      16,         B_F04        ;[17,3]
;-
        BDEC    .S2     h_loop,     B_i                      ;[42,1]
||[!A_c]STDW    .D2T2   B_f76t:B_f54t,          *+B_i_ptr[17];[42,1] put f7..f4
||      PACKHL2 .L2     B_h2g2,     B_h3,       B_h2h3       ;[30,2]
||      SHR2    .S1     A_f76s,     7,          A_f76t       ;[30,2] trnc f7,f6
||      ROTL    .M1     A_f01,      17,         A_f10r       ;[30,2] q-pt f1,f0
||      SUB2    .L1     A_S1Q1,     A_S0Q0,     A_s0q0       ;[18,3]
||      XOR     .D1X    A_F04,      B_k_neg,    A_F0n4       ;[18,3] negate F4
||      DOTPRSU2.M2X    B_F26,      A_C26,      B_r0         ;[18,3]
;-
        ADD2    .S2     B_g0g1,     B_h2h3,     B_f01        ;[31,2]
||      SUB2    .D2     B_h0h1,     B_g2g3,     B_f45        ;[31,2]
||      SUB2    .L2     B_g0g1,     B_h2h3,     B_f76        ;[31,2]
||      SADD2   .S1     A_f54r,     A_f54r,     A_f54s       ;[31,2] sat  f5,f4
||      DOTPNRSU2.M2X   B_F26,      A_C62,      B_r1         ;[19,3]
||      ADD2    .D1     A_S1Q1,     A_S0Q0,     A_h2g2       ;[19,3]
||      AVG2    .M1     A_F40,      A_F0n4,     A_p0p1_t     ;[19,3]
||      PACKH2  .L1     A_F54,      A_F32,      A_F53        ;[ 7,4]
;-
        ADD2    .D2     B_h0h1,     B_g2g3,     B_f32        ;[32,2]
||      ROTL    .M2     B_f45,      17,         B_f54r       ;[32,2] q-pt f5,f4
||[ A_c]SUB     .D1     A_c,        1,          A_c          ;[32,2]
||      SADD2   .S1     A_f10r,     A_f10r,     A_f10s       ;[32,2] sat  f1,f0
||      XOR     .S2     B_F04,      B_k_neg,    B_F0n4       ;[20,3] negate F4
||      PACK2   .L2     B_S0,       B_Q0,       B_S0Q0       ;[20,3]
||      DOTPNRSU2.M1    A_s0q0,     A_C00,      A_g3         ;[20,3]
||      PACKH2  .L1     A_F10,      A_F76,      A_F17        ;[ 8,4]
;-
        ROTL    .M2     B_f01,      17,         B_f10r       ;[33,2] q-pt f1,f0
||      ADD     .D2     B_f32,      B_f32,      B_f32r       ;[33,2]
||      ADD     .L2     B_f76,      B_f76,      B_f76r       ;[33,2]
||      SHR2    .S1     A_f54s,     7,          A_f54t       ;[33,2] trnc f5,f4
||      PACK2   .L1     A_r0,       A_r1,       A_r0r1       ;[21,3]
||      ADD2    .D1X    A_p0p1_t,   B_rnd,      A_p0p1       ;[21,3] round DC
||      PACKH2  .S2     B_F10,      B_F76,      B_F17        ;[ 9,4]
||      DOTPRSU2.M1     A_F17,      A_C17,      A_S1         ;[ 9,4]
;-
        SADD2   .S2     B_f32r,     B_f32r,     B_f32s       ;[34,2] sat  f3,f2
||[!A_c]STDW    .D1T1   A_f76t:A_f54t,          *+A_i_ptr[13];[34,2] put f7..f4
||      ADD2    .D2     B_S1Q1,     B_S0Q0,     B_h2g2       ;[22,3]
||      AVG2    .M2     B_F40,      B_F0n4,     B_p0p1_t     ;[22,3]
||      DOTPRSU2.M1     A_s0q0,     A_C00,      A_h3         ;[22,3]
||      SUB2    .L1     A_p0p1,     A_r0r1,     A_h0h1       ;[22,3]
||      PACK2   .L2     B_F32,      B_F76,      B_F26        ;[10,4]
||      PACK2   .S1     A_F54,      A_F10,      A_F40        ;[10,4]
;-
        SADD2   .S2     B_f10r,     B_f10r,     B_f10s       ;[35,2] sat  f1,f0
||      SHR2    .S1     A_f10s,     7,          A_f10t       ;[35,2] trnc f1,f0
||      SUB2    .D2     B_S1Q1,     B_S0Q0,     B_s0q0       ;[23,3]
||      PACK2   .L2     B_r0,       B_r1,       B_r0r1       ;[23,3]
||      ADD2    .D1     A_p0p1,     A_r0r1,     A_g0g1       ;[23,3]
||      DOTPNRSU2.M2X   B_F17,      A_C71,      B_Q1         ;[11,4]
||      PACK2   .L1     A_F32,      A_F76,      A_F26        ;[11,4]
||      DOTPNRSU2.M1    A_F17,      A_C71,      A_Q1         ;[11,4]
;-
; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:
; Collapsed 2 stages of epilog

* ========================================================================= *
*  Exit code                                                                *
*                                                                           *
*  Some slight rescheduling and rewriting squeezed a cycle out of this so   *
*  that I can issue my return branch immediately upon exiting the software  *
*  pipeline above.  The only way to return faster would be to return from   *
*  the loop kernel itself, which would sacrifice interruptibility, due to   *
*  having multiple branches in flight.                                      *
* ========================================================================= *

        STDW    .D1T1   A_f32t:A_f10t,          *+A_i_ptr[12];[36,4] put f3..f0
||      RET     .S2     B_ret                                ;[36,4] return.

        SHR2    .S1X    B_f10s,     7,          A_f10t       ;[37,4] trnc f1,f0
||      SADD2   .S2     B_f54r,     B_f54r,     B_f54s       ;[37,4] sat f5,f4

        SADD2   .S2     B_f76r,     B_f76r,     B_f76s       ;[38,4] sat f7,f6
||      SHR2    .S1X    B_f32s,     7,          A_f32t       ;[39,4] trnc f3,f2

        SHR2    .S2     B_f54s,     7,          B_f54t       ;[39,4] trnc f5,f4
||      STDW    .D2T1   A_f32t:A_f10t,          *+B_i_ptr[12];[40,4] put f3..f0
;-
        SHR2    .S2     B_f76s,     7,          B_f76t       ;[40,4] trnc f7,f6

        STDW    .D2T2   B_f76t:B_f54t,          *+B_i_ptr[13];[41,4] put f7..f4
;-
; ===== Branch Occurs =====
* ========================================================================= *
*   End of file:  img_idct_8x8_12q4.asm                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
idct_8x8_1.asm/ 1066928952  0     0     0       10251     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Fri Oct 25 00:29:08 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_idct_8x8 -- Wrapper for idct_8x8_12q4, Little Endian.           *
*                                                                           *
*   REVISION DATE                                                           *
*       24-Oct-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_idct_8x8(short idct_data[], unsigned num_idcts)        *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function provides a wrapper around the IMG_idct_8x8_12q4       *
*       function.  It reads 12Q0 values in from the input array, and        *
*       writes them back as 12Q4.  Once all the values have been adjusted,  *
*       the function then branches directly to IMG_idct_8x8_12q4.           *
*                                                                           *
*       It is strongly recommended that you adapt your code to call         *
*       IMG_idct_8x8_12q4 directly.  Calling this wrapper adds an extra     *
*       16 cycles per block of processing overhead, as well as 116          *
*       bytes of additional code.                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This is a LITTLE ENDIAN implementation.                             *
*       The input array must be aligned on a double-word boundary.          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*                                                                           *
*   NOTES                                                                   *
*       This code locks out interrupts for its entire duration.             *
*       It is, however, fully interrupt tolerant.                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 16 + 16 * num_idcts, for num_idcts > 0                     *
*                                                                           *
*   CODESIZE                                                                *
*       116 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .global _IMG_idct_8x8_12q4
        .global _IMG_idct_8x8
        .sect ".text:_idct_wrap"
        .global _IMG_idct_8x8
_IMG_idct_8x8:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A5,         A_ptr
        .asg            B5,         B_ptr
        .asg            A1,         A_i
        .asg            B7,         B_msk
        .asg            B17,        B_x76
        .asg            B16,        B_x54
        .asg            A9,         A_x32
        .asg            A8,         A_x10
        .asg            B19,        B_y76
        .asg            B18,        B_y54
        .asg            A17,        A_y32
        .asg            A16,        A_y10
        .asg            B29,        B_z76
        .asg            B28,        B_z54
        .asg            A27,        A_z32
        .asg            A26,        A_z10
        .asg            B0,         B_p
        .asg            B20,        B_idct_8x8_12q4
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        MV              A4,                     A_ptr
||      ADD             A4,         8,          B_ptr

        B       .S1     loop
||      LDDW    .D1T1   *A_ptr++[2],A_x32:A_x10                 ;[ 1,1]
||      LDDW    .D2T2   *B_ptr++[2],B_x76:B_x54                 ;[ 1,1]
||      MVKL    .S2     0xFFF0FFF0, B_msk

        MVKH    .S2     0xFFF0FFF0, B_msk
||      SHL     .S1X    B4,         3,          A_i

        LDDW    .D1T1   *A_ptr++[2],A_x32:A_x10                 ;[ 1,2]
||      LDDW    .D2T2   *B_ptr++[2],B_x76:B_x54                 ;[ 1,2]
||      MVKL    .S2     _IMG_idct_8x8_12q4,     B_idct_8x8_12q4
||[A_i] BDEC    .S1     loop,       A_i

        MVKH    .S2     _IMG_idct_8x8_12q4,     B_idct_8x8_12q4
||      MVK     .L2     2,          B_p

; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        AND     .L1X    A_y32,      B_msk,      A_z32           ;[ 9,1]
||      AND     .L2     B_y76,      B_msk,      B_z76           ;[ 9,1]
||      ROTL    .M1     A_x32,      4,          A_y32           ;[ 7,2]
||      SHL     .S2     B_x54,      4,          B_y54           ;[ 7,2]
||[ A_i]BDEC    .S1     loop,       A_i                         ;[ 5,3]
||      LDDW    .D1T1   *A_ptr++[2],A_x32:A_x10                 ;[ 1,5]
||      LDDW    .D2T2   *B_ptr++[2],B_x76:B_x54                 ;[ 1,5]

  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[10,1]
||[!B_p]STDW    .D1T1   A_z32:A_z10,            *-A_ptr[10]     ;[10,1]
||[!B_p]STDW    .D2T2   B_z76:B_z54,            *-B_ptr[10]     ;[10,1]
||      AND     .L1X    A_y10,      B_msk,      A_z10           ;[ 8,2]
||      AND     .S2     B_y54,      B_msk,      B_z54           ;[ 8,2]
||      SHL     .S1     A_x10,      4,          A_y10           ;[ 6,3]
||      ROTL    .M2     B_x76,      4,          B_y76           ;[ 6,3]

* ========================================================================= *
; ===== epilog collapsed completely
        CRNOP   .S2     B_idct_8x8_12q4, 5

* ========================================================================= *
*   End of file:  img_idct_8x8.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_16x16.asm/  1066928952  0     0     0       33540     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:32:24 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_16x16                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       18-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           int                 h,                                          *
*           int                 v,                                          *
*           unsigned            *restrict match                             *
*       )                                                                   *
*                                                                           *
*       refImg          Reference image.                                    *
*       srcImg[256]     16x16 block image to look for.                      *
*       pitch           Width of reference image.                           *
*       h               Horiz. size of search area.                         *
*       v               Vert.  size of search area. Must be multiple of 2.  *
*       match[2]        Result:                                             *
*                           match[0] is packed x, y.                        *
*                           match[1] is MAD value.                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 16x16 search block and some block in a         *
*       (h + 16) x (v + 16) search area. h and v are the sizes of the       *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+16,0)                             *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;        within reference image      *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+16)                 (v+16,h+16)                          *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       srcImg and refImg do not alias in memory.                           *
*       The routine is written for Little Endian configuration.             *
*       Two MADS are performed together and hence it is assumed that v      *
*       the vertical dimension is a multiple of 2.                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No special requirements on alignment of arrays is required.         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The two outer loops are merged, the two inner loops are merged.     *
*       The inner loop process 2 lines of 2 search locations in parallel.   *
*       The search is performed in top-to-bottom, left-to-right order,      *
*       with the earliest match taking precedence in the case of ties.      *
*       Further use is made of C64x specific instructions such as SUBABS4   *
*       and DOTPU4. The SUBABS4 takes the absolute difference on four 8     *
*       bit quantities packed into a 32 bit word. The DOTPU4 performs four  *
*       8 bit wide multiplies and adds the results together.                *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch, int h, int v,                                        *
*           unsigned int *restrict match                                    *
*       )                                                                   *
*       {                                                                   *
*           int i, j, x, y, matx, maty;                                     *
*           unsigned matpos, matval;                                        *
*                                                                           *
*           matval = ~0U;                                                   *
*           matx   = maty = 0;                                              *
*                                                                           *
*           for (x = 0; x < x; x++)                                         *
*               for (y = 0; y < v; y++)                                     *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 16; i++)                                *
*                       for (j = 0; j < 16; j++)                            *
*                           acc += abs(srcImg[i*16 + j] -                   *
*                                      refImg[(i+y)*pitch + x + j]);        *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*                                                                           *
*           matpos    = (0xffff0000 & (matx << 16)) |                       *
*                       (0x0000ffff & maty);                                *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       38 * h * v + 20                                                     *
*                                                                           *
*       e.g. h=v= 4:   628 cycles                                           *
*            h=v=32: 38932 cycles                                           *
*                                                                           *
*   CODESIZE                                                                *
*       776 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            B2,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A30,        A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A0,         A_best
        .asg            A0,         A_i
        .asg            A0,         A_sub
        .asg            A0,         A_w
        .asg            A1,         A_vl
        .asg            A16,        A_matpos
        .asg            A17,        A_matval
        .asg            A14,        A_ptch
        .asg            A10,        A_ref_ri0d
        .asg            A11,        A_ref_ri0c
        .asg            A18,        A_2diffi_1c
        .asg            A18,        A_2sumi1d
        .asg            A18,        A_diffi_1d
        .asg            A19,        A_2sumi1c
        .asg            A19,        A_sumi1c
        .asg            A2,         A_vl1
        .asg            A20,        A_2diffi_1d
        .asg            A20,        A_2sumi0d
        .asg            A20,        A_diffi_0d
        .asg            A20,        A_diffi_1c
        .asg            A21,        A_matchi1
        .asg            A22,        A_k_ones
        .asg            A23,        A_pitch_8
        .asg            A24,        A_2sumi0c
        .asg            A24,        A_2sumi0cd
        .asg            A24,        A_srchid
        .asg            A25,        A_2sumi1cd
        .asg            A25,        A_diffi_0c
        .asg            A25,        A_srchic
        .asg            A26,        A_2srchid
        .asg            A26,        A_sumi1
        .asg            A26,        A_sumi1cd
        .asg            A27,        A_2diffi_0c
        .asg            A27,        A_2srchic
        .asg            A27,        A_sumi0cd
        .asg            A27,        A_sumi1d
        .asg            A28,        A_2diffi_0d
        .asg            A28,        A_ref_ri2d
        .asg            A28,        A_sumi0c
        .asg            A29,        A_ref_ri2c
        .asg            A29,        A_sumi0d
        .asg            A3,         A_vptch
        .asg            A30,        A_ref_ri1d
        .asg            A31,        A_2sumi1
        .asg            A31,        A_ref_ri1c
        .asg            A4,         A_ref_img
;       .asg            A5,         A_c40
        .asg            A6,         A_hl
        .asg            A6,         A_pitch
        .asg            A7,         A_ffff
        .asg            B6,         B_h
        .asg            A9,         A_bptch
        .asg            B0,         B_best
        .asg            B1,         B_ml
        .asg            B5,         B_matval
        .asg            B16,        B_ref_ri0b
        .asg            B17,        B_ref_ri0a
        .asg            B18,        B_2sumi0ab
        .asg            B18,        B_2sumi0b
        .asg            B18,        B_sumi0a
        .asg            B19,        B_diffi_0b
        .asg            B19,        B_sumi0b
        .asg            B19,        B_sumi1b
        .asg            B20,        B_src_imgcp
        .asg            B21,        B_2diffi_0b
        .asg            B21,        B_2sumi0a
        .asg            B22,        B_matchi0
        .asg            B23,        B_k_ones
        .asg            B24,        B_2sumi1a
        .asg            B24,        B_srchib
        .asg            B25,        B_2diffi_0a
        .asg            B25,        B_diffi_0a
        .asg            B25,        B_srchia
        .asg            B26,        B_2srchib
        .asg            B26,        B_sumi1ab
        .asg            B27,        B_2srchia
        .asg            B27,        B_2sumi1ab
        .asg            B27,        B_diffi_1b
        .asg            B28,        B_2diffi_1b
        .asg            B28,        B_ref_ri2b
        .asg            B29,        B_ref_ri2a
        .asg            B29,        B_sumi1a
        .asg            B30,        B_ref_ri1b
        .asg            B31,        B_2sumi1b
        .asg            B31,        B_ref_ri1a
        .asg            B4,         B_src_img
        .asg            B8,         B_match
        .asg            A8,         A_v
        .asg            B9,         B_2diffi_1a
        .asg            B9,         B_2sumi0
        .asg            B9,         B_diffi_1a
        .asg            B9,         B_sumi0
        .asg            B9,         B_sumi0ab
; ============================================================================

        .sect ".text:_mad_16x16"
        .global _IMG_mad_16x16
_IMG_mad_16x16:
; parameters: A_refImg, B_srcImg, A_pitch, B_h, A_v, B_match
;             A4,       B4,       A6,      B6,  A8,  B8

        STW     .D2T1   A14,        *B_SP--[3]               ; Save A14
||      MVC     .S2     CSR,        B_csr                    ; Remember CSR

        AND             B_csr,      -2,         B_no_gie     ; Clear GIE
||      STW     .D2T1   A11,        *+B_SP[2]                ; Save A11
||      ADD     .D1     A_v,        17,         A_w          ; pitch
||      MPY     .M1     -16,        A_pitch,    A_bptch      ; hpatch

        STW     .D2T1   A10,        *+B_SP[1]                ; Save A10
||      MVC     .S2     B_no_gie,   CSR                      ; Disable ints
||      MPY     .M1     A_w,        A_pitch,    A_vptch      ; vptch
||      SUB     .L1     A_pitch,    8,          A_pitch_8    ; pitch - 8
||      MVKL    .S1     0000FFFFh,  A_ffff                   ; save -1
; ===== Interrupts masked here =====

        MVKL    .S1     01010101h,  A_k_ones                 ; constant
||      MV      .L1     A_v,        A_vl                     ; vert. v...1
||      LDNDW   .D      *A_ref_img++(8),        B_ref_ri0a:B_ref_ri0b  ; Load ref

        MVKH    .S1     01010101h,  A_k_ones                 ; constant
||      ADD     .L1     -1,         A_vptch,    A_vptch      ; vptch--
||      MPY     .M2X    A_v,        B_h,        B_ml         ; ml = h*v
||      LDNDW   .D      *A_ref_img++(A_pitch_8),A_ref_ri0c:A_ref_ri0d   ; Load
||      MV      .D2     B_src_img,  B_src_imgcp              ; srcimg

        MVKL    .S2     01010101h,  B_k_ones                 ; constant
||      MV      .L1     A_v,        A_vl1                    ; v
||      MVKH    .S1     0000FFFFh,  A_ffff                   ; -1
||      LDNDW   .D2T2   *B_src_imgcp++,         B_srchia:B_srchib      ; Load src
||      SUB     .D1     A_pitch,    A_bptch,    A_bptch      ;

        MVKH    .S2     01010101h,  B_k_ones                 ; constant
||      OR      .L2     -1,         B_matval,   B_matval     ; matval
||      MV      .S1     A_bptch,    A_ptch                   ; ptch
||      ZERO    .L1     A_hl                                 ; hl
||      LDNDW   .D      *A_ref_img++(8),        B_ref_ri1a:B_ref_ri1b ; Load ref

; ============================ PIPE LOOP PROLOG ==============================

        LDNDW   .D2T1   *B_src_imgcp++,         A_srchic:A_srchid     ; Load
||      ZERO    .S1     A_matpos                             ; matpos

        LDNDW   .D      *A_ref_img++(A_pitch_8),A_ref_ri1c:A_ref_ri1d ;[ 4,1]

        LDNDW   .D      *A_ref_img++(8),        B_ref_ri2a:B_ref_ri2b ;[ 5,1]

        LDNDW   .D      *A_ref_img++(A_pitch_8),A_ref_ri2c:A_ref_ri2d ;[ 6,1]

        SUBABS4 .L2     B_ref_ri1b, B_srchib,   B_diffi_1b   ;[ 7,1]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_2srchia:B_2srchib ;[ 7,1]
||      B       .S2     L_5 + 12                             ;

        LDNDW   .D2T1   *B_src_imgcp++,  A_2srchic:A_2srchid ;[ 8,1]
||      B       .S2     L_6 + 4                              ;

M_LOOP:
        ADD     .D1     -2,         A_vl,       A_vl         ; vl-= 2
||      MPY     .M1     0, A_matchi1, A_matchi1              ; matchi1
||[!A_vl1 ]MV   .S1     A_v,        A_vl1                    ;[16,0]
||      SUBABS4 .L2     B_ref_ri1a, B_srchia,   B_diffi_1a   ;[ 9,1]
||      SUBABS4 .L1     A_ref_ri1d, A_srchid,   A_diffi_1d   ;[ 9,1]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_srchia:B_srchib   ;[ 1,2]
||      B       .S2     L_7 + 8                              ;

        MVK     .S1     7,          A_i                      ; i = 7
||      MV      .D2     B_ref_ri2b, B_ref_ri0b               ;[10,1]
||      SUBABS4 .L2     B_ref_ri0b, B_srchib,   B_diffi_0b   ;[10,1]
||      DOTPU4  .M2     B_diffi_1a, B_k_ones,   B_sumi1a     ;[10,1]
||      SUBABS4 .L1     A_ref_ri1c, A_srchic,   A_diffi_1c   ;[10,1]
||      LDNDW   .D      *A_ref_img++(8), B_ref_ri1a:B_ref_ri1b;[ 2,2]
||      B       .S2     L_8 + 8                              ;[ 2,2]

        MV      .S2     B_ref_ri2a, B_ref_ri0a               ;[11,1]
||      DOTPU4  .M2     B_diffi_1b, B_k_ones,   B_sumi1b     ;[11,1]
||      SUBABS4 .L2     B_ref_ri0a, B_srchia,   B_diffi_0a   ;[11,1]
||      SUBABS4 .L1     A_ref_ri0d, A_srchid,   A_diffi_0d   ;[11,1]
||      DOTPU4  .M1     A_diffi_1c, A_k_ones,   A_sumi1c     ;[11,1]
||      LDNDW   .D2T1   *B_src_imgcp++,  A_srchic:A_srchid   ;[ 3,2]
||      B       .S1     LOOP_X                               ;
||[!A_vl]MV     .D1     A_vptch,    A_ptch                   ; ptch

        SUBABS4 .L1     A_ref_ri0c, A_srchic,   A_diffi_0c   ;[12,1]
||      DOTPU4  .M2     B_diffi_0a, B_k_ones,   B_sumi0a     ;[12,1]
||      SUBABS4 .L2     B_ref_ri1a, B_2srchia,  B_2diffi_0a  ;[12,1]
||      DOTPU4  .M1     A_diffi_0d, A_k_ones,   A_sumi0d     ;[12,1]
||      LDNDW   .D      *A_ref_img++(A_pitch_8),A_ref_ri1c:A_ref_ri1d ;[ 4,2]
||[!A_vl]MV     .S1     A_v,         A_vl                    ; vl = v
||      ZERO    .S2     B_matchi0                            ; matchi0

; ============================ PIPE LOOP KERNEL ==============================
LOOP_X:

  [ A_i]ADD     .S1     A_i,        -1,         A_i           ;[17,1]
||      ADD     .S2     B_sumi1a,   B_sumi1b,   B_sumi1ab     ;[17,1]
||      DOTPU4  .M2     B_2diffi_1b,B_k_ones,   B_2sumi1b     ;[17,1]
||      DOTPU4  .M1     A_2diffi_0d,A_k_ones,   A_2sumi0d     ;[17,1]
||      ADD     .D1     A_sumi1c,   A_sumi1d,   A_sumi1cd     ;[17,1]
||      SUBABS4 .L2     B_ref_ri1a, B_srchia,   B_diffi_1a    ;[ 9,2]
||      SUBABS4 .L1     A_ref_ri1d, A_srchid,   A_diffi_1d    ;[ 9,2]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_srchia:B_srchib    ;[ 1,3]

        ADD     .S2     B_sumi0a,   B_sumi0b,   B_sumi0ab     ;[18,1]
||      DOTPU4  .M1     A_2diffi_1d,A_k_ones,   A_2sumi1d     ;[18,1]
||      ADD     .S1     A_sumi0c,   A_sumi0d,   A_sumi0cd     ;[18,1]
||      ADD     .D2     B_ref_ri2b, 0,          B_ref_ri0b    ;[10,2]
||      SUBABS4 .L2     B_ref_ri0b, B_srchib,   B_diffi_0b    ;[10,2]
||      DOTPU4  .M2     B_diffi_1a, B_k_ones,   B_sumi1a      ;[10,2]
||      SUBABS4 .L1     A_ref_ri1c, A_srchic,   A_diffi_1c    ;[10,2]
||      LDNDW   .D      *A_ref_img++(8), B_ref_ri1a:B_ref_ri1b;[ 2,3]

  [ A_i]B       .S1     LOOP_X                                ;[19,1]
||      ADD     .D1X    A_sumi1cd,  B_sumi1ab,  A_sumi1       ;[19,1]
||      ADD     .S2     B_ref_ri2a, 0,          B_ref_ri0a    ;[11,2]
||      DOTPU4  .M2     B_diffi_1b, B_k_ones,   B_sumi1b      ;[11,2]
||      SUBABS4 .L2     B_ref_ri0a, B_srchia,   B_diffi_0a    ;[11,2]
||      SUBABS4 .L1     A_ref_ri0d, A_srchid,   A_diffi_0d    ;[11,2]
||      DOTPU4  .M1     A_diffi_1c, A_k_ones,   A_sumi1c      ;[11,2]
||      LDNDW   .D2T1   *B_src_imgcp++,  A_srchic:A_srchid    ;[ 3,3]

        ADD     .S2X    B_sumi0ab,  A_sumi0cd,  B_sumi0       ;[20,1]
||      ADD     .S1     A_matchi1,  A_sumi1,    A_matchi1     ;[20,1]
||      SUBABS4 .L1     A_ref_ri0c, A_srchic,   A_diffi_0c    ;[12,2]
||      DOTPU4  .M2     B_diffi_0a, B_k_ones,   B_sumi0a      ;[12,2]
||      SUBABS4 .L2     B_ref_ri1a, B_2srchia,  B_2diffi_0a   ;[12,2]
||      DOTPU4  .M1     A_diffi_0d, A_k_ones,   A_sumi0d      ;[12,2]
||      LDNDW   .D      *A_ref_img++(A_pitch_8),A_ref_ri1c:A_ref_ri1d   ;[ 4,3]

L_5:    ADD     .D2     B_matchi0,  B_sumi0,    B_matchi0     ;[21,1]
||      ADD     .S2     B_2sumi1a,  B_2sumi1b,  B_2sumi1ab    ;[21,1]
||      ADD     .S1     A_2sumi0c,  A_2sumi0d,  A_2sumi0cd    ;[21,1]
||      SUBABS4 .L2     B_ref_ri2a, B_2srchia,  B_2diffi_1a   ;[13,2]
||      DOTPU4  .M1     A_diffi_1d, A_k_ones,   A_sumi1d      ;[13,2]
||      SUBABS4 .L1     A_ref_ri2d, A_2srchid,  A_2diffi_1d   ;[13,2]
||      DOTPU4  .M2     B_2diffi_0a,B_k_ones,   B_2sumi0a     ;[13,2]
||      LDNDW   .D      *A_ref_img++(8), B_ref_ri2a:B_ref_ri2b;[ 5,3]

L_6:    ADD     .D2     B_2sumi0a,  B_2sumi0b,  B_2sumi0ab    ;[22,1]
||      ADD     .S1     A_2sumi1c,  A_2sumi1d,  A_2sumi1cd    ;[22,1]
||      DOTPU4  .M1     A_diffi_0c, A_k_ones,   A_sumi0c      ;[14,2]
||      SUBABS4 .L1     A_ref_ri2c, A_2srchic,  A_2diffi_1c   ;[14,2]
||      DOTPU4  .M2     B_diffi_0b, B_k_ones,   B_sumi0b      ;[14,2]
||      SUBABS4 .L2     B_ref_ri1b, B_2srchib,  B_2diffi_0b   ;[14,2]
||      LDNDW   .D      *A_ref_img++(A_pitch_8), A_ref_ri2c:A_ref_ri2d  ;[ 6,3]

L_7:    ADD     .S1X    A_2sumi1cd, B_2sumi1ab, A_2sumi1     ;[23,1]
||      ADD     .S2X    B_2sumi0ab, A_2sumi0cd, B_2sumi0     ;[23,1]
||      ADD     .D1     A_ref_ri2c, 0,          A_ref_ri0c   ;[15,2]
||      DOTPU4  .M1     A_2diffi_1c,A_k_ones,   A_2sumi1c    ;[15,2]
||      SUBABS4 .L1     A_ref_ri1c, A_2srchic,  A_2diffi_0c  ;[15,2]
||      DOTPU4  .M2     B_2diffi_1a,B_k_ones,   B_2sumi1a    ;[15,2]
||      SUBABS4 .L2     B_ref_ri1b, B_srchib,   B_diffi_1b   ;[ 7,3]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_2srchia:B_2srchib ;[ 7,3]


L_8:    ADD     .S2     B_matchi0,  B_2sumi0,   B_matchi0    ;[24,1]
||      ADD     .S1     A_matchi1,  A_2sumi1,   A_matchi1    ;[24,1]
||      ADD     .D1     A_ref_ri2d, 0,          A_ref_ri0d   ;[16,2]
||      DOTPU4  .M2     B_2diffi_0b,B_k_ones,   B_2sumi0b    ;[16,2]
||      SUBABS4 .L2     B_ref_ri2b, B_2srchib,  B_2diffi_1b  ;[16,2]
||      SUBABS4 .L1     A_ref_ri1d, A_2srchid,  A_2diffi_0d  ;[16,2]
||      DOTPU4  .M1     A_2diffi_0c,A_k_ones,   A_2sumi0c    ;[16,2]
||      LDNDW   .D2T1   *B_src_imgcp++,  A_2srchic:A_2srchid ;[ 8,3]

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

        ADD     .S2     B_sumi1a,   B_sumi1b,   B_sumi1ab    ;[17,3]
||      DOTPU4  .M2     B_2diffi_1b,B_k_ones,   B_2sumi1b    ;[17,3]
||      DOTPU4  .M1     A_2diffi_0d,A_k_ones,   A_2sumi0d    ;[17,3]
||      ADD     .D1     A_sumi1c,   A_sumi1d,   A_sumi1cd    ;[17,3]
||      SUB     .S1     A_ref_img,  A_ptch,     A_ref_img    ;

        ADD     .S2     B_sumi0a,   B_sumi0b,   B_sumi0ab    ;[18,3]
||      DOTPU4  .M1     A_2diffi_1d,A_k_ones,   A_2sumi1d    ;[18,3]
||      ADD     .S1     A_sumi0c,   A_sumi0d,   A_sumi0cd    ;[18,3]
||      MV      .L2     B_src_img,  B_src_imgcp              ;

        ADD     .S1X    A_sumi1cd,  B_sumi1ab,  A_sumi1      ;[19,3]
||      LDNDW   .D      *A_ref_img++(8), B_ref_ri0a:B_ref_ri0b;

        ADD     .S2X    B_sumi0ab,  A_sumi0cd,  B_sumi0      ;[20,3]
||      ADD     .S1     A_matchi1,  A_sumi1,    A_matchi1    ;[20,3]
||      LDNDW   .D      *A_ref_img++(A_pitch_8), A_ref_ri0c:A_ref_ri0d;

        ADD     .L2     B_matchi0,  B_sumi0,    B_matchi0    ;[21,3]
||      ADD     .S2     B_2sumi1a,  B_2sumi1b,  B_2sumi1ab   ;[21,3]
||      ADD     .S1     A_2sumi0c,  A_2sumi0d,  A_2sumi0cd   ;[21,3]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_srchia:B_srchib   ;

        ADD     .S2     B_2sumi0a,  B_2sumi0b,  B_2sumi0ab   ;[22,3]
||      ADD     .S1     A_2sumi1c,  A_2sumi1d,  A_2sumi1cd   ;[22,3]
|| [B_ml]ADD    .L2     B_ml,       -2,         B_ml         ;
||      LDNDW   .D      *A_ref_img++(8),        B_ref_ri1a:B_ref_ri1b; Load ref

        ADD     .S1X    A_2sumi1cd, B_2sumi1ab, A_2sumi1     ;[23,3]
||      ADD     .L2X    B_2sumi0ab, A_2sumi0cd, B_2sumi0     ;[23,3]
||[ B_ml]B      .S2     M_LOOP                               ;
||      LDNDW   .D2T1   *B_src_imgcp++,         A_srchic:A_srchid ; Load

        ADD     .L2     B_matchi0,  B_2sumi0,   B_matchi0    ;[24,3]
||      ADD     .S1     A_matchi1,  A_2sumi1,   A_matchi1    ;[24,3]
||      LDNDW   .D      *A_ref_img++(A_pitch_8),  A_ref_ri1c:A_ref_ri1d ;[ 4,1]
||      MV      .L1X    B_matval,   A_matval

; ============================================================================
; END:

        CMPLTU  .L2     B_matchi0,  B_matval,   B_best       ;
||      ADD     .L1     -1,         A_vl1,      A_vl1        ;
||      MV      .S1     A_bptch,    A_ptch                   ;
||      LDNDW   .D      *A_ref_img++(8),        B_ref_ri2a:B_ref_ri2b ;[ 5,1]

  [ B_best] MV    .L2   B_matchi0,  B_matval                 ;
||[ B_best] MV    .L1X  B_matchi0,  A_matval                 ;
||[ B_best] PACK2 .S1   A_hl,       A_vl1,      A_matpos     ;
||          LDNDW .D    *A_ref_img++(A_pitch_8),A_ref_ri2c:A_ref_ri2d ;[ 6,1]

        ADD     .S1     -1,         A_vl1,      A_vl1        ;
||      CMPLTU  .L1     A_matchi1,  A_matval,   A_best       ; XP stall
||      SUBABS4 .L2     B_ref_ri1b, B_srchib,   B_diffi_1b   ;[ 7,1]
||      LDNDW   .D2T2   *B_src_imgcp++,  B_2srchia:B_2srchib ;[ 7,1]
||[ B_ml]B      .S2     L_5 + 12                             ;

  [ A_best] PACK2 .L1   A_hl,       A_vl1,      A_matpos     ;
||[!A_vl1 ] ADD   .D1   A_hl,       1,          A_hl         ;
||[ A_best] MV    .S2X  A_matchi1,  B_matval                 ;
||          LDNDW .D2T1 *B_src_imgcp++,  A_2srchic:A_2srchid ;[ 8,1]
||[ B_ml]   B     .S1   L_6 + 4                              ;

        ;==== Branch occurs

; ========================================================================= ;
        LDW     .D2T1   *+B_SP[1],  A10

        RET     .S2     B_ret                                ; Return to caller
||      LDW     .D2T1   *+B_SP[2],  A11

        MV      .S1     A_v,        A_sub                    ;
||      AND     .L1     A_matpos,   A_ffff,     A_vl         ;
||      LDW     .D2T1   *++B_SP[3],  A14

        SUB     .L1     A_sub,      1,          A_sub        ;
||      SHL     .S1     A_ffff,     16,         A_ffff       ;

        SUB     .S1     A_sub,      A_vl,       A_vl         ;
||      AND     .L1     A_matpos,   A_ffff,     A_matpos     ;

        ADD     .S1     A_matpos,   A_vl,       A_matpos     ;
||      MV      .L1X    B_matval,   A_matval                 ;

        STNDW   .D2T1   A_matval:A_matpos,      *B_match     ;
||      MVC     .S2     B_csr,            CSR         ; Restore CSR
; ===== Interruptibility state restored here =====
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_mad_16x16.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mad_8x8.asm/    1066928952  0     0     0       35092     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.16    Sun Sep 29 02:31:01 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mad_8x8 : Minimum absolute Difference                           *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *ref_data,  /* Ref. image to search */      *
*           const unsigned char *src_data,  /* Source 8x8 block     */      *
*           int                 pitch,      /* Width of ref image   */      *
*           int sx, int sy,                 /* Search window size   */      *
*           unsigned int        *match      /* Result               */      *
*       );                                                                  *
*                                                                           *
*       The reference image is an image of width 'pitch'.  The IMG_mad_8x8  *
*       routine searches a (sx,sy) window within the image.                 *
*                                                                           *
*       The source image is an 8x8 block of pixels which contain the        *
*       image block that is being searched for.                             *
*                                                                           *
*       The match[] array is where the best match location and MAD value    *
*       for the best match are stored.  The best match position and its     *
*       absolute difference are returned in match, packed as follows:       *
*                                                                           *
*                      31             16 15             0                   *
*                      +----------------+----------------+                  *
*           match[0]:  |    X offset    |    Y offset    |                  *
*                      +----------------+----------------+                  *
*                                                                           *
*                      31                               0                   *
*                      +---------------------------------+                  *
*           match[1]:  |   Sum of absolute differences   |                  *
*                      +---------------------------------+                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine locates the position in a reference image which        *
*       most closely matches an 8x8 block from a source image, using        *
*       the Minimum Absolute Difference metric.  Searches over a range      *
*       that is 'sx' pixels wide and 'sy' pixels tall within a reference    *
*       image that is 'pitch' pixels wide.                                  *
*                                                                           *
*       The search is performed in top-to-bottom, left-to-right order,      *
*       with the earliest match taking precedence in the case of ties.      *
*                                                                           *
*       The match location as well as the Minimum Absolute Difference       *
*       metric for the match are returned in the 'match' array.             *
*       The first element contains the packed horizontal and vertical       *
*       coordinates of the match, with the X coordinate in the upper        *
*       halfword and the Y coordinate in the lower halfword.  The           *
*       second element contains the MAD value for this match location.      *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loops that perform the 8x8 mads are completely            *
*       unrolled and the outer two loops are collpaesd together. In         *
*       addition all source image data is pre-loaded into registers.        *
*                                                                           *
*       The data required for any one row is brought in using               *
*       non-aligned loads. SUBABS4 and DOTPU4 are used together to do       *
*       the MAD computation.                                                *
*                                                                           *
*       To save instructions and fit within an 8 cycle loop, the            *
*       precise location of a given match is not stored.  Rather,           *
*       the loop iteration that it was encountered on is stored.            *
*       A short divide loop after the search loop converts this             *
*       value into X and Y coordinates for the location.                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The arrays for the source image data and the result must be         *
*       word aligned.                                                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur for this kernel.                            *
*                                                                           *
*       No particular memory alignment is required for the reference        *
*       image, although the source image data and result                    *
*       must be word aligned.                                               *
*                                                                           *
*   NOTES                                                                   *
*       The search window spans from (0,0) to (sx-1,sy-1), inclusive.       *
*                                                                           *
*       The inner loop comprises 64 instructions that are executed in 8     *
*       cycles, with 64 absolute-differences accumulated in a single        *
*       iteration.  The source pixels are pre-read into registers and       *
*       the inner loop is unrolled completely.  This code thus executes     *
*       8 instructions per cycle, and computes 8 absolute differences       *
*       per cycle.                                                          *
*                                                                           *
*       This benchmark is Little Endian.                                    *
*                                                                           *
*       This code suppresses interrupts for the entire duration of the      *
*       code, hence it is interrupt tolerant but not interruptible.         *
*                                                                           *
*   C CODE                                                                  *
*       The following is the equivalent C code.  The assembly code          *
*       has restrictions as noted under "ASSUMPTIONS".                      *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch, int sx, int sy,                                      *
*           unsigned int *restrict match                                    *
*       )                                                                   *
*       {                                                                   *
*           int i, j, x, y, matx, maty;                                     *
*           unsigned matpos, matval;                                        *
*                                                                           *
*           matval = ~0U;                                                   *
*           matx   = maty = 0;                                              *
*                                                                           *
*           for (x = 0; x < sx; x++)                                        *
*               for (y = 0; y < sy; y++)                                    *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 8; i++)                                 *
*                       for (j = 0; j < 8; j++)                             *
*                           acc += abs(srcImg[i*8 + j] -                    *
*                                      refImg[(i+y)*pitch + x + j]);        *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*                                                                           *
*           matpos    = (0xffff0000 & (matx << 16)) |                       *
*                       (0x0000ffff & maty);                                *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       sx = # of columns of the search space                               *
*       sy = # of rows of the search space                                  *
*       cycles = 8 * sx * sy + 66.                                          *
*                                                                           *
*       For sx=  4 and sy=  4, cycles = 194.                                *
*       For sx= 64 and sy= 32, cycles = 16450.                              *
*                                                                           *
*       Overall throughput is 7.97 pixels/cycle (0.126 cycles/pixel)        *
*       over the whole function for the case H=64 and V=32.                 *
*                                                                           *
*   CODESIZE                                                                *
*       788 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

               .sect    ".data:copyright_h"
        .global __divu

        .sect ".text:_mad_8x8"
        .global _IMG_mad_8x8
_IMG_mad_8x8:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_i
        .asg            A1,         A_err1l
        .asg            A1,         A_err7l
        .asg            A1,         A_mad_3
        .asg            A1,         A_mad_4
        .asg            A1,         A_row_6
        .asg            A2,         A_f
        .asg            A2,         A_src
        .asg            A3,         A_h_fix
        .asg            A4,         A_ref_d
        .asg            A5,         A_src7l
        .asg            A6,         A_p1
        .asg            A7,         A_err3l
        .asg            A7,         A_mad_2
        .asg            A8,         A_v_dim
        .asg            A8,         A_k_one
        .asg            A9,         A_p7
        .asg            A9,         A_tmp
        .asg            A10,        A_err5l
        .asg            A10,        A_row_4
        .asg            A10,        A_row_5
        .asg            A10,        A_row_7
        .asg            A11,        A_err6l
        .asg            A11,        A_mad_5
        .asg            A11,        A_row_1
        .asg            A12,        A_mad_6
        .asg            A12,        A_ref1l
        .asg            A12,        A_ref3l
        .asg            A13,        A_err2l
        .asg            A13,        A_ref1h
        .asg            A13,        A_ref3h
        .asg            A13,        A_row_3
        .asg            A16,        A_p2
        .asg            A17,        A_p3
        .asg            A18,        A_p4
        .asg            A19,        A_p5
        .asg            A20,        A_p6
        .asg            A21,        A_src0l
        .asg            A22,        A_src1l
        .asg            A23,        A_src2l
        .asg            A24,        A_src3l
        .asg            A25,        A_src4l
        .asg            A26,        A_src5l
        .asg            A27,        A_src6l
        .asg            A28,        A_ref5l
        .asg            A28,        A_ref7l
        .asg            A28,        A_row_2
        .asg            A29,        A_ref5h
        .asg            A29,        A_ref7h
        .asg            A30,        A_row_0
        .asg            A31,        A_err0l
        .asg            A31,        A_err4l
        .asg            B0,         B_v1
        .asg            B1,         B_bst
        .asg            B1,         B_err0h
        .asg            B1,         B_err2h
        .asg            B1,         B_mad_0
        .asg            B1,         B_mad_4
        .asg            B1,         B_row_4
        .asg            B2,         B_k_one
        .asg            B3,         B_ret
        .asg            B4,         B_src
        .asg            B4,         B_v_dim
        .asg            B5,         B_err1h
        .asg            B5,         B_err6h
        .asg            B5,         B_err7h
        .asg            B5,         B_row_1
        .asg            B5,         B_row_7
        .asg            B6,         B_bhvl
        .asg            B6,         B_h_dim
        .asg            B7,         B_no_gie
        .asg            B7,         B_err3h
        .asg            B7,         B_err4h
        .asg            B7,         B_err5h
        .asg            B7,         B_mad_5
        .asg            B7,         B_mad_6
        .asg            B8,         B_match
        .asg            B9,         B_mad_2
        .asg            B9,         B_row_3
        .asg            B16,        B_mad_1
        .asg            B17,        B_row_0
        .asg            B18,        B_best
        .asg            B19,        B_hvl
        .asg            B20,        B_mad
        .asg            B21,        B_src0h
        .asg            B22,        B_src1h
        .asg            B23,        B_src2h
        .asg            B24,        B_src3h
        .asg            B25,        B_src4h
        .asg            B26,        B_src5h
        .asg            B27,        B_src6h
        .asg            B28,        B_src7h
        .asg            B29,        B_csr
        .asg            B30,        B_mad_3
        .asg            B30,        B_ref0l
        .asg            B30,        B_ref2l
        .asg            B30,        B_ref4l
        .asg            B30,        B_ref6l
        .asg            B30,        B_row_5
        .asg            B31,        B_ref0h
        .asg            B31,        B_ref2h
        .asg            B31,        B_ref4h
        .asg            B31,        B_ref6h
        .asg            B31,        B_row_2
        .asg            B31,        B_row_6
* ========================================================================= *

        STW     .D2T1   A10,        * B15--(16)
||      MV              B_src,      A_src

        LDW     .D2T2   *B_src[15], B_src7h
||      LDW     .D1T1   *A_src[14], A_src7l
||      SUB     .S1     A_v_dim,    1,          A_tmp

        LDW     .D2T2   *B_src[13], B_src6h
||      LDW     .D1T1   *A_src[12], A_src6l
||      MPY     .M1     A_tmp,      A_p1,       A_tmp

        LDW     .D2T2   *B_src[11], B_src5h
||      LDW     .D1T1   *A_src[10], A_src5l
||      MVKL    .S2     0x01010101, B_k_one

        LDW     .D2T2   *B_src[ 9], B_src4h
||      LDW     .D1T1   *A_src[ 8], A_src4l
||      SUB     .S1     1,          A_tmp,      A_h_fix

        LDW     .D2T2   *B_src[ 7], B_src3h
||      LDW     .D1T1   *A_src[ 6], A_src3l
||      MVKH    .S2     0x01010101, B_k_one

        LDW     .D2T2   *B_src[ 5], B_src2h
||      LDW     .D1T1   *A_src[ 4], A_src2l

        LDW     .D2T2   *B_src[ 3], B_src1h
||      LDW     .D1T1   *A_src[ 2], A_src1l

        LDW     .D2T2   *B_src[ 1], B_src0h
||      LDW     .D1T1   *A_src[ 0], A_src0l
||      MVC     .S2     CSR,        B_csr
* =========================== PIPE LOOP PROLOG ============================ *
        MPYUS   .M1     A_p1,       7,          A_p7
||      STW     .D2T1   A11,        *+B15(4)
||      AND     .L2     B_csr,      -2,         B_no_gie

        MPYUS   .M1     A_p1,       6,          A_p6
||      MV      .L2X    A_v_dim,    B_v_dim
||      STDW    .D2T1   A13:A12,    *+B15(8)
||      MVC     .S2     B_no_gie,   CSR

        LDNDW   .D      *A_ref_d(A_p7),         A_ref7h:A_ref7l ;[ 1,1]
||      MV      .S1     A_p1,       A_f                         ;[ 1,1]
||      MPYUS   .M1     A_p1,       3,          A_p3

        LDNDW   .D      *A_ref_d(A_p6),         B_ref6h:B_ref6l ;[ 2,1]
||      MPYUS   .M1     A_p1,       5,          A_p5

        LDNDW   .D      *A_ref_d(A_p3),         A_ref3h:A_ref3l ;[ 3,1]
||      SUB     .D2     B_v_dim,    1,          B_v1            ;[ 3,1]
||      MPYUS   .M1     A_p1,       4,          A_p4

        LDNDW   .D      *A_ref_d(A_p5),         A_ref5h:A_ref5l ;[ 4,1]
||[!B_v1]MV     .S1     A_h_fix,    A_f                         ;[ 4,1]
||      MPYUS   .M1     A_p1,       2,          A_p2

        LDNDW   .D      *A_ref_d(A_p4),         B_ref4h:B_ref4l ;[ 5,1]
||      MPY     .M1X    B_h_dim,    A_v_dim,    A_i
||      ZERO    .L2     B_hvl
||      ZERO    .D2     B_bhvl
||      MVK     .S2     0x7FFF,     B_best

        LDNDW   .D      *A_ref_d(A_p2),         B_ref2h:B_ref2l ;[ 6,1]
||      SUBABS4 .L2X    B_src7h,    A_ref7h,    B_err7h         ;[ 6,1]
||[!B_v1]MV     .S2     B_v_dim,    B_v1                        ;[ 6,1]
||      MV      .S1X    B_k_one,    A_k_one

        LDNDW   .D      *A_ref_d(A_p1),         A_ref1h:A_ref1l ;[ 7,1]
||      SUBABS4 .L2     B_src6h,    B_ref6h,    B_err6h         ;[ 7,1]
||      DOTPU4  .M2     B_err7h,    B_k_one,    B_row_7         ;[ 7,1]
||      SUBABS4 .L1     A_src7l,    A_ref7l,    A_err7l         ;[ 7,1]
||      SUB     .S1     A_i,        1,          A_i

        LDNDW   .D      *A_ref_d++(A_f),        B_ref0h:B_ref0l ;[ 8,1]
||      SUBABS4 .L2X    B_src3h,    A_ref3h,    B_err3h         ;[ 8,1]
||      DOTPU4  .M2     B_err6h,    B_k_one,    B_row_6         ;[ 8,1]
||      SUBABS4 .L1X    A_src6l,    B_ref6l,    A_err6l         ;[ 8,1]
||      DOTPU4  .M1     A_err7l,    A_k_one,    A_row_7         ;[ 8,1]

        DOTPU4  .M2     B_err3h,    B_k_one,    B_row_3         ;[ 9,1]
||      SUBABS4 .L1     A_src5l,    A_ref5l,    A_err5l         ;[ 9,1]
||      SUBABS4 .L2X    B_src5h,    A_ref5h,    B_err5h         ;[ 9,1]
||      LDNDW   .D      *A_ref_d(A_p7),         A_ref7h:A_ref7l ;[ 1,2]

        SUBABS4 .L1X    A_src4l,    B_ref4l,    A_err4l         ;[10,1]
||      SUBABS4 .L2     B_src4h,    B_ref4h,    B_err4h         ;[10,1]
||      DOTPU4  .M2     B_err5h,    B_k_one,    B_row_5         ;[10,1]
||      DOTPU4  .M1     A_err6l,    A_k_one,    A_row_6         ;[10,1]
||      LDNDW   .D      *A_ref_d(A_p6),         B_ref6h:B_ref6l ;[ 2,2]

        SUBABS4 .L2     B_src2h,    B_ref2h,    B_err2h         ;[11,1]
||      SUBABS4 .L1     A_src3l,    A_ref3l,    A_err3l         ;[11,1]
||      DOTPU4  .M2     B_err4h,    B_k_one,    B_row_4         ;[11,1]
||      DOTPU4  .M1     A_err5l,    A_k_one,    A_row_5         ;[11,1]
||      LDNDW   .D      *A_ref_d(A_p3),         A_ref3h:A_ref3l ;[ 3,2]
||      SUB     .D2     B_v1,       1,          B_v1            ;[ 3,2]

        SUBABS4 .L2X    B_src1h,    A_ref1h,    B_err1h         ;[12,1]
||      DOTPU4  .M2     B_err2h,    B_k_one,    B_row_2         ;[12,1]
||      SUBABS4 .L1X    A_src2l,    B_ref2l,    A_err2l         ;[12,1]
||      DOTPU4  .M1     A_err4l,    A_k_one,    A_row_4         ;[12,1]
||      ADD     .D2     B_row_6,    B_row_7,    B_mad_6         ;[12,1]
||      LDNDW   .D      *A_ref_d(A_p5),         A_ref5h:A_ref5l ;[ 4,2]
||[!B_v1]MV     .S1     A_h_fix,    A_f                         ;[ 4,2]

        SUBABS4 .L1X    A_src0l,    B_ref0l,    A_err0l         ;[13,1]
||      SUBABS4 .L2     B_src0h,    B_ref0h,    B_err0h         ;[13,1]
||      DOTPU4  .M2     B_err1h,    B_k_one,    B_row_1         ;[13,1]
||      DOTPU4  .M1     A_err3l,    A_k_one,    A_row_3         ;[13,1]
||      LDNDW   .D      *A_ref_d(A_p4),         B_ref4h:B_ref4l ;[ 5,2]

        DOTPU4  .M2     B_err0h,    B_k_one,    B_row_0         ;[14,1]
||      SUBABS4 .L1     A_src1l,    A_ref1l,    A_err1l         ;[14,1]
||      DOTPU4  .M1     A_err2l,    A_k_one,    A_row_2         ;[14,1]
||      ADD     .D2     B_row_5,    B_mad_6,    B_mad_5         ;[14,1]
||      ADD     .S1     A_row_6,    A_row_7,    A_mad_6         ;[14,1]
||      LDNDW   .D      *A_ref_d(A_p2),         B_ref2h:B_ref2l ;[ 6,2]
||      SUBABS4 .L2X    B_src7h,    A_ref7h,    B_err7h         ;[ 6,2]
||[!B_v1]MV     .S2     B_v_dim,    B_v1                        ;[ 6,2]

        DOTPU4  .M1     A_err1l,    A_k_one,    A_row_1         ;[15,1]
||      ADD     .D2     B_row_4,    B_mad_5,    B_mad_4         ;[15,1]
||      ADD     .S1     A_row_5,    A_mad_6,    A_mad_5         ;[15,1]
||      LDNDW   .D1T1   *A_ref_d(A_p1),         A_ref1h:A_ref1l ;[ 7,2]
||      SUBABS4 .L2     B_src6h,    B_ref6h,    B_err6h         ;[ 7,2]
||      DOTPU4  .M2     B_err7h,    B_k_one,    B_row_7         ;[ 7,2]
||      SUBABS4 .L1     A_src7l,    A_ref7l,    A_err7l         ;[ 7,2]
||      B       .S2     loop_4 + 8                              ; pro. coll.

        ADD     .D2     B_row_3,    B_mad_4,    B_mad_3         ;[16,1]
||      ADD     .S1     A_row_4,    A_mad_5,    A_mad_4         ;[16,1]
||      LDNDW   .D      *A_ref_d++(A_p1),       B_ref0h:B_ref0l ;[ 8,2]
||      SUBABS4 .L2X    B_src3h,    A_ref3h,    B_err3h         ;[ 8,2]
||      DOTPU4  .M2     B_err6h,    B_k_one,    B_row_6         ;[ 8,2]
||      SUBABS4 .L1X    A_src6l,    B_ref6l,    A_err6l         ;[ 8,2]
||      DOTPU4  .M1     A_err7l,    A_k_one,    A_row_7         ;[ 8,2]

; Collapsed 1 Prolog Stage
* =========================== PIPE LOOP KERNEL ============================ *
mad8x8_loop:
        ADD     .D2     B_hvl,      1,          B_hvl           ;[25,1]
||      DOTPU4  .M1     A_err0l,    A_k_one,    A_row_0         ;[17,2]
||      ADD     .S2     B_row_2,    B_mad_3,    B_mad_2         ;[17,2]
||      DOTPU4  .M2     B_err3h,    B_k_one,    B_row_3         ;[ 9,3]
||      SUBABS4 .L1     A_src5l,    A_ref5l,    A_err5l         ;[ 9,3]
||      SUBABS4 .L2X    B_src5h,    A_ref5h,    B_err5h         ;[ 9,3]
||      LDNDW   .D      *A_ref_d(A_p7),         A_ref7h:A_ref7l ;[ 1,4]
||      MV      .S1     A_p1,       A_f                         ;[ 1,4]
loop_1:
        ADD     .D2X    A_row_0,    B_mad_0,    B_mad_0         ;[26,1]
||      ADD     .S2     B_row_1,    B_mad_2,    B_mad_1         ;[18,2]
||      ADD     .S1     A_row_3,    A_mad_4,    A_mad_3         ;[18,2]
||      SUBABS4 .L1X    A_src4l,    B_ref4l,    A_err4l         ;[10,3]
||      SUBABS4 .L2     B_src4h,    B_ref4h,    B_err4h         ;[10,3]
||      DOTPU4  .M2     B_err5h,    B_k_one,    B_row_5         ;[10,3]
||      DOTPU4  .M1     A_err6l,    A_k_one,    A_row_6         ;[10,3]
||      LDNDW   .D      *A_ref_d(A_p6),         B_ref6h:B_ref6l ;[ 2,4]
loop_2:
  [A_i] BDEC    .S1     mad8x8_loop,            A_i             ;[27,1]
||      ADD     .S2X    B_mad_0,    A_mad_2,    B_mad           ;[27,1]
||      SUBABS4 .L2     B_src2h,    B_ref2h,    B_err2h         ;[11,3]
||      SUBABS4 .L1     A_src3l,    A_ref3l,    A_err3l         ;[11,3]
||      DOTPU4  .M2     B_err4h,    B_k_one,    B_row_4         ;[11,3]
||      DOTPU4  .M1     A_err5l,    A_k_one,    A_row_5         ;[11,3]
||      LDNDW   .D      *A_ref_d(A_p3),         A_ref3h:A_ref3l ;[ 3,4]
||      SUB     .D2     B_v1,       1,          B_v1            ;[ 3,4]
loop_3:
        CMPGT2  .S2     B_best,     B_mad,      B_bst           ;[28,1]
||      SUBABS4 .L2X    B_src1h,    A_ref1h,    B_err1h         ;[12,3]
||      DOTPU4  .M2     B_err2h,    B_k_one,    B_row_2         ;[12,3]
||      SUBABS4 .L1X    A_src2l,    B_ref2l,    A_err2l         ;[12,3]
||      DOTPU4  .M1     A_err4l,    A_k_one,    A_row_4         ;[12,3]
||      ADD     .D2     B_row_6,    B_row_7,    B_mad_6         ;[12,3]
||      LDNDW   .D      *A_ref_d(A_p5),         A_ref5h:A_ref5l ;[ 4,4]
||[!B_v1]MV     .S1     A_h_fix,    A_f                         ;[ 4,4]
loop_4:
  [ B_bst]SUB   .D2     B_hvl,      1,          B_bhvl          ;[29,1]
||[ B_bst]MV    .S2     B_mad,      B_best                      ;[29,1]
||      ADD     .S1     A_row_2,    A_mad_3,    A_mad_2         ;[21,2]
||      SUBABS4 .L1X    A_src0l,    B_ref0l,    A_err0l         ;[13,3]
||      SUBABS4 .L2     B_src0h,    B_ref0h,    B_err0h         ;[13,3]
||      DOTPU4  .M2     B_err1h,    B_k_one,    B_row_1         ;[13,3]
||      DOTPU4  .M1     A_err3l,    A_k_one,    A_row_3         ;[13,3]
|| [A_i]LDNDW   .D      *A_ref_d(A_p4),         B_ref4h:B_ref4l ;[ 5,4]

        DOTPU4  .M2     B_err0h,    B_k_one,    B_row_0         ;[14,3]
||      SUBABS4 .L1     A_src1l,    A_ref1l,    A_err1l         ;[14,3]
||      DOTPU4  .M1     A_err2l,    A_k_one,    A_row_2         ;[14,3]
||      ADD     .D2     B_row_5,    B_mad_6,    B_mad_5         ;[14,3]
||      ADD     .S1     A_row_6,    A_row_7,    A_mad_6         ;[14,3]
|| [A_i]LDNDW   .D      *A_ref_d(A_p2),         B_ref2h:B_ref2l ;[ 6,4]
|| [A_i]SUBABS4 .L2X    B_src7h,    A_ref7h,    B_err7h         ;[ 6,4]
||[!B_v1]MV     .S2     B_v_dim,    B_v1                        ;[ 6,4]

        ADD     .D2X    A_row_1,    B_mad_1,    B_mad_1         ;[23,2]
||      DOTPU4  .M1     A_err1l,    A_k_one,    A_row_1         ;[15,3]
||      ADD     .S2     B_row_4,    B_mad_5,    B_mad_4         ;[15,3]
||      ADD     .S1     A_row_5,    A_mad_6,    A_mad_5         ;[15,3]
|| [A_i]LDNDW   .D      *A_ref_d(A_p1),         A_ref1h:A_ref1l ;[ 7,4]
|| [A_i]SUBABS4 .L2     B_src6h,    B_ref6h,    B_err6h         ;[ 7,4]
|| [A_i]DOTPU4  .M2     B_err7h,    B_k_one,    B_row_7         ;[ 7,4]
|| [A_i]SUBABS4 .L1     A_src7l,    A_ref7l,    A_err7l         ;[ 7,4]

        ADD     .S2     B_row_0,    B_mad_1,    B_mad_0         ;[24,2]
||      ADD     .D2     B_row_3,    B_mad_4,    B_mad_3         ;[16,3]
||      ADD     .S1     A_row_4,    A_mad_5,    A_mad_4         ;[16,3]
|| [A_i]LDNDW   .D      *A_ref_d++(A_f),        B_ref0h:B_ref0l ;[ 8,4]
|| [A_i]SUBABS4 .L2X    B_src3h,    A_ref3h,    B_err3h         ;[ 8,4]
|| [A_i]DOTPU4  .M2     B_err6h,    B_k_one,    B_row_6         ;[ 8,4]
|| [A_i]SUBABS4 .L1X    A_src6l,    B_ref6l,    A_err6l         ;[ 8,4]
|| [A_i]DOTPU4  .M1     A_err7l,    A_k_one,    A_row_7         ;[ 8,4]

* =========================== PIPE LOOP EPILOG ============================ *
; Collapsed 2 Epilog Stages
        .asg            A13,        A_v_dim
        .asg            A12,        A_ret
        .asg            A11,        A_bhvl
        .asg            A10,        A_match
        .asg            A4,         A_num
        .asg            B4,         B_den       ; Note: B_v_dim already in B4
        .asg            A4,         A_best_x
        .asg            A3,         A_best_y
        .asg            A4,         A_best_xy

        ADD     .L2X    A_row_0,    B_mad_0,    B_mad_0         ;[26,4]
||      CALL    .S2     __divu
||      MV      .S1X    B_v_dim,    A_v_dim

        ADD     .S2X    B_mad_0,    A_mad_2,    B_mad           ;[27,4]
||      MV      .S1X    B_ret,      A_ret

        CMPGT2  .S2     B_best,     B_mad,      B_bst           ;[28,4]
||      SUB     .L1X    B_bhvl,     1,          A_num           ;[29,4]

  [ B_bst]SUB   .D1X    B_hvl,      1,          A_num           ;[29,4]
||[ B_bst]MV    .S2     B_mad,      B_best                      ;[29,4]

        STW     .D2T2   B_best,     *B_match[1]
||      MV      .S1X    B_match,    A_match
||      MV      .L1     A_num,      A_bhvl

        ADDKPC  .S2     RL0,        B_ret,      0
; ===== Call Occurs.
RL0:
* ========================================================================= *
        LDDW    .D2T1   *B15(8),    A13:A12

        RET     .S2X    A_ret
||      LDW             *B15(4),    A11
||      MPYU    .M1     A_best_x,   A_v_dim,    A_tmp

        LDW     .D2T1   *++B15(16), A10

        SUB     .L1     A_bhvl,     A_tmp,      A_best_y

        PACK2   .L1     A_best_x,   A_best_y,   A_best_xy

        STW     .D1T1   A_best_xy,  *A_match[0]

        MVC     .S2     B_csr,      CSR
; ===== Branch Occurs.

* ========================================================================= *
*   End of file:  img_mad_8x8.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
median_3x3.asm/ 1066928952  0     0     0       26802     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.14    Thu Sep 11 18:42:51 2003 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_median_3x3                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Sep-2003                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_median_3x3                                             *
*           (                                                               *
*              const unsigned char *restrict i_data, /* Input image     */  *
*              int n,                    /* Length of input (or output) */  *
*              unsigned char       *restrict o_data  /* Output image    */  *
*           )                                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 3x3 median filter operation on 8-bit         *
*       unsigned values.  The median filter comes under the class           *
*       of non-linear signal processing algorithms.                         *
*                                                                           *
*       Rather than replace the grey level at a pixel by a weighted         *
*       average of the nine pixels including and surrounding it, the        *
*       grey level at each pixel is replaced by the median of the nine      *
*       values.  The median of a set of nine numbers is the middle          *
*       element so that half of the elements in the list are larger and     *
*       half are smaller.  Median filters remove the effects of extreme     *
*       values from data, such as salt and pepper noise, although using     *
*       a wide may result in unacceptable blurring of sharp edges in        *
*       the original image.                                                 *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm without      *
*       restrictions.  The optimized implementations may have               *
*       restrictions, as noted under the "ASSUMPTIONS" below.               *
*                                                                           *
*       void IMG_median_3x3                                                 *
*       (                                                                   *
*           const unsigned char *restrict i_data,                           *
*           int n,                                                          *
*           unsigned char       *restrict o_data                            *
*       )                                                                   *
*       {                                                                   *
*           unsigned char c0h, c1h, c2h; /* "hi",  columns 0..2 */          *
*           unsigned char c0m, c1m, c2m; /* "mid", columns 0..2 */          *
*           unsigned char c0l, c1l, c2l; /* "lo",  columns 0..2 */          *
*           unsigned char h_min;         /* "min" */                        *
*           unsigned char m_mid;         /* "mid" */                        *
*           unsigned char l_max;         /* "max" */                        *
*           unsigned char m_h, m_l, t, out;                                 *
*                                                                           *
*           int i;                                                          *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Start off with a well-defined initial state.        */      *
*           /* ---------------------------------------------------- */      *
*           c1h = c2h = c1m = c2m = c1l = c2l = 127;                        *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Iterate over the input row.                         */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < n; i++)                                         *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Slide the two previous columns of sorted        */      *
*               /*  pixels over by 1.                               */      *
*               /* ------------------------------------------------ */      *
*               c0h = c1h;    c1h = c2h;                                    *
*               c0m = c1m;    c1m = c2m;                                    *
*               c0l = c1l;    c1l = c2l;                                    *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Load in a new column of pixels, and sort into   */      *
*               /*  low, medium, high.                              */      *
*               /* ------------------------------------------------ */      *
*               c2h = i_data[i      ];                                      *
*               c2m = i_data[i +   n];                                      *
*               c2l = i_data[i + 2*n];                                      *
*                                                                           *
*               if (c2l > c2h) { t = c2l; c2l = c2h; c2h = t; }             *
*               if (c2l > c2m) { t = c2l; c2l = c2m; c2m = t; }             *
*               if (c2m > c2h) { t = c2m; c2m = c2h; c2h = t; }             *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the minimum value of the "hi" terms.       */      *
*               /* ------------------------------------------------ */      *
*               h_min = c2h;                                                *
*               if (c1h < h_min) { h_min = c1h; }                           *
*               if (c0h < h_min) { h_min = c0h; }                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the middle value of the "mid" terms.       */      *
*               /* ------------------------------------------------ */      *
*               m_l   = c0m;                                                *
*               m_mid = c1m;                                                *
*               m_h   = c2m;                                                *
*                                                                           *
*               if (m_l   > m_h  ) { t = m_l; m_l = m_h; m_h = t; }         *
*               if (m_l   > m_mid) { m_mid = m_l; }                         *
*               if (m_mid > m_h  ) { m_mid = m_h; }                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the maximum value of the "lo" terms.       */      *
*               /* ------------------------------------------------ */      *
*               l_max = c2l;                                                *
*               if (c1l > l_max) { l_max = c1l; }                           *
*               if (c0l > l_max) { l_max = c0l; }                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the middle value of "h_min", "m_mid",      */      *
*               /*  "l_max" into "out".                             */      *
*               /* ------------------------------------------------ */      *
*               out = m_mid;                                                *
*                                                                           *
*               if (h_min > l_max) { t=h_min; h_min = l_max; l_max=t; }     *
*               if (h_min > out  ) { out = h_min; }                         *
*               if (out   > l_max) { out = l_max; }                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Store the resulting pixel.                      */      *
*               /* ------------------------------------------------ */      *
*               o_data[i] = out;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       This implementation uses an incremental sorting technique to        *
*       greatly reduce the number of compares and exchanges necessary       *
*       to sort the image pixels.                                           *
*                                                                           *
*       The main loop reads three new pixels from the input image each      *
*       iteration.  These three pixels form the right edge of the filter    *
*       mask.  The filter data from the previous iteration is "slid         *
*       over" by one pixel to form the complete 3x3 mask.                   *
*       For the first output pixel, two columns of input data outside the   *
*       input image are assumed to be all 127. See the C implementation for *
*       more details.                                                       *
*                                                                           *
*       As 3-pixel is read in from the image, the pixels are sorted,        *
*       resulting in a "lo", "medium" and "hi" pixel value for that         *
*       column.  The result is that the filter mask is sorted into          *
*       three rows -- a row of "minimums", a row of "middle values",        *
*       and a row of "maximums".                                            *
*                                                                           *
*       The median filter operates from this partially ordered mask.        *
*       It finds the smallest element in the row of "maximums",             *
*       the middle element in the row of "middle values", and               *
*       the largest element in the row of "minimums".  The median           *
*       value of these three values is the median for the entire 3x3        *
*       mask.                                                               *
*                                                                           *
*       This process minimizes compares, as the whole mask does not         *
*       need to be sorted between iterations.  Rather, the partial          *
*       ordering for two of the three columns from one iteration is         *
*       used directly for the next iteration.                               *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The length 'len' must be a multiple of four.                        *
*       No alignment is required.                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       No stack frame is used.                                             *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = len * 2 + 32.                                              *
*                                                                           *
*       For len =  64, cycles = 160.                                        *
*       For len = 256, cycles = 544.                                        *
*                                                                           *
*   CODESIZE                                                                *
*       248 bytes                                                           *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Knuth, Donald E.  The_Art_of_Computer_Programming, Vol 3,           *
*           Pg. 180:  "Minimum Comparison Sorting."                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_median_3x3"
        .global _IMG_median_3x3
_IMG_median_3x3:
*====================== SYMBOLIC REGISTER ASSIGNMENTS ======================*
        .asg   B15, B_SP            ;Stack pointer, B datapath
        .asg   B24, B_csr           ;CSR's value
        .asg   B25, B_no_gie        ;CSR w/ GIE bit cleared
        .asg   B3,  B_ret           ;Return address
        .asg   A0,  A_pro           ;prolog collapse counter
        .asg   B0,  B_pro           ;prolog collapse counter
        .asg   B4,  B_n             ;number of values in image width
        .asg   A27, A_two           ;const = 2
        .asg   B27, B_two           ;const = 2
        .asg   A4,  A_ptr_in        ;indata
        .asg   A6,  A_ptr_out       ;out data
        .asg   A3,  A_line0         ;line i
        .asg   B6,  B_line1         ;line i+1
        .asg   B5,  B_line2         ;line i+2
        .asg   A1,  A_i             ;loop count
        .asg   A5,  A_x01x00        ;existing data 2 pts row 0
        .asg   B21, B_x11x10        ;existing data 2 pts row 1
        .asg   B20, B_x21x20        ;existing data 2 pts row 2
        .asg   A18, A_x0_3210       ;4 new points row 0
        .asg   B4,  B_x1_3210       ;4 new points row 1
        .asg   B9,  B_x2_3210       ;4 new points row 2
        .asg   B22, B_d1_3210_a     ;intermediate values of
        .asg   B16, B_m1_3210_a     ;MAX operation bewteen
        .asg   B16, B_x1_3210_a0    ;x2_3210
        .asg   B8,  B_x1_3210_a1    ;and x1_3210
        .asg   B8,  B_x1_3210_a     ;max of x1,x2
        .asg   B7,  B_x2_3210_a     ;min of x1_3210 and x2_3210
        .asg   A4,  A_x0_3210_b     ;max of x0_3210,x1_3210_a
        .asg   A17, A_x1_3210_b     ;final max of new data
        .asg   B16, B_x1_3210_c     ;final med of new data
        .asg   B17, B_x2_3210_c     ;final min of new data
        .asg   A8,  A_max0_3210     ;transposed maximums
        .asg   A17, A_max1_3210     ;transposed maximums
        .asg   A8,  A_minmax_3210   ;minimum of maximums
        .asg   B19, B_min0_3210     ;transposed minimums
        .asg   B9,  B_min1_3210     ;transposed minimums
        .asg   A16, A_min2_3210     ;transposed minimums
        .asg   B18, B_maxmin_3210   ;partial maximum of mins
        .asg   A7,  A_maxmin_3210   ;maximum of mins
        .asg   B21, B_med0_3210     ;tranposed medians
        .asg   B20, B_med1_3210     ;tranposed medians
        .asg   B19, B_maxmed_3210_0 ;maximum of medians
        .asg   B17, B_minmed_3210_0 ;tmp minimum of medians
        .asg   B18, B_minmed_3210_1 ;minimum of medians
        .asg   B18, B_medmed_3210   ;median of medians
        .asg   A9,  A_maxa_3210     ;find block of
        .asg   A9,  A_mina_3210     ;medians
        .asg   A5,  A_minb_3210     ;from the medians
        .asg   A7,  A_d_med_3210    ;calculated for the new data
        .asg   A16, A_m_med_3210    ;using CMPGTU4 and XPND
        .asg   A9,  A_med_3210a     ;& and |.
        .asg   A4,  A_med_3210b     ;
        .asg   A9,  A_med_3210      ;final medians of the 3 3x3 blocks
*============================= PIPE LOOP PROLOG ===========================*
        MVC    .S2  CSR,            B_csr                        ;Get CSR state
        AND    .D2  B_csr,          -2,            B_no_gie      ;Clear GIE

        ADD    .L2X B_n,            A_ptr_in,      B_line1       ;line 1
||      MVC    .S2  B_no_gie,       CSR                          ;Disable intrpt
        ;INTERRUPTS MASKED HERE
        LDNW   .D2T2 *B_line1++,    B_x1_3210                    ;line 1 4 pts
||      ADD    .L2   B_line1,       B_n,           B_line2       ;line 2

        LDNW   .D2T2 *B_line2++,    B_x2_3210                    ;4 pts line 2
        MVK    .S2   2,             B_two                        ;const = 2
;-
        MVKLH  .S2   0x7f7f,        B_x11x10                     ;initial values
||      MVK    .S1   2,             A_two                        ;const = 2

        MVKLH  .S1   0x7f7f,        A_x01x00                     ;initial values
||      SHL    .S2   B_two,         14,            B_pro         ;prolog counter
||      ADD    .L1X  B_n,           8,             A_i           ;loop count

        MV     .L2   B_x11x10,      B_x21x20                     ;initial values
||      SHL    .S1   A_two,         13,            A_pro         ;prolog counter
||      MV     .D1   A_ptr_in,      A_line0                      ;line 0
*============================= PIPE LOOP KERNEL ===========================*
LOOP:
  [!A_pro]MINU4.L1X  A_maxmin_3210, B_medmed_3210, A_mina_3210   ;sort cols
||[!B_pro]SHLMB.S2   B_x11x10,      B_x1_3210_c,   B_med1_3210   ;transpose
||[!B_pro]MAXU4.L2   B_min0_3210,   B_min1_3210,   B_maxmin_3210 ;sort cols

  [!A_pro]CMPGTU4.S1 A_minb_3210,   A_mina_3210,   A_d_med_3210  ;sort cols
||[!B_pro]MVD  .M1   A_x0_3210_b,   A_x01x00                     ;feed back data
||[!B_pro]MAXU4.L2   B_med1_3210,   B_x1_3210_c,   B_maxmed_3210_0;sort cols
||[!B_pro]PACKLH2.S2 B_x1_3210_c,   B_x11x10,      B_med0_3210   ;transpose
||[!B_pro]MINU4.L1   A_max0_3210,   A_max1_3210,   A_minmax_3210 ;sort cols

  [ A_i]B      .S1   LOOP                                        ;(i=0;i<n;i++){
||[!A_pro]XPND4.M1   A_d_med_3210,  A_m_med_3210                 ;synthesize MAX
||[!B_pro]MVD  .M2   B_x2_3210_c,   B_x21x20                     ;feed back data
||[!B_pro]MINU4.L2   B_med1_3210,   B_x1_3210_c,   B_minmed_3210_0;sort cols
||      MINU4  .L1X  A_x0_3210,     B_x1_3210_a,   A_x1_3210_b   ;sort cols
||      CMPGTU4.S2   B_x2_3210,     B_x1_3210,     B_d1_3210_a   ;sort cols

  [!B_pro]MINU4.L2   B_med0_3210, B_maxmed_3210_0, B_minmed_3210_1;sort cols
||[!B_pro]MAXU4.L1X  B_maxmin_3210, A_min2_3210,   A_maxmin_3210 ;sort cols
||      XPND4  .M2   B_d1_3210_a,   B_m1_3210_a                  ;synthesize MAX
||[A_i] LDNW   .D2T2 *B_line1++,    B_x1_3210                    ;get next 4 pts
||[!A_i]RET    .S2   B_ret                                       ;return to call
|| [A_i]SUB    .D1   A_i,           4,             A_i           ;dec loop

  [!A_pro]ANDN .S1   A_mina_3210,   A_m_med_3210,  A_med_3210b   ;synthesize MAX
||[!A_pro]AND  .D1   A_minb_3210,   A_m_med_3210,  A_med_3210a   ;synthesize MAX
||[!B_pro]MVD  .M2   B_x1_3210_c,   B_x11x10                     ;feedback data
||[!B_pro]MAXU4.L2   B_minmed_3210_1,B_minmed_3210_0,B_medmed_3210;sort cols
||[!B_pro]MINU4.L1   A_minmax_3210, A_x0_3210_b,   A_minmax_3210 ;sort cols
||[A_i] LDNW   .D2T2 *B_line2++,    B_x2_3210                    ;get next 4 pts

        MPYU   .M1   A_two,         A_pro,         A_pro         ;proog count
||[!A_pro]OR   .S1   A_med_3210a,   A_med_3210b,   A_med_3210    ;synthesize MAX
||      MINU4  .L2X  B_x2_3210_a,   A_x1_3210_b,   B_x2_3210_c   ;sort cols
||      MAXU4  .L1X  A_x0_3210,     B_x1_3210_a,   A_x0_3210_b   ;sort cols
||      ANDN   .D2   B_x1_3210,     B_m1_3210_a,   B_x1_3210_a1  ;synthesize MAX
||      AND    .S2   B_x2_3210,     B_m1_3210_a,   B_x1_3210_a0  ;synthesize MAX
||[A_i] LDNW   .D1T1 *A_line0++,    A_x0_3210                    ;get next 4 pts

  [!A_pro]STNW .D1T1 A_med_3210,    *A_ptr_out++                 ;4 new med's
||[!B_pro]MAXU4.L1X  A_maxmin_3210, B_medmed_3210, A_maxa_3210   ;sort cols
||      PACKLH2.S2   B_x2_3210_c,   B_x21x20,      B_min0_3210   ;transpose
||      SHLMB  .S1   A_x01x00,      A_x0_3210_b,   A_max1_3210   ;transpose
||      MAXU4  .L2X  B_x2_3210_a,   A_x1_3210_b,   B_x1_3210_c   ;sort cols
||      OR     .D2   B_x1_3210_a0,  B_x1_3210_a1,  B_x1_3210_a   ;synthesize MAX
||      MPYU   .M2   B_two,         B_pro,         B_pro         ;pro cnt

  [!B_pro]MINU4.L1   A_minmax_3210, A_maxa_3210,   A_minb_3210   ;sort cols
||      MV     .D1X  B_x2_3210_c,   A_min2_3210                  ;feed back data
||      SHLMB  .S2   B_x21x20,      B_x2_3210_c,   B_min1_3210   ;transpose
||      PACKLH2.S1   A_x0_3210_b,   A_x01x00,      A_max0_3210   ;transpose
||      MINU4  .L2   B_x2_3210,     B_x1_3210,     B_x2_3210_a   ;get MIN
* =========================== PIPE LOOP EPILOG ============================ *
        MVC    .S2   B_csr,         CSR                          ;Restore CSR
* ===== Interruptibility state restored here ============================== *
        ;BRANCH OCCURS

* ========================================================================= *
*   End of file:  img_median_3x3.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mpeg2_vld0.asm/ 1066928952  0     0     0       49103     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:32:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_inter                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6400                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       23-May-2002                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine takes a bitstream of an MPEG-2 non-intra coded         *
*       macroblock and returns the decoded IDCT coefficients. The routine   *
*       is implemented as specified in the MPEG-2 standard text (ISO/IEC    *
*       13818-2). The routine checks the coded block pattern (cbp),         *
*       performs coefficient decoding inlcuding, variable length decode,    *
*       run-length expansion, inverse zigzag, dequantization, saturation    *
*       and mismatch control.                                               *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_mpeg2_vld_inter                                            *
*       (                                                                   *
*           const short    *restrict Wptr,                                  *
*           short          *restrict outi,                                  *
*           IMG_mpeg2_vld  *restrict Mpeg2v,                                *
*           int            mode_12Q4,                                       *
*           int            num_blocks,                                      *
*           int            bsbuf_words                                      *
*       );                                                                  *
*                                                                           *
*         Wptr:   Pointer to array that contains quantization matrix. The   *
*                 elements of the quantization matrix in *Wptr must be      *
*                 ordered according to the scan pattern used (zigzag or     *
*                 alternate scan). Video format 4:2:0 requires one          *
*                 quantization matrix (64 array elements).  For formats     *
*                 4:2:2 and 4:4:4 two quantization matrices (one for luma   *
*                 and one for chroma) must specified in the array (128      *
*                 array elements).                                          *
*                                                                           *
*         outi:   Pointer to the IDCT coefficients output array             *
*                 (6*64 elements), elements must be set to zero prior to    *
*                 function call.                                            *
*                                                                           *
*         Mpeg2v: Pointer to the context object containing the coding       *
*                 parameters of the MB to be decoded and the current state  *
*                 of the bitstream buffer. The structure is described       *
*                 below.                                                    *
*                                                                           *
*      mode_12Q4: 0: Coefficients are returned in normal 16-bit integer     *
*                 format.                                                   *
*                 Otherwise: Coefficients are returned in 12Q4 format       *
*                 (normal 16-bit integer format left shifted by 4). This    *
*                 mode is useful for directly passing the coefficients      *
*                 into the IMG_idct_8x8 routine.                            *
*                                                                           *
*     num_blocks: Number of blocks that the MB contains. Valid values are   *
*                 6 for 4:2:0, 8 for 4:2:2 and 12 for 4:4:4 format.         *
*                                                                           *
*    bsbuf_words: Size of bitstream buffer in words. Must be a power of 2.  *
*                 Bitstream buffer must be aligned at an address boundary   *
*                 equal to its size in bytes (bitstream buffer is           *
*                 addressed circularly by this routine.)                    *
*                                                                           *
*       The structure Mpeg2v is defined as follows:                         *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;    // reserved                        *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*       The Mpeg2v variables should  have a fixed layout since they are     *
*       accessed by this routine. If the layout is changed, the             *
*       corresponding changes have to be made in the assembly code too.     *
*                                                                           *
*       The routine sets the fault flag Mpeg2v.fault to 1 if an invalid     *
*       VLC code was encountered or the total run went beyond 63. In        *
*       theses cases the decoder has to resynchronize.                      *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v        *
*       have to be initialized. If bsbuf is a circular buffer and bsptr     *
*       contains the number of bits in the buffer that already have         *
*       been consumed, then next_wptr, bptr, word1, word2, top0 and         *
*       top1 are initialized as follows:                                    *
*                                                                           *
*       1. nextwptr: bsptr may not be a multiple of 32, therefore obtain    *
*       the next lower multiple of 32.                                      *
*                                                                           *
*           next_wptr = (bsptr >> 5);                                       *
*                                                                           *
*       2. bptr: bptr is the bit pointer which points to the current        *
*       bit WITHIN the word pointed to by next_wptr.                        *
*                                                                           *
*           bptr = bsptr & 31;                                              *
*           bptr_cmpl = 32 - bptr;                                          *
*                                                                           *
*       3. word1 and word2: read next 3 words from the bitstream buffer     *
*       (word0 is a temporary variable). bsbuf_words is the size of the     *
*       bitstream buffer in words.                                          *
*                                                                           *
*           word0 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word1 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word2 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*       4. top0 and top1: Shift words word0, word1, word2 by bptr to the    *
*       left so that the current bit becomes the MSB in word0. word0 can    *
*       simply be shifted by bptr; the then empty LSBs of word0 have to be  *
*       filled with the MSBs of word1. To do that the required MSBs are     *
*       brought into the position of empty LSBs of word0 by shifting word1  *
*       to the right by (32-bptr). The result is then copied into word0 by  *
*       an addition. Rather than overwriting word0, top0 is used to hold    *
*       the new bit aligned word. The same procedure is used to obtain      *
*       top1. top0 and top1 contain the next 64 bits of the bitstream.      *
*                                                                           *
*           s1 = word0 << bptr;                                             *
*           s2 = word1 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top0 = s1 + s2;                                                 *
*                                                                           *
*           s3 = word1 << bptr;                                             *
*           s4 = word2 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top1 = s3 + s4;                                                 *
*                                                                           *
*       Note that the routine returns the updated state of the bitstream    *
*       buffer variables, top0, top1, word1, word2, bptr and next_wptr. If  *
*       all other functions which access the bitstream in a decoder system  *
*       maintain the buffer variables in the same way, then the above       *
*       initialization procedure has to be performed only once at the       *
*       beginning.                                                          *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The instruction NORM is used to detect the number of leading zeros  *
*       or ones in a code word. This value together with additional bits    *
*       extracted from the codeword is then used as an index into look-up   *
*       tables to determine the length, run, level and sign. Escape code    *
*       sequences are directly extracted from the code word.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The bitstream must be stored in memory in 32-bit words which are    *
*       in little endian byte order.                                        *
*                                                                           *
*       Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 halfwords behind the weighting matrix should be      *
*       valid (e.g. peripherals). No memory is overwritten,                 *
*       only loads occurr.                                                  *
*                                                                           *
*       Note that the AMR register is set to zero on exit.                  *
*                                                                           *
*   NOTES                                                                   *
*       This code is little ENDIAN.                                         *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   MEMORY NOTES                                                            *
*       No bank conflicts                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       10 * (S - CB) + 37 * CB + 15 * NCB + 34                             *
*       where S:   Number of symbols in MB, CB: Number of coded blocks,     *
*             NCB: Number of not-coded blocks, and CB+NCB=6                 *
*                                                                           *
*   CODE SIZE                                                               *
*       1248 bytes                                                          *
*                                                                           *
*   MEMORY REQUIREMENTS                                                     *
*       1792 bytes for the lookup tables                                    *
*       (can be shared with mpeg2_vld_intra)                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ====================== *
        .asg            A0,         A_neg
        .asg            A1,         A_bptr1
        .asg            A1,         A_qw
        .asg            A1,         A_test1
        .asg            A1,         A_test2
        .asg            A16,        A_len_c
        .asg            A17,        A_bptr
        .asg            A18,        A_len_tbl_adr
        .asg            A19,        A_const31
        .asg            A2,         A_top0l
        .asg            A20,        A_const32
        .asg            A22,        A_const36
        .asg            A23,        A_qscl
        .asg            A24,        A_level4
        .asg            A24,        A_t2
        .asg            A24,        A_top0_bk
        .asg            A25,        A_empty
        .asg            A25,        A_len
        .asg            A26,        A_nrm
        .asg            A26,        A_t1l
        .asg            A26,        A_t4l
        .asg            A27,        A_t1h
        .asg            A27,        A_t4h
        .asg            A3,         A_top0h
        .asg            A4,         A_ptop0l
        .asg            A5,         A_level_f
        .asg            A5,         A_level5
        .asg            A5,         A_ptop0h
        .asg            A6,         A_W
        .asg            A7,         A_top1
        .asg            A8,         A_word1
        .asg            A9,         A_t3
        .asg            A9,         A_t7
        .asg            A9,         A_t8
        .asg            B0,         B_eob
        .asg            B1,         B_run
        .asg            B1,         B_test3
        .asg            B1,         B_12Q4      ; 12Q4 MERGE
        .asg            B16,        B_level2
        .asg            B16,        B_rld_left
        .asg            B17,        B_bptr_cmpl
        .asg            B17,        B_t14
        .asg            B17,        B_t9
        .asg            B19,        B_word2
        .asg            B20,        B_Wptr_end
        .asg            B21,        B_Zptr
        .asg            B22,        B_outi
        .asg            B23,        B_sum
        .asg            B24,        B_top0_bk
        .asg            B26,        B_level3
        .asg            B3,         B_const63
        .asg            B4,         B_rld_table_adr
        .asg            B5,         B_const32
        .asg            B6,         B_rld_table_adr_1
        .asg            B7,         B_bsbuf_circ
        .asg            B8,         B_Wptr
        .asg            B9,         B_level
        .asg            B9,         B_t12
        .asg            B9,         B_t13
        .asg            B9,         B_t15
        .asg            B9,         B_t16
        .asg            A11,        A_outi      ; 12Q4
        .asg            A12,        A_cnum      ; 12Q4
        .asg            A13,        A_const16   ; 12Q4
        .asg            B18,        B_constFFF0 ; 12Q4

* ========================================================================= *

        .global _IMG_len_tbl0
        .global _IMG_rld_table0

; Mpeg2v structure:
BSBUF_M2OFF      .set   0x0
NEXTWPTR_M2OFF   .set   0x1
BPTR_M2OFF       .set   0x2
WORD1_M2OFF      .set   0x3
WORD2_M2OFF      .set   0x4
TOP0_M2OFF       .set   0x5
TOP1_M2OFF       .set   0x6
ZPTR_M2OFF       .set   0x7
QSCL_M2OFF       .set   0x9
CBP_M2OFF        .set   0xB
FAULT_M2OFF      .set   0xC

        .sect ".text:_mpeg2_vld_inter"
        .global _IMG_mpeg2_vld_inter
_IMG_mpeg2_vld_inter:
; parameters: B_Wptr, B_outi, A_Mpeg2v, B_12Q4, A_num_blocks, B_bsbuf_words
;             A4,     B4,     A6,       B6,     A8,           B8

* ========================================================================= *
*  Setup
* ========================================================================= *
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A16,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
        .asg            A29,        A_Mpeg2v
        .asg            B18,        B_Mpeg2v
        .asg            B2,         B_cnt
        .asg            A10,        A_amr_arg            ; AMR arg
        .asg            B9,         B_amr_arg            ; AMR arg

        STW     .D2T1   A10,        *B_SP--[9]           ; RWD, MERGE, 2 W-mat
||      MVC     .S2     CSR,        B_csr                ; Get CSR's state
||      MV      .L2     B4,         B_outi
||      MV      .L1     A6,         A_Mpeg2v
||      MV      .S1X    B8,         A_amr_arg            ; AMR arg

        STW     .D2T2   B_csr,      *+B_SP[1]            ; Save CSR
||      AND     .L2     B_csr,      -2,         B_no_gie ; Clear GIE
||      MV      .S2X    A4,         B_Wptr
||      MV      .D1X    B_SP,       A_SP                 ; 12Q4 MERGE
||      LMBD    .L1     1,          A_amr_arg,  A_amr_arg; AMR arg
||      MVK     .S1     32,         A_const32            ; AMR arg

        STW     .D2T2   B_ret,      *+B_SP[2]            ; Save return addr.
||      STW     .D1T1   A14,        *+A_SP[6]            ; MERGE
||      MV      .L2X    A6,         B_Mpeg2v
||      MVC     .S2     B_no_gie,   CSR                  ; Disable ints.
||      SUB     .L1     A_const32,  A_amr_arg,  A_amr_arg; AMR arg
; ===== Interrupts masked here =====

* ========================================================================= *
*  Get bitstream info
*  Setup circuar bitstream buffer
*  Load table addresses and constants
*  Block loop setup
* ========================================================================= *
        .asg     B31,    B_bsbuf
        .asg     B29,    B_next_wptr
        .asg     B27,    B_cbp
        .asg     B0,     B0_amr_config
        .asg     A21,    A_const1
        .asg     A9,     A_tbs1
        .asg     A4,     A_tbs2
        .asg     B17,    B_tbs3
        .asg     B3,     B_const126
        .asg     B3,     B_const128
        .asg     A14,    A_constSHR                             ; 12Q4 MERGE

        LDW     .D2T2    *+B_Mpeg2v[BSBUF_M2OFF],      B_bsbuf
||      LDW     .D1T1    *+A_Mpeg2v[TOP0_M2OFF],       A_top0_bk
||      MVK     .S2      128,          B_const128
||      MV      .L2      B6,           B_12Q4                   ; 12Q4 MERGE

        LDW     .D2T2    *+B_Mpeg2v[NEXTWPTR_M2OFF],   B_next_wptr
||      LDW     .D1T1    *+A_Mpeg2v[TOP1_M2OFF],       A_top1
||      ADD     .L2      B_Wptr,       B_const128,     B_Wptr_end
||[!B_12Q4]MVK  .S1      20,           A_constSHR             ; non-12Q4 MERGE
||      SHL     .S2X     A_amr_arg,    16,             B_amr_arg; AMR arg

        LDW     .D1T1    *+A_Mpeg2v[BPTR_M2OFF],       A_bptr
||      STW     .D2T2    B_Wptr,         *+B_SP[7]              ; 2 W-mat
||      MV      .L2X     A8,             B_cnt                  ; 2 W-mat
||      SET     .S2      B_amr_arg, 14, 14,     B_amr_arg          ; AMR arg

        LDW     .D1T1    *+A_Mpeg2v[WORD1_M2OFF],      A_word1
||      LDW     .D2T2    *+B_Mpeg2v[WORD2_M2OFF],      B_word2
||      MVC     .S2      B_amr_arg,            AMR                 ; AMR arg
||      MVK     .S1      31,            A_const31

        LDW     .D1T1    *+A_Mpeg2v[QSCL_M2OFF],       A_qscl
||      LDW     .D2T2    *+B_Mpeg2v[CBP_M2OFF],        B_cbp
||[B_12Q4]MVK   .S1      16,           A_constSHR               ; 12Q4 MERGE
; B_constFFF0 and B_Mpeg2v share the same register

* ========================================================================= *
*  Setup bitstream pointers: top0h:top0l, top1 contain top bitstream
* ========================================================================= *
        .asg    B25,    B_word2_bk
        .asg    A28,    A_word1_bk
        .asg    A10,    A_word1_rw      ; RWD
        .asg    A21,    A_word1_rw_bk   ; RWD
        .asg    A31,    A_top0h_bk
        .asg    A30,    A_top0l_bk
        .asg    B28,    B_bptr_bk
        .asg    B30,    B_bsbuf_circ_bk

        SHL     .S1      A_top0_bk,     8,          A_tbs1
||      STW     .D2T1    A11,           *+B_SP[3]
||[B_12Q4]MVKL  .S2      0xFFF0,        B_constFFF0            ; 12Q4 MERGE

        SHRU    .S1      A_top1,        24,         A_tbs2
||      STW     .D2T1    A12,           *+B_SP[4]
||[!B_12Q4]MVKL .S2      0xFFFF,        B_constFFF0           ; non-12Q4 MERGE

        ADD     .L1      A_tbs1,        A_tbs2,     A_top0l_bk
||      ADD     .S1      A_bptr,        8,          A_bptr1
||      STW     .D2T1    A13,           *+B_SP[5]

        CMPGT   .L1      A_bptr1,       A_const31,  A_test2
||      AND     .S1      A_bptr1,       A_const31,  A_bptr
||      MVK     .S2      32,            B_const32
||      ADDAW   .D2      B_bsbuf,       B_next_wptr,B_bsbuf_circ

  [A_test2]MV   .S1      A_word1,                   A_word1_rw  ; RWD
||[A_test2]MV   .L1X     B_word2,                   A_word1
||[A_test2]LDW  .D2T2    *B_bsbuf_circ++,           B_word2
||      SUB     .S2      B_const32,     A_bptr,     B_bptr_cmpl

        MVKL    .S1      _IMG_len_tbl0,     A_len_tbl_adr
||      MVKL    .S2      _IMG_rld_table0,   B_rld_table_adr
||      MV      .L2X     A_bptr,        B_bptr_bk
||      STW     .D2T2    B_cnt,         *+B_SP[8]               ; 2 W-mat

        MVKH    .S1      _IMG_len_tbl0,     A_len_tbl_adr
||      MVKH    .S2      _IMG_rld_table0,   B_rld_table_adr

 [B_12Q4]MVK   .S1      16,            A_const16               ; 12Q4

 [!B_12Q4]MVK   .S1      1,             A_const16              ; non-12Q4

        SHL     .S1      A_word1,       A_bptr,     A_tbs1
||      SHRU    .S2      B_word2,       B_bptr_cmpl,B_tbs3

        ADD     .L1X     A_tbs1,        B_tbs3,     A_top1
||      SHRU    .S1      A_top0_bk,     24,         A_top0h_bk
||      MV      .D1      A_word1,       A_word1_bk
||      MV      .D2      B_word2,       B_word2_bk
||      MV      .L2      B_bsbuf_circ,  B_bsbuf_circ_bk


block_loop:
* ------------------------------------------------------------------------- *
*  check cbp, etc.
* ------------------------------------------------------------------------- *
        .asg     B17,     B_cbp_mask
        .asg     B0,      B_coded
        .asg     A5,      A_last_coeff
        .asg     A2,      A2_odd
        .asg    B31,      B_run_bk
        .asg    B26,      B_num_blocks                        ; 2 W-mat

            SUB   .S2     B_cnt,        1,        B_cnt       ; cbp, cnt--
||          ZERO  .L2     B_sum
||          ZERO  .D2     B_run_bk                            ; not coded
||          ZERO  .L1     A2_odd                              ; not coded
||          MVK   .S1     1,            A_const1              ; cbp

            SHL   .S2X    A_const1,     B_cnt,    B_cbp_mask  ; cbp
||          MV    .L2     B_Wptr_end,   B_Wptr                ; not coded
||          MVK   .S1     0,            A_last_coeff          ; not coded

            AND   .D2     B_cbp_mask,   B_cbp,    B_coded     ; cbp
||          MVK   .S2     126,          B_const126            ; const

  [!B_coded]B     .S1     mismatch                            ; not coded
||[!B_coded]ADD   .L2     B_outi,       B_const126, B_outi    ; not coded
||[B_coded]LDW  .D2T2   *+B_SP[8],      B_num_blocks          ; 2 W-mat

* =========================== PIPE LOOP PROLOG ============================ *
        .asg     A0,      A_tm
        .asg     B0,      B_tm_neg

; the added lines below calculate cc which is required for weighting
; matrix selection in 4:2:2 and 4:4:4 mode
; the following additional registers are required: B_block, B_flag, B_cc
        .asg    B31,      B_block
        .asg    B1,       B_cc
        .asg    B0,       B_flag

        NORM    .L1     A_top0h_bk:A_top0l_bk,  A_nrm           ;[ 1,1]
||      SHRU    .S1     A_top0h_bk,     7,      A_tm            ;table mod

        MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,1]
||      SHL     .S1     A_top0h_bk:A_top0l_bk,  A_nrm, A_t1h:A_t1l;[ 2,1]

        MVK     .S1     36,             A_const36               ;const

        SHRU    .S1     A_t1h:A_t1l,    A_const36,  A_t4h:A_t4l ;[ 4,1]
||      SUB     .L1     A_len_tbl_adr,  A_t2,       A_t3        ;[ 4,1]
||[B_coded]LDW  .D2T2   *+B_SP[7],      B_Wptr             ;get W-mat base adr

  [!A_tm]LDBU   .D1T1   *A_t3[A_t4l],   A_len                   ;[ 5,1]
||[B_coded] SUB .L2     B_num_blocks,   1,          B_num_blocks;2 W-mat
; branch occurs if not coded MB

        SUB     .S2     B_num_blocks,   B_cnt,      B_block    ;cc for 2 W-mat
||      CMPGT   .L2     B_num_blocks,   6,          B_flag
;prevent 2 W-mat if 4:2:0

        SHRU    .S1     A_top0h_bk:A_top0l_bk, 8, A_empty:A_top0_bk;[ 8,1]
||[B_flag]CMPGT .L2     B_block,        3,          B_flag     ;cc for 2 W-mat
||      ZERO    .S2     B_cc                                   ;cc for 2 W-mat

  [A_tm]MVK     .L1     2,          A_len                      ;table mod
||[B_flag] AND  .D2     B_block,        1,          B_cc       ;cc for 2 W-mat

        MV      .L1X    B_bptr_bk,  A_bptr                     ;restore
||      MVK     .S2     128,         B_const128                ;const
||[B_flag] ADD  .D2     B_cc,           1,          B_cc       ;cc for 2 W-mat

        SUB     .S2X    A_len,      5,          B_rld_left      ;[10,1]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,1]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,1]
||      SHL     .S1     A_top0h_bk:A_top0l_bk,  A_len, A_ptop0h:A_ptop0l;[10,1]
||[!A_tm]SUB    .D1     A_const32,  A_len,      A_len_c         ;[10,1]
||[B_cc]ADD     .D2     B_Wptr,     B_const128, B_Wptr
;if cc!=0 select 2nd W-mat

  [B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,1]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,1]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,1]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,1]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,2]

        CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,1]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,2]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,2]
||      ADD     .L2     B_Wptr,      B_const128, B_Wptr_end     ;reset

        SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,1]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,1]
||[A_tm]MVK     .S1     30,                     A_len_c         ;table mod
||      MV      .L1     A_word1_bk,  A_word1                    ;restore
||      MV      .L2     B_word2_bk,  B_word2                    ;restore
||      MV      .D2     B_bsbuf_circ_bk, B_bsbuf_circ           ;restore

        SHRU    .S2     B_t13,      27,         B_t14           ;[14,1]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,1]
||      SHRU    .S1     A_t1h:A_t1l,            A_const36,  A_t4h:A_t4l ;[ 4,2]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,2]

        ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,1]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,1]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,1]
|| [A_test2]MV  .S1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,2]
||      ZERO    .D2     B_tm_neg                                ;table mod

        ADD     .L2     B_t15,      B_t15,      B_t16           ;[16,1]
||[!A_tm]SUB    .D1     A_len,      24,         A_test1         ;[16,1]
||[A_tm]ZERO    .L1     A_test1                                 ;table mod
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,1]
||[A_tm]EXTU    .S2     B_top0_bk,  1, 31,      B_tm_neg        ;table mod

  [ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,1]
||      ADD     .D1     A_ptop0l,   A_t7,       A_top0l         ;[17,1]
||      ADD     .L2     B_rld_table_adr,     1, B_rld_table_adr_1;const
||[A_tm]MVK     .S2     1,          B_level                     ;table mod

  [ A_test1]LDB .D2T2   *B_rld_table_adr_1[B_t16], B_run        ;[18,1]
||[!A_tm]EXT    .S2     B_top0_bk,  12, 20,    B_level          ;[18,1]
||      SHRU    .S1     A_top0h:A_top0l, 8,    A_empty:A_top0_bk;[ 8,2]
||[B_tm_neg]NEG .L2     B_level,    B_level                     ;table mod

        SHRU    .S2     B_word2,    B_bptr_cmpl,B_t9            ;[19,1]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[19,1]

        SUB     .S2X    A_len,      5,          B_rld_left      ;[10,2]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,2]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,2]
||      SHL     .S1     A_top0h:A_top0l, A_len, A_ptop0h:A_ptop0l;[10,2]
||      SUB     .D1     A_const32,  A_len,      A_len_c         ;[10,2]

  [!A_tm]EXTU   .S2     B_top0_bk,  6,  26,     B_run           ;[21,1]
||[A_tm] ZERO   .D2     B_run                                   ;table mod
||[B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,2]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,2]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,2]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,2]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,3]

        MPY     .M2     B_level,    2,          B_level2        ;[22,1]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,2]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,3]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,3]
||      LDW     .D1T2   *+A_Mpeg2v[ZPTR_M2OFF], B_Zptr          ;reset
||      MVK     .S2     63,         B_const63                   ;const

        LDH     .D2T1   *++B_Wptr[B_run],       A_W             ;[23,1]
||      CMPLT   .L1X    B_level,    0,          A_neg           ;[23,1]
||      SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,2]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,2]

        ADD     .L2     B_Wptr,     2,          B_Wptr          ;[24,1]
||      ADD     .D1X    A_t8,       B_t9,       A_top1          ;[24,1]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[14,2]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,2]
||      SHRU    .S1     A_t1h:A_t1l,            A_const36,  A_t4h:A_t4l;[ 4,3]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,3]

  [ A_neg]SUB   .D2     B_level2,   1,          B_level3        ;[25,1]
||      ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,2]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,2]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,2]
|| [A_test2]MV  .S1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,3]

  [!A_neg]ADD   .L2     B_level2,   1,          B_level3        ;[26,1]
||      ADD     .S2     B_t15,      B_t15,      B_t16           ;[16,2]
||      SUB     .D1     A_len,      24,         A_test1         ;[16,2]
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,2]

        CMPGT   .L2     B_run,      B_const63,  B_eob           ;[27,1]
||[ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,2]
||      ADD     .D1     A_ptop0l,   A_t7,       A_top0l         ;[17,2]
||      MV      .L1X    B_outi,     A_outi                      ; 12Q4

* =========================== PIPE LOOP KERNEL ============================ *
        .asg    A2,     A2_top0l

loop:
        MPY     .M1     A_qscl,     A_W,        A_qw            ;[28,1]
||[!B_eob]CMPGT .L2     B_Wptr,     B_Wptr_end, B_eob           ;[28,1]
||[A_test1]LDB  .D2T2   *B_rld_table_adr_1[B_t16],      B_run   ;[18,2]
||      EXT     .S2     B_top0_bk,  12, 20,    B_level          ;[18,2]
||      SHRU    .S1     A_top0h:A_top0l, 8,    A_empty:A_top0_bk;[ 8,3]
||[B_eob]MPY    .M2     0,          B_Wptr,     B_Wptr          ;err det

        LDB     .D2T1   *++B_Zptr[B_run],       A_cnum          ;[29,1]
||      SHRU    .S2     B_word2,    B_bptr_cmpl,B_t9            ;[19,2]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[19,2]
||[!B_eob]MV    .L1     A_top0h:A_top0l, A_top0h_bk:A_top0l_bk  ;preserve
||[B_eob]ADD    .L2     B_outi,     B_const63,  B_outi          ;mismatch
||[!B_eob]MPY   .M2X    1,          A_bptr,     B_bptr_bk       ;preserve

        ADD     .D2     B_Zptr,     1,          B_Zptr          ;[30,1]
||      MPY     .M1X    A_qw,       B_level3,   A_level4        ;[30,1]
||      SUB     .S2X    A_len,      5,          B_rld_left      ;[10,3]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,3]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,3]
||      SHL     .S1     A_top0h:A_top0l, A_len, A_ptop0h:A_ptop0l;[10,3]
||      SUB     .D1     A_const32,  A_len,      A_len_c         ;[10,3]
||[B_eob]MPY    .M2     1,          B_run,      B_run_bk        ;preserve

        EXTU    .S2     B_top0_bk,  6,  26,     B_run           ;[21,2]
||[B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,3]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,3]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,3]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,3]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,4]
||[B_eob]ADD    .D2     B_outi,     B_const63,  B_outi          ;mismatch

  [!B_eob]B     .S2     loop                                    ;[32,1]
||[ A_neg]ADD   .D1     A_level4,   A_const31,  A_level4        ;[32,1]
||      MPY     .M2     B_level,    2,          B_level2        ;[22,2]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,3]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,4]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,4]
||[!B_eob]MV    .L2     B_bsbuf_circ,      B_bsbuf_circ_bk      ;preserve
||[B_eob]LDH    .D2T1   *B_outi,    A_last_coeff                ;mismatch

        SSHL    .S1     A_level4,   15,         A_level5        ;[33,1]
||[!B_eob]LDH   .D2T1   *++B_Wptr[B_run],       A_W             ;[23,2]
||      CMPLT   .L1X    B_level,    0,          A_neg           ;[23,2]
||      SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,3]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,3]
||[!B_eob]MV    .L2     B_word2,    B_word2_bk                  ;preserve
||[!B_eob]MV    .D1     A_word1,    A_word1_bk                  ;preserve
||[!B_eob]MVD   .M1     A_word1_rw, A_word1_rw_bk               ;preserve

  [!B_eob]ADD   .L2     B_Wptr,     2,          B_Wptr          ;[24,2]
||[!B_eob]ADD   .D1X    A_t8,       B_t9,       A_top1          ;[24,2]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[14,3]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,3]
||      SHRU    .S1     A_t1h:A_t1l, A_const36, A_t4h:A_t4l     ;[ 4,4]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,4]

        SHR     .S1     A_level5,   A_constSHR, A_level_f       ;[35,1] 12Q4
||[ A_neg]SUB   .D2     B_level2,   1,          B_level3        ;[25,2]
||      ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,3]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,3]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,3]
|| [A_test2]MVD .M1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,4]

  [!A_neg]ADD   .L2     B_level2,   1,          B_level3        ;[26,2]
||      ADD     .S2     B_t15,      B_t15,      B_t16           ;[16,3]
||      SUB     .D1     A_len,      24,         A_test1         ;[16,3]
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,3]
||[!B_eob]AND   .L1X    B_constFFF0,A_level_f,  A_level_f       ; 12Q4

  [!B_eob]STH   .D1T1   A_level_f,  *+A_outi[A_cnum]            ;[36,1] BC
||[!B_eob]ADD   .S2X    B_sum,      A_level_f,  B_sum           ;[37,1]
||        CMPGT .L2     B_run,      B_const63,  B_eob           ;[27,2]
||[ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,3]
||[!B_eob]ADD   .L1     A_ptop0l,   A_t7,       A2_top0l        ;[17,3]
||[B_eob] XOR   .S1     A_const16,  A_last_coeff, A_last_coeff  ;mismatch 12Q4
||[B_eob] MVD   .M1     A_word1_rw_bk,          A_word1_rw      ; RWD

* =========================== PIPE LOOP EPILOG ============================ *
* ========================================================================= *
; live-out: top0h:top0k, top1, word1, word2, bsbuf_circ, run, Wptr, Wptr_end,
;           sum, bptr

    .asg    B0,     B_err       ; same reg as B_eob
    .asg    A29,    A_Mpeg2v
    .asg    B31,    B_bsbuf
    .asg    B3,     B_ret       ; Return address
    .asg    B15,    B_SP        ; Stack pointer, B datapath
    .asg    B1,     B_const65

mismatch:
 [B_cnt] B       .S1     block_loop                             ; -- BRANCH --
||       MVK     .S2     65,           B_const65                ; invalid VLC
||       CMPGTU  .L2     B_Wptr,       B_Wptr_end, B_err        ; overrun
||       AND     .L1X    A_const16,    B_sum,      A2_odd       ; mismatch 12Q4

 [!B_err]CMPGT   .L2     B_run_bk,     B_const65,  B_err        ; invalid VLC
||       ADD     .S2     B_outi,       2,          B_outi
||       LDW     .D1T2   *+A_Mpeg2v[BSBUF_M2OFF],  B_bsbuf      ; exit
||[!A2_odd]STH   .D2T1   A_last_coeff, *B_outi                  ; mismatch

  [B_err]B       .S2     exit                                   ; -- BRANCH --
||       LDW     .D2T2   *+B_SP[2],    B_ret                    ; exit
||       MV      .L2     B_bsbuf_circ_bk, B_bsbuf_circ          ; AMR arg

         NOP             3                                      ; MERGE
; branch occurs to block_loop
; branch occurs to exit occurs after 2 cycles in block_loop
; (preserve B0_err for exit)

; this will execute only if B_cnt was 0
        NOP              2                                      ; MERGE

* =================================== EXIT =============================== *
        .asg            B26,        B_csr        ; CSR value to restore
        .asg            B22,        B_byte_diff
        .asg            B29,        B_next_wptr
        .asg            B1,         B_lz
        .asg            B27,        B_amr_config
        .asg            B4,         B_constBUFMASK

exit:
        SUB     .L2      B_bsbuf_circ,  B_bsbuf, B_byte_diff
||      SHRU    .S1      A_top1,        8,         A_t2
||      SUB     .S2      B_bptr_bk,     8,         B_bptr_bk
||      LDW     .D2T1    *+B_SP[6],     A14                     ; MERGE

        SHR     .S2      B_byte_diff,   2,         B_next_wptr
||      SHL     .S1      A_top0l_bk,    24,        A_t3
||      CMPLT   .L2      B_bptr_bk,     0,         B_lz
||      LDW     .D2T1    *+B_SP[3],     A11

        ADD     .L1      A_t2,          A_t3,      A_top1
||      SHRU    .S1      A_top0h_bk:A_top0l_bk, 8, A_empty:A_top0_bk
||      STW     .D1T2    B_err,      *+A_Mpeg2v[FAULT_M2OFF]
||[B_lz]MVD     .M1      A_word1_rw,               A_word1_bk   ; RWD
||[B_lz]MV      .L2X     A_word1_bk,               B_word2_bk
||      LDW     .D2T1    *+B_SP[4],     A12

        LDW     .D2T2    *+B_SP[1],     B_csr       ; Get CSR's value
||      STW     .D1T1    A_top1,        *+A_Mpeg2v[TOP1_M2OFF]
||[B_lz]ADD     .L2      B_bptr_bk,     A_const32, B_bptr_bk

        STW     .D1T2    B_bptr_bk,     *+A_Mpeg2v[BPTR_M2OFF]
||      LDW     .D2T1    *+B_SP[5],     A13

        RET     .S2      B_ret                      ; Return to caller
||      STW     .D1T1    A_top0_bk,     *+A_Mpeg2v[TOP0_M2OFF]
||[B_lz]SUBAW   .D2      B_bsbuf_circ,  1, B_bsbuf_circ       ; AMR arg

        STW     .D1T2    B_next_wptr,   *+A_Mpeg2v[NEXTWPTR_M2OFF]
||      ZERO    .L2      B_amr_config
||      LDW     .D2T1    *++B_SP[9],    A10                   ; MERGE, 2 W-mat
||[B_lz]SUB     .S2      B_bsbuf_circ,  B_bsbuf, B_byte_diff  ; AMR arg

        STW     .D1T1    A_word1_bk,    *+A_Mpeg2v[WORD1_M2OFF]
||[B_lz]SHR     .S2      B_byte_diff,   2,         B_next_wptr ; AMR arg

        STW     .D1T2    B_word2_bk,    *+A_Mpeg2v[WORD2_M2OFF]
;  ===== Interruptibility state restored here =====

        STW     .D1T2    B_next_wptr,   *+A_Mpeg2v[NEXTWPTR_M2OFF]
||      MVC     .S2      B_amr_config,  AMR

        MVC     .S2      B_csr,         CSR           ; Restore CSR
; Branch occurs

* ========================================================================= *
*   End of file:   img_mpeg2_vld_inter.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mpeg2_vld1.asm/ 1066928952  0     0     0       57049     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.16    Sun Sep 29 03:32:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_intra                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6400                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       22-May-2002                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine takes a bitstream of an MPEG-2 intra coded macroblock  *
*       and returns the decoded IDCT coefficients. The routine is           *
*       implemented as specified in the MPEG-2 standard text (ISO/IEC       *
*       13818-2). The routine checks the coded block pattern (cbp),         *
*       performs DC and AC decoding inlcuding, variable length decode,      *
*       run-length expansion, inverse zigzag, dequantization, saturation    *
*       and mismatch control.                                               *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_mpeg2_vld_intra                                            *
*       (                                                                   *
*           const short    *restrict Wptr,                                  *
*           short          *restrict outi,                                  *
*           IMG_mpeg2_vld  *restrict Mpeg2v,                                *
*           int            dc_pred[3],                                      *
*           int            mode_12Q4,                                       *
*           int            num_blocks,                                      *
*           int            bsbuf_words                                      *
*       );                                                                  *
*                                                                           *
*         Wptr:   Pointer to array that contains quantization matrix. The   *
*                 elements of the quantization matrix in *Wptr must be      *
*                 ordered according to the scan pattern used (zigzag or     *
*                 alternate scan). Video format 4:2:0 requires one          *
*                 quantization matrix (64 array elements).  For formats     *
*                 4:2:2 and 4:4:4 two quantization matrices (one for luma   *
*                 and one for chroma) must specified in the array (128      *
*                 array elements).                                          *
*                                                                           *
*         outi:   Pointer to the IDCT coefficients output array             *
*                 (6*64 elements), elements must be set to zero prior to    *
*                 function call.                                            *
*                                                                           *
*         Mpeg2v: Pointer to the context object containing the coding       *
*                 parameters of the MB to be decoded and the current state  *
*                 of the bitstream buffer. The structure is described       *
*                 below.                                                    *
*                                                                           *
*        dc_pred: Intra DC prediction array, the first element of dc_pred   *
*                 is the DC prediction for Y, the second for Cr and the     *
*                 third for Cb.                                             *
*                                                                           *
*      mode_12Q4: 0: Coefficients are returned in normal 16-bit integer     *
*                 format.                                                   *
*                 Otherwise: Coefficients are returned in 12Q4 format       *
*                 (normal 16-bit integer format left shifted by 4). This    *
*                 mode is useful for directly passing the coefficients      *
*                 into the IMG_idct_8x8 routine.                            *
*                                                                           *
*     num_blocks: Number of blocks that the MB contains. Valid values are   *
*                 6 for 4:2:0, 8 for 4:2:2 and 12 for 4:4:4 format.         *
*                                                                           *
*    bsbuf_words: Size of bitstream buffer in words. Must be a power of 2.  *
*                 Bitstream buffer must be aligned at an address boundary   *
*                 equal to its size in bytes (bitstream buffer is           *
*                 addressed circularly by this routine.)                    *
*                                                                           *
*       The structure Mpeg2v is defined as follows:                         *
*                                                                           *
*C        #ifndef IMG_MPEG2_VLD_STRUCT_                                     *
*C        #define IMG_MPEG2_VLD_STRUCT_ 1                                   *
*C                                                                          *
*C        typedef struct {                                                  *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;    // reserved                        *
*C        } IMG_mpeg2_vld;                                                  *
*C                                                                          *
*C        #endif                                                            *
*                                                                           *
*       The Mpeg2v variables should have a fixed layout since they are      *
*       accessed by this routine.  If the layout is changed, the            *
*       corresponding changes have to be made in the assembly code too.     *
*                                                                           *
*       The routine sets the fault flag Mpeg2v.fault to 1 if an invalid     *
*       VLC code was encountered or the total run went beyond 63. In        *
*       theses cases the decoder has to resynchronize.                      *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream variables in Mpeg2v        *
*       have to be initialized. If bsbuf is a circular buffer and bsptr     *
*       contains the number of bits in the buffer that already have         *
*       been consumed, then next_wptr, bptr, word1, word2, top0 and         *
*       top1 are initialized as follows:                                    *
*                                                                           *
*       1. nextwptr: bsptr may not be a multiple of 32, therefore obtain    *
*       the next lower multiple of 32.                                      *
*                                                                           *
*           next_wptr = (bsptr >> 5);                                       *
*                                                                           *
*       2. bptr: bptr is the bit pointer which points to the current        *
*       bit WITHIN the word pointed to by next_wptr.                        *
*                                                                           *
*           bptr = bsptr & 31;                                              *
*           bptr_cmpl = 32 - bptr;                                          *
*                                                                           *
*       3. word1 and word2: read next 3 words from the bitstream buffer     *
*       (word0 is a temporary variable). bsbuf_words is the size of the     *
*       bitstream buffer in words.                                          *
*                                                                           *
*           word0 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word1 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word2 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*       4. top0 and top1: Shift words word0, word1, word2 by bptr to the    *
*       left so that the current bit becomes the MSB in word0. word0 can    *
*       simply be shifted by bptr; the then empty LSBs of word0 have to be  *
*       filled with the MSBs of word1. To do that the required MSBs are     *
*       brought into the position of empty LSBs of word0 by shifting word1  *
*       to the right by (32-bptr). The result is then copied into word0 by  *
*       an addition. Rather than overwriting word0, top0 is used to hold    *
*       the new bit aligned word. The same procedure is used to obtain      *
*       top1. top0 and top1 contain the next 64 bits of the bitstream.      *
*                                                                           *
*           s1 = word0 << bptr;                                             *
*           s2 = word1 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top0 = s1 + s2;                                                 *
*                                                                           *
*           s3 = word1 << bptr;                                             *
*           s4 = word2 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top1 = s3 + s4;                                                 *
*                                                                           *
*       Note that the routine returns the updated state of the bitstream    *
*       buffer variables, top0, top1, word1, word2, bptr and next_wptr. If  *
*       all other functions which access the bitstream in a decoder system  *
*       maintain the buffer variables in the same way, then the above       *
*       initialization procedure has to be performed only once at the       *
*       beginning.                                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*       The instruction NORM is used to detect the number of leading zeros  *
*       or ones in a code word. This value together with additional bits    *
*       extracted from the codeword is then used as an index into look-up   *
*       tables to determine the length, run, level and sign. Escape code    *
*       sequences are directly extracted from the code word.                *
*                                                                           *
*       DC coefficients are decoded without lookup tables by exploiting     *
*       the relatively simple relationship between the number of leading    *
*       zeros and dc_size and the length of the code word.                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The bitstream must be stored in memory in 32-bit words which are    *
*       in little endian byte order.                                        *
*                                                                           *
*       Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 halfwords behind the weighting matrix should be      *
*       valid (e.g. peripherals). No memory is overwritten,                 *
*       only loads occurr.                                                  *
*                                                                           *
*       Note that the AMR register is set to zero on exit.                  *
*                                                                           *
*   NOTES                                                                   *
*       This code is little ENDIAN.                                         *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   MEMORY NOTES                                                            *
*       No bank conflicts                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       10 * (S - CB) + 55 * CB + 15 * NCB + 35                             *
*       where S:   Number of symbols in MB, CB: Number of coded blocks,     *
*             NCB: Number of not-coded blocks, and CB+NCB=6                 *
*                                                                           *
*   CODE SIZE                                                               *
*       1508 bytes                                                          *
*                                                                           *
*   DATA SIZE                                                               *
*       3584 bytes for the lookup tables                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ====================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_neg
        .asg            A1,         A_bptr1
        .asg            A1,         A_qw
        .asg            A1,         A_test1
        .asg            A1,         A_test2
        .asg            A14,        A_constSHR      ; 12Q4 MERGE
        .asg            A16,        A_len_c
        .asg            A17,        A_bptr
        .asg            A18,        A_len_tbl_adr
        .asg            A19,        A_const31
        .asg            A2,         A_top0l
        .asg            A20,        A_const32
        .asg            A22,        A_const36
        .asg            A23,        A_qscl
        .asg            A24,        A_level4
        .asg            A24,        A_t2
        .asg            A24,        A_top0_bk
        .asg            A25,        A_empty
        .asg            A25,        A_len
        .asg            A26,        A_nrm
        .asg            A26,        A_t1l
        .asg            A26,        A_t4l
        .asg            A27,        A_t1h
        .asg            A27,        A_t4h
        .asg            A3,         A_top0h
        .asg            A4,         A_ptop0l
        .asg            A5,         A_level5
        .asg            A5,         A_level_f
        .asg            A5,         A_ptop0h
        .asg            A6,         A_W
        .asg            A7,         A_top1
        .asg            A8,         A_word1
        .asg            A9,         A_t3
        .asg            A9,         A_t7
        .asg            A9,         A_t8
        .asg            B0,         B_eob
        .asg            B1,         B_run
        .asg            B1,         B_test3
        .asg            B16,        B_level2
        .asg            B16,        B_rld_left
        .asg            B17,        B_bptr_cmpl
        .asg            B17,        B_t14
        .asg            B17,        B_t9
        .asg            B18,        B_cnum
        .asg            B19,        B_word2
        .asg            B2,         B_cnt
        .asg            B20,        B_Wptr_end
        .asg            B21,        B_Zptr
        .asg            B22,        B_outi
        .asg            B23,        B_sum
        .asg            B24,        B_top0_bk
        .asg            B26,        B_level3
        .asg            B3,         B_const63
        .asg            B4,         B_rld_table_adr
        .asg            B5,         B_const32
        .asg            B6,         B_rld_table_adr_1
        .asg            B7,         B_bsbuf_circ
        .asg            B8,         B_Wptr
        .asg            B9,         B_level
        .asg            B9,         B_t12
        .asg            B9,         B_t13
        .asg            B9,         B_t15
        .asg            B9,         B_t16
        .asg            A11,        A_outi      ; 12Q4
        .asg            A12,        A_cnum      ; 12Q4
        .asg            A13,        A_const16   ; 12Q4
        .asg            B18,        B_constFFF0 ; 12Q4
        .asg            A2,         A_12Q4      ; 12Q4 MERGE
* ========================================================================= *

        .global _IMG_len_tbl0
        .global _IMG_rld_table0
        .global _IMG_len_tbl1
        .global _IMG_rld_table1

; Mpeg2v structure:
BSBUF_M2OFF      .set   0x0
NEXTWPTR_M2OFF   .set   0x1
BPTR_M2OFF       .set   0x2
WORD1_M2OFF      .set   0x3
WORD2_M2OFF      .set   0x4
TOP0_M2OFF       .set   0x5
TOP1_M2OFF       .set   0x6
ZPTR_M2OFF       .set   0x7
FORMAT_M2OFF     .set   0x8
QSCL_M2OFF       .set   0x9
DCPREC_M2OFF     .set   0xA
CBP_M2OFF        .set   0xB
FAULT_M2OFF      .set   0xC

        .sect ".text:_mpeg2_vld_intra"
        .global _IMG_mpeg2_vld_intra
_IMG_mpeg2_vld_intra:
; parameters: B_Wptr, B_outi, A_Mpeg2v, B_dc_pred, A_12Q4, B_num_blocks, A_bsbuf_words
;             A4,     B4,     A6,       B6,        A8,     B8,           A10

* ========================================================================= *
*  Setup
* ========================================================================= *
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
        .asg            A29,        A_Mpeg2v
        .asg            B18,        B_Mpeg2v
        .asg            B14,        B_dc_pred
        .asg            A10,        A_amr_arg            ; AMR arg
        .asg            A3,         A_const32            ; AMR arg

        STW     .D2T1   A10,        *B_SP--[10]          ; RWD, 2 W-mat
||      MVC     .S2     CSR,        B_csr                ; Get CSR's state
||      MV      .L2     B4,         B_outi
||      MV      .L1     A6,         A_Mpeg2v
||      MV      .D1     A8,         A_12Q4               ; 12Q4 MERGE

        STW     .D2T2   B_csr,      *+B_SP[3]            ; Save CSR
||      AND     .L2     B_csr,      -2,         B_no_gie ; Clear GIE
||      MV      .S2     B8,         B_cnt                ; 2 W-mat
||      LMBD    .L1     1,          A_amr_arg,  A_amr_arg; AMR arg
||      MVK     .S1     32,         A_const32            ; AMR arg

        STW     .D2T2   B14,        *+B_SP[1]
||      MV      .S2X    A6,         B_Mpeg2v
||      SUB     .L1     A_const32,  A_amr_arg,  A_amr_arg; AMR arg

        STW     .D2T2   B_ret,      *+B_SP[2]            ; Save return addr.
||      MVC     .S2     B_no_gie,   CSR                  ; Disable ints.
||      MV      .L2X    A4,         B_Wptr               ; 2 W-mat
||      SHL     .S1     A_amr_arg,  16,         A_amr_arg; AMR arg
; ===== Interrupts masked here =====

* ========================================================================= *
*  Get bitstream info
*  Setup circuar bitstream buffer
*  Load table addresses and constants
*  Block loop setup
* ========================================================================= *
        .asg     B31,    B_bsbuf
        .asg     B29,    B_next_wptr
        .asg     B27,    B_cbp
        .asg     B0,     B0_amr_config
        .asg     A21,    A_const1
        .asg     A9,     A_tbs1
        .asg     A4,     A_tbs2
        .asg     B17,    B_tbs3
        .asg     B3,     B_const126
        .asg     B3,     B_const128
        .asg     A0,     A_if        ; intra_vlc_format
        .asg     B26,    B_num_blocks                               ; 2 W-mat
        .asg     B26,    B_non420                                   ; 2 W-mat


        LDW     .D2T2    *+B_Mpeg2v[BSBUF_M2OFF],      B_bsbuf
||      LDW     .D1T1    *+A_Mpeg2v[TOP0_M2OFF],       A_top0_bk
||      MVK     .S2      128,          B_const128
||      SET     .S1      A_amr_arg, 14, 14,     A_amr_arg          ; AMR arg
||      MV      .L2     B6,         B_dc_pred

        LDW     .D2T2    *+B_Mpeg2v[CBP_M2OFF],        B_cbp
||      LDW     .D1T1    *+A_Mpeg2v[TOP1_M2OFF],       A_top1
||      MVC     .S2X     A_amr_arg,            AMR                 ; AMR arg

        LDW     .D2T2    *+B_Mpeg2v[NEXTWPTR_M2OFF],   B_next_wptr
||      LDW     .D1T1    *+A_Mpeg2v[BPTR_M2OFF],       A_bptr
||      ADD     .L2      B_Wptr,       B_const128,     B_Wptr_end

        LDW     .D1T1    *+A_Mpeg2v[WORD1_M2OFF],      A_word1

        LDW     .D2T2    *+B_Mpeg2v[WORD2_M2OFF],      B_word2
||      LDW     .D1T1    *+A_Mpeg2v[FORMAT_M2OFF],     A_if
||      MVK     .S1      31,            A_const31

* ========================================================================= *
*  Setup bitstream pointers: top0h:top0l, top1 contain top bitstream
* ========================================================================= *
        .asg    B25,    B_word2_bk
        .asg    A28,    A_word1_bk
        .asg    A10,    A_word1_rw      ; RWD
        .asg    A21,    A_word1_rw_bk   ; RWD
        .asg    A31,    A_top0h_bk
        .asg    A30,    A_top0l_bk
        .asg    B28,    B_bptr_bk
        .asg    B30,    B_bsbuf_circ_bk

        SHL     .S1      A_top0_bk,     8,          A_tbs1
||      STW     .D2T1    A11,           *+B_SP[4]            ; 12Q4
||[A_12Q4]MVKL  .S2      0xFFF0,        B_constFFF0          ; 12Q4 MERGE

        SHRU    .S1      A_top1,        24,         A_tbs2
||      STW     .D2T1    A12,           *+B_SP[5]            ; 12Q4
||[!A_12Q4]MVKL .S2      0xFFFF,        B_constFFF0          ; non-12Q4 MERGE

        ADD     .L1      A_tbs1,        A_tbs2,     A_top0l_bk
||      ADD     .D1      A_bptr,        8,          A_bptr1
||      STW     .D2T1    A13,           *+B_SP[6]            ; 12Q4
||[A_12Q4]MVK   .S1      16,            A_const16            ; 12Q4 MERGE

        CMPGT   .L1      A_bptr1,       A_const31,  A_test2
||      AND     .S1      A_bptr1,       A_const31,  A_bptr
||      MVK     .S2      32,            B_const32
||      ADDAW   .D2      B_bsbuf,       B_next_wptr,B_bsbuf_circ
||[!A_12Q4]MVK  .D1      1,             A_const16            ; non-12Q4 MERGE

  [A_test2]MV   .S1      A_word1,                   A_word1_rw  ; RWD
||[A_test2]MV   .L1X     B_word2,                   A_word1
||[A_test2]LDW  .D2T2    *B_bsbuf_circ++,           B_word2
||      SUB     .S2      B_const32,     A_bptr,     B_bptr_cmpl

  [!A_if]MVKL   .S1      _IMG_len_tbl0,     A_len_tbl_adr
||[!A_if]MVKL   .S2      _IMG_rld_table0,   B_rld_table_adr
||      MV      .L2X     A_bptr,        B_bptr_bk
||      STW     .D2T1    A14,           *+B_SP[7]            ; 12Q4 MERGE
||      MVK     .L1      15,            A_constSHR           ; 12Q4 MERGE

  [!A_if]MVKH   .S1      _IMG_len_tbl0,     A_len_tbl_adr
||[!A_if]MVKH   .S2      _IMG_rld_table0,   B_rld_table_adr
||[A_12Q4]ADD   .L1      A_constSHR,    1, A_constSHR        ;(16) 12Q4 MERGE

  [A_if]MVKL    .S1      _IMG_len_tbl1,     A_len_tbl_adr
||[A_if]MVKL    .S2      _IMG_rld_table1,   B_rld_table_adr
||[!A_12Q4]ADD  .L1      A_constSHR,    5, A_constSHR        ;(20) 12Q4 MERGE

  [A_if]MVKH    .S1      _IMG_len_tbl1,     A_len_tbl_adr
||[A_if]MVKH    .S2      _IMG_rld_table1,   B_rld_table_adr
||      ADD     .L2      B_Wptr,        2,          B_Wptr       ; 2 W-mat

        SHL     .S1      A_word1,       A_bptr,     A_tbs1
||      SHRU    .S2      B_word2,       B_bptr_cmpl,B_tbs3
||      SUB     .L2      B_cnt,         1,          B_num_blocks ; 2 W-mat
||      STW     .D2T2    B_Wptr,        *+B_SP[9]
; base+2 of W-mat

        ADD     .L1X     A_tbs1,        B_tbs3,     A_top1
||      SHRU    .S1      A_top0_bk,     24,         A_top0h_bk
||      MV      .D1      A_word1,       A_word1_bk
||      MV      .S2      B_word2,       B_word2_bk
||      MV      .L2      B_bsbuf_circ,  B_bsbuf_circ_bk
||      STW     .D2T2    B_num_blocks,  *+B_SP[8]                ; 2 W-mat


block_loop:
* ------------------------------------------------------------------------- *
*  check cbp, etc.
* ------------------------------------------------------------------------- *
        .asg     B17,     B_cbp_mask
        .asg     B0,      B_coded
        .asg     A5,      A_last_coeff
        .asg     A0,      A_odd

            SUB   .S2     B_cnt,        1,        B_cnt       ; cbp, cnt--
||          ZERO  .L2     B_sum
||          ZERO  .L1     A_odd                               ; not coded
||          MVK   .S1     1,            A_const1
||          LDW   .D2T2   *+B_SP[8],    B_num_blocks          ; 2 W-mat

            SHL   .S2X    A_const1,     B_cnt,    B_cbp_mask  ; cbp
||          MV    .L2     B_Wptr_end,   B_Wptr                ; not coded
||          MVK   .S1     0,            A_last_coeff          ;not coded 12Q4

            AND   .D2     B_cbp_mask,   B_cbp,    B_coded     ; cbp
||          MVK   .S2     126,          B_const126            ; const

  [!B_coded]B     .S1     mismatch                            ; not coded
||[!B_coded]ADD   .L2     B_outi,       B_const126, B_outi    ; not coded

; branch occurs 5 cycles later

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B31,        B_cnt_bk
        .asg            A31,        A_top0h_bk
        .asg            A30,        A_top0l_bk
        .asg            A28,        A_dc_prec
        .asg            A25,        A_len
        .asg            A20,        A_const32
        .asg            A29,        A_Mpeg2v
        .asg            B30,        B_block
        .asg            B0,         B_flag
        .asg            B0,         B_12Q4              ; 12Q4 MERGE
        .asg            B2,         B_cc
        .asg            A1,         A_cc0
        .asg            A0,         A_cc1
        .asg            A2,         A_b
        .asg            A0,         A_c
        .asg            B30,        B_d1
        .asg            A27,        A_dc_len
        .asg            B1,         B_dc_size
        .asg            B1,         B_non420_cc         ; 2 W-mat
        .asg            B0,         B_d
        .asg            B30,        B_dc_diff
        .asg            A26,        A_r1
        .asg            A9,         A_r2
        .asg            A23,        A_half_range
        .asg            B28,        B_r3
        .asg            A2,         A_test0
        .asg            B29,        B_r4
        .asg            A16,        A_r5
        .asg            A24,        A_pred
        .asg            A28,        A_val
        .asg            A27,        A_invq
        .asg            A27,        A_valdq
        .asg            A27,        A_lentot
        .asg            A26,        A_lentot_c
        .asg            A27,        A_r6h
        .asg            A26,        A_r6l
        .asg            A24,        A_r7
        .asg            A25,        A_bptr2
        .asg            B30,        B_bptr_cmpl1
        .asg            A26,        A_r8
        .asg            B30,        B_r9
        .asg            A24,        A_t20
        .asg            A27,        A_t9h
        .asg            A26,        A_t9l
        .asg            A27,        A_t8h
        .asg            A26,        A_t8l
        .asg            A25,        A_t30
* ========================================================================= *
        MV      .L1     A_word1_bk,  A_word1                    ;restore
||      MV      .L2     B_word2_bk,  B_word2                    ;restore
||      MV      .D2     B_bsbuf_circ_bk, B_bsbuf_circ           ;restore
||      MV      .S1X    B_bptr_bk,   A_bptr                     ;restore
||      MV      .S2     B_cnt,       B_cnt_bk                   ;preserve
; B_cnt_bk shares its register with B_run_bk, in case of not coded MB
; B_run_bk is always <65 (since B_cnt_bk is) which ensures that the fault
; flag (B_err) is not set.

  [B_coded]SUB  .S2     B_num_blocks, B_cnt,    B_block         ;2 W-mat
||    CMPGT     .L2     B_num_blocks, 6,        B_non420        ;2 W-mat

  [B_coded]CMPLT.L2     B_block,    4,          B_flag          ;[ 3,0]
||[B_coded]ZERO .S2     B_cc                                    ;[ 3,0]
||[!B_coded]MVK .D2     1,          B_flag                      ; not coded
||      SHRU    .S1     A_top0h_bk:A_top0l_bk,  8, A_empty:A_top0_bk ;[ 3,0]
||      XPND2   .M2     B_non420,   B_non420                    ; 2 W-mat

  [!B_flag]AND  .S2     B_block,    1,          B_cc            ;[ 4,0]
||      LMBD    .L1     0,          A_top0_bk,  A_b             ;[ 4,0]
||      LDW     .D2T2   *+B_SP[9],  B_Wptr                      ;W-mat basadr

  [!B_flag]ADD  .D2     B_cc,       1,          B_cc            ;[ 5,0]
||      ZERO    .L1     A_cc0                                   ;[ 5,0]

        ADD     .D1     A_b,        1,          A_dc_len        ;[ 6,0]
||[!B_cc]CMPGT  .L1     A_b,        8,          A_cc0           ;[ 6,0]
||[!B_cc]ADD    .D2X    A_b,        2,          B_dc_size       ;[ 6,0]
||[!B_cc]SHRU   .S1     A_b,        1,          A_b             ;[ 6,0]
; --- Branch occurs if MB not coded

        SHRU    .S2X    A_top0_bk,  29,         B_d1            ;[ 7,0]

  [!B_cc]SUB    .L2     B_d1,       4,          B_d             ;[ 8,0]
||      SHRU    .S1     A_top0_bk,  30,         A_c             ;[ 8,0]
||[ B_cc]ADD    .D2X    A_b,        1,          B_dc_size       ;[ 8,0]
||       MVK    .S2     128,        B_const128                  ; 2 W-mat

  [ B_cc]MVK    .S2     1,          B_d                         ;[ 9,0]
||[!A_c]SUB     .L2     B_dc_size,  1,          B_dc_size       ;[ 9,0]

        ZERO    .S1     A_cc1                                   ;[10,0]
||[!B_d]SUB     .D2     B_dc_size,  3,          B_dc_size       ;[10,0]
||[!A_b]ADD     .D1     A_dc_len,   1,          A_dc_len        ;[10,0]

  [ B_cc]CMPGT  .L1     A_b,        9,          A_cc1           ;[11,0]
||[ A_cc0]MVK   .L2     11,         B_dc_size                   ;[11,0]
||[ A_cc0]MVK   .D1     9,          A_dc_len                    ;[11,0]

  [ A_cc1]MVK   .S2     11,         B_dc_size                   ;[12,0]
||[ A_cc1]MVK   .S1     10,         A_dc_len                    ;[12,0]

        SHL     .S1     A_top0_bk,  A_dc_len,   A_r1            ;[13,0]

  [ B_dc_size]SUB.S1X   B_dc_size,  1,          A_r2            ;[14,0]
||[ B_dc_size]SUB.S2    B_const32,  B_dc_size,  B_r3            ;[14,0]
||      ZERO    .L2     B_dc_diff                               ;[14,0]
||      ADD     .D1X    A_dc_len,   B_dc_size,  A_lentot        ;[14,0]

  [ B_dc_size]SHL.S1    A_const1,   A_r2,       A_half_range    ;[15,0]
||[ B_dc_size]SHRU.S2X  A_r1,       B_r3,       B_dc_diff       ;[15,0]
||      SUB     .L1X    B_const32,  A_lentot,   A_lentot_c      ;[15,0]

        ZERO    .L1     A_test0                                 ;[16,0]
||      SHRU    .S1     A_top1,     A_lentot_c, A_r7            ;[16,0]
||      LDW     .D1T1   *+A_Mpeg2v[DCPREC_M2OFF],   A_dc_prec   ;param

  [ B_dc_size]CMPLT.L1X B_dc_diff,  A_half_range,         A_test0    ;[17,0]
||      SHL     .S1     A_top0h_bk:A_top0l_bk,  A_lentot, A_r6h:A_r6l;[17,0]
||      ADD     .D1     A_bptr,     A_lentot,   A_bptr2         ;[17,0]
||      AND     .L2     B_non420,   B_cc,       B_non420_cc     ; 2 W-mat

        LDW     .D2T1   *B_dc_pred[B_cc],       A_pred          ;[18,0]
||      ADD     .S1     A_r6l,      A_r7,       A_top0l_bk      ;[18,0]
||      MV      .D1     A_r6h,      A_top0h_bk                  ;[18,0]
||      CMPGT   .L1     A_bptr2,    A_const31,  A_test2         ;[18,0]
||[B_non420_cc]ADD.L2   B_Wptr,     B_const128, B_Wptr
;if cc!=0 select 2nd W-mat

; =============================== PROLOG ==============================
  [ A_test0]SHL .S1     A_half_range,           1,          A_r5;[19,0]
||      NORM    .L1     A_top0h_bk:A_top0l_bk,  A_nrm           ;[19,0]
||      CMPGT   .L2X    A_const16,  1,          B_12Q4          ; 12Q4 MERGE

  [ A_test0]ADD .L2     B_dc_diff,  1,          B_r4            ;[20,0]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[20,0]
||      MVK     .S1     36,         A_const36                   ;[20,0]
||      MPY     .M1     A_nrm,      -16,        A_t20           ;[20,0]

  [ A_test0]SUB .D2X    B_r4,       A_r5,       B_dc_diff       ;[21,0]
||      SHL     .S1     A_top0h_bk:A_top0l_bk,  A_nrm, A_t9h:A_t9l;[21,0]
||[B_12Q4]SUB   .L1     A_dc_prec,  4,          A_dc_prec       ; 12Q4 MERGE

        AND     .D1     A_bptr2,    A_const31,  A_bptr          ;[22,0]
||      SHRU    .S1     A_t9h:A_t9l,            A_const36, A_t8h:A_t8l;[22,0]
||      SUB     .L1     A_len_tbl_adr,          A_t20,      A_t30     ;[22,0]

        SUB     .S1     3,          A_dc_prec,  A_invq          ;[23,0]
||      ADD     .L1X    A_pred,     B_dc_diff,  A_val           ;[23,0]
||      LDBU    .D1T1   *A_t30[A_t8l],          A_len           ;[23,0]

        SHL     .S1     A_val,      A_invq,     A_valdq         ;[24,0]
||[ A_test2]MV  .D1X    B_word2,    A_word1                     ;[24,0]
|| [A_test2]MV  .L1     A_word1,    A_word1_rw                  ; RWD
||      SUB     .D2X    B_const32,  A_bptr,     B_bptr_cmpl1    ;[24,0]

        SHRU    .S1     A_top0h_bk:A_top0l_bk,  8, A_empty:A_top0_bk;[25,0]
||      SHRU    .S2     B_word2,    B_bptr_cmpl1,           B_r9;[25,0]

        STH     .D2T1   A_valdq,    *B_outi                     ;[26,0]
||      SHL     .S1     A_word1,    A_bptr,     A_r8            ;[26,0]

        STW     .D2T1   A_val,      *B_dc_pred[B_cc]            ;[27,0]
||      ADD     .L2X    B_sum,      A_valdq,    B_sum           ;[27,0]
||      MVK     .S1     32,         A_const32                   ;[27,0]
||      ADD     .L1X    A_r8,       B_r9,       A_top1          ;[27,0]
||      MV      .S2     B_cnt_bk,   B_cnt                       ;restore
* ------------------------------------------------------------------------- *

        SUB     .S2X    A_len,      5,          B_rld_left      ;[10,1]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,1]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,1]
||      SHL     .S1     A_top0h_bk:A_top0l_bk,  A_len, A_ptop0h:A_ptop0l;[10,1]
||      SUB     .D1     A_const32,  A_len,      A_len_c         ;[10,1]

  [B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,1]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,1]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,1]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,1]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,2]

        CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,1]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,2]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,2]
||      MVK     .S2     126,         B_const126                 ;const

        SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,1]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,1]

        SHRU    .S2     B_t13,      27,         B_t14           ;[14,1]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,1]
||      SHRU    .S1     A_t1h:A_t1l, A_const36, A_t4h:A_t4l     ;[ 4,2]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,2]

        ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,1]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,1]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,1]
|| [A_test2]MV  .S1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,2]

        ADD     .L2     B_t15,      B_t15,      B_t16           ;[16,1]
||      SUB     .D1     A_len,      24,         A_test1         ;[16,1]
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,1]

  [ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,1]
||      ADD     .D1     A_ptop0l,   A_t7,       A_top0l         ;[17,1]
||      ADD     .L2     B_rld_table_adr,     1, B_rld_table_adr_1;const

  [ A_test1]LDB .D2T2   *B_rld_table_adr_1[B_t16], B_run        ;[18,1]
||      EXT     .S2     B_top0_bk,  12, 20,    B_level          ;[18,1]
||      SHRU    .S1     A_top0h:A_top0l, 8,    A_empty:A_top0_bk;[ 8,2]

        SHRU    .S2     B_word2,    B_bptr_cmpl,B_t9            ;[19,1]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[19,1]
||      ADD     .L2     B_Wptr,     B_const126, B_Wptr_end      ;rset 2 W-mat
||      MV      .L1     A_top0h:A_top0l, A_top0h_bk:A_top0l_bk  ;preserve
||      MPY     .M2X    1,          A_bptr,     B_bptr_bk       ;preserve
||      LDW     .D1T1    *+A_Mpeg2v[QSCL_M2OFF],A_qscl

        SUB     .S2X    A_len,      5,          B_rld_left      ;[10,2]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,2]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,2]
||      SHL     .S1     A_top0h:A_top0l, A_len, A_ptop0h:A_ptop0l;[10,2]
||      SUB     .D1     A_const32,  A_len,      A_len_c         ;[10,2]

        EXTU    .S2     B_top0_bk,  6,  26,     B_run           ;[21,1]
||[B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,2]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,2]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,2]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,2]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,3]

        MPY     .M2     B_level,    2,          B_level2        ;[22,1]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,2]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,3]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,3]
||      LDW     .D1T2   *+A_Mpeg2v[ZPTR_M2OFF], B_Zptr          ;reset
||      MVK     .S2     63,         B_const63                   ;const
||      MV      .L2     B_bsbuf_circ,           B_bsbuf_circ_bk ;preserve

        LDH     .D2T1   *++B_Wptr[B_run],       A_W             ;[23,1]
||      CMPLT   .L1X    B_level,    0,          A_neg           ;[23,1]
||      SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,2]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,2]
||      MV      .L2     B_word2,    B_word2_bk                  ;preserve
||      MV      .D1     A_word1,    A_word1_bk                  ;preserve
||      MVD     .M1     A_word1_rw, A_word1_rw_bk               ;preserve

        ADD     .L2     B_Wptr,     2,          B_Wptr          ;[24,1]
||      ADD     .D1X    A_t8,       B_t9,       A_top1          ;[24,1]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[14,2]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,2]
||      SHRU    .S1     A_t1h:A_t1l, A_const36, A_t4h:A_t4l     ;[ 4,3]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,3]

  [ A_neg]SUB   .D2     B_level2,   0,          B_level3        ;[25,1]
||      ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,2]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,2]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,2]
|| [A_test2]MV  .S1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,3]

  [!A_neg]ADD   .L2     B_level2,   0,          B_level3        ;[26,1]
||      ADD     .D2     B_t15,      B_t15,      B_t16           ;[16,2]
||      SUB     .D1     A_len,      24,         A_test1         ;[16,2]
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,2]

        CMPGT   .L2     B_run,      B_const63,  B_eob           ;[27,1]
||[ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,2]
||      ADD     .D1     A_ptop0l,   A_t7,       A_top0l         ;[17,2]
||      ADD     .S2     B_Zptr,     1,          B_Zptr          ;reset
||      MV      .L1X    B_outi,     A_outi                      ; 12Q4

* =========================== PIPE LOOP KERNEL ============================ *
        .asg    A2,     A2_top0l
        .asg    B31,    B_run_bk

loop:
        MPY     .M1     A_qscl,     A_W,        A_qw            ;[28,1]
||[!B_eob]CMPGT .L2     B_Wptr,     B_Wptr_end, B_eob           ;[28,1]
||[A_test1]LDB  .D2T2   *B_rld_table_adr_1[B_t16],      B_run   ;[18,2]
||      EXT     .S2     B_top0_bk,  12, 20,    B_level          ;[18,2]
||      SHRU    .S1     A_top0h:A_top0l, 8,    A_empty:A_top0_bk;[ 8,3]
||[B_eob]MPY    .M2     0,          B_Wptr,     B_Wptr          ;err det

        LDB     .D2T1   *++B_Zptr[B_run],       A_cnum          ;[29,1]
||      SHRU    .S2     B_word2,    B_bptr_cmpl,B_t9            ;[19,2]
||      SHL     .S1     A_word1,    A_bptr,     A_t8            ;[19,2]
||[!B_eob]MV    .L1     A_top0h:A_top0l, A_top0h_bk:A_top0l_bk  ;preserve
||[B_eob]ADD    .L2     B_outi,     B_const63,  B_outi          ;mismatch
||[!B_eob]MPY   .M2X    1,          A_bptr,     B_bptr_bk       ;preserve

        ADD     .D2     B_Zptr,     1,          B_Zptr          ;[30,1]
||      MPY     .M1X    A_qw,       B_level3,   A_level4        ;[30,1]
||      SUB     .S2X    A_len,      5,          B_rld_left      ;[10,3]
||      CMPLT   .L2X    A_len,      5,          B_test3         ;[10,3]
||      ADD     .L1     A_bptr,     A_len,      A_bptr1         ;[10,3]
||      SHL     .S1     A_top0h:A_top0l, A_len, A_ptop0h:A_ptop0l;[10,3]
||      SUB     .D1     A_const32,  A_len,      A_len_c         ;[10,3]
||[B_eob]MPY    .M2     1,          B_run,      B_run_bk        ;preserve

        EXTU    .S2     B_top0_bk,  6,  26,     B_run           ;[21,2]
||[B_test3]MPY  .M2     B_rld_left, 0,          B_rld_left      ;[11,3]
||      MV      .L2X    A_top0_bk,  B_top0_bk                   ;[11,3]
||      AND     .S1     A_const31,  A_bptr1,    A_bptr          ;[11,3]
||      MV      .D1     A_ptop0h,   A_top0h                     ;[11,3]
||      NORM    .L1     A_ptop0h:A_ptop0l,      A_nrm           ;[ 1,4]
||[B_eob]ADD    .D2     B_outi,     B_const63,  B_outi          ;mismatch

  [!B_eob]B     .S2     loop                                    ;[32,1]
||[ A_neg]ADD   .D1     A_level4,   A_const31,  A_level4        ;[32,1]
||      MPY     .M2     B_level,    2,          B_level2        ;[22,2]
||      CMPGT   .L1     A_bptr1,    A_const31,  A_test2         ;[12,3]
||      MPY     .M1     A_nrm,      -16,        A_t2            ;[ 2,4]
||      SHL     .S1     A_ptop0h:A_ptop0l, A_nrm, A_t1h:A_t1l   ;[ 2,4]
||[!B_eob]MV    .L2     B_bsbuf_circ,      B_bsbuf_circ_bk      ;preserve
||[B_eob]LDH    .D2T1   *B_outi,    A_last_coeff                ;mismatch

        SSHL    .S1     A_level4,   15,         A_level5        ;[33,1]
||[!B_eob]LDH   .D2T1   *++B_Wptr[B_run],       A_W             ;[23,2]
||      CMPLT   .L1X    B_level,    0,          A_neg           ;[23,2]
||      SHL     .S2     B_top0_bk,  B_rld_left, B_t13           ;[13,3]
||      MPY     .M2X    B_const32,  A_len,      B_t12           ;[13,3]
||[!B_eob]MV    .L2     B_word2,    B_word2_bk                  ;preserve
||[!B_eob]MV    .D1     A_word1,    A_word1_bk                  ;preserve
||[!B_eob]MVD   .M1     A_word1_rw, A_word1_rw_bk               ;preserve

  [!B_eob]ADD   .L2     B_Wptr,     2,          B_Wptr          ;[24,2]
||[!B_eob]ADD   .D1X    A_t8,       B_t9,       A_top1          ;[24,2]
||      SHRU    .S2     B_t13,      27,         B_t14           ;[14,3]
||[ A_test2]LDW .D2T2   *B_bsbuf_circ++,        B_word2         ;[14,3]
||      SHRU    .S1     A_t1h:A_t1l, A_const36, A_t4h:A_t4l     ;[ 4,4]
||      SUB     .L1     A_len_tbl_adr,          A_t2,       A_t3;[ 4,4]

        SHR     .S1     A_level5,   A_constSHR, A_level_f       ;[35,1] 12Q4 MERGE
||[ A_neg]SUB   .D2     B_level2,   0,          B_level3        ;[25,2]
||      ADD     .L2     B_t14,      B_t12,      B_t15           ;[15,3]
||      SUB     .S2X    B_const32,  A_bptr,     B_bptr_cmpl     ;[15,3]
||[ A_test2]MV  .L1X    B_word2,    A_word1                     ;[15,3]
|| [A_test2]MVD .M1     A_word1,    A_word1_rw                  ; RWD
||      LDBU    .D1T1   *A_t3[A_t4l],           A_len           ;[ 5,4]

  [!A_neg]ADD   .L2     B_level2,   0,          B_level3        ;[26,2]
||      ADD     .S2     B_t15,      B_t15,      B_t16           ;[16,3]
||      SUB     .D1     A_len,      24,         A_test1         ;[16,3]
||      SHRU    .S1     A_top1,     A_len_c,    A_t7            ;[16,3]
||[!B_eob]AND   .L1X    B_constFFF0,A_level_f,  A_level_f       ; 12Q4

  [!B_eob]STH   .D1T1   A_level_f,  *+A_outi[A_cnum]            ;[36,1] BC
||[!B_eob]ADD   .S2X    B_sum,      A_level_f,  B_sum           ;[37,1]
||        CMPGT .L2     B_run,      B_const63,  B_eob           ;[27,2]
||[ A_test1]LDB .D2T2   *B_rld_table_adr[B_t16],B_level         ;[17,3]
||[!B_eob]ADD   .L1     A_ptop0l,   A_t7,       A2_top0l        ;[17,3]
||[B_eob] XOR   .S1     A_const16,  A_last_coeff, A_last_coeff  ;mismatch
||[B_eob] MVD   .M1     A_word1_rw_bk,          A_word1_rw      ; RWD

* =========================== PIPE LOOP EPILOG ============================ *
* ========================================================================= *
; live-out: top0h:top0k, top1, word1, word2, bsbuf_circ, run, Wptr, Wptr_end,
;           sum, bptr

    .asg    B0,     B_err       ; same reg as B_eob
    .asg    A29,    A_Mpeg2v
    .asg    B31,    B_bsbuf
    .asg    B3,     B_ret       ; Return address
    .asg    B15,    B_SP        ; Stack pointer, B datapath
    .asg    B1,     B_const65

mismatch:
 [B_cnt] B       .S1     block_loop                             ; -- BRANCH --
||       MVK     .S2     65,           B_const65                ; invalid VLC
||       CMPGTU  .L2     B_Wptr,       B_Wptr_end, B_err        ; overrun
||       AND     .L1X    A_const16,    B_sum,      A_odd        ;mismatch

 [!B_err]CMPGT   .L2     B_run_bk,     B_const65,  B_err        ; invalid VLC
||       ADD     .S2     B_outi,       2,          B_outi
||       LDW     .D1T2   *+A_Mpeg2v[BSBUF_M2OFF],  B_bsbuf      ; exit
||       MVK     .S1     32,           A_const32                ; exit
||[!A_odd]STH    .D2T1   A_last_coeff, *B_outi                  ; mismatch

 [B_err] B       .S2     exit                                   ; -- BRANCH --
||       LDW     .D2T2   *+B_SP[2],    B_ret                    ; exit
||       MV      .L2     B_bsbuf_circ_bk, B_bsbuf_circ          ; AMR arg

         NOP             3
; branch occurs to block_loop
         NOP             2
; branch occurs to exit after 2 cycles in block_loop
; (preserve B0_err for exit)

* =================================== EXIT =============================== *
        .asg            B26,        B_csr        ; CSR value to restore
        .asg            B22,        B_byte_diff
        .asg            B29,        B_next_wptr
        .asg            B1,         B_lz
        .asg            B27,        B_amr_config
        .asg            B4,         B_constBUFMASK
        .asg            A14,        A_SP                     ; 12Q4 MERGE

exit:
        SUB     .L2      B_bsbuf_circ,  B_bsbuf, B_byte_diff
||      SHRU    .S1      A_top1,        8,         A_t2
||      SUB     .S2      B_bptr_bk,     8,         B_bptr_bk
||      LDW     .D2T1    *+B_SP[6], A13                      ; 12Q4
||      MV      .L1X     B_SP,            A_SP               ; 12Q4 MERGE

        SHR     .S2      B_byte_diff,   2,         B_next_wptr
||      SHL     .S1      A_top0l_bk,    24,        A_t3
||      CMPLT   .L2      B_bptr_bk,     0,         B_lz
||      LDW     .D2T2    *+B_SP[1],     B14
||      LDW     .D1T1    *+A_SP[7],     A14                 ; 12Q4 MERGE

        ADD     .L1      A_t2,          A_t3,      A_top1
||      SHRU    .S1      A_top0h_bk:A_top0l_bk, 8, A_empty:A_top0_bk
||      STW     .D1T2    B_err,      *+A_Mpeg2v[FAULT_M2OFF]
||[B_lz]MVD     .M1      A_word1_rw,               A_word1_bk   ; RWD
||[B_lz]MV      .L2X     A_word1_bk,               B_word2_bk
||      LDW     .D2T1    *+B_SP[4], A11                      ; 12Q4

        LDW     .D2T2    *+B_SP[3],     B_csr        ; Get CSR's value
||      STW     .D1T1    A_top1,        *+A_Mpeg2v[TOP1_M2OFF]
||[B_lz]ADD     .L2      B_bptr_bk,     A_const32, B_bptr_bk

        STW     .D1T2    B_bptr_bk,     *+A_Mpeg2v[BPTR_M2OFF]
||      LDW     .D2T1    *+B_SP[5], A12                      ; 12Q4

        RET     .S2      B_ret                       ; Return to caller
||      STW     .D1T1    A_top0_bk,     *+A_Mpeg2v[TOP0_M2OFF]
||[B_lz]SUBAW   .D2      B_bsbuf_circ, 1, B_bsbuf_circ    ; AMR arg

        LDW     .D2T1    *++B_SP[10],   A10          ; 2 W-mat
||      ZERO    .S2      B_amr_config
||[B_lz]SUB     .L2      B_bsbuf_circ,  B_bsbuf, B_byte_diff  ; AMR arg

        STW     .D1T1    A_word1_bk,    *+A_Mpeg2v[WORD1_M2OFF]
||[B_lz]SHR     .S2      B_byte_diff,   2,         B_next_wptr  ; AMR arg

        STW     .D1T2    B_word2_bk,    *+A_Mpeg2v[WORD2_M2OFF]
;  ===== Interruptibility state restored here =====

        STW     .D1T2    B_next_wptr,   *+A_Mpeg2v[NEXTWPTR_M2OFF] ; AMR arg
||      MVC     .S2      B_amr_config,  AMR

        MVC     .S2      B_csr,         CSR           ; Restore CSR
; Branch occurs

* ========================================================================= *
*   End of file:   img_mpeg2_vld_intra.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

len_tbl0.asm/   1066928952  0     0     0       10396     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Fri Oct 25 00:31:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_tbl0                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Apr-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_tbl0[640];                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       MPEG-2 VLD look-up table for VLC code length decoding (Table B-14)  *
*       To be used with mpeg2_vld_intra and mpeg2_vld_inter routines.       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_tbl0
        .data
        .align 8
        .global _IMG_len_tbl0
_IMG_len_tbl0:
        .byte   0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x04, 0x04
        .byte   0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x09, 0x06, 0x06, 0x06
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x0D
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03

* ========================================================================= *
*   End of file:  img_len_tbl0.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
len_tbl1.asm/   1066928952  0     0     0       10396     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Fri Oct 25 00:31:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_len_tbl1                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Apr-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned char IMG_len_tbl1[640];                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       MPEG-2 VLD look-up table for VLC code length decoding (Table B-15)  *
*       To be used with mpeg2_vld_intra and mpeg2_vld_inter routines.       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_len_tbl1
        .data
        .align 8
        .global _IMG_len_tbl1
_IMG_len_tbl1:
        .byte   0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x05
        .byte   0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x09, 0x06, 0x06, 0x06
        .byte   0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
        .byte   0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08
        .byte   0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18
        .byte   0x08, 0x08, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0B, 0x0A
        .byte   0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x0D
        .byte   0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00
        .byte   0x00, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
        .byte   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        .byte   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09

* ========================================================================= *
*   End of file:  img_len_tbl1.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
rld_table0.asm/ 1066928952  0     0     0       11042     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Fri Oct 25 00:31:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_rld_table0                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Apr-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned short IMG_rld_table0[576];                *
*                                                                           *
*   DESCRIPTION                                                             *
*       MPEG-2 VLD look-up table for VLC run-level decoding (Table B-14).   *
*       To be used with mpeg2_vld_intra routine.                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_rld_table0
        .data
        .align 8
        .global _IMG_rld_table0
_IMG_rld_table0:
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF, 0x41FF
        .short  0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0001, 0x0001, 0x0001, 0x0001, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x0101, 0x0101, 0x01FF, 0x01FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0002, 0x00FE, 0x0201, 0x02FF, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0003, 0x00FD, 0x0401, 0x04FF, 0x0301, 0x03FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0701, 0x07FF, 0x0601, 0x06FF, 0x0102, 0x01FE, 0x0501, 0x05FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0202, 0x02FE, 0x0901, 0x09FF, 0x0004, 0x00FC, 0x0801, 0x08FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0D01, 0x0DFF, 0x0006, 0x00FA, 0x0C01, 0x0CFF, 0x0B01, 0x0BFF
        .short  0x0302, 0x03FE, 0x0103, 0x01FD, 0x0005, 0x00FB, 0x0A01, 0x0AFF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x1001, 0x10FF, 0x0502, 0x05FE, 0x0007, 0x00F9, 0x0203, 0x02FD
        .short  0x0104, 0x01FC, 0x0F01, 0x0FFF, 0x0E01, 0x0EFF, 0x0402, 0x04FE
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x000B, 0x00F5, 0x0802, 0x08FE, 0x0403, 0x04FD, 0x000A, 0x00F6
        .short  0x0204, 0x02FC, 0x0702, 0x07FE, 0x1501, 0x15FF, 0x1401, 0x14FF
        .short  0x0009, 0x00F7, 0x1301, 0x13FF, 0x1201, 0x12FF, 0x0105, 0x01FB
        .short  0x0303, 0x03FD, 0x0008, 0x00F8, 0x0602, 0x06FE, 0x1101, 0x11FF
        .short  0x0A02, 0x0AFE, 0x0902, 0x09FE, 0x0503, 0x05FD, 0x0304, 0x03FC
        .short  0x0205, 0x02FB, 0x0107, 0x01F9, 0x0106, 0x01FA, 0x000F, 0x00F1
        .short  0x000E, 0x00F2, 0x000D, 0x00F3, 0x000C, 0x00F4, 0x1A01, 0x1AFF
        .short  0x1901, 0x19FF, 0x1801, 0x18FF, 0x1701, 0x17FF, 0x1601, 0x16FF
        .short  0x001F, 0x00E1, 0x001E, 0x00E2, 0x001D, 0x00E3, 0x001C, 0x00E4
        .short  0x001B, 0x00E5, 0x001A, 0x00E6, 0x0019, 0x00E7, 0x0018, 0x00E8
        .short  0x0017, 0x00E9, 0x0016, 0x00EA, 0x0015, 0x00EB, 0x0014, 0x00EC
        .short  0x0013, 0x00ED, 0x0012, 0x00EE, 0x0011, 0x00EF, 0x0010, 0x00F0
        .short  0x0028, 0x00D8, 0x0027, 0x00D9, 0x0026, 0x00DA, 0x0025, 0x00DB
        .short  0x0024, 0x00DC, 0x0023, 0x00DD, 0x0022, 0x00DE, 0x0021, 0x00DF
        .short  0x0020, 0x00E0, 0x010E, 0x01F2, 0x010D, 0x01F3, 0x010C, 0x01F4
        .short  0x010B, 0x01F5, 0x010A, 0x01F6, 0x0109, 0x01F7, 0x0108, 0x01F8
        .short  0x0112, 0x01EE, 0x0111, 0x01EF, 0x0110, 0x01F0, 0x010F, 0x01F1
        .short  0x0603, 0x06FD, 0x1002, 0x10FE, 0x0F02, 0x0FFE, 0x0E02, 0x0EFE
        .short  0x0D02, 0x0DFE, 0x0C02, 0x0CFE, 0x0B02, 0x0BFE, 0x1F01, 0x1FFF
        .short  0x1E01, 0x1EFF, 0x1D01, 0x1DFF, 0x1C01, 0x1CFF, 0x1B01, 0x1BFF

* ========================================================================= *
*   End of file:  img_rld_table0.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
rld_table1.asm/ 1066928952  0     0     0       11042     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Fri Oct 25 00:31:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_rld_table1                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Apr-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*C      extern far const unsigned short IMG_rld_table1[576];                *
*                                                                           *
*   DESCRIPTION                                                             *
*       MPEG-2 VLD look-up table for VLC run-level decoding (Table B-15).   *
*       To be used with mpeg2_vld_intra routine.                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _IMG_rld_table1
        .data
        .align 8
        .global _IMG_rld_table1
_IMG_rld_table1:
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0001, 0x0001, 0x0001, 0x0001, 0x00FF, 0x00FF, 0x00FF, 0x00FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0101, 0x0101, 0x01FF, 0x01FF, 0x41FF, 0x41FF, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0002, 0x0002, 0x00FE, 0x00FE, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x0003, 0x00FD
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0201, 0x02FF, 0x0102, 0x01FE, 0x0301, 0x03FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0004, 0x00FC, 0x0005, 0x00FB, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0007, 0x00F9, 0x0006, 0x00FA, 0x0401, 0x04FF, 0x0501, 0x05FF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0701, 0x07FF, 0x0801, 0x08FF, 0x0601, 0x06FF, 0x0202, 0x02FE
        .short  0x0901, 0x09FF, 0x0103, 0x01FD, 0x0A01, 0x0AFF, 0x0008, 0x00F8
        .short  0x0009, 0x00F7, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0105, 0x01FB, 0x0B01, 0x0BFF, 0x000B, 0x00F5, 0x000A, 0x00F6
        .short  0x0D01, 0x0DFF, 0x0C01, 0x0CFF, 0x0302, 0x03FE, 0x0104, 0x01FC
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x000C, 0x00F4, 0x000D, 0x00F3
        .short  0x0203, 0x02FD, 0x0402, 0x04FE, 0x000E, 0x00F2, 0x000F, 0x00F1
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0502, 0x05FE, 0x0E01, 0x0EFF, 0x4400, 0x4400, 0x0F01, 0x0FFF
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x0204, 0x02FC, 0x1001, 0x10FF, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0802, 0x08FE, 0x0403, 0x04FD, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x0702, 0x07FE, 0x1501, 0x15FF, 0x1401, 0x14FF
        .short  0x4400, 0x4400, 0x1301, 0x13FF, 0x1201, 0x12FF, 0x4400, 0x4400
        .short  0x0303, 0x03FD, 0x4400, 0x4400, 0x0602, 0x06FE, 0x1101, 0x11FF
        .short  0x0A02, 0x0AFE, 0x0902, 0x09FE, 0x0503, 0x05FD, 0x0304, 0x03FC
        .short  0x0205, 0x02FB, 0x0107, 0x01F9, 0x0106, 0x01FA, 0x4400, 0x4400
        .short  0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x4400, 0x1A01, 0x1AFF
        .short  0x1901, 0x19FF, 0x1801, 0x18FF, 0x1701, 0x17FF, 0x1601, 0x16FF
        .short  0x001F, 0x00E1, 0x001E, 0x00E2, 0x001D, 0x00E3, 0x001C, 0x00E4
        .short  0x001B, 0x00E5, 0x001A, 0x00E6, 0x0019, 0x00E7, 0x0018, 0x00E8
        .short  0x0017, 0x00E9, 0x0016, 0x00EA, 0x0015, 0x00EB, 0x0014, 0x00EC
        .short  0x0013, 0x00ED, 0x0012, 0x00EE, 0x0011, 0x00EF, 0x0010, 0x00F0
        .short  0x0028, 0x00D8, 0x0027, 0x00D9, 0x0026, 0x00DA, 0x0025, 0x00DB
        .short  0x0024, 0x00DC, 0x0023, 0x00DD, 0x0022, 0x00DE, 0x0021, 0x00DF
        .short  0x0020, 0x00E0, 0x010E, 0x01F2, 0x010D, 0x01F3, 0x010C, 0x01F4
        .short  0x010B, 0x01F5, 0x010A, 0x01F6, 0x0109, 0x01F7, 0x0108, 0x01F8
        .short  0x0112, 0x01EE, 0x0111, 0x01EF, 0x0110, 0x01F0, 0x010F, 0x01F1
        .short  0x0603, 0x06FD, 0x1002, 0x10FE, 0x0F02, 0x0FFE, 0x0E02, 0x0EFE
        .short  0x0D02, 0x0DFE, 0x0C02, 0x0CFE, 0x0B02, 0x0BFE, 0x1F01, 0x1FFF
        .short  0x1E01, 0x1EFF, 0x1D01, 0x1DFF, 0x1C01, 0x1CFF, 0x1B01, 0x1BFF

* ========================================================================= *
*   End of file:  img_rld_table1.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
perimeter.asm/  1066928952  0     0     0       29647     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Sun Sep 29 07:07:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


*============================================================================*
*                                                                            *
*    TEXAS INSTRUMENTS, INC.                                                 *
*                                                                            *
*    NAME                                                                    *
*        Perimeter: Detection of the boundary of a binary image              *
*                                                                            *
*    REVISION DATE                                                           *
*        21-Aug-2001                                                         *
*                                                                            *
*    USAGE                                                                   *
*        This routine is C callable, and has the following C prototype:      *
*                                                                            *
*           int IMG_perimeter                                               *
*           (                                                               *
*               const unsigned char *restrict in,  /* Input image    */     *
*               int cols,                          /* Width of input */     *
*               unsigned char       *restrict out  /* Output image   */     *
*           );                                                              *
*                                                                            *
*     DESCRIPTION                                                            *
*           This routine produces the boundary of a binary image. It echoes  *
*     the boundary pixels with a value of 0xFF and sets the other pixels     *
*     as 0. Detection of the boundary of a binary image is a segmentation    *
*     problem and is done by examining spatial locality of the neighboring   *
*     pixels. This is done by using the four connectivity algorithm          *
*                                                                            *
*               pix_up                                                       *
*      pix_lft pix_cent pix_rgt                                              *
*              pix_dn                                                        *
*                                                                            *
*     The output pixel at location pix_cent is echoed as a boundary pixel    *
*     if pix_cent is non-zero and any one of its four neighbors is zero      *
*     The four neighbors are shown and stand for the foll:                   *
*                                                                            *
*     pix_up:  top pixel                                                     *
*     pix_lft: left pixel                                                    *
*     pix_rgt: right pixel                                                   *
*     pix_dn:  bottom pixel                                                  *
*                                                                            *
*     ASSUMPTIONS                                                            *
*       input image must be double-word aligned                              *
*       cols must be a multiple of 16                                        *
*                                                                            *
*     MEMORY NOTE                                                            *
*        No bank conflicts are expected for this kernel.                     *
*                                                                            *
*     TECHNIQUES                                                             *
*                                                                            *
*     Use double word wide loads and bring in pixels along three lines which *
*     we shall call top, mid and bot. Use split compares to compare if pix-  *
*     els are greater than or equal to zero. Use the 4 lsb's to find out     *
*     the result. Prepare an 8 bit mask using the result of 2 such split     *
*     compares. Perform this operation for the top, middle and botton.       *
*     Logically invert the result of mid, left shift and right shift and     *
*     add the context information by setting the 8 th bit or the 1st bit.    *
*     Use xpnd4 and bitc4 to perform expansion and bit count. Store output   *
*     pixels as double word. The actual handassembly code is unrolled once   *
*     and computes 16 output pixels in 10 cycles                             *
*                                                                            *
*    CYCLES                                                                  *
*        10 * cols/16 + 55                                                   *
*        cols = 720,    505 cycles                                           *
*                                                                            *
*    CodeSize: 600 bytes                                                     *
*                                                                            *
*============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*

        .sect ".text:_perimeter"
        .global _IMG_perimeter
_IMG_perimeter: 


*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
*==============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]             ; Save A15
||      MV      .S1X    B_SP,       A_SP                    ; Twin Stack Pointer

        STW     .D1T1   A14,        *-A_SP[ 2]              ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]              ; Save B14
||      MVC     .S2     CSR,        B_csr                   ; Capture CSR

        STW     .D1T1   A13,        *-A_SP[ 4]              ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]              ; Save B13
||      AND     .L2     B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]              ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]              ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]             ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]              ; Save B11
||      MV      .L1X    B_csr,      A_csr                   ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]              ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]              ; Save B10
||      MVC     .S2     B_no_gie,   CSR                     ; Dis interrupts
; ===== Interrupts masked here =====
;-

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_img_in                    ;
        .asg            B4,         B_incols                    ;
        .asg            A6,         A_img_out                   ;
        .asg            A11,        A_top_ptr                   ;
        .asg            A10,        A_mid_ptr                   ;
        .asg            A2,         A_bot_ptr                   ;
        .asg            B5,         B_top_ptr                   ;
        .asg            B6,         B_mid_ptr                   ;
        .asg            B16,        B_bot_ptr                   ;
        .asg            A19,        A_bot_zero                  ;
        .asg            B19,        B_bot_zero                  ;
        .asg            A20,        A_k_16                      ;
        .asg            B20,        B_k_16                      ;
        .asg            A21,        A_FF                        ;
        .asg            B21,        B_FF                        ;
        .asg            B1,         B_lt0                       ;
        .asg            A3,         A_sum                       ;
        .asg            A5,         A_optr                      ;
        .asg            B17,        B_optr                      ;
        .asg            B2,         B_pd                        ;
        .asg            A16,        A_byte_ptr                  ;
        .asg            A22,        A_mid_rt_const              ;
        .asg            B22,        B_mid_lf_const              ;
        .asg            A23,        A_mid_lf_const              ;
        .asg            B23,        B_mid_rt_const              ;
        .asg            B18,        B_i                         ;
; ============================================================================
        MVK     .S1     080h,       A_mid_rt_const              ;[ 1,0]
||      STW     .D1T1   A_csr,      *-A_SP[12]              ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]              ; return address

        MV      .L1     A_img_out,  A_optr                      ;[ 2,0]

        MV      .D2X    A_mid_rt_const,         B_mid_rt_const  ;[ 3,0]
||      MVK     .S1     16,         A_k_16                      ;[ 3,0]

        SHRU    .S2     B_incols,   4,          B_i             ;[ 4,0]
||      ADD     .L2X    A_optr,     8,          B_optr          ;[ 4,0]
||      ADD     .D1X    A_img_in,   B_incols,   A_bot_ptr       ;[ 4,0]

        MVK     .L2     01h,        B_mid_lf_const              ;[ 5,0]
||      MV      .D2X    A_k_16,     B_k_16                      ;[ 5,0]
||      ADD     .S1     A_img_in,   0,          A_mid_ptr       ;[ 5,0]

        ADD     .D2X    A_bot_ptr,  8,          B_bot_ptr       ;[ 6,0]
||      SUB     .L1X    A_img_in,   B_incols,   A_top_ptr       ;[ 6,0]

        MV      .S1X    B_mid_lf_const,         A_mid_lf_const  ;[ 7,0]
||      ADD     .D1     A_img_in,   16,         A_byte_ptr      ;[ 7,0]
||      ZERO    .D2     B_lt0                                   ;[ 7,0]
||      ADD     .L2X    A_mid_ptr,  8,          B_mid_ptr       ;[ 7,0]
||      MVK     .S2     3,          B_pd

        ZERO    .L2     B_bot_zero                              ;[ 8,0]
||      ZERO    .D1     A_bot_zero                              ;[ 8,0]
||      ADD     .D2X    A_top_ptr,  8,          B_top_ptr       ;[ 8,0]

        ;==== Branch occurs

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A11,        A_top_ptr
        .asg            A10,        A_mid_ptr
        .asg            A2,         A_bot_ptr
        .asg            B5,         B_top_ptr
        .asg            B6,         B_mid_ptr
        .asg            B16,        B_bot_ptr
        .asg            A19,        A_bot_zero
        .asg            B19,        B_bot_zero
        .asg            A20,        A_k_16
        .asg            B20,        B_k_16
        .asg            A21,        A_FF
        .asg            B21,        B_FF
        .asg            B1,         B_lt0
        .asg            A3,         A_sum
        .asg            A5,         A_optr
        .asg            B17,        B_optr
        .asg            B2,         B_pd
        .asg            A22,        A_mid_rt_const
        .asg            B22,        B_mid_lf_const
        .asg            A23,        A_mid_lf_const
        .asg            B23,        B_mid_rt_const
        .asg            A16,        A_byte_ptr
        .asg            B18,        B_i
        .asg            A27,        A_top_word1
        .asg            A26,        A_top_word0
        .asg            A31,        A_mid_word1
        .asg            A30,        A_mid_word0
        .asg            A29,        A_bot_word1
        .asg            A28,        A_bot_word0
        .asg            B27,        B_top_word3
        .asg            B26,        B_top_word2
        .asg            B31,        B_mid_word3
        .asg            B30,        B_mid_word2
        .asg            B29,        B_bot_word3
        .asg            B28,        B_bot_word2
        .asg            A17,        A_mid_word0c
        .asg            A9,         A_mid_word1c
        .asg            B12,        B_mid_word2c
        .asg            B29,        B_mid_word3c
        .asg            A25,        A_midval00
        .asg            A7,         A_midval01
        .asg            B7,         B_midval02
        .asg            B8,         B_midval03
        .asg            A8,         A_midval01_s
        .asg            B3,         B_midval03_s
        .asg            A18,        A_midval_w0
        .asg            B3,         B_midval_w1
        .asg            A26,        A_upval00
        .asg            A24,        A_upval01
        .asg            B26,        B_upval02
        .asg            B9,         B_upval03
        .asg            A24,        A_upval01_s
        .asg            B25,        B_upval03_s
        .asg            A8,         A_upval_w0
        .asg            B10,        B_upval_w1
        .asg            A8,         A_botval00
        .asg            A7,         A_botval01
        .asg            B28,        B_botval02
        .asg            B8,         B_botval03
        .asg            A24,        A_botval01_s
        .asg            B9,         B_botval03_s
        .asg            A27,        A_botval_w0
        .asg            B27,        B_botval_w1
        .asg            A30,        A_midval_k0
        .asg            B8,         B_midval_k1
        .asg            A9,         A_mid_rt_val0
        .asg            B8,         B_mid_rt_val1
        .asg            A27,        A_mid_lt_val0
        .asg            B7,         B_mid_lt_val1
        .asg            B0,         B_rt0
        .asg            A1,         A_lt1
        .asg            A0,         A_rt1
        .asg            A12,        A_updnval0
        .asg            A7,         A_rgtlft0
        .asg            A7,         A_udrl0
        .asg            A25,        A_udrlm0
        .asg            B11,        B_updnval1
        .asg            B7,         B_rgtlft1
        .asg            B7,         B_udrl1
        .asg            B8,         B_udrlm1
        .asg            A30,        A_count0
        .asg            B7,         B_count1
        .asg            A25,        A_count
        .asg            A24,        A_pixel0
        .asg            A7,         A_udrlm_s
        .asg            A25,        A_pixel1
        .asg            B24,        B_pixel2
        .asg            B14,        B_udrl_r
        .asg            B25,        B_pixel3
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDDW    .D2T2   *B_top_ptr++[2],        B_top_word3:B_top_word2 ;[ 1,1]
||      LDDW    .D1T1   *A_bot_ptr++[2],        A_bot_word1:A_bot_word0 ;[ 1,1]
||      ZERO    .L1     A_sum                                           ;[ 8,0]
||      MVK     .S2     0FFh,                   B_FF                    ;[ 8,0]
||      MVK     .S1     0FFh,                   A_FF                    ;[ 8,0]

        LDDW    .D2T2   *B_bot_ptr++[2],        B_bot_word3:B_bot_word2 ;[ 2,1]

        NOP             3                                               ;

        CMPEQ4  .S2     B_top_word3,            B_bot_zero, B_upval03   ;[ 6,1]

        MPY     .M2     B_upval03,  B_k_16,     B_upval03_s             ;[ 7,1]


; ============================ PIPE LOOP KERNEL ==============================
LOOP:
        OR      .D1   A_mid_rt_val0,      A_mid_lt_val0,   A_rgtlft0       ;
||      OR      .L2   B_mid_rt_val1,      B_mid_lt_val1,   B_rgtlft1       ;
||      AND     .D2   B_mid_word2,        B_FF,            B_rt0           ;
||      ADD     .L1   A_botval01_s,       A_botval00,      A_botval_w0     ;
||      SHRU    .S1   A_mid_word1,        24,              A_lt1           ;
||      CMPGTU4 .S2   B_mid_word3,        B_bot_zero,      B_midval03      ;
||      MPY     .M1   A_midval01,         A_k_16,          A_midval01_s    ;

        OR      .L1   A_updnval0,         A_rgtlft0,       A_udrl0         ;
||      OR      .L2   B_updnval1,         B_rgtlft1,       B_udrl1         ;
||[ B_pd]SUB    .D2   B_pd,               1,               B_pd            ;
||      CMPEQ4  .S1   A_top_word0,        A_bot_zero,      A_upval00       ;
||      MPY     .M2   B_midval03,         B_k_16,          B_midval03_s    ;
||      LDDW    .D1T1 *A_top_ptr++[2],    A_top_word1:A_top_word0          ;
||      CMPEQ4  .S2   B_bot_word3,        B_bot_zero, B_botval03           ;

        AND     .L1   A_udrl0,            A_midval_w0,     A_udrlm0        ;
||      AND     .L2   B_udrl1,            B_midval_w1,     B_udrlm1        ;
||      MVD     .M1   A_mid_word0,        A_mid_word0c                     ;
||      CMPGTU4 .S2   B_mid_word2,        B_bot_zero,      B_midval02      ;
||      ADD     .S1   A_midval01_s,       A_midval00,      A_midval_w0     ;
||      MPY     .M2   B_botval03,         B_k_16,          B_botval03_s    ;
||      LDDW    .D2T2 *B_top_ptr++[2],    B_top_word3:B_top_word2          ;
||      LDDW    .D1T1 *A_bot_ptr++[2],    A_bot_word1:A_bot_word0          ;

        SHRU    .S1   A_udrlm0,           4,               A_udrlm_s       ;
||      XPND4   .M1   A_udrlm0,           A_pixel0                         ;
||      XPND4   .M2   B_udrlm1,           B_pixel2                         ;
||      SHRU    .S2   B_udrlm1,           4,               B_udrl_r        ;
||      ADD     .L2   B_midval03_s,       B_midval02,      B_midval_w1     ;
||      NOT     .L1   A_midval_w0,        A_midval_k0                      ;
||      LDDW    .D1T1 *A_mid_ptr++[2],    A_mid_word1:A_mid_word0          ;
||      LDDW    .D2T2 *B_bot_ptr++[2],    B_bot_word3:B_bot_word2          ;

        BDEC    .S2   LOOP,               B_i                              ;
||      XPND4   .M1   A_udrlm_s,          A_pixel1                         ;
||      BITC4   .M2   B_udrlm1,           B_count1                         ;
||      ADD     .L1   A_upval01_s,        A_upval00,       A_upval_w0      ;
||      OR      .D2   B_upval_w1,         B_botval_w1,     B_updnval1      ;
||      NOT     .L2   B_midval_w1,        B_midval_k1                      ;
||      AND     .D1   A_midval_k0,        A_FF,            A_midval_k0     ;
||      CMPEQ4  .S1   A_bot_word1,        A_bot_zero,      A_botval01      ;

        BITC4   .M1   A_udrlm0,           A_count0                         ;
||      AND     .D1   A_pixel0,           A_mid_word0c,    A_pixel0        ;
||      XPND4   .M2   B_udrl_r,           B_pixel3                         ;
||      OR      .L1   A_upval_w0,         A_botval_w0,     A_updnval0      ;
||      AND     .L2   B_midval_k1,        B_FF,            B_midval_k1     ;
||      CMPEQ4  .S1   A_bot_word0,        A_bot_zero,      A_botval00      ;
||      CMPEQ4  .S2   B_top_word2,        B_bot_zero,      B_upval02       ;
||      LDDW    .D2T2 *B_mid_ptr++[2],    B_mid_word3:B_mid_word2          ;

        AND     .L1   A_pixel1,           A_mid_word1c,    A_pixel1        ;
||      AND     .L2   B_pixel2,           B_mid_word2c,    B_pixel2        ;
||      SHRU    .S1   A_midval_k0,        1,               A_mid_rt_val0   ;
||      MPY     .M2   B_midval_k1,        2,               B_mid_lt_val1   ;
||      MPY     .M1   A_midval_k0,        2,               A_mid_lt_val0   ;
||      LDBU    .D1T1 *A_byte_ptr++[16],  A_rt1                            ;
||      ADD     .D2   B_upval03_s,        B_upval02,       B_upval_w1      ;
||      CMPEQ4  .S2   B_bot_word2,        B_bot_zero,      B_botval02      ;

  [!B_pd]STNDW  .D1T1 A_pixel1:A_pixel0, *A_optr++[2]                      ;
||      ADD     .L1X  A_count0,           B_count1,        A_count         ;
||      AND     .D2   B_pixel3,           B_mid_word3c,    B_pixel3        ;
||      MVD     .M2   B_mid_word2,        B_mid_word2c                     ;
||      MVD     .M1   A_mid_word1,        A_mid_word1c                     ;
||      ADD     .L2   B_botval03_s,       B_botval02,      B_botval_w1     ;
||      CMPEQ4  .S1   A_top_word1,        A_bot_zero,      A_upval01       ;
||      CMPEQ4  .S2   B_top_word3,        B_bot_zero,      B_upval03       ;

  [!B_pd]ADD    .L1   A_sum,              A_count,         A_sum           ;
||[!B_pd]STNDW  .D2T2 B_pixel3:B_pixel2,  *B_optr++[2]                     ;
||      SHRU    .S2   B_midval_k1,        1,               B_mid_rt_val1   ;
||      AND     .D1   A_mid_lt_val0,      A_FF,            A_mid_lt_val0   ;
||      AND     .L2   B_mid_lt_val1,      B_FF,            B_mid_lt_val1   ;
||      CMPGTU4 .S1   A_mid_word0,        A_bot_zero,      A_midval00      ;
||      MPY     .M1   A_botval01,         A_k_16,          A_botval01_s    ;
||      MPY     .M2   B_upval03,          B_k_16,          B_upval03_s     ;

        MVD     .M2   B_mid_word3,        B_mid_word3c                     ;
||[!B_rt0]ADD   .D1   A_mid_rt_val0,      A_mid_rt_const,  A_mid_rt_val0   ;
||[!A_rt1]ADD   .L2   B_mid_rt_val1,      B_mid_rt_const,  B_mid_rt_val1   ;
||[!B_lt0]ADD   .L1   A_mid_lt_val0,      A_mid_lf_const,  A_mid_lt_val0   ;
||[!A_lt1]ADD   .D2   B_mid_lt_val1,      B_mid_lf_const,  B_mid_lt_val1   ;
||      SHRU    .S2   B_mid_word3,        24,              B_lt0           ;
||      MPY     .M1   A_upval01,          A_k_16,          A_upval01_s     ;
||      CMPGTU4 .S1   A_mid_word1,        A_bot_zero,      A_midval01      ;

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

; ============================================================================
; END:


; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A19,        A_bot_zero                  ;
        .asg            A6,         A_img_out                   ;
        .asg            B4,         B_incols                    ;
        .asg            A3,         A_sum                       ;
        .asg            A4,         A_ret_val                   ;
        .asg            A0,         A_p0
        .asg            A5,         A_offset
        .asg            A0,         A_p1
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
        .asg            B0,         B_p1
        .asg            B14,        B_udrl_r
;============================================================================

        LDBU    .D1T1   *A_img_out, A_p0                                   ;
||      SUB     .S1X    B_incols,   1,          A_offset                   ;

        SHRU    .S2      B_udrl_r,  3,           B_p1
||      MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11


 [ A_p0]SUB     .L1     A_sum,      1,          A_sum                      ;
||      LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

  [ B_p1]SUB    .S1     A_sum,      1,          A_sum                      ;
||       LDW    .D1T2   *+A_SP[ 9], B13         ; Restore B13
||       LDW    .D2T1   *+B_SP[10], A13         ; Restore A13

        ;==== Branch occurs                                                ;


*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A15,        A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B3,         B_ret       ; Return address
*==============================================================================*

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14
||      RET     .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
*====== Interruptibility state restored here ==================================*

        STB     .D1T1   A_bot_zero, *+A_img_out[A_offset]                  ;

        MV      .L1     A_sum,      A_ret_val                              ;
||      STB     .D1T1   A_bot_zero, *A_img_out                             ;

        NOP             2
;====== Branch Occurs =====

*==============================================================================*
*=  End of file:  img_perimeter.asm                                          =*
*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*

pix_expand.asm/ 1066928952  0     0     0       12426     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Sun Sep 29 03:32:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_expand                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       19-Jan-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_pix_expand                                                 *
*       (                                                                   *
*           int n,                                    /* # of elements */   *
*           const unsigned char *restrict in_data,    /* Input data    */   *
*           short               *restrict out_data    /* Output data   */   *
*       )                                                                   *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code takes an array of bytes and promotes them to half-words    *
*       by zero-extension.                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code, without              *
*       restrictions.  The assembly code has restrictions, as noted below.  *
*                                                                           *
*       void IMG_pix_expand                                                 *
*       (                                                                   *
*           int n,                                                          *
*           const unsigned char *restrict in_data,                          *
*           short               *restrict out_data                          *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < n; i++)                                         *
*               out_data[i] =  in_data[i];                                  *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays must be double-word (8-byte) aligned.       *
*                                                                           *
*       The input must be at least 16 elements long and contain a           *
*       multiple of 16 elements.                                            *
*                                                                           *
*   NOTE                                                                    *
*       Interrupts are masked during the entire duration of this            *
*       function, as the entire function occurs within branch delay slots.  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.  This is a LITTLE ENDIAN implementation.   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16 times, loading bytes with LDDW.  It uses    *
*       UNPKHU4 and UNPKLU4 to unpack the data and store the results with   *
*       STDW.                                                               *
*                                                                           *
*       To shave a few extra cycles from the function, the return branch    *
*       is issued from within the kernel.                                   *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 3 * n/16 + 15.                                             *
*       For n = 1072, cycles = 216.                                         *
*                                                                           *
*   CODESIZE                                                                *
*       108 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_pix_expand"
        .global _IMG_pix_expand
_IMG_pix_expand:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,          A_i
        .asg            A2,          A_p_10
        .asg            A3,          A_p_32
        .asg            A4,          A_n
        .asg            A6,          A_o0
        .asg            A7,          A_i1
        .asg            A8,          A_p_3210
        .asg            A8,          A_p_98
        .asg            A9,          A_p_7654
        .asg            A9,          A_p_BA
        .asg            B0,          B_p
        .asg            B1,          B_e
        .asg            B3,          B_ret
        .asg            B4,          B_i0
        .asg            B5,          B_o1
        .asg            B6,          B_p_BA98
        .asg            B6,          B_p_DC
        .asg            B7,          B_p_FE
        .asg            B7,          B_p_FEDC
        .asg            B8,          B_p_54
        .asg            B9,          B_p_76
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        B               loop                                    ;[ 4,1]

        ADD             B_i0,       8,          A_i1
||      ADD             A_o0,       8,          B_o1
||      SHR             A_n,        4,          A_i

        LDDW    .D1T2   *A_i1++[2], B_p_FEDC:B_p_BA98           ;[ 1,1]
||      LDDW    .D2T1   *B_i0++[2], A_p_7654:A_p_3210           ;[ 1,1]
||      MVK             0xFFFF8000, B_p
||      MVK             1,          B_e

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_p]STDW    .D1T1   A_p_BA:A_p_98,          *A_o0[2]        ;[ 8,1]
||[!B_p]STDW    .D2T2   B_p_FE:B_p_DC,          *B_o1[2]        ;[ 8,1]
||[ A_i]BPOS    .S1     loop,       A_i                         ;[ 5,2]
||[!A_i]RET     .S2     B_ret
||      SUB     .L1     A_i,        1,          A_i
||[!A_i]ZERO    .L2     B_e
||[ B_p]MPY     .M2     B_p,        2,          B_p

  [!B_p]STDW    .D1T1   A_p_32:A_p_10,          *A_o0++[4]      ;[ 9,1]
||[!B_p]STDW    .D2T2   B_p_76:B_p_54,          *B_o1++[4]      ;[ 9,1]
||      UNPKLU4 .S1     A_p_3210,   A_p_10                      ;[ 6,2]
||      UNPKHU4 .L1     A_p_3210,   A_p_32                      ;[ 6,2]
||      UNPKLU4 .L2X    A_p_7654,   B_p_54                      ;[ 6,2]
||      UNPKHU4 .S2X    A_p_7654,   B_p_76                      ;[ 6,2]

        UNPKLU4 .S1X    B_p_BA98,   A_p_98                      ;[ 7,2]
||      UNPKHU4 .L1X    B_p_BA98,   A_p_BA                      ;[ 7,2]
||      UNPKLU4 .L2     B_p_FEDC,   B_p_DC                      ;[ 7,2]
||      UNPKHU4 .S2     B_p_FEDC,   B_p_FE                      ;[ 7,2]
||[ B_e]LDDW    .D1T2   *A_i1++[2], B_p_FEDC:B_p_BA98           ;[ 1,4]
||[ B_e]LDDW    .D2T1   *B_i0++[2], A_p_7654:A_p_3210           ;[ 1,4]

* ========================================================================= *

* ========================================================================= *
*   End of file:  img_pix_expand.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
pix_sat.asm/    1066928952  0     0     0       11789     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Sep 29 03:32:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_sat -- Pixel saturate and pack.                             *
*                                                                           *
*   REVISION DATE                                                           *
*       23-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_pix_sat                                                *
*           (                                                               *
*               int n,                            /* Number of pixels */    *
*               const short   *restrict in_data,  /* Incoming data    */    *
*               unsigned char *restrict out_data  /* Outgoing data    */    *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_pix_sat() takes signed 16-bit input pixels and     *
*       saturates them to unsigned 8-bit results.  Pixel values above       *
*       255 are clamped to 255, and values below 0 are clamped to 0.        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop has been unrolled to fill a 6 cycle loop.  This      *
*       allows the code to be interruptible.                                *
*                                                                           *
*       The prolog and epilog have been collapsed into the kernel.  Also,   *
*       most of the setup and all of the exit code has been overlapped      *
*       with the kernel.  The result is that the function runs with a       *
*       very minimum amount of overhead.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input size must be a multiple of 32 pixels.  The code behaves   *
*       correctly if a pixel count of zero is passed in.                    *
*                                                                           *
*   NOTES                                                                   *
*       This code is fully interruptible.                                   *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The input and output data must be double-word aligned.              *
*                                                                           *
*       This code accesses 128 bits every cycle.  No bank conflicts occur.  *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (pixels / 16) * 3 + 13                                     *
*       (This includes 6 cycles of function call overhead.)                 *
*       For pixels = 640, cycles = 133.                                     *
*                                                                           *
*   CODESIZE                                                                *
*       116 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_pix_sat"
        .global _IMG_pix_sat
_IMG_pix_sat:
; ====================== SYMBOLIC REGISTER ASSIGNMENTS ==================== ;
        .asg            A4,         A_n
        .asg            A0,         A_i
        .asg            A1,         A_c
        .asg            A2,         A_l
        .asg            B3,         B_ret
        .asg            A6,         A_o_data
        .asg            B4,         B_i_data
        .asg            A3,         A_i_data
        .asg            B21,        B_FE
        .asg            B20,        B_DC
        .asg            B17,        B_BA
        .asg            B16,        B_98
        .asg            B23,        B_76
        .asg            B22,        B_54
        .asg            B9,         B_32
        .asg            B8,         B_10
        .asg            A21,        A_FE
        .asg            A20,        A_DC
        .asg            A23,        A_BA
        .asg            A22,        A_98
        .asg            A25,        A_76
        .asg            A24,        A_54
        .asg            A17,        A_32
        .asg            A16,        A_10
        .asg            B19,        B_FEDC
        .asg            B18,        B_BA98
        .asg            B7,         B_7654
        .asg            B6,         B_3210
        .asg            A9,         A_FEDC
        .asg            A8,         A_BA98
        .asg            A19,        A_7654
        .asg            A18,        A_3210
        .asg            B5,         B_o_data
; ========================================================================= ;
        MV      .L1X    B_i_data,   A_i_data
||      SHRU    .S1     A_n,        5,          A_i
||      MVK     .D1     1,          A_c
; ============================ PIPE LOOP KERNEL =========================== ;
loop:
  [ A_i]BDEC    .S1     loop,       A_i                         ;[ 7,1]
||[ A_i]LDDW    .D2T1   *+B_i_data  [6],        A_BA:A_98       ;[ 1,2]
||[ A_i]LDDW    .D1T2   *+A_i_data  [1],        B_76:B_54       ;[ 1,2]
||[!A_i]RET     .S2     B_ret
||      MV      .L1     A_i,        A_l

        SPACKU4 .S1     A_FE,       A_DC,       A_FEDC          ;[ 8,1]
||      SPACKU4 .S2     B_32,       B_10,       B_3210          ;[ 8,1]
||[ A_l]LDDW    .D2T1   *+B_i_data  [7],        A_FE:A_DC       ;[ 2,2]
||[ A_l]LDDW    .D1T2   * A_i_data++[8],        B_32:B_10       ;[ 2,2]
||      MV      .L2X    A_o_data,   B_o_data

        SPACKU4 .S1     A_32,       A_10,       A_3210          ;[ 9,1]
||      SPACKU4 .S2     B_FE,       B_DC,       B_FEDC          ;[ 9,1]
||[ A_l]LDDW    .D2T1   *+B_i_data  [4],        A_32:A_10       ;[ 3,2]
||[ A_l]LDDW    .D1T2   *-A_i_data  [5],        B_FE:B_DC       ;[ 3,2]

        SPACKU4 .S1     A_76,       A_54,       A_7654          ;[10,1]
||      SPACKU4 .S2     B_BA,       B_98,       B_BA98          ;[10,1]
||[ A_l]LDDW    .D2T1   *+B_i_data  [5],        A_76:A_54       ;[ 4,2]
||[ A_l]LDDW    .D1T2   *-A_i_data  [6],        B_BA:B_98       ;[ 4,2]

  [!A_c]STDW    .D2T1   A_7654:A_3210,          *+B_o_data  [2] ;[11,1]
||[!A_c]STDW    .D1T2   B_FEDC:B_BA98,          *+A_o_data  [1] ;[11,1]

  [!A_c]STDW    .D2T1   A_FEDC:A_BA98,          *+B_o_data  [3] ;[12,1]
||[!A_c]STDW    .D1T2   B_7654:B_3210,          * A_o_data++[4] ;[12,1]
||      SPACKU4 .S1     A_BA,       A_98,       A_BA98          ;[ 6,2]
||      SPACKU4 .S2     B_76,       B_54,       B_7654          ;[ 6,2]
||      MVK     .L1     0,          A_c
||      MV      .L2X    A_i_data,   B_i_data
; ========================================================================= ;

* ========================================================================= *
*   End of file:  img_pix_sat.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

quantize.asm/   1066928952  0     0     0       35831     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:32:28 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_quantize -- Matrix Quantization w/ Rounding, Little Endian      *
*                                                                           *
*   REVISION DATE                                                           *
*       04-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short           *data,      /* Data to be quantized.        */  *
*           unsigned short  num_blks,   /* Number of blocks to process. */  *
*           unsigned short  blk_size,   /* Block size (multiple of 16). */  *
*           const short     *recip_tbl, /* Quant. values (reciprocals). */  *
*           int             q_pt        /* Q-point of Quant values.     */  *
*       )                                                                   *
*                                                                           *
*       The number of blocks, num_blks, may be zero.  The block             *
*       size (number of elements in each block) must be at least 32,        *
*       and a multiple of 16.  The Q-point, q_pt, controls rounding and     *
*       final truncation; it must be in the range from 0 <= q_pt <= 31.     *
*                                                                           *
*       Both input arrays, data[] and recip_tbl[], must be double-word      *
*       aligned.  The data[] array must be 'num_blks * blk_size' elements,  *
*       and the recip_tbl[] array must be 'blk_size' elements.              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_quantize() quantizes matrices by multiplying their *
*       contents with a second matrix that contains reciprocals of the      *
*       quantization terms.  This step corresponds to the quantization      *
*       that is performed in 2-D DCT-based compression techniques,          *
*       although IMG_quantize() may be used on any signed 16-bit data using *
*       signed 16-bit quantization terms.                                   *
*                                                                           *
*       IMG_quantize() multiplies the contents of the quantization matrix   *
*       with the data being quantized.  Therefore, it may be used for       *
*       inverse quantization as well, by setting the Q-point                *
*       appropriately.                                                      *
*                                                                           *
*       The assembly code requires 26 + (blk_size/16) * num_blks * 8        *
*       cycles to execute, including function call overhead.  This code     *
*       does not explicitly disable interrupts.  On entry to the function,  *
*       interrupts are masked by branch delay slots for a maximum of 16     *
*       cycles.                                                             *
*                                                                           *
*       The following C code describes the general implementation of        *
*       IMG_quantize().                                                     *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short           *data,      /* Data to be quantized.        */  *
*           unsigned short  num_blks,   /* Number of 64-element blocks. */  *
*           unsigned short  blk_size,   /* Block size (multiple of 16). */  *
*           const short     *recip_tbl, /* Quant. values (reciprocals). */  *
*           int             q_pt        /* Q-point of Quant values.     */  *
*       )                                                                   *
*       {                                                                   *
*           short recip;                                                    *
*           int i, j, k, quot, round;                                       *
*                                                                           *
*           round = q_pt ? 1 << (q_pt - 1) : 0;                             *
*                                                                           *
*           for (i = 0; i < blk_size; i++)                                  *
*           {                                                               *
*               recip   = recip_tbl[i];                                     *
*               k       = i;                                                *
*               for (j = 0; j < num_blks; j++)                              *
*               {                                                           *
*                   quot    = data[k] * recip + round;                      *
*                   data[k] = quot >> q_pt;                                 *
*                   k      += blk_size;                                     *
*               }                                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has restrictions, as noted above.  *
*                                                                           *
*   TECHNIQUES                                                              *
*       The outer loop is unrolled 16 times to allow greater amounts        *
*       of work to be performed in the inner loop.  The resulting loop-     *
*       nest was then collapsed and pipelined as a single loop, since       *
*       the code is not bottlenecked on bandwidth.                          *
*                                                                           *
*       Reciprocals and data terms are loaded in groups of four using       *
*       double-word loads, making best use of the available memory          *
*       bandwidth.                                                          *
*                                                                           *
*       SSHVR is used in the M-unit to avoid an S-unit bottleneck.          *
*                                                                           *
*       Twin stack pointers have been used to speed up stack accesses.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The recip_tbl[] and data[] must be double-word aligned.             *
*       The block size, blk_size, must be a multiple of 16 and at least 32. *
*       The number of blocks, num_blks, may be 0.                           *
*       The Q-point, q_pt, must be in the range 0 <= q_pt <= 31.            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur, regardless of the relative orientation     *
*       of recip_tbl[] and data[].                                          *
*                                                                           *
*       A total of 6 words of stack frame are used for saving the           *
*       Save-On-Entry registers.                                            *
*                                                                           *
*   NOTES                                                                   *
*       This code is fully interruptible, with a maximum interrupt latency  *
*       due to branch delay slots of 16.                                    *
*                                                                           *
*       Input arrays must be double-word-aligned for correct operation.     *
*                                                                           *
*       No checking is performed on the input arguments for correctness.    *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 26 + (blk_size/16) * num_blks * 8                          *
*                                                                           *
*       For blk_size =  64 and num_blks =  8, cycles =  282.                *
*       For blk_size = 256 and num_blks = 24, cycles = 3098.                *
*                                                                           *
*   CODESIZE                                                                *
*       580 bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_quantize"
        .global _IMG_quantize
_IMG_quantize:

; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg          B15,     B_SP     ; Stack pointer
        .asg          A5,      A_SP     ; Twin stack pointer
        .asg          B3,      B_ret    ; Return address
        .asg          A6,      A_blksz  ; Block size
        .asg          B6,      B_r_ptr  ; Reciprocal array pointer (twin)
        .asg          A9,      A_r_ptr  ; Reciprocal array pointer
        .asg          A10,     A_r_end  ; End of reciprocal array
        .asg          B5,      B_di_ptr ; Data 'in' pointer (twin)
        .asg          A4,      A_di_ptr ; Data 'in' pointer
        .asg          B7,      B_do_ptr ; Data 'out' pointer (twin)
        .asg          A2,      A_do_ptr ; Data 'out' pointer
        .asg          B9,      B_fix    ; Pointer fixup value.
        .asg          A6,      A_fix    ; Pointer fixup value
        .asg          A11,     A_rnd    ; Rounding term:  1 << (q_pt-1)
        .asg          B8,      B_q_pt   ; Q-point
        .asg          A8,      A_q_pt   ; Q-point
        .asg          B2,      B_j      ; Outer loop counter
        .asg          A0,      A_i      ; Inner loop control
        .asg          B23,     B_r_FE   ; Reciprocals 15, 14
        .asg          B22,     B_r_DC   ; Reciprocals 13, 12
        .asg          A29,     A_r_BA   ; Reciprocals 11, 10
        .asg          A28,     A_r_98   ; Reciprocals  9,  8
        .asg          B25,     B_r_76   ; Reciprocals  7,  6
        .asg          B24,     B_r_54   ; Reciprocals  5,  4
        .asg          A31,     A_r_32   ; Reciprocals  3,  2
        .asg          A30,     A_r_10   ; Reciprocals  1,  0
        .asg          B29,     B_d_FE   ; Data        15, 14
        .asg          B28,     B_d_DC   ; Data        13, 12
        .asg          A23,     A_d_BA   ; Data        11, 10
        .asg          A22,     A_d_98   ; Data         9,  8
        .asg          B31,     B_d_76   ; Data         7,  6
        .asg          B30,     B_d_54   ; Data         5,  4
        .asg          A25,     A_d_32   ; Data         3,  2
        .asg          A24,     A_d_10   ; Data         1,  0
        .asg          B1,      B_qp_F   ; Product: qp[15] = r[15] * d[15]
        .asg          B0,      B_qp_E   ; Product: qp[14] = r[14] * d[14]
        .asg          B13,     B_qp_D   ; Product: qp[13] = r[13] * d[13]
        .asg          B12,     B_qp_C   ; Product: qp[12] = r[12] * d[12]
        .asg          A21,     A_qp_B   ; Product: qp[11] = r[11] * d[11]
        .asg          A20,     A_qp_A   ; Product: qp[10] = r[10] * d[10]
        .asg          A19,     A_qp_9   ; Product: qp[ 9] = r[ 9] * d[ 9]
        .asg          A18,     A_qp_8   ; Product: qp[ 8] = r[ 8] * d[ 8]
        .asg          B17,     B_qp_7   ; Product: qp[ 7] = r[ 7] * d[ 7]
        .asg          B16,     B_qp_6   ; Product: qp[ 6] = r[ 6] * d[ 6]
        .asg          B21,     B_qp_5   ; Product: qp[ 5] = r[ 5] * d[ 5]
        .asg          B20,     B_qp_4   ; Product: qp[ 4] = r[ 4] * d[ 4]
        .asg          A21,     A_qp_3   ; Product: qp[ 3] = r[ 3] * d[ 3]
        .asg          A20,     A_qp_2   ; Product: qp[ 2] = r[ 2] * d[ 2]
        .asg          A27,     A_qp_1   ; Product: qp[ 1] = r[ 1] * d[ 1]
        .asg          A26,     A_qp_0   ; Product: qp[ 0] = r[ 0] * d[ 0]
        .asg          B10,     B_qr_F   ; Round:   qr[15] = qp[15] + rnd
        .asg          B4,      B_qr_E   ; Round:   qr[14] = qp[14] + rnd
        .asg          B24,     B_qr_D   ; Round:   qr[13] = qp[13] + rnd
        .asg          B26,     B_qr_C   ; Round:   qr[12] = qp[12] + rnd
        .asg          A3,      A_qr_B   ; Round:   qr[11] = qp[11] + rnd
        .asg          A25,     A_qr_A   ; Round:   qr[10] = qp[10] + rnd
        .asg          A12,     A_qr_9   ; Round:   qr[ 9] = qp[ 9] + rnd
        .asg          A1,      A_qr_8   ; Round:   qr[ 8] = qp[ 8] + rnd
        .asg          B16,     B_qr_7   ; Round:   qr[ 7] = qp[ 7] + rnd
        .asg          B10,     B_qr_6   ; Round:   qr[ 6] = qp[ 6] + rnd
        .asg          B10,     B_qr_5   ; Round:   qr[ 5] = qp[ 5] + rnd
        .asg          B20,     B_qr_4   ; Round:   qr[ 4] = qp[ 4] + rnd
        .asg          A5,      A_qr_3   ; Round:   qr[ 3] = qp[ 3] + rnd
        .asg          A12,     A_qr_2   ; Round:   qr[ 2] = qp[ 2] + rnd
        .asg          A3,      A_qr_1   ; Round:   qr[ 1] = qp[ 1] + rnd
        .asg          A16,     A_qr_0   ; Round:   qr[ 0] = qp[ 0] + rnd
        .asg          B10,     B_qt_F   ; Trunc:   qt[15] = qr[15] >> q_pt
        .asg          B19,     B_qt_E   ; Trunc:   qt[14] = qr[14] >> q_pt
        .asg          B0,      B_qt_D   ; Trunc:   qt[13] = qr[13] >> q_pt
        .asg          B18,     B_qt_C   ; Trunc:   qt[12] = qr[12] >> q_pt
        .asg          A16,     A_qt_B   ; Trunc:   qt[11] = qr[11] >> q_pt
        .asg          A19,     A_qt_A   ; Trunc:   qt[10] = qr[10] >> q_pt
        .asg          A23,     A_qt_9   ; Trunc:   qt[ 9] = qr[ 9] >> q_pt
        .asg          A3,      A_qt_8   ; Trunc:   qt[ 8] = qr[ 8] >> q_pt
        .asg          B27,     B_qt_7   ; Trunc:   qt[ 7] = qr[ 7] >> q_pt
        .asg          B4,      B_qt_6   ; Trunc:   qt[ 6] = qr[ 6] >> q_pt
        .asg          B17,     B_qt_5   ; Trunc:   qt[ 5] = qr[ 5] >> q_pt
        .asg          B4,      B_qt_4   ; Trunc:   qt[ 4] = qr[ 4] >> q_pt
        .asg          A18,     A_qt_3   ; Trunc:   qt[ 3] = qr[ 3] >> q_pt
        .asg          A17,     A_qt_2   ; Trunc:   qt[ 2] = qr[ 2] >> q_pt
        .asg          A0,      A_qt_1   ; Trunc:   qt[ 1] = qr[ 1] >> q_pt
        .asg          A7,      A_qt_0   ; Trunc:   qt[ 0] = qr[ 0] >> q_pt
        .asg          B19,     B_q_FE   ; Quotients 15, 14
        .asg          B18,     B_q_DC   ; Quotients 13, 12
        .asg          A1,      A_q_BA   ; Quotients 11, 10
        .asg          A0,      A_q_98   ; Quotients  9,  8
        .asg          B27,     B_q_76   ; Quotients  7,  6
        .asg          B26,     B_q_54   ; Quotients  5,  4
        .asg          A17,     A_q_32   ; Quotients  3,  2
        .asg          A16,     A_q_10   ; Quotients  1,  0
; ========================================================================= ;

* ========================================================================= *
*   Setup / Prolog Code                                                     *
*                                                                           *
*   This code sets up all of the pointers and controls for the inner loop,  *
*   while simultaneously saving off registers to the stack.  Heavy use of   *
*   twin pointers speeds everything up.                                     *
*                                                                           *
*   The inner loop's "r_ptr" is controlled by comparing r_ptr to an "end    *
*   of array" pointer.  Whenever r_ptr >= r_end, we subtract the "block     *
*   fixup" (blk_sz * sizeof(short)) from the pointer.  Using the r_ptr as   *
*   our inner loop counter saves an instruction which would otherwise be    *
*   used to reinitialize the inner loop counter.  (The effect on register   *
*   pressure is negligible, since we trade an inner loop counter for an     *
*   end-of-block pointer.  Although it predicate register pressure is       *
*   reduced, predicates are not an issue in this code.)                     *
*                                                                           *
*   An early-abort is taken if the loop trip count is calculated to be      *
*   zero.  This might happen if the block count is zero.  Also, because     *
*   the kernel has a minimum trip count of 2, the minimum block size that   *
*   this code supports is 32 elements.                                      *
*                                                                           *
*   To save code size, the first five cycles of the final stage of the      *
*   prolog have been collapsed.  This was achieved by branching into the    *
*   loop kernel and back out again to execute the three cycles of code      *
*   which could not be speculated.                                          *
* ========================================================================= *
;-
; =========================== PIPE LOOP PROLOG ============================ ;
        LDDW   .D1T2  *+A_di_ptr[3],    B_d_FE:B_d_DC  ;[ 1,1] Data  F,E,D,C
||      SHR    .S2X   A_blksz, 4,       B2             ; B2 = blk_sz / 16
||      ADD    .L2    B_r_ptr, 8,       B_r_ptr        ; Twin 'r_ptr'
||      MV     .L1X   B_r_ptr, A_r_ptr                 ; Twin 'r_ptr'
;-
        LDDW   .D2T2  *+B_r_ptr[2],     B_r_FE:B_r_DC  ;[ 2,1] Recip F,E,D,C
||      LDDW   .D1T1  *+A_r_ptr[2],     A_r_BA:A_r_98  ;[ 2,1] Recip B,A,9,8
||      ADD    .L1    A_blksz, A_blksz, A_fix          ; fix = blk_sz * 2
||      MV     .L2X   A_q_pt,  B_q_pt                  ; Partition MV.
||      ADD    .S1    A_q_pt,  -1,      A3             ; A3 = q_pt - 1
||      MPYU   .M2    B2,      B4,      B0             ; Set up trip count

        LDDW   .D1T1  *+A_di_ptr[2],    A_d_BA:A_d_98  ;[ 3,1] Data  B,A,9,8
||      MV     .L1X   B_SP,    A_SP                    ; Twin stack pointer

;-
  [ B0] MV     .L1    A_di_ptr,         A_do_ptr       ; Initialize 'do_ptr'
||[ B0] ADD    .L2X   A_di_ptr,    8,   B_di_ptr       ; Twin 'di_ptr'
||[ B0] ADD    .S2X   A_di_ptr,    8,   B_do_ptr       ; Twin 'do_ptr'
||[ B0] STW    .D2T2  B10,     * B_SP--[6]             ; Save B10
||[ B0] STW    .D1T1  A12,     *-A_SP[5]               ; Save A12
;-
  [ B0] MV     .L2X   A_fix,   B_fix                   ; Twin 'fix'
||[ B0] ADD    .S1    A_fix,   A_r_ptr, A_r_end        ; Set "end of r[]" ptr
||[ B0] ADD    .S2    B0,      -2,      B_j            ; Adjust for para iters
||[ B0] STDW   .D1T1  A11:A10, *-A_SP[ 2]              ; Save A11, A10
||[ B0] STDW   .D2T2  B13:B12, *+B_SP[ 2]              ; Save B13, B12
||[ B0] MVK    .L1    1,       A_rnd

  [ B0] LDDW   .D2T2  *B_di_ptr++[4],   B_d_76:B_d_54  ;[ 5,1] Data  7,6,5,4
||[!B0] RET    .S2    B_ret                            ; Abort if trip cnt == 0
||[ B0] SHL    .S1    A_rnd,   A3,      A_rnd          ; rnd = 1 << (q_pt-1)
;-
  [ B0] LDDW   .D1T1  *A_r_ptr++[4],    A_r_32:A_r_10  ;[ 6,1] Recip 3,2,1,0
||[ B0] LDDW   .D2T2  *B_r_ptr++[4],    B_r_76:B_r_54  ;[ 6,1] Recip 7,6,5,4

  [ B0] MPY2   .M2    B_d_DC,  B_r_DC,  B_qp_D:B_qp_C  ;[ 7,1] qp[n]=d[n]*r[n]
||[ B0] LDDW   .D1T1  *A_di_ptr++[4],   A_d_32:A_d_10  ;[ 7,1] Data  3,2,1,0

  [ B0] MPY2   .M1    A_d_BA,  A_r_BA,  A_qp_B:A_qp_A  ;[ 8,1] qp[n]=d[n]*r[n]
||[ B0] B      .S1    j_loop_1                         ; Prolog collapse

  [ B0] LDDW   .D2T2  *+B_di_ptr[2],    B_d_FE:B_d_DC  ;[ 1,2] Data  F,E,D,C
||[ B0] MPY2   .M2    B_d_FE,  B_r_FE,  B_qp_F:B_qp_E  ;[ 9,1] qp[n]=d[n]*r[n]
;-
  [ B0] MPY2   .M1    A_d_98,  A_r_98,  A_qp_9:A_qp_8  ;[10,1] qp[n]=d[n]*r[n]
||[ B0] LDDW   .D1T1  *+A_r_ptr[2],     A_r_BA:A_r_98  ;[ 2,2] Recip B,A,9,8
||[ B0] LDDW   .D2T2  *+B_r_ptr[2],     B_r_FE:B_r_DC  ;[ 2,2] Recip F,E,D,C

        ADD    .S2X   B_qp_C,  A_rnd,   B_qr_C         ;[11,1] qp_C=qr_C+rnd
||      ADD    .L2X   B_qp_D,  A_rnd,   B_qr_D         ;[11,1] qp_D=qr_D+rnd
||      MPY2   .M2    B_d_54,  B_r_54,  B_qp_5:B_qp_4  ;[11,1] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *+A_di_ptr[2],    A_d_BA:A_d_98  ;[ 3,2] Data  B,A,9,8
;-
        SHR    .S2    B_qr_C,  B_q_pt,  B_qt_C         ;[12,1] qt_C=qr_C>>q_pt
||      ADD    .L1    A_qp_A,  A_rnd,   A_qr_A         ;[12,1] qp_A=qr_A+rnd
||      ADD    .D1    A_qp_B,  A_rnd,   A_qr_B         ;[12,1] qp_B=qr_B+rnd
||      MPY2   .M1    A_d_32,  A_r_32,  A_qp_3:A_qp_2  ;[12,1] qp[n]=d[n]*r[n]
||      SSHVR  .M2    B_qr_D,  B_q_pt,  B_qt_D         ;[13,1] qt_D=qr_D>>q_pt
;-
        SHR    .S1    A_qr_B,  A_q_pt,  A_qt_B         ;[13,1] qt_B=qr_B>>q_pt
||      ADD    .L2X   B_qp_E,  A_rnd,   B_qr_E         ;[13,1] qp_E=qr_E+rnd
||      MPY2   .M2    B_d_76,  B_r_76,  B_qp_7:B_qp_6  ;[13,1] qp[n]=d[n]*r[n]
||      LDDW   .D2T2  *B_di_ptr++[4],   B_d_76:B_d_54  ;[ 5,2] Data  7,6,5,4
||      B             j_loop_p                         ; Prolog collapse
; ===== Branch Occurs (j_loop) =====

; ===== 5 cycles of prolog collapsed =====

;-
j_loop_p:
        PACK2  .S1    A_qt_9,  A_qt_8,  A_q_98         ;[19,1] Packed quot 9,8
||      SSHVR  .M1    A_qr_0,  A_q_pt,  A_qt_0         ;[19,1] qt_0=qr_0>>q_pt
||      ADD    .S2X   B_qp_C,  A_rnd,   B_qr_C         ;[11,2] qp_C=qr_C+rnd
||      ADD    .L2X   B_qp_D,  A_rnd,   B_qr_D         ;[11,2] qp_D=qr_D+rnd
||      MPY2   .M2    B_d_54,  B_r_54,  B_qp_5:B_qp_4  ;[11,2] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *+A_di_ptr[2],    A_d_BA:A_d_98  ;[ 3,3] Data  B,A,9,8
;-
        STDW   .D2T2  B_q_FE:B_q_DC,    *+B_do_ptr[2]  ;[20,1] Quot. F,E,D,C
||      PACK2  .L2    B_qt_5,  B_qt_4,  B_q_54         ;[20,1] Packed quot 5,4
||      SSHVR  .M2    B_qr_7,  B_q_pt,  B_qt_7         ;[20,1] qt_7=qr_7>>q_pt
||      SHR    .S2    B_qr_C,  B_q_pt,  B_qt_C         ;[12,2] qt_C=qr_C>>q_pt
||      ADD    .L1    A_qp_A,  A_rnd,   A_qr_A         ;[12,2] qp_A=qr_A+rnd
||      ADD    .S1    A_qp_B,  A_rnd,   A_qr_B         ;[12,2] qp_B=qr_B+rnd
||      MPY2   .M1    A_d_32,  A_r_32,  A_qp_3:A_qp_2  ;[12,2] qp[n]=d[n]*r[n]
;-
; ============================ PIPE LOOP KERNEL ==============================
j_loop:
        STDW   .D1T1  A_q_BA:A_q_98,    *+A_do_ptr[2]  ;[21,1] Quot. B,A,9,8
||      SSHVR  .M1    A_qr_2,  A_q_pt,  A_qt_2         ;[21,1] qt_2=qr_2>>q_pt
||      ADD    .L1    A_qp_1,  A_rnd,   A_qr_1         ;[21,1] qp_1=qr_1+rnd
||      SHR    .S1    A_qr_B,  A_q_pt,  A_qt_B         ;[13,2] qt_B=qr_B>>q_pt
||      SHR    .S2    B_qr_D,  B_q_pt,  B_qt_D         ;[13,2] qt_D=qr_D>>q_pt
||      ADD    .L2X   B_qp_E,  A_rnd,   B_qr_E         ;[13,2] qp_E=qr_E+rnd
||      MPY2   .M2    B_d_76,  B_r_76,  B_qp_7:B_qp_6  ;[13,2] qp[n]=d[n]*r[n]
||      LDDW   .D2T2  *B_di_ptr++[4],   B_d_76:B_d_54  ;[ 5,3] Data  7,6,5,4
;-
j_loop_1:
        SSHVR  .M2    B_qr_6,  B_q_pt,  B_qt_6         ;[22,1] qt_6=qr_6>>q_pt
||      SHR    .S1    A_qr_A,  A_q_pt,  A_qt_A         ;[14,2] qt_A=qr_A>>q_pt
||      SHR    .S2    B_qr_E,  B_q_pt,  B_qt_E         ;[14,2] qt_E=qr_E>>q_pt
||      ADD    .L1    A_qp_9,  A_rnd,   A_qr_9         ;[14,2] qp_9=qr_9+rnd
||      ADD    .L2X   B_qp_F,  A_rnd,   B_qr_F         ;[14,2] qp_F=qr_F+rnd
||      MPY2   .M1    A_d_10,  A_r_10,  A_qp_1:A_qp_0  ;[14,2] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *A_r_ptr++[4],    A_r_32:A_r_10  ;[ 6,3] Recip 3,2,1,0
||      LDDW   .D2T2  *B_r_ptr++[4],    B_r_76:B_r_54  ;[ 6,3] Recip 7,6,5,4
;-
j_loop_2:
        BDEC   .S2    j_loop,  B_j                     ;[24,1] while (j-->0)
||      SSHVR  .M1    A_qr_3,  A_q_pt,  A_qt_3         ;[23,1] qt_3=qr_3>>q_pt
||      PACK2  .L2    B_qt_D,  B_qt_C,  B_q_DC         ;[15,2] Packed quot D,C
||      ADD    .D2X   B_qp_4,  A_rnd,   B_qr_4         ;[15,2] qp_4=qr_4+rnd
||      ADD    .S1    A_qp_8,  A_rnd,   A_qr_8         ;[15,2] qp_8=qr_8+rnd
||      MPY2   .M2    B_d_DC,  B_r_DC,  B_qp_D:B_qp_C  ;[ 7,3] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *A_di_ptr++[4],   A_d_32:A_d_10  ;[ 7,3] Data  3,2,1,0
||      CMPLTU .L1    A_r_ptr, A_r_end, A_i            ;[ 7,3] while (r<r_end)
;-
j_loop_3:
        PACK2  .L2    B_qt_7,  B_qt_6,  B_q_76         ;[24,1] Packed quot 7,6
||      SHR    .S2    B_qr_F,  B_q_pt,  B_qt_F         ;[15,2] qt_F=qr_F>>q_pt
||      SSHVR  .M2    B_qr_4,  B_q_pt,  B_qt_4         ;[16,2] qt_4=qr_4>>q_pt
||      SHR    .S1    A_qr_9,  A_q_pt,  A_qt_9         ;[16,2] qt_9=qr_9>>q_pt
||      ADD    .D1    A_qp_2,  A_rnd,   A_qr_2         ;[16,2] qp_2=qr_2+rnd
||      ADD    .L1    A_qp_3,  A_rnd,   A_qr_3         ;[16,2] qp_3=qr_3+rnd
||      MPY2   .M1    A_d_BA,  A_r_BA,  A_qp_B:A_qp_A  ;[ 8,3] qp[n]=d[n]*r[n]
||[!A_i]SUB    .D2    B_r_ptr, B_fix,   B_r_ptr        ;[ 8,3] (o) update r_ptr
;-
j_loop_4:
        PACK2  .L1    A_qt_3,  A_qt_2,  A_q_32         ;[25,1] Packed quot 3,2
||      SSHVR  .M1    A_qr_1,  A_q_pt,  A_qt_1         ;[25,1] qt_1=qr_1>>q_pt
||      PACK2  .S2    B_qt_F,  B_qt_E,  B_q_FE         ;[17,2] Packed quot F,E
||      SHR    .S1    A_qr_8,  A_q_pt,  A_qt_8         ;[17,2] qt_8=qr_8>>q_pt
||      ADD    .L2X   B_qp_5,  A_rnd,   B_qr_5         ;[17,2] qp_5=qr_5+rnd
||      MPY2   .M2    B_d_FE,  B_r_FE,  B_qp_F:B_qp_E  ;[ 9,3] qp[n]=d[n]*r[n]
||[!A_i]SUB    .D1    A_r_ptr, A_fix,   A_r_ptr        ;[ 9,3] (o) update r_ptr
||      LDDW   .D2T2  *+B_di_ptr[2],    B_d_FE:B_d_DC  ;[ 1,4] Data  F,E,D,C
;-
j_loop_5:
        PACK2  .S1    A_qt_B,  A_qt_A,  A_q_BA         ;[18,2] Packed quot B,A
||      SSHVR  .M2    B_qr_5,  B_q_pt,  B_qt_5         ;[18,2] qt_5=qr_5>>q_pt
||      ADD    .L1    A_qp_0,  A_rnd,   A_qr_0         ;[18,2] qp_0=qr_0+rnd
||      ADD    .L2X   B_qp_6,  A_rnd,   B_qr_6         ;[18,2] qp_6=qr_6+rnd
||      ADD    .S2X   B_qp_7,  A_rnd,   B_qr_7         ;[18,2] qp_7=qr_7+rnd
||      MPY2   .M1    A_d_98,  A_r_98,  A_qp_9:A_qp_8  ;[10,3] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *+A_r_ptr[2],     A_r_BA:A_r_98  ;[ 2,4] Recip B,A,9,8
||      LDDW   .D2T2  *+B_r_ptr[2],     B_r_FE:B_r_DC  ;[ 2,4] Recip F,E,D,C
;-
j_loop_6:
        STDW   .D2T2  B_q_76:B_q_54,    *B_do_ptr++[4] ;[27,1] Quot. 7,6,5,4
||      PACK2  .L1    A_qt_1,  A_qt_0,  A_q_10         ;[27,1] Packed quot 1,0
||      PACK2  .S1    A_qt_9,  A_qt_8,  A_q_98         ;[19,2] Packed quot 9,8
||      SSHVR  .M1    A_qr_0,  A_q_pt,  A_qt_0         ;[19,2] qt_0=qr_0>>q_pt
||      ADD    .S2X   B_qp_C,  A_rnd,   B_qr_C         ;[11,3] qp_C=qr_C+rnd
||      ADD    .L2X   B_qp_D,  A_rnd,   B_qr_D         ;[11,3] qp_D=qr_D+rnd
||      MPY2   .M2    B_d_54,  B_r_54,  B_qp_5:B_qp_4  ;[11,3] qp[n]=d[n]*r[n]
||      LDDW   .D1T1  *+A_di_ptr[2],    A_d_BA:A_d_98  ;[ 3,4] Data  B,A,9,8
;-
j_loop_7:
        STDW   .D1T1  A_q_32:A_q_10,    *A_do_ptr++[4] ;[28,1] Quot. 3,2,1,0
||      STDW   .D2T2  B_q_FE:B_q_DC,    *+B_do_ptr[2]  ;[20,2] Quot. F,E,D,C
||      PACK2  .L2    B_qt_5,  B_qt_4,  B_q_54         ;[20,2] Packed quot 5,4
||      SSHVR  .M2    B_qr_7,  B_q_pt,  B_qt_7         ;[20,2] qt_7=qr_7>>q_pt
||      SHR    .S2    B_qr_C,  B_q_pt,  B_qt_C         ;[12,3] qt_C=qr_C>>q_pt
||      ADD    .L1    A_qp_A,  A_rnd,   A_qr_A         ;[12,3] qp_A=qr_A+rnd
||      ADD    .S1    A_qp_B,  A_rnd,   A_qr_B         ;[12,3] qp_B=qr_B+rnd
||      MPY2   .M1    A_d_32,  A_r_32,  A_qp_3:A_qp_2  ;[12,3] qp[n]=d[n]*r[n]
;-
; ========================================================================= ;

* ========================================================================= *
*   Cleanup / Epilog Code                                                   *
*                                                                           *
*   Since the return address was not saved on the stack, we begin our       *
*   return to caller immediately on exiting the loop kernel.                *
*                                                                           *
*   To save code size, all but the final stage of epilog has been           *
*   collapsed.  For speed, the remaining epilog instructions have been      *
*   scheduled in the delay slots of the return branch.                      *
*                                                                           *
*   Twin stack pointers are used to load the Save-On-Entry registers from   *
*   the stack as quickly as possible.                                       *
* ========================================================================= *

; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            A0,         A_SP      ; Stack pointer, B datapath
        .asg            B3,         B_ret     ; Return address
; ========================================================================= ;
        STDW   .D1T1  A_q_BA:A_q_98,    *+A_do_ptr[2]  ;[21,2] Quot. B,A,9,8
||      SSHVR  .M1    A_qr_2,  A_q_pt,  A_qt_2         ;[21,2] qt_2=qr_2>>q_pt
||      ADD    .L1    A_qp_1,  A_rnd,   A_qr_1         ;[21,2] qp_1=qr_1+rnd
||      MV     .S1X   B_SP,    A_SP                    ; Twin the stack ptr.

        LDDW   .D1T2  *+ A_SP[ 2], B13:B12             ; Restore B13,B12
||      LDDW   .D2T1  *+ B_SP[ 1], A11:A10             ; Restore A11,A10
||      RET    .S2    B_ret                            ; Return to caller
||      SHR    .S1    A_qr_3,  A_q_pt,  A_qt_3         ;[23,4] qt_3=qr_3>>q_pt
;-
        LDW    .D2T2  *++B_SP[ 6], B10                 ; Load val of B10
||      LDW    .D1T1  *+ A_SP[ 1], A12                 ; Load val of A12
||      SHR    .S2    B_qr_6,  B_q_pt,  B_qt_6         ;[22,4] qt_6=qr_6>>q_pt

        PACK2  .L2    B_qt_7,  B_qt_6,  B_q_76         ;[24,4] Packed quot 7,6
||      PACK2  .L1    A_qt_3,  A_qt_2,  A_q_32         ;[25,4] Packed quot 3,2
||      SHR    .S1    A_qr_1,  A_q_pt,  A_qt_1         ;[25,4] qt_1=qr_1>>q_pt

        STDW   .D2T2  B_q_76:B_q_54,    *B_do_ptr      ;[27,4] Quot. 7,6,5,4

        PACK2  .L1    A_qt_1,  A_qt_0,  A_q_10         ;[27,4] Packed quot 1,0
;-
        STDW   .D1T1  A_q_32:A_q_10,    *A_do_ptr      ;[28,4] Quot. 3,2,1,0

; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  img_quantize.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sad_16x16.asm/  1066928952  0     0     0       13752     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Sep 29 03:32:28 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_16x16 -- Sum of Absolute Differences on single 16x16 block  *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_16x16                                              *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 16x16 source block */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 16x16 source block (srcImg),      *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 16x16 region pointed to in the     *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 16x16 region.     *
*       It returns the final accumulation.                                  *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm that lacks   *
*       restrictions.  The assembly code may have additional restrictions   *
*       as noted below.                                                     *
*                                                                           *
*           unsigned IMG_sad_16x16                                          *
*           (                                                               *
*               const unsigned char *restrict srcImg,                       *
*               const unsigned char *restrict refImg,                       *
*               int pitch                                                   *
*           )                                                               *
*           {                                                               *
*               int i, j;                                                   *
*               unsigned sad = 0;                                           *
*                                                                           *
*               for (i = 0; i < 16; i++)                                    *
*                   for (j = 0; j < 16; j++)                                *
*                       sad += abs(srcImg[j+i*16] - refImg[j+i*pitch]);     *
*                                                                           *
*               return sad;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Some versions of this kernel may assume that srcImg is double-      *
*       word aligned.                                                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       Endian Neutral.                                                     *
*                                                                           *
*   NOTES                                                                   *
*       This kernel blocks interrupts for 61 cycles.                        *
*                                                                           *
*   CYCLES                                                                  *
*       67 cycles                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       168 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_16x16"
        .global _IMG_sad_16x16
_IMG_sad_16x16:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_p
        .asg            A1,         A_i
        .asg            A2,         A_s0
        .asg            A3,         A_k1
        .asg            A4,         A_srcImg
        .asg            A4,         A_retval
        .asg            A5,         A_sad
        .asg            A6,         A_pitch
        .asg            A6,         A_s3210
        .asg            A7,         A_d7654
        .asg            A7,         A_s7654
        .asg            A8,         A_r3210
        .asg            A8,         A_s1
        .asg            A9,         A_d3210
        .asg            A9,         A_r7654
        .asg            B3,         B_retaddr
        .asg            B4,         B_refImg
        .asg            B5,         B_pitch
        .asg            B6,         B_rBA98
        .asg            B7,         B_dFEDC
        .asg            B7,         B_rFEDC
        .asg            B8,         B_dBA98
        .asg            B8,         B_sBA98
        .asg            B9,         B_sFEDC
        .asg            B16,        B_sad
        .asg            B17,        B_srcImg
        .asg            B18,        B_s2
        .asg            B19,        B_s3
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D2T2   *+B_refImg(8),          B_rFEDC:B_rBA98 ;[ 1,1]
||      B       .S2     loop
||      MVK     .S1     0x0101,     A_k1
||      ADD     .L2X    A_srcImg,   8,          B_srcImg

        LDDW    .D1T1   *A_srcImg++(16),        A_s7654:A_s3210 ;[ 2,1]
||      LDDW    .D2T2   *B_srcImg++(16),        B_sFEDC:B_sBA98 ;[ 2,1]
||      MV      .L2X    A_pitch,    B_pitch
||      PACK2   .L1     A_k1,       A_k1,       A_k1

        LDNDW   .D2T1   *B_refImg++(B_pitch),   A_r7654:A_r3210 ;[ 3,1]
||      ZERO    .L2     B_sad
||      ZERO    .L1     A_sad
||      MVK     .S1     15,         A_i
||      MVK     .D1     3,          A_p

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!A_p]ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,1]
||[!A_p]ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,1]
||[ A_i]BDEC    .S1     loop,       A_i                         ;[10,2]
||      DOTPU4  .M1     A_d3210,    A_k1,       A_s0            ;[10,2]
||      SUBABS4 .L2     B_sFEDC,    B_rFEDC,    B_dFEDC         ;[ 7,3]
||      LDNDW   .D2T2   *+B_refImg(8),          B_rFEDC:B_rBA98 ;[ 1,5]

  [!A_p]ADD     .S2     B_sad,      B_s2,       B_sad           ;[14,1]
||      DOTPU4  .M2X    B_dFEDC,    A_k1,       B_s3            ;[ 8,3]
||      SUBABS4 .L1     A_s7654,    A_r7654,    A_d7654         ;[ 8,3]
||      SUBABS4 .L2     B_sBA98,    B_rBA98,    B_dBA98         ;[ 8,3]
||      LDDW    .D1T1   *A_srcImg++(16),        A_s7654:A_s3210 ;[ 2,5]
||      LDDW    .D2T2   *B_srcImg++(16),        B_sFEDC:B_sBA98 ;[ 2,5]

  [ A_p]SUB     .D1     A_p,        1,          A_p             ;[15,1]
||[!A_p]ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,1]
||      DOTPU4  .M1     A_d7654,    A_k1,       A_s1            ;[ 9,3]
||      DOTPU4  .M2X    B_dBA98,    A_k1,       B_s2            ;[ 9,3]
||      SUBABS4 .L1     A_s3210,    A_r3210,    A_d3210         ;[ 9,3]
||      LDNDW   .D2T1   *B_refImg++(B_pitch),   A_r7654:A_r3210 ;[ 3,5]

* =========================== PIPE LOOP EPILOG ============================ *
        ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,4]
||      ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,4]
||      DOTPU4  .M1     A_d3210,    A_k1,       A_s0            ;[10,5]

        ADD     .L2     B_sad,      B_s2,       B_sad           ;[14,4]
||      RET     .S2     B_retaddr

        ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,4]

        ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,5]
||      ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,5]

        ADD     .S2     B_sad,      B_s2,       B_sad           ;[14,5]

        ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,5]

        ADD     .S1X    A_sad,      B_sad,      A_retval
* ========================================================================= *
* ========================================================================= *
*   End of file: img_sad_16x16.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
sad_8x8.asm/    1066928952  0     0     0       13705     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:32:29 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_8x8 -- Sum of Absolute Differences on single 16x16 block    *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_8x8                                                *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 8x8 source block   */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 8x8 source block (srcImg),        *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 8x8 region pointed to in the       *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 8x8 region.       *
*       It returns the final accumulation.                                  *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm that lacks   *
*       restrictions.  The assembly code may have additional restrictions   *
*       as noted below.                                                     *
*                                                                           *
*           unsigned IMG_sad_8x8                                            *
*           (                                                               *
*               const unsigned char *restrict srcImg,                       *
*               const unsigned char *restrict refImg,                       *
*               int pitch                                                   *
*           )                                                               *
*           {                                                               *
*               int i, j;                                                   *
*               unsigned sad = 0;                                           *
*                                                                           *
*               for (i = 0; i < 8; i++)                                     *
*                   for (j = 0; j < 8; j++)                                 *
*                       sad += abs(srcImg[j+i*8] - refImg[j+i*pitch]);      *
*                                                                           *
*               return sad;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Some versions of this kernel may assume that srcImg is double-      *
*       word aligned.                                                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       Endian Neutral.                                                     *
*                                                                           *
*   NOTES                                                                   *
*       This kernel blocks interrupts for 25 cycles.                        *
*                                                                           *
*   CYCLES                                                                  *
*       31 cycles                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       164 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_8x8"
        .global _IMG_sad_8x8
_IMG_sad_8x8:  
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_p
        .asg            A1,         A_i
        .asg            A2,         A_s0
        .asg            A3,         A_k1
        .asg            A4,         A_srcImg
        .asg            A4,         A_retval
        .asg            A5,         A_sad
        .asg            A6,         A_pitch
        .asg            A6,         A_s3210
        .asg            A7,         A_d7654
        .asg            A7,         A_s7654
        .asg            A8,         A_r3210
        .asg            A8,         A_s1
        .asg            A9,         A_d3210
        .asg            A9,         A_r7654
        .asg            B3,         B_retaddr
        .asg            B4,         B_refImg
        .asg            B5,         B_pitch
        .asg            B6,         B_r3210
        .asg            B7,         B_d7654
        .asg            B7,         B_r7654
        .asg            B8,         B_d3210
        .asg            B8,         B_s3210
        .asg            B9,         B_s7654
        .asg            B16,        B_sad
        .asg            B17,        B_srcImg
        .asg            B18,        B_s2
        .asg            B19,        B_s3
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D2T2   *B_refImg,              B_r7654:B_r3210 ;[ 1,1]
||      B       .S2     loop
||      MVK     .S1     0x0101,     A_k1
||      ADD     .L2X    A_srcImg,   8,          B_srcImg

        LDDW    .D2T1   *B_srcImg++(16),        A_s7654:A_s3210 ;[ 2,1]
||      LDDW    .D1T2   *A_srcImg++(16),        B_s7654:B_s3210 ;[ 2,1]
||      MV      .L2X    A_pitch,    B_pitch
||      PACK2   .L1     A_k1,       A_k1,       A_k1

        LDNDW   .D2T1   *++B_refImg(B_pitch),   A_r7654:A_r3210 ;[ 3,1]
||      ZERO    .L2     B_sad
||      ZERO    .L1     A_sad
||      MVK     .S1     3,          A_i

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!A_i]ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,1]
||[!A_i]ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,1]
||[ A_i]B       .S1     loop                                    ;[10,2]
||      DOTPU4  .M1     A_d3210,    A_k1,       A_s0            ;[10,2]
||      SUBABS4 .L2     B_s7654,    B_r7654,    B_d7654         ;[ 7,3]
||      LDNDW   .D2T2   *++B_refImg(B_pitch),   B_r7654:B_r3210 ;[ 1,5]

  [!A_i]ADD     .S2     B_sad,      B_s2,       B_sad           ;[14,1]
||      DOTPU4  .M2X    B_d7654,    A_k1,       B_s3            ;[ 8,3]
||      SUBABS4 .L1     A_s7654,    A_r7654,    A_d7654         ;[ 8,3]
||      SUBABS4 .L2     B_s3210,    B_r3210,    B_d3210         ;[ 8,3]
||      LDDW    .D2T1   *B_srcImg++(16),        A_s7654:A_s3210 ;[ 2,5]
||      LDDW    .D1T2   *A_srcImg++(16),        B_s7654:B_s3210 ;[ 2,5]

  [ A_i]SUB     .D1     A_i,        1,          A_i             ;[15,1]
||[!A_i]ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,1]
||      DOTPU4  .M1     A_d7654,    A_k1,       A_s1            ;[ 9,3]
||      DOTPU4  .M2X    B_d3210,    A_k1,       B_s2            ;[ 9,3]
||      SUBABS4 .L1     A_s3210,    A_r3210,    A_d3210         ;[ 9,3]
||      LDNDW   .D2T1   *++B_refImg(B_pitch),   A_r7654:A_r3210 ;[ 3,5]

* =========================== PIPE LOOP EPILOG ============================ *
        ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,4]
||      ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,4]
||      DOTPU4  .M1     A_d3210,    A_k1,       A_s0            ;[10,5]

        ADD     .L2     B_sad,      B_s2,       B_sad           ;[14,4]
||      RET     .S2     B_retaddr

        ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,4]

        ADD     .L1     A_sad,      A_s1,       A_sad           ;[13,5]
||      ADD     .S2     B_sad,      B_s3,       B_sad           ;[13,5]

        ADD     .S2     B_sad,      B_s2,       B_sad           ;[14,5]

        ADD     .S1     A_sad,      A_s0,       A_sad           ;[15,5]

        ADD     .S1X    A_sad,      B_sad,      A_retval
* ========================================================================= *
* ========================================================================= *
*   End of file: img_sad_8x8.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sobel.asm/      1066928952  0     0     0       39291     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Fri Oct 10 16:01:13 2003 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_sobel, Little Endian.                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Oct-2003                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_sobel                                                      *
*       (                                                                   *
*           const unsigned char *in_data,      /* Input image data  */      *
*           unsigned char       *out_data,     /* Output image data */      *
*           short cols, short rows             /* Image dimensions  */      *
*       )                                                                   *
*                                                                           *
*       The IMG_sobel filter is applied to the input image. The input image *
*       dimensions are given by the arguments 'cols' and 'rows'.  The       *
*       output image is 'cols' pixels wide and 'rows - 2' pixels tall.      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       To see how the implementation is going to work on the input         *
*       buffer, lets imagine we have the following input buffer:            *
*                                                                           *
*               yyyyyyyyyyyyyyyy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yyyyyyyyyyyyyyyy                                            *
*                                                                           *
*       The output buffer would be:                                         *
*                                                                           *
*               tXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXt                                            *
*                                                                           *
*       Where:                                                              *
*                                                                           *
*           X = IMG_sobel(x)    The algorithm is applied to that pixel.     *
*                           The correct output is obtained, the data        *
*                           around the pixels we work on is used            *
*                                                                           *
*           t               Whatever was in the output buffer in that       *
*                           position is kept there.                         *
*                                                                           *
*           z = IMG_sobel(y)    The algorithm is applied to that pixel.     *
*                           The output is not meaningful, because the       *
*                           necessary data to process the pixel is not      *
*                           available.  This is because for each output     *
*                           pixel we need input pixels from the right and   *
*                           from the left of the output pixel.  But this    *
*                           data doesn't exist.                             *
*                                                                           *
*       This means that we will only process (rows-2) lines.  Then, we      *
*       will process all the pixels inside each line. Even though the       *
*       results for the first and last pixels in each line will not         *
*       be relevant, it makes the control much simpler and ends up          *
*       saving cycles.                                                      *
*                                                                           *
*       Also the first pixel in the first processed line and the            *
*       last pixel in the last processed line will not be computed.         *
*       It is not necessary, since the results would be bogus.              *
*                                                                           *
*       The following horizontal and vertical masks that are                *
*       applied to the input buffer to obtain one output pixel.             *
*                                                                           *
*           Horizontal:                                                     *
*               -1 -2 -1                                                    *
*                0  0  0                                                    *
*                1  2  1                                                    *
*                                                                           *
*           Vertical:                                                       *
*               -1  0  1                                                    *
*               -2  0  2                                                    *
*               -1  0  1                                                    *
*                                                                           *
*       This is a C model of the Sobel implementation.  This C code         *
*       is functionally equivalent to the assembly code without             *
*       restrictions.   The assembly code may impose additional             *
*       restrictions.                                                       *
*                                                                           *
*           void IMG_sobel                                                  *
*           (                                                               *
*               const unsigned char *in,       /* Input image data  */      *
*               unsigned char       *out,      /* Output image data */      *
*               short cols, short rows         /* Image dimensions  */      *
*           )                                                               *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Intermediate values.                            */      *
*               /* ------------------------------------------------ */      *
*               int H;    /* Horizontal mask result                 */      *
*               int V;    /* Vertical mask result                   */      *
*               int O;    /* Sum of horizontal and vertical masks   */      *
*               int i;    /* Input pixel offset                     */      *
*               int o;    /* Output pixel offset.                   */      *
*               int xy;   /* Loop counter.                          */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Input values.                                   */      *
*               /* ------------------------------------------------ */      *
*               int i00, i01, i02;                                          *
*               int i10,      i12;                                          *
*               int i20, i21, i22;                                          *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Step through the entire image.  We step         */      *
*               /*  through 'rows - 2' rows in the output image,    */      *
*               /*  since those are the only rows that are fully    */      *
*               /*  defined for our filter.                         */      *
*               /* ------------------------------------------------ */      *
*               for (xy = 0, i = cols + 1, o = 1;                           *
*                    xy < cols*(rows-2) - 2;                                *
*                    xy++, i++, o++)                                        *
*               {                                                           *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Read necessary data to process an input     */      *
*                   /*  pixel.  The following instructions are      */      *
*                   /*  written to reflect the position of the      */      *
*                   /*  input pixels in reference to the pixel      */      *
*                   /*  being processed, which would correspond     */      *
*                   /*  to the blank space left in the middle.      */      *
*                   /* -------------------------------------------- */      *
*                   i00=in[i-cols-1]; i01=in[i-cols]; i02=in[i-cols+1];     *
*                   i10=in[i     -1];                 i12=in[i     +1];     *
*                   i20=in[i+cols-1]; i21=in[i+cols]; i22=in[i+cols+1];     *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the horizontal mask.                  */      *
*                   /* -------------------------------------------- */      *
*                   H = -i00 - 2*i01 -   i02 +   i20 + 2*i21 + i22;         *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the vertical mask.                    */      *
*                   /* -------------------------------------------- */      *
*                   V = -i00 +   i02 - 2*i10 + 2*i12 -   i20 + i22;         *
*                                                                           *
*                   O = abs(H) + abs(V);                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  If the result is over 255 (largest valid    */      *
*                   /*  pixel value), saturate (clamp) to 255.      */      *
*                   /* -------------------------------------------- */      *
*                   if (O > 255) O = 255;                                   *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the result.                           */      *
*                   /* -------------------------------------------- */      *
*                   out[o] = O;                                             *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       Eight output pixels are computed per iteration using loop unrolling *
*       and packed operations.                                              *
*       The prolog is only partially collapsed because use of predicate is  *
*       not possible since there is no free instruction slot avaible in     *
*       the kernel.                                                         *
*       The last stage of the epilog is kept to accommodate for the         *
*       exception of storing only 6 outputs in the last iteration.          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least eight output pixels must be processed.                     *
*       The input image width must be even (eg. 'cols' must be even).       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur ever.                                       *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*       The image arrays do not need to be aligned.                         *
*                                                                           *
*       The values of the left-most and right-most pixels on each line      *
*       of the output are not well-defined.                                 *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 11 * cols * (rows-2)/8 + 23                                *
*       For cols = 128 and rows = 128, cycles = 22,199.                     *
*                                                                           *
*   CODESIZE                                                                *
*       688 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sobel"
        .global _IMG_sobel
_IMG_sobel:

* ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== *
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A1,         A_SP        ; Stack pointer, A datapath
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_csr       ; CSR's value

* ================= SYMBOLIC REGISTER ASSIGNMENTS: INPUT PARAMETERS ======= *
        .asg            A4,         A_in        ; input image pointer
        .asg            B4,         B_out       ; output image pointer
        .asg            A6,         A_w         ; image width
        .asg            B6,         B_h         ; image height

* ================= SYMBOLIC REGISTER ASSIGNMENTS: ARRAY ACCESS =========== *
        .asg            B8,         B_in        ; copy of input image pointer
        .asg            A16,        A_wD4       ; image width / 4
        .asg            A17,        A_wD8       ; image width / 8
        .asg            B9,         B_wD4       ; copy of image width / 4
        .asg            B0,         B_wD8       ; copy of image width / 8
        .asg            A8,         A_out       ; copy of image output ptr
        .asg            A26,        A_in1_l     ; input pixels 0-3, 1st line
        .asg            A27,        A_in1_h     ; input pixels 4-7, 1st line
        .asg            A26,        A_in2_l     ; input pixels 0-3, 2nd line
        .asg            A27,        A_in2_l2    ; input pixels 4-7, 2nd line
        .asg            A30,        A_in3_l     ; input pixels 0-3, 3rd line
        .asg            A31,        A_in3_h     ; input pixels 4-7, 3rd line
                                                ; input lines with offset 2:
        .asg            B26,        B_tmp1      ; input pixels 0-3, 1st line
        .asg            B27,        B_tmp2      ; input pixels 4-7, 1st line
        .asg            B26,        B_in2_h     ; input pixels 0-3, 2nd line
        .asg            B27,        B_in2_h2    ; input pixels 4-7, 2nd line
        .asg            B30,        B_tmp3      ; input pixels 0-3, 3rd line
        .asg            B31,        B_tmp4      ; input pixels 4-7, 3rd line

* ================= SYMBOLIC REGISTER ASSIGNMENTS: COEFFICIENTS =========== *
        .asg            A20,        A_mult1         ;  0, -1, -2, -1
        .asg            B18,        B_mult1         ;  0, -1, -2, -1
        .asg            A21,        A_mult1_b       ; -1, -2, -1,  0
        .asg            B19,        B_mult1_b       ; -1, -2, -1,  0
        .asg            A22,        A_mult2         ;  0,  1,  2,  1
        .asg            B20,        B_mult2         ;  0,  1,  2,  1
        .asg            A23,        A_mult2_b       ;  1,  2,  1,  0
        .asg            B21,        B_mult2_b       ;  1,  2,  1,  0
        .asg            A18,        A_f2            ;  2,  2,  2,  2
        .asg            B16,        B_f2            ;  2,  2,  2,  2
        .asg            A19,        A_f1            ;  1,  1,  1,  1
        .asg            B17,        B_f1            ;  1,  1,  1,  1

* ================= SYMBOLIC REGISTER ASSIGNMENTS: TEMPORARY REGISTERS ==== *
        .asg            A28,        A_t1
        .asg            A7,         A_t2
        .asg            A25,        A_t3
        .asg            A25,        A_t4
        .asg            A24,        A_t5
        .asg            A5,         A_t6
        .asg            B27,        B_t1
        .asg            B26,        B_t2
        .asg            B6,         B_t3
        .asg            B24,        B_t4
        .asg            B22,        B_t5
        .asg            B1,         B_t6
        .asg            A7,         A_t7
        .asg            A26,        A_t8
        .asg            A3,         A_t9
        .asg            A29,        A_t10
        .asg            A28,        A_t11
        .asg            A0,         A_t12
        .asg            B7,         B_t7
        .asg            B29,        B_t8
        .asg            B24,        B_t9
        .asg            B4,         B_t10
        .asg            B2,         B_t11
        .asg            B4,         B_t12
        .asg            A29,        A_b10_h
        .asg            A28,        A_b10_l
        .asg            A25,        A_b11_h
        .asg            A24,        A_b11_l
        .asg            A25,        A_b12_h
        .asg            A24,        A_b12_l
        .asg            B23,        B_b13_h
        .asg            B22,        B_b13_l
        .asg            B29,        B_b14_h
        .asg            B28,        B_b14_l
        .asg            B23,        B_b15_h
        .asg            B22,        B_b15_l
        .asg            A0,         A_u1
        .asg            A26,        A_u2
        .asg            A5,         A_u3
        .asg            A26,        A_b1
        .asg            A1,         A_u4
        .asg            A1,         A_u5
        .asg            A2,         A_u6
        .asg            A6,         A_b2
        .asg            B4,         B_u1
        .asg            B22,        B_u2
        .asg            B7,         B_u3
        .asg            B30,        B_b3
        .asg            B30,        B_u4
        .asg            B22,        B_u5
        .asg            B1,         B_u6
        .asg            B6,         B_b4
        .asg            A24,        A_u7
        .asg            A30,        A_u8
        .asg            A24,        A_b5
        .asg            A29,        A_u9
        .asg            A3,         A_u10
        .asg            A7,         A_b6
        .asg            B22,        B_u7
        .asg            B23,        B_u8
        .asg            B28,        B_b7
        .asg            B23,        B_u9
        .asg            B5,         B_u10
        .asg            B5,         B_b8
        .asg            A6,         A_u11
        .asg            B6,         B_u11
        .asg            A6,         A_u12
        .asg            B5,         B_u12

* ================= SYMBOLIC REGISTER ASSIGNMENTS: INTERMEDIATE RESULTS === *
        .asg            A25,        A_H             ; horizontal mask
        .asg            B6,         B_H3
        .asg            A3,         A_H5
        .asg            B5,         B_H7
        .asg            A6,         A_V2            ; vertical mask
        .asg            B2,         B_V4
        .asg            A0,         A_V6
        .asg            B25,        B_V8

* ================= SYMBOLIC REGISTER ASSIGNMENTS: FINAL RESULTS ========== *
        .asg            B24,        B_r13
        .asg            B25,        B_r14
        .asg            A7,         A_r9
        .asg            B23,        B_r10
        .asg            A5,         A_r11
        .asg            B25,        B_r12

* ================= SYMBOLIC REGISTER ASSIGNMENTS: EXIT CODE + LOOP COUNT = *
        .asg            B24,        B_r15
        .asg            B25,        B_r16
        .asg            A9,         A_cnt

* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
        SHR     .S1     A_w,        3,      A_wD8               ; line+1
||      SHR     .S2X    A_w,        2,      B_wD4               ; line+2
||      SUB     .L2     B_h,        2,      B_h
||      ADD     .L1X    B_out,      1,      A_out

        ADD     .L2X    A_in,       2,      B_in
||      MVC     .S2     CSR,        B_csr                       ; Remember CSR

        MVKL    .S1     0xFEFF,     A_mult1
||      MVKL    .S2     0x0202,     B_f2
||      MV      .D2X    A_wD8,      B_wD8
||      AND     .L2     B_csr,      -2, B_no_gie                ; Clear GIE
||      LDNDW   .D1T1   *+A_in[A_wD8],  A_in2_l2:A_in2_l        ;[ 1,1]

        MPYU    .M1X    A_w,        B_h,    A_cnt
||      MVKLH   .S1     0x00FF,     A_mult1
||      MVKLH   .S2     0x0202,     B_f2
||      LDNDW   .D      *+B_in[B_wD8],  B_in2_h2:B_in2_h        ;[ 2,1]

        MVKL    .S1     0xFF00,     A_mult1_b
||      MVKL    .S2     0x0100,     B_mult2_b
||      STW     .D2T2   B_csr,      *B_SP--[2]                  ; Save csr

        MVKLH   .S1     0xFFFE,     A_mult1_b
||      MVKLH   .S2     0x0102,     B_mult2_b
||      MV      .L1X    B_wD4,      A_wD4
||      LDNDW   .D      *+B_in[B_wD4],  B_tmp4:B_tmp3           ;[ 4,1]
||      MV      .L2X    A_mult1,    B_mult1

        MVKL    .S2     0x0201,     B_mult2
||      MV      .L1X    B_f2,       A_f2
||      LDNDW   .D1T1   *+A_in[A_wD4],  A_in3_h:A_in3_l         ;[ 5,1]

        MVKLH   .S2     0x0001,     B_mult2
||      LDNDW   .D      *B_in++,    B_tmp2:B_tmp1               ;[ 6,1]
||      MV      .L2X    A_mult1_b,  B_mult1_b
||      MV      .L1X    B_mult2_b,  A_mult2_b
||      B       .S1     instr1

        SHRU    .S1     A_cnt,      3,  A_cnt
||      MVKL    .S2     0x0101,     B_f1
||      MPYU4   .M2     B_in2_h,    B_f2,   B_b13_h:B_b13_l     ;[ 7,1]
||      LDNDW   .D1T1   *A_in++,    A_in1_h:A_in1_l             ;[ 7,1]

        SUB     .L1     A_cnt,      2,  A_cnt
||      MV      .S1X    B_mult2,    A_mult2
||      MVKLH   .S2     0x0101,     B_f1
||      MPYU4   .M2     B_in2_h2,   B_f2,   B_b14_h:B_b14_l     ;[ 8,1]
||      MPYU4   .M1     A_in2_l,    A_f2,   A_b12_h:A_b12_l     ;[ 8,1]

        MPYU4   .M1     A_in2_l2,   A_f2,   A_b10_h:A_b10_l     ;[ 9,1]
||      DOTPSU4 .M2     B_mult2_b,  B_tmp3, B_t4                ;[ 9,1]
||      MVC     .S2     B_no_gie,   CSR                         ; Disable ints
; ===== Interrupts masked here =====

        MV      .L1X    B_f1,       A_f1
||      UNPKHU4 .L2     B_tmp3,     B_u6                        ;[10,1]
||      DOTPSU4 .M1     A_mult2_b,  A_in3_l,    A_t4            ;[10,1]
||      DOTPSU4 .M2     B_mult2_b,  B_tmp4,     B_t10           ;[10,1]
||      UNPKLU4 .S1     A_in3_l,    A_u3                        ;[10,1]
||      B       .S2     cont

        UNPKLU4 .L2     B_tmp3,     B_u3                        ;[11,1]
||      DOTPSU4 .M2     B_mult1_b,  B_tmp2,     B_t7            ;[11,1]
||      UNPKLU4 .S1     A_in3_h,    A_u8                        ;[11,1]
||      DOTPSU4 .M1     A_mult2,    A_in3_l,    A_t5            ;[11,1]
||      UNPKHU4 .L1     A_in3_l,    A_u6                        ;[11,1]
||      B       .S2     instr6

* ========================================================================= *
*    here kernel instructions instr1, instr2, instr3, instr4 are executed   *
* ========================================================================= *

cont:
* ========================================================================= *
*    this is kernel instruction instr5 in parallel with additional branch   *
*    to skip the store operation in kernel instruction instr11              *
* ========================================================================= *
        UNPKHU4 .L2     B_tmp4,     B_u10                       ;[16,1]
||      SUB2    .L1     A_b2,       A_b1,       A_u11           ;[16,1]
||      ADD2    .S1     A_b11_l,    A_b10_l,    A_u7            ;[16,1]
||      ADD2    .D2     B_u5,       B_u6,       B_b4            ;[16,1]
||      DOTPSU4 .M2     B_mult1_b,  B_tmp1,     B_t1            ;[16,1]
||      DOTPSU4 .M1     A_mult1,    A_in1_h,    A_t8            ;[16,1]
||      LDNDW   .D1T1   *+A_in[A_wD4],          A_in3_h:A_in3_l ;[ 5,2]
||      B       .S2     instr11+1*4

* ========================================================================= *
*    here kernel instructions instr6, instr7, instr8, instr9, instr10       *
*    and instr11 (with store operation skipped) are executed, then the      *
*    loop begins                                                            *
* ========================================================================= *

* =========================== PIPE LOOP KERNEL ============================ *
loop:
instr1:
        ADD2    .D2     B_t9,       B_t12,      B_H7            ;[23,1]
||      ABS2    .L2     B_u12,      B_V8                        ;[23,1]
||      PACK2   .S1     A_t10,      A_t11,      A_t12           ;[23,1]
||      UNPKLU4 .S2     B_tmp1,     B_u1                        ;[12,2]
||      DOTPSU4 .M2     B_mult2,    B_tmp4,     B_t11           ;[12,2]
||      UNPKHU4 .L1     A_in1_l,    A_u4                        ;[12,2]
||      MPYU4   .M1     A_in1_h,    A_f1,       A_b11_h:A_b11_l ;[12,2]
||      LDNDW   .D1T1   *+A_in[A_wD8],          A_in2_l2:A_in2_l;[ 1,3]

instr2:
        ADD2    .S1     A_t9,       A_t12,      A_H5            ;[24,1]
||      ADD2    .L2     B_u1,       B_b13_l,    B_u2            ;[13,2]
||      UNPKHU4 .S2     B_tmp1,     B_u4                        ;[13,2]
||      DOTPSU4 .M2     B_mult2,    B_tmp3,     B_t5            ;[13,2]
||      ADD2    .D1     A_u4,       A_b12_h,    A_u5            ;[13,2]
||      UNPKLU4 .L1     A_in1_l,    A_u1                        ;[13,2]
||      DOTPSU4 .M1     A_mult1_b,  A_in1_l,    A_t1            ;[13,2]
||      LDNDW   .D      *+B_in[B_wD8],          B_in2_h2:B_in2_h;[ 2,3]

instr3:
        ABS2    .L2     B_H3,       B_H3                        ;[25,1]
||      ABS2    .L1     A_u12,      A_V6                        ;[25,1]
||      ADD2    .D2     B_u2,       B_u3,       B_b3            ;[14,2]
||      ADD2    .S2     B_u4,       B_b13_h,    B_u5            ;[14,2]
||      MPYU4   .M2     B_tmp2,     B_f1,       B_b15_h:B_b15_l ;[14,2]
||      ADD2    .D1     A_u1,       A_b12_l,    A_u2            ;[14,2]
||      ADD2    .S1     A_u5,       A_u6,       A_b2            ;[14,2]
||      DOTPSU4 .M1     A_mult1,    A_in1_l,    A_t2            ;[14,2]

instr4:
        ABS2    .L1     A_H5,       A_H5                        ;[26,1]
||      ADD2    .S2     B_H3,       B_V4,       B_r10           ;[26,1]
||      ABS2    .L2     B_H7,       B_H7                        ;[26,1]
||      DOTPSU4 .M2     B_mult1,    B_tmp1,     B_t2            ;[15,2]
||      ADD2    .D1     A_u2,       A_u3,       A_b1            ;[15,2]
||      DOTPSU4 .M1     A_mult1_b,  A_in1_h,    A_t7            ;[15,2]
||      PACK2   .S1     A_t4,       A_t5,       A_t6            ;[15,2]
||      LDNDW   .D      *+B_in[B_wD4],          B_tmp4:B_tmp3   ;[ 4,3]

instr5:
        ADD2    .L2     B_H7,       B_V8,       B_r12           ;[27,1]
||      UNPKHU4 .S2     B_tmp4,     B_u10                       ;[16,2]
||      SUB2    .L1     A_b2,       A_b1,       A_u11           ;[16,2]
||      ADD2    .S1     A_b11_l,    A_b10_l,    A_u7            ;[16,2]
||      ADD2    .D2     B_u5,       B_u6,       B_b4            ;[16,2]
||      DOTPSU4 .M2     B_mult1_b,  B_tmp1,     B_t1            ;[16,2]
||      DOTPSU4 .M1     A_mult1,    A_in1_h,    A_t8            ;[16,2]
||      LDNDW   .D1T1   *+A_in[A_wD4],          A_in3_h:A_in3_l ;[ 5,3]

instr6:
        BDEC    .S1     loop,       A_cnt                       ;[28,1]
||      SPACKU4 .S2X    B_r10,      A_r9,       B_r13           ;[28,1]
||      ADD2    .D1     A_u7,       A_u8,       A_b5            ;[17,2]
||      ADD2    .L1     A_b11_h,    A_b10_h,    A_u9            ;[17,2]
||      PACK2   .L2     B_t4,       B_t5,       B_t6            ;[17,2]
||      DOTPSU4 .M2     B_mult1,    B_tmp2,     B_t8            ;[17,2]
||      DOTPSU4 .M1     A_mult2_b,  A_in3_h,    A_t10           ;[17,2]
||      LDNDW   .D      *B_in++,    B_tmp2:B_tmp1               ;[ 6,3]

instr7:
        ADD2    .D2     B_b15_l,    B_b14_l,    B_u7            ;[18,2]
||      ADD2    .S2     B_b15_h,    B_b14_h,    B_u9            ;[18,2]
||      PACK2   .L2     B_t10,      B_t11,      B_t12           ;[18,2]
||      DOTPSU4 .M1     A_mult2,    A_in3_h,    A_t11           ;[18,2]
||      PACK2   .S1     A_t1,       A_t2,       A_t3            ;[18,2]
||      ABS2    .L1     A_u11,      A_V2                        ;[18,2]
||      MPYU4   .M2     B_in2_h,    B_f2,       B_b13_h:B_b13_l ;[ 7,3]
||      LDNDW   .D1T1   *A_in++,    A_in1_h:A_in1_l             ;[ 7,3]

instr8:
        ADD2    .S1     A_H5,       A_V6,       A_r11           ;[30,1]
||      SUB2    .L2     B_b4,       B_b3,       B_u11           ;[19,2]
||      ADD2    .D2     B_u9,       B_u10,      B_b8            ;[19,2]
||      UNPKLU4 .S2     B_tmp4,     B_u8                        ;[19,2]
||      UNPKHU4 .L1     A_in3_h,    A_u10                       ;[19,2]
||      ADD2    .D1     A_t3,       A_t6,       A_H             ;[19,2]
||      MPYU4   .M2     B_in2_h2,   B_f2,       B_b14_h:B_b14_l ;[ 8,3]
||      MPYU4   .M1     A_in2_l,    A_f2,       A_b12_h:A_b12_l ;[ 8,3]

instr9:
        ADD2    .D2     B_u7,       B_u8,       B_b7            ;[20,2]
||      PACK2   .S2     B_t1,       B_t2,       B_t3            ;[20,2]
||      ABS2    .L2     B_u11,      B_V4                        ;[20,2]
||      ADD2    .D1     A_u9,       A_u10,      A_b6            ;[20,2]
||      ABS2    .L1     A_H,        A_H                         ;[20,2]
||      PACK2   .S1     A_t7,       A_t8,       A_t9            ;[20,2]
||      MPYU4   .M1     A_in2_l2,   A_f2,       A_b10_h:A_b10_l ;[ 9,3]
||      DOTPSU4 .M2     B_mult2_b,  B_tmp3,     B_t4            ;[ 9,3]

instr10:
        SPACKU4 .S2X    B_r12,      A_r11,      B_r14           ;[32,1]
||      ADD2    .D2     B_t3,       B_t6,       B_H3            ;[21,2]
||      SUB2    .L1     A_b6,       A_b5,       A_u12           ;[21,2]
||      ADD2    .D1     A_H,        A_V2,       A_r9            ;[21,2]
||      UNPKHU4 .L2     B_tmp3,     B_u6                        ;[10,3]
||      DOTPSU4 .M1     A_mult2_b,  A_in3_l,    A_t4            ;[10,3]
||      DOTPSU4 .M2     B_mult2_b,  B_tmp4,     B_t10           ;[10,3]
||      UNPKLU4 .S1     A_in3_l,    A_u3                        ;[10,3]

instr11:
        STNDW   .D      B_r14:B_r13,            *A_out++        ;[33,1]
||      SUB2    .D2     B_b8,       B_b7,       B_u12           ;[22,2]
||      PACK2   .S2     B_t7,       B_t8,       B_t9            ;[22,2]
||      UNPKLU4 .L2     B_tmp3,     B_u3                        ;[11,3]
||      DOTPSU4 .M2     B_mult1_b,  B_tmp2,     B_t7            ;[11,3]
||      UNPKLU4 .S1     A_in3_h,    A_u8                        ;[11,3]
||      DOTPSU4 .M1     A_mult2,    A_in3_l,    A_t5            ;[11,3]
||      UNPKHU4 .L1     A_in3_l,    A_u6                        ;[11,3]

* =========================== PIPE LOOP EPILOG ============================ *

        ADD2    .D2     B_t9,       B_t12,      B_H7            ;[23,3]
||      ABS2    .L2     B_u12,      B_V8                        ;[23,3]
||      PACK2   .S1     A_t10,      A_t11,      A_t12           ;[23,3]

        ADD2    .S1     A_t9,       A_t12,      A_H5            ;[24,3]
||      ABS2    .L2     B_H3,       B_H3                        ;[25,3]
||      ABS2    .L1     A_u12,      A_V6                        ;[25,3]
||      LDW     .D2T2   *++B_SP[2], B_csr                       ; Get rtn, CSR

        ABS2    .L1     A_H5,       A_H5                        ;[26,3]
||      ADD2    .D2     B_H3,       B_V4,       B_r10           ;[26,3]
||      ABS2    .L2     B_H7,       B_H7                        ;[26,3]
||      RET     .S2     B_ret

        ADD2    .L2     B_H7,       B_V8,       B_r12           ;[27,3]
||      SPACKU4 .S2X    B_r10,      A_r9,       B_r13           ;[28,3]
||      ADD2    .S1     A_H5,       A_V6,       A_r11           ;[30,3]

        SPACKU4 .S2X    B_r12,      A_r11,      B_r14           ;[32,3]

* ========================================================================= *

        STNW    .D1T2   B_r13,      *A_out
||      EXTU    .S2     B_r14,      24, 24,     B_r15

        STB     .D1T2   B_r15,      *++A_out[4]
||      EXTU    .S2     B_r14,      16, 24,     B_r16

        STB     .D1T2   B_r16,      *++A_out
||      MVC     .S2     B_csr,      CSR                         ; Restore CSR

; ===== Branch Occurs =====
; ===== Interruptibility state restored here =====

* ========================================================================= *
*   End of file:  img_sobel.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2max.asm/ 1066928952  0     0     0       18555     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:32:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2max                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2max                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to 255 in the output image.                                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|          _________                                 *
*                      |         |                                          *
*                      |         |                                          *
*             O        |         |                                          *
*             U        |         |                                          *
*             T    th _|. . . . .|                                          *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr      *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using CMPGTU4.  The comparison results (stored in        *
*       cFEDC, cBA98, c7654, and c3210) are expanded to masks using XPND4.  *
*       The results are a set of four masks (xFEDC, xBA98, x7654, and       *
*       x3210) which contain 0xFF in bytes that are greater than the        *
*       threshold, and 0x00 in bytes that are less than or equal to the     *
*       threshold.                                                          *
*                                                                           *
*       To complete the thresholding process, we compute the logical OR     *
*       between our original pixel values and the mask.  This forces        *
*       values above the threshold to 0xFF, and leaves the other values     *
*       unmodified.                                                         *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 0.1875 * rows * cols + 22.                                 *
*       For rows = 32 and cols = 32, cycles = 214.                          *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       164 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_gt2max"
        .global _IMG_thr_gt2max
_IMG_thr_gt2max:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            A3,         A_i
        .asg            A5,         A_o_ptr
        .asg            A6,         A_c7654
        .asg            A6,         A_x7654
        .asg            A8,         A_thththth
        .asg            A9,         A_p3210_
        .asg            A16,        A_t3210
        .asg            A16,        A_x3210
        .asg            A17,        A_p7654_
        .asg            A17,        A_t7654
        .asg            A18,        A_c3210
        .asg            A20,        A_p3210
        .asg            A21,        A_p7654
        .asg            B0,         B_p
        .asg            B5,         B_pFEDC_
        .asg            B7,         B_cBA98
        .asg            B7,         B_xBA98
        .asg            B8,         B_pBA98_
        .asg            B8,         B_tBA98
        .asg            B9,         B_tFEDC
        .asg            B9,         B_xFEDC
        .asg            B16,        B_i_ptr
        .asg            B17,        B_cFEDC
        .asg            B18,        B_thththth
        .asg            B20,        B_pBA98
        .asg            B21,        B_pFEDC
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        MPY     .M1X    A_rows,     B_cols,     A_i
||      PACK2   .L1     A_th,       A_th,       A_thththth

        B       .S1     loop                                    ;[ 8,1]
||      PACKL4  .L1     A_thththth, A_thththth, A_thththth

        SHR     .S1     A_i,        4,          A_i
||      ADD     .L2X    A_i_ptr,    8,          B_i_ptr

        LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,1]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,1]
||      ADD     .S1X    B_o_ptr,    8,          A_o_ptr
||      SUB     .L1     A_i,        1,          A_i
||      MVK     .L2     3,          B_p
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[11,1]
||[!B_p]STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]   ;[11,1]
||[!B_p]STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]   ;[11,1]
||      BDEC    .S1     loop,       A_i                         ;[ 8,2]
||      XPND4   .M1     A_c7654,    A_x7654                     ;[ 8,2]
||      XPND4   .M2     B_cBA98,    B_xBA98                     ;[ 8,2]
||      MV      .L1     A_p7654,    A_p7654_                    ;[ 8,2]
||      MV      .S2     B_pBA98,    B_pBA98_                    ;[ 8,2]

        OR      .D1     A_p3210_,   A_x3210,    A_t3210         ;[ 9,2]
||      OR      .D2     B_pFEDC_,   B_xFEDC,    B_tFEDC         ;[ 9,2]
||      CMPGTU4 .S1     A_p3210,    A_thththth, A_c3210         ;[ 6,3]
||      CMPGTU4 .S2X    B_pFEDC,    A_thththth, B_cFEDC         ;[ 6,3]
||      MV      .L1     A_p3210,    A_p3210_                    ;[ 6,3]
||      MV      .L2     B_pFEDC,    B_pFEDC_                    ;[ 6,3]

        OR      .L1     A_p7654_,   A_x7654,    A_t7654         ;[10,2]
||      OR      .L2     B_pBA98_,   B_xBA98,    B_tBA98         ;[10,2]
||      XPND4   .M1     A_c3210,    A_x3210                     ;[ 7,3]
||      XPND4   .M2     B_cFEDC,    B_xFEDC                     ;[ 7,3]
||      CMPGTU4 .S1     A_p7654,    A_thththth, A_c7654         ;[ 7,3]
||      CMPGTU4 .S2X    B_pBA98,    A_thththth, B_cBA98         ;[ 7,3]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,5]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,5]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed.
        STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr        ;[11,5]
||      STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr        ;[11,5]
||      RETNOP  .S2     B_ret_addr, 5

* ========================================================================= *
*   End of file:  img_thr_gt2max.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2thr.asm/ 1066928953  0     0     0       16752     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Sep 29 03:32:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                                                    *
*                      |                                                    *
*             O        |                                                    *
*             U        |                                                    *
*             T    th _|. . . . . _________                                 *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_le2thr, IMG_thr_gt2max      *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using MINU4.  This instruction with select the smaller   *
*       value between our input pixels and the threshold value.  The        *
*       result is that input values above the threshold are clamped to the  *
*       threshold value.                                                    *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 0.125 * rows * cols + 20.                                  *
*       For rows = 32 and cols = 32, cycles = 148.                          *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       108 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_gt2thr"
        .global _IMG_thr_gt2thr
_IMG_thr_gt2thr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            A3,         A_i
        .asg            A5,         A_o_ptr
        .asg            A6,         A_t3210
        .asg            A7,         A_t7654
        .asg            A8,         A_thththth
        .asg            A16,        A_p3210
        .asg            A17,        A_p7654
        .asg            B0,         B_p
        .asg            B5,         B_i_ptr
        .asg            B6,         B_tBA98
        .asg            B7,         B_tFEDC
        .asg            B8,         B_pBA98
        .asg            B9,         B_pFEDC
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        MPY     .M1X    A_rows,     B_cols,     A_i

        PACK2           A_th,       A_th,       A_thththth

        B       .S2     loop                                    ;[ 3,1]
||      SHR             A_i,        4,          A_i

        ADD             A_i_ptr,    8,          B_i_ptr
||      PACKL4          A_thththth, A_thththth, A_thththth
||      SUB             A_i,        2,          A_i

        BDEC    .S1     loop,       A_i                         ;[ 3,2]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,1]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,1]

        MVK             2,          B_p
; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        MINU4   .L1     A_p7654,    A_thththth, A_t7654         ;[ 7,1]
||      MINU4   .L2X    B_pBA98,    A_thththth, B_tBA98         ;[ 7,1]
||      BDEC    .S1     loop,       A_i                         ;[ 3,3]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,4]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,4]

  [ B_p]SUB     .S2     B_p,        1,          B_p             ;[ 8,1]
||[ B_p]ADD             B_o_ptr,    8,          A_o_ptr
||[!B_p]STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]   ;[ 8,1]
||[!B_p]STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]   ;[ 8,1]
||      MINU4   .L1     A_p3210,    A_thththth, A_t3210         ;[ 6,2]
||      MINU4   .L2X    B_pFEDC,    A_thththth, B_tFEDC         ;[ 6,2]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
        MINU4   .L1     A_p7654,    A_thththth, A_t7654         ;[ 7,4]
||      MINU4   .L2X    B_pBA98,    A_thththth, B_tBA98         ;[ 7,4]
||      RETNOP          B_ret_addr, 4

        STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr        ;[ 8,4]
||      STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr        ;[ 8,4]

* ========================================================================= *
*   End of file:  img_thr_gt2thr.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
thr_le2min.asm/ 1066928953  0     0     0       18555     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Sun Sep 29 03:32:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2min                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2min                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to 0 in the output image.                         *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|. . . . . /                                         *
*             P        |         |                                          *
*             U        |         |                                          *
*             T        |         |                                          *
*                      |         |                                          *
*                    0_|_________|__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using CMPGTU4.  The comparison results (stored in        *
*       cFEDC, cBA98, c7654, and c3210) are expanded to masks using XPND4.  *
*       The results are a set of four masks (xFEDC, xBA98, x7654, and       *
*       x3210) which contain 0xFF in bytes that are greater than the        *
*       threshold, and 0x00 in bytes that are less than or equal to the     *
*       threshold.                                                          *
*                                                                           *
*       To complete the thresholding process, we compute the logical AND    *
*       between our original pixel values and the mask.  This forces        *
*       values less than or equal to the threshold to 0x00, and leaves      *
*       the other values unmodified.                                        *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 0.1875 * rows * cols + 22.                                 *
*       For rows = 32 and cols = 32, cycles = 214.                          *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       164 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_le2min"
        .global _IMG_thr_le2min
_IMG_thr_le2min:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            A3,         A_i
        .asg            A5,         A_o_ptr
        .asg            A6,         A_c7654
        .asg            A6,         A_x7654
        .asg            A8,         A_thththth
        .asg            A9,         A_p3210_
        .asg            A16,        A_t3210
        .asg            A16,        A_x3210
        .asg            A17,        A_p7654_
        .asg            A17,        A_t7654
        .asg            A18,        A_c3210
        .asg            A20,        A_p3210
        .asg            A21,        A_p7654
        .asg            B0,         B_p
        .asg            B5,         B_pFEDC_
        .asg            B7,         B_cBA98
        .asg            B7,         B_xBA98
        .asg            B8,         B_pBA98_
        .asg            B8,         B_tBA98
        .asg            B9,         B_tFEDC
        .asg            B9,         B_xFEDC
        .asg            B16,        B_i_ptr
        .asg            B17,        B_cFEDC
        .asg            B18,        B_thththth
        .asg            B20,        B_pBA98
        .asg            B21,        B_pFEDC
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        MPY     .M1X    A_rows,     B_cols,     A_i
||      PACK2   .L1     A_th,       A_th,       A_thththth

        B       .S1     loop                                    ;[ 8,1]
||      PACKL4  .L1     A_thththth, A_thththth, A_thththth

        SHR     .S1     A_i,        4,          A_i
||      ADD     .L2X    A_i_ptr,    8,          B_i_ptr

        LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,1]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,1]
||      ADD     .S1X    B_o_ptr,    8,          A_o_ptr
||      SUB     .L1     A_i,        1,          A_i
||      MVK     .L2     3,          B_p
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[11,1]
||[!B_p]STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]   ;[11,1]
||[!B_p]STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]   ;[11,1]
||      BDEC    .S1     loop,       A_i                         ;[ 8,2]
||      XPND4   .M1     A_c7654,    A_x7654                     ;[ 8,2]
||      XPND4   .M2     B_cBA98,    B_xBA98                     ;[ 8,2]
||      MV      .L1     A_p7654,    A_p7654_                    ;[ 8,2]
||      MV      .S2     B_pBA98,    B_pBA98_                    ;[ 8,2]

        AND     .D1     A_p3210_,   A_x3210,    A_t3210         ;[ 9,2]
||      AND     .D2     B_pFEDC_,   B_xFEDC,    B_tFEDC         ;[ 9,2]
||      CMPGTU4 .S1     A_p3210,    A_thththth, A_c3210         ;[ 6,3]
||      CMPGTU4 .S2X    B_pFEDC,    A_thththth, B_cFEDC         ;[ 6,3]
||      MV      .L1     A_p3210,    A_p3210_                    ;[ 6,3]
||      MV      .L2     B_pFEDC,    B_pFEDC_                    ;[ 6,3]

        AND     .L1     A_p7654_,   A_x7654,    A_t7654         ;[10,2]
||      AND     .L2     B_pBA98_,   B_xBA98,    B_tBA98         ;[10,2]
||      XPND4   .M1     A_c3210,    A_x3210                     ;[ 7,3]
||      XPND4   .M2     B_cFEDC,    B_xFEDC                     ;[ 7,3]
||      CMPGTU4 .S1     A_p7654,    A_thththth, A_c7654         ;[ 7,3]
||      CMPGTU4 .S2X    B_pBA98,    A_thththth, B_cBA98         ;[ 7,3]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,5]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,5]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed.
        STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr        ;[11,5]
||      STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr        ;[11,5]
||      RETNOP  .S2     B_ret_addr, 5

* ========================================================================= *
*   End of file:  img_thr_le2min.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_le2thr.asm/ 1066928953  0     0     0       16752     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Sun Sep 29 03:32:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|_________ /                                         *
*             P        |         .                                          *
*             U        |         .                                          *
*             T        |         .                                          *
*                      |         .                                          *
*                    0_|_________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using MAXU4.  This instruction with select the smaller   *
*       value between our input pixels and the threshold value.  The        *
*       result is that input values below the threshold are clamped to the  *
*       threshold value.                                                    *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts occur, regardless of the relative alignment of    *
*       in_data[] and out_data[].                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 0.125 * rows * cols + 20.                                  *
*       For rows = 32 and cols = 32, cycles = 148.                          *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       108 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_thr_le2thr"
        .global _IMG_thr_le2thr
_IMG_thr_le2thr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i_ptr
        .asg            B4,         B_o_ptr
        .asg            A6,         A_rows
        .asg            B6,         B_cols
        .asg            A8,         A_th
        .asg            B3,         B_ret_addr

        .asg            A3,         A_i
        .asg            A5,         A_o_ptr
        .asg            A6,         A_t3210
        .asg            A7,         A_t7654
        .asg            A8,         A_thththth
        .asg            A16,        A_p3210
        .asg            A17,        A_p7654
        .asg            B0,         B_p
        .asg            B5,         B_i_ptr
        .asg            B6,         B_tBA98
        .asg            B7,         B_tFEDC
        .asg            B8,         B_pBA98
        .asg            B9,         B_pFEDC
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        MPY     .M1X    A_rows,     B_cols,     A_i

        PACK2           A_th,       A_th,       A_thththth

        B       .S2     loop                                    ;[ 3,1]
||      SHR             A_i,        4,          A_i

        ADD             A_i_ptr,    8,          B_i_ptr
||      PACKL4          A_thththth, A_thththth, A_thththth
||      SUB             A_i,        2,          A_i

        BDEC    .S1     loop,       A_i                         ;[ 3,2]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,1]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,1]

        MVK             2,          B_p
; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        MAXU4   .L1     A_p7654,    A_thththth, A_t7654         ;[ 7,1]
||      MAXU4   .L2X    B_pBA98,    A_thththth, B_tBA98         ;[ 7,1]
||      BDEC    .S1     loop,       A_i                         ;[ 3,3]
||      LDDW    .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210 ;[ 1,4]
||      LDDW    .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98 ;[ 1,4]

  [ B_p]SUB     .S2     B_p,        1,          B_p             ;[ 8,1]
||[ B_p]ADD     .S1X    B_o_ptr,    8,          A_o_ptr
||[!B_p]STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]   ;[ 8,1]
||[!B_p]STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]   ;[ 8,1]
||      MAXU4   .L1     A_p3210,    A_thththth, A_t3210         ;[ 6,2]
||      MAXU4   .L2X    B_pFEDC,    A_thththth, B_tFEDC         ;[ 6,2]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
        MAXU4   .L1     A_p7654,    A_thththth, A_t7654         ;[ 7,4]
||      MAXU4   .L2X    B_pBA98,    A_thththth, B_tBA98         ;[ 7,4]
||      RETNOP          B_ret_addr, 4

        STDW    .D2T1   A_t7654:A_t3210,        *B_o_ptr        ;[ 8,4]
||      STDW    .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr        ;[ 8,4]

* ========================================================================= *
*   End of file:  img_thr_le2thr.asm                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
wave_horz.asm/  1066928953  0     0     0       31213     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Sun Sep 29 03:32:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_horz : 1D Wavelet Transform                                *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Jan-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  /* Row of input pixels  */  *
*               const short *restrict qmf,      /* Low-pass QMF filter  */  *
*               const short *restrict mqmf,     /* High-pass QMF filter */  *
*               short       *restrict out_data, /* Row of output data   */  *
*               int                   cols      /* Length of input.     */  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 1D Periodic Orthogonal Wavelet               *
*       decomposition.  This also performs athe row decomposition in a      *
*       2D wavelet transform.  An input signal x[n] is low pass and         *
*       high pass filtered and decimated by two.  This results in a         *
*       reference signal r1[n] which is the decimated output obtained       *
*       by dropping the odd samples of the low pass filtered output and     *
*       a detail signal d[n] obtained by dropping the odd samples of        *
*       the high-pass output.  A circular convolution algorithm is          *
*       implemented and hence the wavelet transform is periodic.  The       *
*       reference signal and the detail signal are half the size of the     *
*       original signal.  The reference signal may then be iterated         *
*       again to perform another scale of multi-resolution analysis.        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The main idea in optimizing the code is to issue one set of         *
*       reads to the x array and to perform low-pass and high pass          *
*       filtering together and to perfrom the filtering operations          *
*       together to maximize the number of multiplies.  The last 6          *
*       elements of the low-pass filter and the first 6 elements of the     *
*       high pass filter use the same input This is used to                 *
*       appropraitely change the output pointer to the low pass filter      *
*       after 6 iterations.  However for the first six iterations           *
*       pointer wrap-around can occurr and hence this creates a             *
*       dependency.  Pre-reading those 6 values outside the array           *
*       prevents the checks that introduce this dependency.  In addtion     *
*       the input data is read as word wide quantities and the low-pass     *
*       and high-pass filter coefficients are stored in registers           *
*       allowing for the input loop to be completely unrolled.  Thus        *
*       the assembly code has only one loop.  A predication register is     *
*       used to reset the low-pass output pointer after three               *
*       iterations.  The merging of the loops in this fashion allows f      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This kernel assumes that the # of filter taps for the qmf and       *
*       mqmf is 8.                                                          *
*                                                                           *
*       Both the filters are assumed to be double-word aligned and have     *
*       8 taps.                                                             *
*                                                                           *
*       The input line is assumed to be word aligned so that LDWs           *
*       may be performed.                                                   *
*                                                                           *
*       This code assumes that filter coefficients are maintained as        *
*       shorts in Q15 format.                                               *
*                                                                           *
*       It also assumes that input data is an array of shorts (16 bit)      *
*       (The input is assumed to be an array of shorts to allow for         *
*       re-using this kernel to perform Multi Resolution Analysis as        *
*       the output of this code will feedback again as input in the         *
*       next stage.)                                                        *
*                                                                           *
*       Since the transform is a dyadic wavelet cols should be a power      *
*       of 2. Cols must also be >=8.                                        *
*                                                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code has no bank conflicts.                                    *
*                                                                           *
*       This code is ENDIAN Neutral.                                        *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration.  As      *
*       a result, the code is interrupt tolerant but not                    *
*       interruptible.                                                      *
*                                                                           *
*       This code can implement the Daubechies D4 filterbank for            *
*       analysis with 4 vansishing moments.  The length of the analyzing    *
*       low-pass and high pass filters is 8 in that case.                   *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without restrictions: *
*       Note that the assembly code is hand optimized and restrictions      *
*       apply as noted under "ASSUMPTIONS".                                 *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  /* Row of input pixels  */  *
*               const short *restrict qmf,      /* Low-pass QMF filter  */  *
*               const short *restrict mqmf,     /* High-pass QMF filter */  *
*               short       *restrict out_data, /* Row of output data   */  *
*               int                   cols      /* Length of input.     */  *
*           );                                                              *
*                                                                           *
*           {                                                               *
*               int    i, res, iters;                                       *
*               int    j, sum, prod;                                        *
*               short *xptr  = in_data;                                     *
*               short *yptr  = out_data;                                    *
*               short *x_end = &in_data[cols - 1];                          *
*               short  xdata, hdata;                                        *
*               short *xstart;                                              *
*               short *filt_ptr;                                            *
*               int    M = 8;                                               *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  Set our loop trip count and starting x posn.     */     *
*               /*  'xstart' is used in the high-pass filter loop.   */     *
*               /* ------------------------------------------------- */     *
*               iters  = cols;                                              *
*               xstart = in_data + (cols - M)  + 2;                         *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  Low pass filter.  Iterate for cols/2 iterations  */     *
*               /*  generating cols/2 low pass sample points with    */     *
*               /*  the low-pass quadrature mirror filter.           */     *
*               /* ------------------------------------------------- */     *
*               for (i = 0; i < iters; i += 2)                              *
*               {                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Initialize our sum to the rounding value     */     *
*                   /*  and reset our pointer.                       */     *
*                   /* --------------------------------------------- */     *
*                   sum  = Qr;                                              *
*                   xptr = in_data + i;                                     *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Iterate over the taps in our QMF.            */     *
*                   /* --------------------------------------------- */     *
*                   for (j = 0; j < M; j++)                                 *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata =  qmf[j];                                    *
*                       prod  =  xdata * hdata;                             *
*                       sum  += prod;                                       *
*                       if (xptr > x_end) xptr = in_data;                   *
*                   }                                                       *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Adjust the Qpt of our sum and store result.  */     *
*                   /* --------------------------------------------- */     *
*                   res    = (sum >> Qpt);                                  *
*                   *out_data++ = res;                                      *
*               }                                                           *
*                                                                           *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  High pass filter.  Iterate for cols/2 iters      */     *
*               /*  generating cols/2 high pass sample points with   */     *
*               /*  the high-pass quadrature mirror filter.          */     *
*               /* ------------------------------------------------- */     *
*               for (i = 0; i < iters ; i+=2)                               *
*               {                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Initialize our sum and filter pointer.       */     *
*                   /* --------------------------------------------- */     *
*                   sum  = Qr;                                              *
*                   filt_ptr  = mqmf + (M - 1);                             *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Set up our data pointer.  This is slightly   */     *
*                   /*  more complicated due to how the data wraps   */     *
*                   /*  around the edge of the buffer.               */     *
*                   /* --------------------------------------------- */     *
*                   xptr = xstart;                                          *
*                   xstart += 2;                                            *
*                   if (xstart > x_end) xstart = in_data;                   *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Iterate over the taps in our QMF.            */     *
*                   /* --------------------------------------------- */     *
*                   for ( j = 0; j < M; j++)                                *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata = *filt_ptr--;                                *
*                       prod  = xdata * hdata;                              *
*                       if (xptr > x_end) xptr = in_data;                   *
*                       sum  += prod;                                       *
*                   }                                                       *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Adjust the Qpt of our sum and store result.  */     *
*                   /* --------------------------------------------- */     *
*                   res = (sum >> Qpt);                                     *
*                   *out_data++ =  res;                                     *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = cols * 2 + 25.                                             *
*                                                                           *
*       For cols = 256, cycles = 537.                                       *
*       For cols = 512, cycles = 1049.                                      *
*                                                                           *
*   CODESIZE                                                                *
*       360 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_wave_horz"
        .global _IMG_wave_horz
_IMG_wave_horz: 


Qr              .set     16384
M               .set     8
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_iptr
        .asg            B4,         B_qmf
        .asg            A6,         A_filter
        .asg            B6,         B_yptr_l1
        .asg            A8,         A_ish_x_dim
        .asg            A6,         A_qr
        .asg            B20,        B_iptr
        .asg            B7,         B_h67
        .asg            B16,        B_h45
        .asg            A5,         A_h23
        .asg            A4,         A_h01
        .asg            B4,         B_l10
        .asg            B5,         B_l32
        .asg            A2,         A_l54
        .asg            A3,         A_l76
        .asg            B19,        B_x10
        .asg            B18,        B_x32
        .asg            A9,         A_x54
        .asg            A8,         A_yptr_h
        .asg            B17,        B_yptr_l0
        .asg            B6,         B_yptr_l1
        .asg            A0,         A_i
        .asg            B0,         B_p
        .asg            A17,        A_h32
        .asg            A16,        A_h10
        .asg            B9,         B_h76
        .asg            B8,         B_h54
        .asg            A7,         A_offset
        .asg            A1,         A_xiptr
        .asg            B2,         B_xiptr
        .asg            A5,         A_optr
        .asg            A7,         A_x76
        .asg            B21,        B_prod_l10
        .asg            B29,        B_csr
        .asg            B28,        B_no_gie
        .asg            A0,         A_qmf
; ============================================================================

        SUB     .L1     A_ish_x_dim,    M - 2,        A_offset      ; x-M+2
||      MVC     .S2     CSR,            B_csr
||      LDDW    .D1T2   *A_filter[1],   B_h76:B_h54                 ; High

        LDDW    .D1T1   *A_filter[0],   A_h32:A_h10                 ; High
||      AND     .L2     B_csr,          -2,           B_no_gie
||      MV      .S2X    A_iptr,         B_iptr                      ; iptr

        ADDAH   .D1     A_iptr,         A_offset,     A_xiptr       ; iptr
||      MVC     .S2     B_no_gie,       CSR                         ; Disabl
||      LDW     .D2T1   *B_iptr++,      A_x76                       ; x76

        ADD     .L2X    A_xiptr,        4,            B_xiptr       ; xiptr
||      LDW     .D1T2   *A_xiptr++[2],  B_x10                       ; x10
||      MV      .S1X    B_qmf,          A_qmf

        LDDW    .D1T1   *A_qmf[1],      A_l76:A_l54                 ; Low
||      LDDW    .D2T2   *B_qmf[0],      B_l32:B_l10                 ; Low

        LDW     .D1T1   *A_xiptr++[2],  A_x54                       ; x54
||      LDW     .D2T2   *B_xiptr++[2],  B_x32                       ; x32
||      MVK     .S1     Qr,             A_qr                        ; A_qr

        SHRU    .S1     A_ish_x_dim,    1,            A_i           ; X>>1
||      MV      .L1X    B_yptr_l1,      A_optr                      ; Copy
||      MVK     .S2     3,              B_p                         ; switch
||      ADD     .L2X    B_yptr_l1,      A_offset,     B_yptr_l0     ; optr-off

        ADDAH   .D1     A_optr,         A_i,          A_yptr_h      ; [x>>1]

        PACKLH2 .S1     A_h10,          A_h10,        A_h01         ; h0:h1
||      PACKLH2 .L1     A_h32,          A_h32,        A_h23         ; h2:h3
||      PACKLH2 .L2     B_h54,          B_h54,        B_h45         ; h4:h5
||      PACKLH2 .S2     B_h76,          B_h76,        B_h67         ; h6:h7


; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A6,         A_qr
        .asg            B20,        B_iptr
        .asg            B7,         B_h67
        .asg            B16,        B_h45
        .asg            A5,         A_h23
        .asg            A4,         A_h01
        .asg            B4,         B_l10
        .asg            B5,         B_l32
        .asg            A2,         A_l54
        .asg            A3,         A_l76
        .asg            B19,        B_x10
        .asg            B18,        B_x32
        .asg            A9,         A_x54
        .asg            A8,         A_yptr_h
        .asg            B17,        B_yptr_l0
        .asg            B6,         B_yptr_l1
        .asg            A0,         A_i
        .asg            B0,         B_p
        .asg            B24,        B_sum_h
        .asg            A19,        A_sum_l
        .asg            A7,         A_x76
        .asg            B9,         B_prod_h10
        .asg            B22,        B_prod_h32
        .asg            A17,        A_prod_h54
        .asg            A18,        A_prod_h76
        .asg            B21,        B_prod_l10
        .asg            B23,        B_prod_l32
        .asg            A19,        A_prod_l54
        .asg            A18,        A_prod_l76
        .asg            B21,        B_tmph0
        .asg            A17,        A_tmph1
        .asg            B22,        B_tmpl0
        .asg            A18,        A_tmpl1
        .asg            B23,        B_tmp_h
        .asg            A16,        A_tmp_l
        .asg            B24,        B_res_hi
        .asg            A16,        A_res_low
        .asg            B3,         B_return
        .asg            A1,         A_p
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDW     .D2T1   *B_iptr++,    A_x76                     ; Load x76
||      MVK     .S1     1,            A_p
||      DOTP2   .M2     B_x10,        B_l10,        B_prod_l10    ; prod
||      B       .S2     L_3  + 8

        DOTP2   .M1     A_x76,        A_l76,        A_prod_l76  ; x6l6 + x7l7
||      DOTP2   .M2     B_x32,        B_l32,        B_prod_l32  ; x2l2 + x3l3
||      B       .S2     L_4  + 12

        MV      .L2     B_x32,        B_x10                     ; x10 = x32
||      DOTP2   .M1     A_x54,        A_l54,        A_prod_l54  ; x4l4 + x5l5
||      DOTP2   .M2     B_x10,        B_h67,        B_prod_h10  ; x0h7 + x1h6
||      B       .S2     L_1  + 4

        DOTP2   .M1     A_x54,        A_h23,        A_prod_h54  ; x5h2 + x4h3
||      DOTP2   .M2     B_x10,        B_l10,        B_prod_l10  ; x0l0 + x1l1
||      SUB     .L1     A_i,          3,            A_i
||      B       .S2     L_2  + 4

        MV      .D1     A_x76,        A_x54                     ; x54 = x76
||      MV      .L2X    A_x54,        B_x32                     ; x32 = x54
||      DOTP2   .M1     A_x76,        A_h01,        A_prod_h76  ; x7h0 + x6h1
||      DOTP2   .M2     B_x32,        B_h45,        B_prod_h32  ; x3h4 + x2h5
||      LDW     .D2T1   *B_iptr++,    A_x76                     ; Load x76

        ADD     .L2     B_prod_l10,   B_prod_l32,   B_tmpl0     ; l10 + l32
||      DOTP2   .M1     A_x76,        A_l76,        A_prod_l76  ; x6l6 + x7l7
||      DOTP2   .M2     B_x32,        B_l32,        B_prod_l32  ; x2l2 + x3l3

; ============================ PIPE LOOP KERNEL ==============================
LOOP:

L_1:
        SHR     .S2     B_sum_h,      15,           B_res_hi    ; >> 15
||      ADD     .L1     A_qr,         A_tmp_l,      A_sum_l     ; += tmp_l
||      ADD     .S1     A_prod_h54,   A_prod_h76,   A_tmph1     ; h54 + h76
||      MV      .D1     A_x76,        A_x54                     ; x54 = x76
||      MV      .L2X    A_x54,        B_x32                     ; x32 = x54
||      DOTP2   .M1     A_x76,        A_h01,        A_prod_h76  ; x7h0 + x6h1
||      DOTP2   .M2     B_x32,        B_h45,        B_prod_h32  ; x3h4 + x2h5
||      LDW     .D2T1   *B_iptr++,    A_x76                     ; Load x76

L_2:
        STH     .D1T2   B_res_hi,     *A_yptr_h++               ; *y_hp
||      SHR     .S1     A_sum_l,      15,           A_res_low   ; >> 15
||      ADD     .S2     B_prod_h10,   B_prod_h32,   B_tmph0     ; h10 + h32
||      ADD     .L2     B_prod_l10,   B_prod_l32,   B_tmpl0     ; l10 + l32
||      DOTP2   .M1     A_x76,        A_l76,        A_prod_l76  ; x6l6 + x7l7
||      DOTP2   .M2     B_x32,        B_l32,        B_prod_l32  ; x2l2 + x3l3
||[A_p] SUB     .L1     A_p,          1,            A_p

L_3:
  [!B_p]STH     .D2T1   A_res_low,    *B_yptr_l1++              ; Store *y_lp1
||      ADD     .L2X    B_tmph0,      A_tmph1,      B_tmp_h     ; tmp_h
||      BDEC    .S1     LOOP,         A_i                       ; if (i) B LOOP
||      ADD     .D1     A_prod_l54,   A_prod_l76,   A_tmpl1     ; l54 + l76
||      MV      .S2     B_x32,        B_x10                     ; x10 = x32
||      DOTP2   .M1     A_x54,        A_l54,        A_prod_l54  ; x4l4 + x5l5
||      DOTP2   .M2     B_x10,        B_h67,        B_prod_h10  ; x0h7 + x1h6

L_4:
  [ B_p]SUB     .L2     B_p,          1,            B_p         ; pred.for LP
||[ B_p]STH     .D2T1   A_res_low,    *B_yptr_l0++              ; Store *y_lp0
||      ADD     .S2X    A_qr,         B_tmp_h,      B_sum_h     ; += tmp_h
||      ADD     .D1X    A_tmpl1,      B_tmpl0,      A_tmp_l     ; tmp_l
||      DOTP2   .M1     A_x54,        A_h23,        A_prod_h54  ; x5h2 + x4h3
||      DOTP2   .M2     B_x10,        B_l10,        B_prod_l10  ; x0l0 + x1l1

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:
        SHR     .S1X    B_sum_h,      15,           A0          ; sum_h >> 15
||      ADD     .L1     A_qr,         A_tmp_l,      A_sum_l     ; sum_l+= tmp_l
||      ADD     .D1     A_prod_h54,   A_prod_h76,   A_tmph1     ; h54 + h76
||      RET     .S2     B_return

        STH     .D1T1   A0,           *A_yptr_h++               ; Store *y_hp
||      SHR     .S1     A_sum_l,      15,           A_res_low   ; sum_l >> 15
||      ADD     .L2     B_prod_h10,   B_prod_h32,   B_tmph0     ; h10 + h32

        STH     .D2T1   A_res_low,    *B_yptr_l1++              ; Store *y_lp1
||      ADD     .L2X    B_tmph0,      A_tmph1,      B_tmp_h     ; tmp_h

        ADD     .S2X    A_qr,         B_tmp_h,      B_sum_h     ; sum_h += tmp_h

        SHR     .S2     B_sum_h,      15,           B_res_hi    ; sum_h >> 15

        STH     .D1T2   B_res_hi,     *A_yptr_h++               ; Store *y_hp
||      MVC     .S2     B_csr,        CSR

* ========================================================================= *
*   End of file:  img_wave_horz.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

wave_vert.asm/  1066928953  0     0     0       53384     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sun Sep 29 03:32:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_vert : Vertical Pass of Wavelet Transform                  *
*                                                                           *
*   REVISION DATE                                                           *
*       08-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   /* Array of row pointers */    *
*           const short *restrict qmf,       /* Low pass QMF filter   */    *
*           const short *restrict mqmf,      /* High pass QMF filter  */    *
*           short       *restrict out_ldata, /* Low pass output data  */    *
*           short       *restrict out_hdata, /* High pass output data */    *
*           int cols                     /* Length of rows to process */    *
*       );                                                                  *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs the vertical pass of 2D wavelet              *
*       transform It performs a vertical filter on 8 rows which are         *
*       pointed to by the pointers contained in an array of pointers.       *
*       It produces two lines worth of output, one being the low-pass       *
*       and the other being the high pass result. Instead of performing     *
*       a transpose on the column and re-using the wave_horz kernel,        *
*       the vertical filter is traversed over the entire width of the       *
*       line and the low pass and high pass filtering kernels are           *
*       performed together.                                                 *
*                                                                           *
*       This implies that the low-pass and highpass filters be              *
*       overlapped in execution so that the input data array may be         *
*       loaded once and both filters can be exceuted in parallel.           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop that advances along each filter tap is totally       *
*       optimized by unrolling.  Double-word loads are performed, and       *
*       paired multiplies are used to perform four iterations of            *
*       low-pass filter in parallel.                                        *
*                                                                           *
*       For the high-pass kernel, the same loop is reused, in order         *
*       to save codesize.  This is done by loading the filter               *
*       coefficients in a special order.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Since the wavelet transform is dyadic, the image dimensions         *
*       "rows" and "cols" are assumed to be powers of 2.  No checking       *
*       is done within the code to ensure this.                             *
*                                                                           *
*       The input filters qmf and mqmf are assumed to be word aligned       *
*       and have exactly 8 taps.                                            *
*                                                                           *
*       The output data and input data on any line is assumed to be         *
*       dword-aligned.                                                      *
*                                                                           *
*       The mqmf filter is constructed from the qmf as follows:             *
*                                                                           *
*           status = -1;                                                    *
*           for (i = 0; i < M; i++)                                         *
*           {                                                               *
*               status = status * -1;                                       *
*               hdata  = qmf[i] * status;                                   *
*               filter[i] = hdata;                                          *
*           }                                                               *
*                                                                           *
*       The kernels assume that the number of filter taps is exactly        *
*       8.  In addition data that is loaded for producing out_ldata[0]      *
*       and out_hdata[0] is not identical. The data loaded for              *
*       producing out_hdata[0] produces results at the location             *
*                                                                           *
*           out_lstart = o_im + ((rows >> 1) - 3) * cols                    *
*           out_hstart = o_im + (rows >> 1) * cols                          *
*                                                                           *
*       Where o_im is start of output image, rows is # of rows of the       *
*       input image, and cols is # of cols of the output image.             *
*                                                                           *
*       The following table illustrates how ylptr and yhptr need to be      *
*       updated at the start of each call to this function:                 *
*                                                                           *
*       Call#        out_ldata                  out_hdata                   *
*         1          out_lstart                 out_hstart                  *
*         2          out_lstart + cols          out_hstart + cols           *
*         3          out_lstart + 2*cols        out_hstart + 2*cols         *
*                                                                           *
*       At this point ylptr wraps around to become o_im, while yhptr        *
*       proceeds as usual:                                                  *
*                                                                           *
*         4          o_im                       out_hstart + 3*cols         *
*                                                                           *
*       In addition the kernel accepts a pointer to an array of             *
*       pointers for each input line so that a working buffer of 10         *
*       lines can be used to effectively mix DMA's and processing as        *
*       shown below:                                                        *
*                                                                           *
*       ihptr                        LINE BUFFER                            *
*       ptr0   ---->|-------------------------------------------------|     *
*       ptr1   ---->|-------------------------------------------------|     *
*       ...                                                                 *
*       ptr7   ---->|-------------------------------------------------|     *
*                                                                           *
*       At the start of the kernel 8 input lines are filled to the          *
*       first 8 lines and processing begins.  In the background the next    *
*       two lines are fetched.  The pointers are moved up by 2 namely       *
*       ptr[i] = ptr[i+2] and the last two lines now point to lines 9       *
*       and 10 and processing starts again.  In the background the next     *
*       two lines are brought in the first two lines of the line            *
*       buffer.  Pointers move up again by 2 but now the last two           *
*       pointers to line 0 and 1.  This pattern then repeats.               *
*                                                                           *
*       The first line to begin filtering is always obtained from           *
*       ptr[0], the next from ptr[1] and so on.                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       In order to eliminate bank conflicts succesive lines in the         *
*       line buffer or the pointers to these lines are seperated by         *
*       exactly two banks (one word) so that loads to any succesive         *
*       lines may be parallelized together.                                 *
*                                                                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration.  As a    *
*       result the code is interrupt tolerant but not interruptible.        *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   /* Array of row pointers */    *
*           const short *restrict qmf,       /* Low pass QMF filter   */    *
*           const short *restrict mqmf,      /* High pass QMF filter  */    *
*           short       *restrict out_ldata, /* Low pass output data  */    *
*           short       *restrict out_hdata, /* High pass output data */    *
*           int cols                     /* Length of rows to process */    *
*       )                                                                   *
*       {                                                                   *
*           const int M = 8;                                                *
*           int            i, iters, j;                                     *
*           int            sum_h, sum_l;                                    *
*           int            prod_h, prod_l;                                  *
*                                                                           *
*           short          res_h, res_l;                                    *
*           short          xdata, hdata, ldata;                             *
*           short          *filt_ptr;                                       *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  iters: variable for the # of loop iterations.         */    *
*           /*                                                        */    *
*           /*  Both the low pass and the high pass filters produce   */    *
*           /*  'iters' points, which is also the width of the input  */    *
*           /*  line.  The low-pass filter reads filter coefficients  */    *
*           /*  from qmf and the high pass filter reads filter        */    *
*           /*  coefficients from the conjugate mirror filter. In     */    *
*           /*  addition note that the low-pass filter coefficients   */    *
*           /*  are read in increasing order while the high pass the  */    *
*           /*  filter coefficients are read in the opposite order.   */    *
*           /* ------------------------------------------------------ */    *
*           iters = cols;                                                   *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  Since the filters have fractional point coefficients, */    *
*           /*  all math is done using Q15 fixed-point arithmetic.    */    *
*           /*  Qr is the associated round value and is set as        */    *
*           /*  follows:                                              */    *
*           /*                                                        */    *
*           /*      #define Qpt 15                                    */    *
*           /*      #define Qr 16384                                  */    *
*           /*                                                        */    *
*           /*  Low-Pass filter: ihptr contains 8 pointers which      */    *
*           /*  point to input lines. The filters are placed          */    *
*           /*  vertically and input data is read from 8 seperate     */    *
*           /*  lines. Hence data-reuse is not possible when          */    *
*           /*  traversing horizontally. sum_l is initialized to Qr   */    *
*           /*  and contains the low-pass FIR sum at the end of the   */    *
*           /*  j loop. sum_h contains the accumulator result for     */    *
*           /*  the high pass filter in a similar fashion.  M is      */    *
*           /*  assumed to be 8 by all kernels and is # filter taps   */    *
*           /*  for D4.                                               */    *
*           /* ------------------------------------------------------ */    *
*                                                                           *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_l    = Qr;                                              *
*               filt_ptr = qmf;                                             *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   ldata   =  *filt_ptr++;                                 *
*                   prod_l  =  xdata * ldata;                               *
*                   sum_l  +=  prod_l;                                      *
*               }                                                           *
*                                                                           *
*               res_l    = (sum_l >> Qpt);                                  *
*               *out_ldata++ = res_l;                                       *
*           }                                                               *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  High-Pass filter:  ihptr contains 8 pointers which    */    *
*           /*  point to input lines.  The filters are placed         */    *
*           /*  vertically and input data is read from 8 seperate     */    *
*           /*  lines.  Hence data-reuse is not possible when         */    *
*           /*  traversing horizontally.  sum_h is initialized to     */    *
*           /*  Qr and contains the low-pass FIR sum at the end of    */    *
*           /*  the j loop.  sum_h contains the accumulator result    */    *
*           /*  for the high pass filter in a similar fashion.  M     */    *
*           /*  is # filter taps and is assumed to be 8 by all        */    *
*           /*  kernels.                                              */    *
*           /* ------------------------------------------------------ */    *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_h    = Qr;                                              *
*               filt_ptr = mqmf + M - 1;                                    *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   hdata   =  *filt_ptr--;                                 *
*                   prod_h  =  xdata * hdata;                               *
*                   sum_h  +=  prod_h;                                      *
*               }                                                           *
*                                                                           *
*               res_h    = (sum_h >> Qpt);                                  *
*               *out_hdata++ = res_h;                                       *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 4*cols + 96  (both lowpass and highpass together)          *
*                                                                           *
*       For cols = 256, cycles = 1120.                                      *
*       For cols = 512, cycles = 2144.                                      *
*                                                                           *
*   CODESIZE                                                                *
*       888 bytes                                                           *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Mallat, Stephane. "A Wavelet Tour of Signal Processing", pg. 309.   *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
                .sect ".data:copyright_h"

        .sect ".text:_wave_vert"
        .global _IMG_wave_vert
_IMG_wave_vert: 

Qr              .set    16384
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A1,         A_SP        ; Stack pointer, A datapath
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_csr       ; CSR's value
        .asg            A4,         A_ihptr
        .asg            B4,         B_qmf
        .asg            A6,         A_filter
        .asg            B6,         B_ylptr
        .asg            A8,         A_yhptr
        .asg            B8,         B_x
        .asg            A10,        A_M
        .asg            A7,         A_in0ptr
        .asg            B7,         B_in1ptr
        .asg            A14,        A_in2ptr
        .asg            B2,         B_in3ptr
        .asg            A9,         A_in4ptr
        .asg            B1,         B_in5ptr
        .asg            A11,        A_in6ptr
        .asg            B3,         B_in7ptr
        .asg            A0,         A_l00
        .asg            B17,        B_l11
        .asg            A1,         A_l22
        .asg            B16,        B_l33
        .asg            A2,         A_l44
        .asg            B19,        B_l55
        .asg            A16,        A_l66
        .asg            B18,        B_l77
        .asg            A10,        A_yptr
        .asg            A12,        A_iters
        .asg            A17,        A_qr
        .asg            B4,         B_qr
        .asg            A13,        A_x
        .asg            B13,        B_filter
        .asg            B14,        B_ihptr
        .asg            B0,         B_j
        .asg            A0,         A_qmf
        .asg            A0,         A_l10
        .asg            B7,         B_l32
        .asg            A1,         A_l54
        .asg            B9,         B_l76
        .asg            A4,         A_l11
        .asg            B5,         B_l22
        .asg            A2,         A_l55
        .asg            B0,         B_l66
        .asg            B5,         B_l44
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T2   B14,        *B_SP--[14]             ; Save B14, get stk
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STDW    .D1T1   A15:A14,    *-A_SP[1]               ; Save A15, A14
||      STDW    .D2T2   B13:B12,    *+B_SP[5]               ; Save B13, B12
||      MVC     .S2     CSR,        B_csr                   ; Remember CSR

        STDW    .D1T1   A13:A12,    *-A_SP[3]               ; Save A13, A12
||      STDW    .D2T2   B11:B10,    *+B_SP[3]               ; Save B11, B10
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STDW    .D1T1   A11:A10,    *-A_SP[5]               ; Save A11, A10
||      STDW    .D2T2   B_ret:B_csr,*+B_SP[1]               ; Save Return, CSR
||      MVC     .S2     B_no_gie,   CSR                     ; Disable ints
||      MV      .L1X    B_qmf,      A_qmf             ; Part. move of pointer

        LDW     .D1T1   *+A_qmf[2], A_l54             ; Paired l54 read l5|l4
||      LDW     .D2T2   *+B_qmf[3], B_l76             ; Paired l76 read l7|l6

        MV      .S2X    A_ihptr,    B_ihptr           ; Part. move of pointer
||      LDW     .D1T1   *+A_qmf[0], A_l10             ; Paired l10 read l1|l0
||      LDW     .D2T2   *+B_qmf[1], B_l32             ; Paired l32 read l3|l2

        LDW     .D2T2   *+B_ihptr[7],   B_in7ptr      ; Pointer to 8th line
||      LDW     .D1T1   *+A_ihptr[6],   A_in6ptr      ; Pointer to 7th line

        LDW     .D2T2   *+B_ihptr[5],   B_in5ptr      ; Pointer to 6th line
||      LDW     .D1T1   *+A_ihptr[4],   A_in4ptr      ; Pointer to 5th line

        MVK     .S2     Qr,             B_qr          ; Round for Q15 math
||      LDW     .D2T2   *+B_ihptr[3],   B_in3ptr      ; Pointer to 4th line
||      LDW     .D1T1   *+A_ihptr[2],   A_in2ptr      ; Pointer to 3rd line

        PACKH2  .L1     A_l54,  A_l54,  A_l55         ; Packed l5
||      LDW     .D2T2   *+B_ihptr[1],   B_in1ptr      ; Pointer to 2nd line
||      LDW     .D1T1   *+A_ihptr[0],   A_in0ptr      ; Pointer to 1st line
||      MV      .S1X    B_x,            A_x           ; Partitioning move

        PACKH2  .L1     A_l10,      A_l10,      A_l11 ; Packed l1
||      PACK2   .S2     B_l76,      B_l76,      B_l66 ; Packed l6
||      MV      .L2X    A_filter,   B_filter          ; Partitioning move
||      MV      .D1X    B_ylptr,    A_yptr            ; Partitioning move

        PACK2   .L2     B_l32,      B_l32,      B_l22 ; Packed l2
||      PACK2   .S1     A_l54,      A_l54,      A_l44 ; Packed l4
||      MV      .L1X    B_qr,       A_qr              ; Round factor
||      MV      .D2X    A_l55,      B_l55             ; Partitioning move

        MVK     .D2     2,          B_j               ; Counter for outer loop
||      MV      .L1X    B_l66,      A_l66             ; Partitioning move
||      MV      .S2X    A_l11,      B_l11             ; Partitioning move

        MV      .L1X    B_l22,      A_l22             ; Partitioning move
||      PACKH2  .L2     B_l76,      B_l76,      B_l77 ; Packed l7
||      PACKH2  .S2     B_l32,      B_l32,      B_l33 ; Packed l3
||      PACK2   .S1     A_l10,      A_l10,      A_l00 ; Packed l0
||      MV      .D2X    A_l44,      B_l44             ; Partitioning move

LOOPJ:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A7,         A_in0ptr    ; Pointer to Line 0
        .asg            B7,         B_in1ptr    ; Pointer to Line 1
        .asg            A14,        A_in2ptr    ; Pointer to Line 2
        .asg            B2,         B_in3ptr    ; Pointer to Line 3
        .asg            A9,         A_in4ptr    ; Pointer to Line 4
        .asg            B1,         B_in5ptr    ; Pointer to Line 5
        .asg            A11,        A_in6ptr    ; Pointer to Line 6
        .asg            B3,         B_in7ptr    ; Pointer to Line 7
        .asg            A0,         A_l00       ; Packed lowpass0/highpass7
        .asg            B17,        B_l11       ; Packed lowpass1/highpass6
        .asg            A1,         A_l22       ; Packed lowpass2/highpass5
        .asg            B16,        B_l33       ; Packed lowpass3/highpass4
        .asg            A2,         A_l44       ; Packed lowpass4/highpass3
        .asg            B19,        B_l55       ; Packed lowpass5/highpass2
        .asg            A16,        A_l66       ; Packed lowpass6/highpass1
        .asg            B18,        B_l77       ; Packed lowpass7/highpass0
        .asg            A10,        A_yptr      ; Output lowpass/ highpass
        .asg            A12,        A_iters     ; Iterations
        .asg            A17,        A_qr        ; Round value
        .asg            B4,         B_qr        ; Round value
        .asg            A27,        A_xdataI8   ; Data for Line 0
        .asg            A26,        A_xdataA0   ; Data for Line 0
        .asg            B25,        B_xdataJ9   ; Data for Line 1
        .asg            B24,        B_xdataB1   ; Data for Line 1
        .asg            A19,        A_xdataKA   ; Data for Line 2
        .asg            A18,        A_xdataC2   ; Data for Line 2
        .asg            B31,        B_xdataLB   ; Data for Line 3
        .asg            B30,        B_xdataD3   ; Data for Line 3
        .asg            A23,        A_xdataMC   ; Data for Line 4
        .asg            A22,        A_xdataE4   ; Data for Line 4
        .asg            B21,        B_xdataND   ; Data for Line 5
        .asg            B20,        B_xdataF5   ; Data for Line 5
        .asg            A21,        A_xdataOE   ; Data for Line 6
        .asg            A20,        A_xdataG6   ; Data for Line 6
        .asg            B31,        B_xdataPF   ; Data for Line 7
        .asg            B30,        B_xdataH7   ; Data for Line 7
        .asg            A23,        A_prod1
        .asg            A22,        A_prod0
        .asg            B9,         B_prod3
        .asg            B8,         B_prod2
        .asg            A31,        A_prod5
        .asg            A30,        A_prod4
        .asg            B27,        B_prod7
        .asg            B26,        B_prod6
        .asg            A29,        A_prod9
        .asg            A28,        A_prod8
        .asg            B11,        B_prodB
        .asg            B10,        B_prodA
        .asg            A25,        A_prodD
        .asg            A24,        A_prodC
        .asg            B29,        B_prodF
        .asg            B28,        B_prodE
        .asg            A25,        A_mpy1
        .asg            A24,        A_mpy0
        .asg            B23,        B_mpy3
        .asg            B22,        B_mpy2
        .asg            A27,        A_mpy5
        .asg            A26,        A_mpy4
        .asg            B25,        B_mpy7
        .asg            B24,        B_mpy6
        .asg            A21,        A_mpy9
        .asg            A20,        A_mpy8
        .asg            B29,        B_mpyB
        .asg            B28,        B_mpyA
        .asg            A23,        A_mpyD
        .asg            A22,        A_mpyC
        .asg            B11,        B_mpyF
        .asg            B10,        B_mpyE
        .asg            A6,         A_prod40
        .asg            B9,         B_prod26
        .asg            A3,         A_prod8C
        .asg            B8,         B_prodAE
        .asg            A28,        A_prod15
        .asg            B27,        B_prod37
        .asg            A20,        A_prod9D
        .asg            B6,         B_prodBF
        .asg            A5,         A_mpy40
        .asg            B23,        B_mpy26
        .asg            A21,        A_mpy8C
        .asg            B20,        B_mpyAE
        .asg            A4,         A_mpy15
        .asg            B22,        B_mpy37
        .asg            A20,        A_mpy9D
        .asg            B24,        B_mpyBF
        .asg            A4,         A_sum0
        .asg            B5,         B_sum1
        .asg            B25,        B_sum_t0
        .asg            A24,        A_sum2
        .asg            B6,         B_sum3
        .asg            A3,         A_sum_t1
        .asg            A5,         A_sum4
        .asg            B28,        B_sum5
        .asg            B26,        B_sum_t2
        .asg            A4,         A_sum6
        .asg            B5,         B_sum7
        .asg            A3,         A_sum_t3
        .asg            B29,        B_sum_l0
        .asg            A19,        A_sum_l1
        .asg            B5,         B_sum_l2
        .asg            A18,        A_sum_l3
        .asg            A22,        A_sum_l0s
        .asg            B20,        B_sum_l1s
        .asg            A24,        A_sum_l2s
        .asg            B21,        B_sum_l3s
        .asg            B20,        B_oword0
        .asg            B21,        B_oword1
        .asg            B13,        B_filter
        .asg            A8,         A_yhptr
        .asg            B0,         B_j
        .asg            A10,        A_yptr
        .asg            A0,         A_l00
        .asg            B17,        B_l11
        .asg            A1,         A_l22
        .asg            B16,        B_l33
        .asg            A2,         A_l44
        .asg            B19,        B_l55
        .asg            A16,        A_l66
        .asg            B18,        B_l77
        .asg            A7,         A_in0ptr
        .asg            B7,         B_in1ptr
        .asg            A14,        A_in2ptr
        .asg            B2,         B_in3ptr
        .asg            A9,         A_in4ptr
        .asg            B1,         B_in5ptr
        .asg            A11,        A_in6ptr
        .asg            B3,         B_in7ptr
        .asg            A0,         A_ihptr
        .asg            A0,         A_filter
        .asg            A1,         A_h10
        .asg            B5,         B_h32
        .asg            A0,         A_h54
        .asg            B6,         B_h76
        .asg            B21,        B_l00
        .asg            A4,         A_l33
        .asg            B2,         B_l44
        .asg            A2,         A_l77

; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================
; PROLOG:

        LDDW    .D1T1   *A_in2ptr++, A_xdataKA:A_xdataC2  ; Load xdataKA:xdataC2
||      LDDW    .D2T2   *B_in3ptr++, B_xdataLB:B_xdataD3  ; Load xdataLB:xdataD3
||      SHRU    .S1     A_x,         2,         A_iters   ; iters = x >> 2

        LDDW    .D2T2   *B_in1ptr++, B_xdataJ9:B_xdataB1  ; Load xdataJ9:xdataB1

        LDDW    .D2T2   *B_in7ptr++, B_xdataPF:B_xdataH7  ; Load xdataPF:xdataH7

        LDDW    .D1T1   *A_in0ptr++, A_xdataI8:A_xdataA0  ; Load xdataI8:xdataA0
||      LDDW    .D2T2   *B_in5ptr++, B_xdataND:B_xdataF5  ; Load xdataND:xdataF5

        SUB     .L1     A_iters,    2,          A_iters   ; Adjust Loop II

        LDDW    .D1T1   *A_in4ptr++, A_xdataMC:A_xdataE4  ; Load xdataMC:xdataE4
||      MPY2    .M2     B_xdataD3,  B_l33, B_prod7:B_prod6; l33 * xdataD3

        LDDW    .D1T1   *A_in6ptr++, A_xdataOE:A_xdataG6   ;Load xdataOE:xdataG6
||      MPY2    .M1     A_xdataC2,  A_l22, A_prod5:A_prod4 ; l22 * xdataC2
||      MPY2    .M2     B_xdataLB,  B_l33, B_mpy7:B_mpy6   ; l33 * xdataLB

        MPY2    .M1     A_xdataKA,  A_l22, A_mpy5:A_mpy4   ; l22 * xdataKA
||      MPY2    .M2     B_xdataJ9,  B_l11, B_mpy3:B_mpy2   ; l11 * xdataJ9

        MPY2    .M1     A_xdataA0,  A_l00, A_prod1:A_prod0 ; l00 * xdataA0
||      MPY2    .M2     B_xdataB1,  B_l11, B_prod3:B_prod2 ; l11 * xdataB1
||      LDDW    .D1T1   *A_in2ptr++,A_xdataKA:A_xdataC2    ;Load xdataKA:xdataC2
||      LDDW    .D2T2   *B_in3ptr++,B_xdataLB:B_xdataD3    ;Load xdataLB:xdataD3

        MPY2    .M1     A_xdataI8,  A_l00, A_mpy1:A_mpy0   ; l00 * xdataI8
||      MPY2    .M2     B_xdataF5,  B_l55, B_prodB:B_prodA ; l55 * xdataF5
||      LDDW    .D2T2   *B_in1ptr++,B_xdataJ9:B_xdataB1    ;Load xdataJ9:xdataB1

        MPY2    .M1     A_xdataMC,  A_l44, A_mpy9:A_mpy8   ; l44 * xdataMC
||      MPY2    .M2     B_xdataH7,  B_l77, B_prodF:B_prodE ; l77 * xdataH7
||      LDDW    .D2T2   *B_in7ptr++,B_xdataPF:B_xdataH7    ;Load xdataPF:xdataH7

        MPY2    .M1     A_xdataE4,  A_l44, A_prod9:A_prod8 ; l44 * xdataE4
||      MPY2    .M2     B_xdataND,  B_l55, B_mpyB:B_mpyA   ; l55 * xdataND
||      LDDW    .D1T1   *A_in0ptr++,A_xdataI8:A_xdataA0    ;Load xdataI8:xdataA0
||      LDDW    .D2T2   *B_in5ptr++,B_xdataND:B_xdataF5    ;Load xdataND:xdataF5

        ADD     .D1     A_prod0,    A_prod4,    A_prod40        ; prod0 + prod4
||      ADD     .S2     B_prod2,    B_prod6,    B_prod26        ; prod2 + prod6
||      ADD     .D2     B_prod3,    B_prod7,    B_prod37        ; prod3 + prod7
||      MPY2    .M2     B_xdataPF,  B_l77,      B_mpyF:B_mpyE   ; l77 * xdataPF
||      MPY2    .M1     A_xdataG6,  A_l66,      A_prodD:A_prodC ; l66 * xdataG6

        ADD     .L1     A_mpy0,     A_mpy4,     A_mpy40         ; mpy0 + mpy4
||      ADD     .L2     B_mpy2,     B_mpy6,     B_mpy26         ; mpy2 + mpy6
||      ADD     .S2     B_mpy3,     B_mpy7,     B_mpy37         ; mpy3 + mpy7
||      MPY2    .M1     A_xdataOE,  A_l66,      A_mpyD:A_mpyC   ; l66 * xdataOE
||      LDDW    .D1T1   *A_in4ptr++,A_xdataMC:A_xdataE4         ;xdataMC:xdataE4
||      MPY2    .M2     B_xdataD3,  B_l33,      B_prod7:B_prod6 ;l33 * xdataD3
||      B       .S1     L_4 + 4                                 ; Branch cyc. 4

        ADD     .D2     B_prodA,    B_prodE,    B_prodAE        ; prodA + prodE
||      ADD     .S2     B_prodB,    B_prodF,    B_prodBF        ; prodB + prodF
||      LDDW    .D1T1   *A_in6ptr++,A_xdataOE:A_xdataG6         ;xdataOE:xdataG6
||      MPY2    .M1     A_xdataC2,  A_l22,      A_prod5:A_prod4 ; l22 * xdataC2
||      MPY2    .M2     B_xdataLB,  B_l33,      B_mpy7:B_mpy6   ; l33 * xdataLB
||      B       .S1     L_5 + 8                                 ; Branch cyc. 5

        ADD     .L1     A_mpy1,     A_mpy5,     A_mpy15         ; mpy1 + mpy5
||      ADD     .L2     B_prod37,   B_prodBF,   B_sum3          ;prod37+ prodBF
||      MPY2    .M1     A_xdataKA,  A_l22,      A_mpy5:A_mpy4   ; l22 * xdataKA
||      MPY2    .M2     B_xdataJ9,  B_l11,      B_mpy3:B_mpy2   ; l11 * xdataJ9
||      B       .S2     L_6                                     ; Branch cyc. 6

        ADD     .L2     B_mpyB,     B_mpyF,     B_mpyBF         ; mpyB + mpyF
||      ADD     .L1     A_prod8,    A_prodC,    A_prod8C        ; prod8 + prodC
||      ADD     .S1     A_prod1,    A_prod5,    A_prod15        ; prod1 + prod5
||      MPY2    .M1     A_xdataA0,  A_l00,      A_prod1:A_prod0 ; l00 * xdataA0
||      MPY2    .M2     B_xdataB1,  B_l11,      B_prod3:B_prod2 ; l11 * xdataB1
||      LDDW    .D1T1   *A_in2ptr++, A_xdataKA:A_xdataC2        ;xdataKA:xdataC2
||      LDDW    .D2T2   *B_in3ptr++, B_xdataLB:B_xdataD3        ;xdataLB:xdataD3
||      B       .S2     L_7 + 4                                 ; Branch cyc. 7

        ADD     .S2     B_mpyA,     B_mpyE,     B_mpyAE         ; mpyA + mpyE
||      ADD     .L1     A_mpy9,     A_mpyD,     A_mpy9D         ; mpy9 + mpyD
||      ADD     .D1     A_mpy8,     A_mpyC,     A_mpy8C         ; mpy8 + mpyC
||      ADD     .L2     B_mpy37,    B_mpyBF,    B_sum7          ; mpy37+ mpyBF
||      MPY2    .M1     A_xdataI8,  A_l00,      A_mpy1:A_mpy0   ; l00  * xdataI8
||      MPY2    .M2     B_xdataF5,  B_l55,      B_prodB:B_prodA ; l55  * xdataF5
||      LDDW    .D2T2   *B_in1ptr++,B_xdataJ9:B_xdataB1         ;xdataJ9:xdataB1
||      B       .S1     L_8 + 4                                 ; Branch cyc. 8

        ADD     .D1     A_mpy40,    A_mpy8C,    A_sum4          ; mpy40 + mpy8C
||      ADD     .L1     A_mpy15,    A_mpy9D,    A_sum6          ; mpy15 + mpy9D
||      ADD     .L2     B_mpy26,    B_mpyAE,    B_sum5          ; mpy26 + mpyAE
||      MPY2    .M1     A_xdataMC,  A_l44,      A_mpy9:A_mpy8   ; l44 * xdataMC
||      MPY2    .M2     B_xdataH7,  B_l77,      B_prodF:B_prodE ; l77 * xdataH7
||      LDDW    .D2T2   *B_in7ptr++,B_xdataPF:B_xdataH7         ;xdataPF:xdataH7
||      B       .S2     LOOPL                                   ; Branch. Loop

; ============================ PIPE LOOP KERNEL ==============================
LOOPL:

;------------------------------------------------------------------------------;
; 32 multiplies are completed in 8 cycles to produce 4 output pixels.          ;
; Each output pixel requires 8 multiplies because an 8 tap wavelet filter      ;
; is used for the de-composition. 64 instructions are performed in 8 cycles    ;
;------------------------------------------------------------------------------;

L_1:                                                            ; Cycle 1
        ADD     .S2     B_qr,       B_sum_t0,   B_sum_l0        ; qr + sum_t0
||      ADD     .L2     B_mpyB,     B_mpyF,     B_mpyBF         ; mpyB * mpyF
||      ADD     .L1     A_prod8,    A_prodC,    A_prod8C        ; prod8* prodC
||      ADD     .S1     A_prod1,    A_prod5,    A_prod15        ; prod1* prod5
||      MPY2    .M1     A_xdataA0,  A_l00,      A_prod1:A_prod0 ; l00 * xdataA0
||      MPY2    .M2     B_xdataB1,  B_l11,      B_prod3:B_prod2 ; l11 * xdataB1
||      LDDW    .D1T1   *A_in2ptr++,A_xdataKA:A_xdataC2         ;xdataKA:xdataC2
||      LDDW    .D2T2   *B_in3ptr++,B_xdataLB:B_xdataD3         ;xdataLB:xdataD3

L_2:                                                            ; Cycle 2
        SHR     .S1X    B_sum_l2,   15,         A_sum_l2s       ; sum_l2 >> 15
||      ADD     .S2     B_mpyA,     B_mpyE,     B_mpyAE         ; mpyA + mpyE
||      ADD     .L1     A_mpy9,     A_mpyD,     A_mpy9D         ; mpy9 + mpyD
||      ADD     .D1     A_mpy8,     A_mpyC,     A_mpy8C         ; mpy8 + mpyC
||      ADD     .L2     B_mpy37,    B_mpyBF,    B_sum7          ; mpy37+ mpyBF
||      MPY2    .M1     A_xdataI8,  A_l00,      A_mpy1:A_mpy0   ; l00 * xdataI8
||      MPY2    .M2     B_xdataF5,  B_l55,      B_prodB:B_prodA ; l55 * xdataF5
||      LDDW    .D2T2   *B_in1ptr++,B_xdataJ9:B_xdataB1         ;xdataJ9:xdataB1

L_3:                                                            ; Cycle 3
        BDEC    .S1     LOOPL,      A_iters                     ; Decr. Branch
||      SHR     .S2X    A_sum_l1,   15,         B_sum_l1s       ; sum_l1 >> 15
||      ADD     .D1     A_mpy40,    A_mpy8C,    A_sum4          ; mpy40 + mpy8C
||      ADD     .L1     A_mpy15,    A_mpy9D,    A_sum6          ; mpy15 + mpy9D
||      ADD     .L2     B_mpy26,    B_mpyAE,    B_sum5          ; mpy26 + mpyAE
||      MPY2    .M1     A_xdataMC,  A_l44,      A_mpy9:A_mpy8   ; l44 * xdataMC
||      MPY2    .M2     B_xdataH7,  B_l77,      B_prodF:B_prodE ; l77 * xdataH7
||      LDDW    .D2T2   *B_in7ptr++,B_xdataPF:B_xdataH7         ;xdataPF:xdataH7

L_4:                                                            ; Cycle 4
        SHR     .S2X    A_sum_l3,   15,         B_sum_l3s       ; sum_l3 >> 15
||      ADD     .S1X    A_sum6,     B_sum7,     A_sum_t3        ; sum6 + sum7
||      ADD     .L1     A_prod40,   A_prod8C,   A_sum0          ; prod40+ prod8C
||      ADD     .L2     B_prod26,   B_prodAE,   B_sum1          ; prod26+ prodAE
||      MPY2    .M1     A_xdataE4,  A_l44,      A_prod9:A_prod8 ; l44 * xdataE4
||      MPY2    .M2     B_xdataND,  B_l55,      B_mpyB:B_mpyA   ; l55 * xdataND
||      LDDW    .D1T1   *A_in0ptr++,A_xdataI8:A_xdataA0         ;xdataI8:xdataA0
||      LDDW    .D2T2   *B_in5ptr++,B_xdataND:B_xdataF5         ;xdataND:xdataF5

L_5:                                                            ; Cycle 5
        SHR     .S1X    B_sum_l0,   15,         A_sum_l0s       ; sum_l0 >> 15
||      PACK2   .L2X    B_sum_l3s,  A_sum_l2s,  B_oword1        ;sum_l3s:sum_l2s
||      ADD     .L1     A_prod9,    A_prodD,    A_prod9D        ; prod9 + prodD
||      ADD     .D1     A_prod0,    A_prod4,    A_prod40        ; prod0 + prod4
||      ADD     .S2     B_prod2,    B_prod6,    B_prod26        ; prod2 + prod6
||      ADD     .D2     B_prod3,    B_prod7,    B_prod37        ; prod3 + prod7
||      MPY2    .M2     B_xdataPF,  B_l77,      B_mpyF:B_mpyE   ; l77 * xdataPF
||      MPY2    .M1     A_xdataG6,  A_l66,      A_prodD:A_prodC ; l66 * xdataG6

L_6:                                                            ; Cycle 6
        ADD     .S1     A_prod15,   A_prod9D,   A_sum2          ; prod15+ prod9D
||      ADD     .D2X    A_sum4,     B_sum5,     B_sum_t2        ; sum4  + sum5
||      ADD     .L1     A_mpy0,     A_mpy4,     A_mpy40         ; mpy0  + mpy4
||      ADD     .L2     B_mpy2,     B_mpy6,     B_mpy26         ; mpy2  + mpy6
||      ADD     .S2     B_mpy3,     B_mpy7,     B_mpy37         ; mpy3  + mpy7
||      MPY2    .M1     A_xdataOE,  A_l66,      A_mpyD:A_mpyC   ; l66 * xdataOE
||      LDDW    .D1T1   *A_in4ptr++,A_xdataMC:A_xdataE4         ;xdataMC:xdataE4
||      MPY2    .M2     B_xdataD3,  B_l33,      B_prod7:B_prod6 ; l33 * xdataD3

L_7:                                                            ; Cycle 7
        PACK2   .L2X    B_sum_l1s,  A_sum_l0s,  B_oword0        ;sum_l1s+sum_l0s
||      ADD     .S1X    A_sum2,     B_sum3,     A_sum_t1        ; sum2 + sum3
||      ADD     .L1     A_qr,       A_sum_t3,   A_sum_l3        ; qr + sum_t3
||      ADD     .D2     B_prodA,    B_prodE,    B_prodAE        ; prodA + prodE
||      ADD     .S2     B_prodB,    B_prodF,    B_prodBF        ; prodB + prodF
||      LDDW    .D1T1   *A_in6ptr++,A_xdataOE:A_xdataG6         ;xdataOE:xdataG6
||      MPY2    .M1     A_xdataC2,  A_l22,      A_prod5:A_prod4 ; l22 * xdataC2
||      MPY2    .M2     B_xdataLB,  B_l33,      B_mpy7:B_mpy6   ; l33 * xdataLB

L_8:                                                            ; Cycle 8
        STDW    .D1T2   B_oword1:B_oword0,      *A_yptr++       ; Store output
||      ADD     .S1     A_qr,       A_sum_t1,   A_sum_l1        ; qr + sum_t1
||      ADD     .S2     B_qr,       B_sum_t2,   B_sum_l2        ; qr + sum_t2
||      ADD     .D2X    A_sum0,     B_sum1,     B_sum_t0        ; sum0 + sum1
||      ADD     .L1     A_mpy1,     A_mpy5,     A_mpy15         ; mpy1 + mpy5
||      ADD     .L2     B_prod37,   B_prodBF,   B_sum3          ; prod37+prodBF
||      MPY2    .M1     A_xdataKA,  A_l22,      A_mpy5:A_mpy4   ; l22 * xdataKA
||      MPY2    .M2     B_xdataJ9,  B_l11,      B_mpy3:B_mpy2   ; l11 * xdataJ9

; ============================ PIPE LOOP EPILOG ==============================
; EPILOG:

; ============================================================================
; END:

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B14,        B_ihptr
        .asg            B13,        B_filter
        .asg            A8,         A_yhptr
        .asg            B0,         B_j
        .asg            A10,        A_yptr
        .asg            A0,         A_l00
        .asg            B17,        B_l11
        .asg            A1,         A_l22
        .asg            B16,        B_l33
        .asg            A2,         A_l44
        .asg            B19,        B_l55
        .asg            A16,        A_l66
        .asg            B18,        B_l77
        .asg            A7,         A_in0ptr
        .asg            B7,         B_in1ptr
        .asg            A14,        A_in2ptr
        .asg            B2,         B_in3ptr
        .asg            A9,         A_in4ptr
        .asg            B1,         B_in5ptr
        .asg            A11,        A_in6ptr
        .asg            B3,         B_in7ptr
        .asg            A0,         A_ihptr
        .asg            A0,         A_filter
        .asg            A1,         A_h10
        .asg            B5,         B_h32
        .asg            A0,         A_h54
        .asg            B6,         B_h76
        .asg            B21,        B_l00
        .asg            A4,         A_l33
        .asg            B2,         B_l44
        .asg            A2,         A_l77
; ============================================================================
;L; instructions are for outer loop
;R; instructions are for return branch.

        MV      .L1X    B_filter,   A_filter              ;L; Load highpass
||      LDW     .D2T2   *+B_filter[1],          B_h32     ;L; Load h32
||[ B_j]SUB     .S2     B_j,        1,          B_j       ;L; j--

  [ B_j]LDW     .D1T1   *+A_filter[0],          A_h10     ;L; Load h10
||[!B_j]LDDW    .D2T2   *+B_SP[1],  B_ret:B_csr           ;R; Get rtn, CSR

  [ B_j]LDW     .D1T1   *+A_filter[2],          A_h54     ;L; Load h54
||[ B_j]LDW     .D2T2   *+B_filter[3],          B_h76     ;L; Load x76
||[ B_j]MV      .S1X    B_ihptr,    A_ihptr               ;L; Reload

  [ B_j]LDW     .D2T2   *+B_ihptr[7],           B_in7ptr  ;L; Reload pointer
||[ B_j]LDW     .D1T1   *+A_ihptr[6],           A_in6ptr  ;L; Reload pointer

  [ B_j]LDW     .D2T2   *+B_ihptr[5],           B_in5ptr  ;L; Reload pointer
||[ B_j]LDW     .D1T1   *+A_ihptr[4],           A_in4ptr  ;L; Reload pointer

  [ B_j]LDW     .D2T2   *+B_ihptr[3],           B_in3ptr  ;L; Reload pointer
||[ B_j]LDW     .D1T1   *+A_ihptr[2],           A_in2ptr  ;L; Reload pointer
||[ B_j]B       .S2     LOOPJ                             ;L; Branch.

  [ B_j]LDW     .D2T2   *+B_ihptr[1],           B_in1ptr  ;L; load pointer
||[ B_j]LDW     .D1T1   *+A_ihptr[0],           A_in0ptr  ;L; load pointer

  [ B_j]PACK2   .S1     A_h10,      A_h10,      A_l77     ;L; h0:h0
||[ B_j]PACKH2  .S2     B_h32,      B_h32,      B_l44     ;L; h3:h3
||[!B_j]MV              B_SP,       A_SP                  ;L; Twin Stack Ptr

  [ B_j]PACK2   .S1     A_h54,      A_h54,      A_l33     ;L; h4:h4
||[ B_j]PACKH2  .S2     B_h76,      B_h76,      B_l00     ;L; h7:h7
||[ B_j]MV      .L1     A_yhptr,    A_yptr                ;L; Part. move
||[!B_j]LDDW    .D1T1   *+A_SP[2],  A11:A10               ;R; Restore A11, A10
||[!B_j]LDDW    .D2T2   *+B_SP[3],  B11:B10               ;R; Restore B11, B10

  [ B_j]MV      .L2X    A_l77,      B_l77                 ;L; Part.move
||[ B_j]PACKH2  .L1     A_h10,      A_h10,      A_l66     ;L; h1:h1
||[ B_j]MV      .S1X    B_l44,      A_l44                 ;L; Part. move
||[!B_j]LDDW    .D1T1   *+A_SP[4],  A13:A12               ;R; Restore A13, A12
||[!B_j]LDDW    .D2T2   *+B_SP[5],  B13:B12               ;R; Restore B13, B12

  [ B_j]PACK2   .L2     B_h32,      B_h32,      B_l55     ;L; h2:h2
||[ B_j]MV      .D2X    A_l33,      B_l33                 ;L; Part. move
||[ B_j]PACKH2  .L1     A_h54,      A_h54,      A_l22     ;L; h5:h5
||[ B_j]PACK2   .S2     B_h76,      B_h76,      B_l11     ;L; h6:h6
||[ B_j]MV      .S1X    B_l00,      A_l00                 ;R; Part. move
||[!B_j]LDDW    .D1T1   *+A_SP[6],  A15:A14               ;R; Restore A15, A14

        ;==== Branch occurs

        LDW     .D2T2   *++B_SP[14],B14                     ; Restore B14, ...
||      RETNOP  .S2     B_ret,      4                       ; Return to caller
        MVC     .S2     B_csr,      CSR                     ; Restore CSR

        ;==== Branch Occurs ====
        ;==== Interruptibility state restored here ====

* ========================================================================= *
*   End of file:  img_wave_vert.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
yc_demux_0.asm/ 1066928953  0     0     0       18927     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Sun Sep 29 03:32:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_be16 -- De-interleave a 4:2:2 BIG ENDIAN video stream  *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       09-Oct-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_be16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in BIG ENDIAN byte order       *
*       within each 4-byte word.  This is consistent with reading the       *
*       video stream from a word-oriented BIG ENDIAN device while the       *
*       C6000 device is in a LITTLE ENDIAN configuration.                   *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              |cb0 y1  cr0 y0 |cb2 y3  cr2 y2 |cb4 y5  cr4 y4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in BIG ENDIAN mode, while the CPU is in LITTLE ENDIAN     *
*       mode.  This results in a pixel ordering which is not                *
*       immediately obvious.  This function correctly reorders the          *
*       pixel values so that further processing may proceed in LITTLE       *
*       ENDIAN mode.                                                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are double-word aligned.                    *
*       The input must be a multiple of 16 luma pixels long.                *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 16 times to allow for         *
*       processing 8 pixels in each datapath.                               *
*                                                                           *
*       Double-word loads and stores maximize memory bandwidth              *
*       utilization.                                                        *
*                                                                           *
*       This code uses _gmpy4() to ease the L/S/D unit bottleneck on        *
*       ANDs.  The _gmpy4(value, 0x00010001) is equivalent to               *
*       value & 0x00FF00FF, as long as the size field of GFPGFR is          *
*       equal to 7.  (The polynomial does not matter.)                      *
*                                                                           *
*   NOTES                                                                   *
*       This kernel is fully interruptible.                                 *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 3 * (num_luma / 8) + 18.                                   *
*       For num_luma = 1024, cycles = 402.                                  *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       316 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_yc_demux_be16"
        .global _IMG_yc_demux_be16
_IMG_yc_demux_be16:
* =============== SYMBOLIC REGISTER ASSIGNMENTS: ARGUMENTS ================ *
        .asg            A4,         A_n         ; Number of Y pixels
        .asg            B4,         B_yc        ; Interleaved Y/Cr/Cb
        .asg            A6,         A_y         ; Luma plane (16-bit)
        .asg            B6,         B_cr        ; Cr chroma plane (16-bit)
        .asg            A8,         A_cb        ; Cb chroma plane (16-bit)
        .asg            B3,         B_ret_addr  ; Return address
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i
        .asg            A1,         A_p
        .asg            A16,        A_y0r0y1b0
        .asg            A17,        A_y2r2y3b2
        .asg            A18,        A_r0b0
        .asg            A18,        A_r4b4
        .asg            A19,        A_yc
        .asg            A20,        A_cr
        .asg            A21,        A_r6b6
        .asg            A23,        A_00010001
        .asg            A24,        A_y1y0
        .asg            A24,        A_y5y4
        .asg            A25,        A_y0y1
        .asg            A25,        A_y3y2
        .asg            A25,        A_y7y6
        .asg            A26,        A_y4r4y5b4
        .asg            A27,        A_y6r6y7b6
        .asg            A28,        A_b2b0
        .asg            A28,        A_r2b2
        .asg            A28,        A_y2y3
        .asg            A29,        A_b6b4
        .asg            A30,        A_r2r0
        .asg            A30,        A_y4y5
        .asg            A30,        A_y6y7
        .asg            A31,        A_r6r4
        .asg            B5,         B_gfpgfr
        .asg            B7,         B_yEyF
        .asg            B16,        B_y8r8y9b8
        .asg            B17,        B_yArAyBbA
        .asg            B18,        B_rEbE
        .asg            B19,        B_y
        .asg            B20,        B_cb
        .asg            B21,        B_00FF00FF
        .asg            B22,        B_bAb8
        .asg            B22,        B_rAbA
        .asg            B23,        B_bEbC
        .asg            B23,        B_rCbC
        .asg            B24,        B_yCrCyDbC
        .asg            B25,        B_yErEyFbE
        .asg            B26,        B_r8b8
        .asg            B26,        B_yAyB
        .asg            B26,        B_y9y8
        .asg            B27,        B_y8y9
        .asg            B27,        B_yByA
        .asg            B28,        B_yDyC
        .asg            B29,        B_yCyD
        .asg            B29,        B_yFyE
        .asg            B30,        B_rAr8
        .asg            B31,        B_rErC
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDDW    .D2T1   *B_yc[1],   A_y6r6y7b6:A_y4r4y5b4       ;[ 1,1]
||      MVK     .S2     0x00FF,     B_00FF00FF
||      ADD     .S1X    B_yc,       8,          A_yc
||      ZERO    .L1     A_p

        MVKLH   .S1     0x0700,     A_p
||      ADD     .L1     A_yc,       8,          A_yc
||      LDDW    .D2T2   *B_yc[3],   B_yErEyFbE:B_yCrCyDbC       ;[ 1,1]
||      PACK2   .S2     B_00FF00FF, B_00FF00FF, B_00FF00FF

        MVC     .S2     GFPGFR,     B_gfpgfr
||      ADD     .L2X    A_y,        8,          B_y
||      SHRU    .S1     A_n,        4,          A_i

        MVC     .S2X    A_p,        GFPGFR
||      SHRU2   .S1X    B_00FF00FF, 7,          A_00010001

        LDDW    .D2T1   *B_yc++[4], A_y2r2y3b2:A_y0r0y1b0       ;[ 5,1]
||      LDDW    .D1T2   *A_yc++[4], B_yArAyBbA:B_y8r8y9b8       ;[ 5,1]
||      ADD     .L2     B_y,        8,          B_y
||      SUB     .L1     A_i,        2,          A_i
||      ADD     .S1X    B_cr,       8,          A_cr

        ANDN    .S1X    A_y4r4y5b4, B_00FF00FF, A_y4y5          ;[ 6,1]
||      ADD     .L2X    A_cb,       8,          B_cb
; ===== 1 prolog stage removed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        BDEC    .S1     loop,       A_i                         ;[13,1]
||      PACKH2  .S2     B_rEbE,     B_rCbC,     B_rErC          ;[13,1]
||      ROTL    .M1     A_y4y5,     8,          A_y5y4          ;[ 7,2]
||      ANDN    .L1X    A_y6r6y7b6, B_00FF00FF, A_y6y7          ;[ 7,2]
||      ANDN    .L2     B_yErEyFbE, B_00FF00FF, B_yEyF          ;[ 7,2]
||      LDDW    .D2T1   *B_yc[1],   A_y6r6y7b6:A_y4r4y5b4       ;[ 1,3]
||      LDDW    .D1T2   *A_yc[1],   B_yErEyFbE:B_yCrCyDbC       ;[ 1,3]

  [!A_p]STDW    .D1T1   A_y3y2:A_y1y0,          *A_y++[4]       ;[14,1]
||[!A_p]STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]         ;[14,1]
||      PACK2   .L1     A_r2b2,     A_r0b0,     A_b2b0          ;[14,1]
||      PACK2   .S2     B_rEbE,     B_rCbC,     B_bEbC          ;[14,1]
||      PACKH2  .S1     A_r2b2,     A_r0b0,     A_r2r0          ;[14,1]
||      ROTL    .M1     A_y6y7,     8,          A_y7y6          ;[ 8,2]
||      ROTL    .M2     B_yEyF,     8,          B_yFyE          ;[ 8,2]
||      ANDN    .L2     B_yCrCyDbC, B_00FF00FF, B_yCyD          ;[ 8,2]

  [!A_p]STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb++[2]      ;[15,1]
||[!A_p]STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb++[2]      ;[15,1]
||      ROTL    .M2     B_yCyD,     8,          B_yDyC          ;[ 9,2]
||      AND     .L1X    A_y4r4y5b4, B_00FF00FF, A_r4b4          ;[ 9,2]
||      AND     .S1X    A_y6r6y7b6, B_00FF00FF, A_r6b6          ;[ 9,2]
||      AND     .S2     B_yCrCyDbC, B_00FF00FF, B_rCbC          ;[ 9,2]
||      AND     .L2     B_yErEyFbE, B_00FF00FF, B_rEbE          ;[ 9,2]
||      DOTPN2  .M1     A_00010001, A_00010001, A_p

  [!A_p]STDW    .D2T2   B_yByA:B_y9y8,          *B_y++[4]       ;[16,1]
||      STDW    .D1T1   A_y7y6:A_y5y4,          *A_y[1]         ;[10,2]
||      ANDN    .S1X    A_y0r0y1b0, B_00FF00FF, A_y0y1          ;[10,2]
||      ANDN    .L1X    A_y2r2y3b2, B_00FF00FF, A_y2y3          ;[10,2]
||      ANDN    .L2     B_y8r8y9b8, B_00FF00FF, B_y8y9          ;[10,2]
||      ANDN    .S2     B_yArAyBbA, B_00FF00FF, B_yAyB          ;[10,2]
||      GMPY4   .M1     A_y0r0y1b0, A_00010001, A_r0b0          ;[10,2]

        ROTL    .M1     A_y2y3,     8,          A_y3y2          ;[11,2]
||      ROTL    .M2     B_yAyB,     8,          B_yByA          ;[11,2]
||      PACK2   .S1     A_r6b6,     A_r4b4,     A_b6b4          ;[11,2]
||      AND     .L1X    A_y2r2y3b2, B_00FF00FF, A_r2b2          ;[11,2]
||      AND     .L2     B_y8r8y9b8, B_00FF00FF, B_r8b8          ;[11,2]
||      AND     .S2     B_yArAyBbA, B_00FF00FF, B_rAbA          ;[11,2]
||      LDDW    .D2T1   *B_yc++[4], A_y2r2y3b2:A_y0r0y1b0       ;[ 5,3]
||      LDDW    .D1T2   *A_yc++[4], B_yArAyBbA:B_y8r8y9b8       ;[ 5,3]

  [!A_p]STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr++[2]      ;[18,1]
||[!A_p]STDW    .D1T2   B_rErC:B_rAr8,          *A_cr++[2]      ;[18,1]
||      ROTL    .M1     A_y0y1,     8,          A_y1y0          ;[12,2]
||      ROTL    .M2     B_y8y9,     8,          B_y9y8          ;[12,2]
||      PACK2   .L2     B_rAbA,     B_r8b8,     B_bAb8          ;[12,2]
||      PACKH2  .L1     A_r6b6,     A_r4b4,     A_r6r4          ;[12,2]
||      PACKH2  .S2     B_rAbA,     B_r8b8,     B_rAr8          ;[12,2]
||      ANDN    .S1X    A_y4r4y5b4, B_00FF00FF, A_y4y5          ;[ 6,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage removed
        PACKH2  .L2     B_rEbE,     B_rCbC,     B_rErC          ;[13,3]
||      RET     .S2     B_ret_addr

        STDW    .D1T1   A_y3y2:A_y1y0,          *A_y++[4]       ;[14,3]
||      STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]         ;[14,3]
||      PACK2   .L1     A_r2b2,     A_r0b0,     A_b2b0          ;[14,3]
||      PACK2   .S2     B_rEbE,     B_rCbC,     B_bEbC          ;[14,3]
||      PACKH2  .S1     A_r2b2,     A_r0b0,     A_r2r0          ;[14,3]

        STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb++[2]      ;[15,3]
||      STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb++[2]      ;[15,3]

        STDW    .D2T2   B_yByA:B_y9y8,          *B_y++[4]       ;[16,3]

        MVC     .S2     B_gfpgfr,   GFPGFR

        STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr++[2]      ;[18,3]
||      STDW    .D1T2   B_rErC:B_rAr8,          *A_cr++[2]      ;[18,3]

* ========================================================================= *
*   End of file:  img_yc_demux_be16.asm                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

yc_demux_1.asm/ 1066928953  0     0     0       19415     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Sep 29 03:32:32 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_le16 -- De-interleave a 4:2:2 LITTLE ENDIAN video stream *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_le16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in LITTLE ENDIAN byte          *
*       order within each 4-byte word.  This is consistent with reading     *
*       the video stream from a word-oriented LITTLE ENDIAN device          *
*       while the C6000 device is in a LITTLE ENDIAN configuration.         *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              | y0 cr0 y1 cb0 | y2 cr2 y3 cb2 | y4 cr4 y5 cb4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*       Please see the IMGLIB function IMB_yc_demux_be16 for code which     *
*       handles input coming from a BIG ENDIAN device.                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in LITTLE ENDIAN mode, while the CPU is in LITTLE         *
*       ENDIAN mode.  This function unpacks the byte-oriented data          *
*       so that further processing may proceed in LITTLE ENDIAN mode.       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are double-word aligned.                    *
*       The input must be a multiple of 16 luma pixels long.                *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 16 times to allow for         *
*       processing 8 pixels in each datapath.                               *
*                                                                           *
*       Double-word loads and stores maximize memory bandwidth              *
*       utilization.                                                        *
*                                                                           *
*       This code uses _gmpy4() to ease the L/S/D unit bottleneck on        *
*       ANDs.  The _gmpy4(value, 0x00010001) is equivalent to               *
*       value & 0x00FF00FF, as long as the size field of GFPGFR is          *
*       equal to 7.  (The polynomial does not matter.)                      *
*                                                                           *
*   NOTES                                                                   *
*       This code is fully interruptible.                                   *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 3 * (num_luma / 8) + 18.                                   *
*       For num_luma = 1024, cycles = 402                                   *
*                                                                           *
*       This number includes 6 cycles of function call overhead.  The       *
*       exact overhead will vary depending on compiler options used.        *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_le16"
        .global _IMG_yc_demux_le16
_IMG_yc_demux_le16



* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_i
        .asg            B4,         B_yc
        .asg            A6,         A_y
        .asg            B6,         B_cr
        .asg            A8,         A_cb
        .asg            B3,         B_ret_addr

        .asg            A1,         A_p
        .asg            A2,         A_b0y1r0y0
        .asg            A3,         A_b2y3r2y2
        .asg            A16,        A_r0b0
        .asg            A17,        A_b0r0
        .asg            A18,        A_b6r6
        .asg            A19,        A_r2b2
        .asg            A20,        A_yc
        .asg            A21,        A_r6b6
        .asg            A22,        A_cr
        .asg            A23,        A_00010001
        .asg            A24,        A_r2r0
        .asg            A25,        A_b2r2
        .asg            A25,        A_r6r4
        .asg            A26,        A_b2b0
        .asg            A26,        A_y5y4
        .asg            A27,        A_b4r4
        .asg            A27,        A_b6b4
        .asg            A27,        A_y7y6
        .asg            A28,        A_b4y5r4y4
        .asg            A29,        A_b6y7r6y6
        .asg            A30,        A_r4b4
        .asg            A30,        A_y1y0
        .asg            A31,        A_y3y2

        .asg            B8,         B_bCyDrCyC
        .asg            B9,         B_bEyFrEyE
        .asg            B17,        B_gfpgfr
        .asg            B18,        B_rAbA
        .asg            B19,        B_rCbC
        .asg            B20,        B_rEbE
        .asg            B21,        B_cb
        .asg            B22,        B_00FF00FF
        .asg            B23,        B_y
        .asg            B24,        B_rAr8
        .asg            B24,        B_y9y8
        .asg            B25,        B_rErC
        .asg            B25,        B_yByA
        .asg            B26,        B_b8r8
        .asg            B26,        B_bAb8
        .asg            B26,        B_bErE
        .asg            B27,        B_bArA
        .asg            B27,        B_bEbC
        .asg            B28,        B_b8y9r8y8
        .asg            B29,        B_bAyBrAyA
        .asg            B29,        B_bCrC
        .asg            B30,        B_r8b8
        .asg            B30,        B_yDyC
        .asg            B31,        B_yFyE
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
        LDDW    .D2T1   *B_yc[1],   A_b6y7r6y6:A_b4y5r4y4       ;[ 1,1]
||      ZERO    .S1     A_p
||      ADD     .L1X    B_yc,       8,          A_yc
||      ADD     .L2X    A_y,        8,          B_y

        MVKLH   .S1     0x0700,     A_p
||      ADD     .L1     A_yc,       8,          A_yc
||      ADD     .L2     B_y,        8,          B_y
||      MVK     .S2     0x00FF,     B_00FF00FF

        LDDW    .D2T1   *B_yc++[4], A_b2y3r2y2:A_b0y1r0y0       ;[ 3,1]
||      LDDW    .D1T2   *A_yc[1],   B_bEyFrEyE:B_bCyDrCyC       ;[ 3,1]
||      PACK2   .L2     B_00FF00FF, B_00FF00FF, B_00FF00FF

        MVC     .S2     GFPGFR,     B_gfpgfr
||      ADD     .L1X    B_cr,       8,          A_cr
||      ADD     .L2X    A_cb,       8,          B_cb
||      SHRU    .S1     A_i,        4,          A_i

        MVC     .S2X    A_p,        GFPGFR
||      SHRU2   .S1X    B_00FF00FF, 7,          A_00010001
||      SUB     .L1     A_i,        2,          A_i

        ANDN    .L1X    A_b6y7r6y6, B_00FF00FF, A_b6r6          ;[ 6,1]
||      AND     .S1X    A_b4y5r4y4, B_00FF00FF, A_y5y4          ;[ 6,1]
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        BDEC    .S1     loop,       A_i                         ;[13,1]
||      ROTL    .M1     A_b4r4,     8,          A_r4b4          ;[13,1]
||      ROTL    .M2     B_b8r8,     8,          B_r8b8          ;[13,1]
||      AND     .L2     B_b8y9r8y8, B_00FF00FF, B_y9y8          ;[13,1]
||      AND     .S2     B_bAyBrAyA, B_00FF00FF, B_yByA          ;[13,1]
||      AND     .L1X    A_b6y7r6y6, B_00FF00FF, A_y7y6          ;[ 7,2]
||      LDDW    .D1T2   *A_yc++[4], B_bAyBrAyA:B_b8y9r8y8       ;[ 7,2]
||      LDDW    .D2T1   *B_yc[1],   A_b6y7r6y6:A_b4y5r4y4       ;[ 1,3]

  [!A_p]STDW    .D1T1   A_y3y2:A_y1y0,          *A_y++[4]       ;[14,1]
||[!A_p]STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]         ;[14,1]
||      PACK2   .S2     B_rEbE,     B_rCbC,     B_bEbC          ;[14,1]
||      ROTL    .M2     B_bArA,     8,          B_rAbA          ;[14,1]
||      ANDN    .L1X    A_b2y3r2y2, B_00FF00FF, A_b2r2          ;[ 8,2]
||      ANDN    .L2     B_bEyFrEyE, B_00FF00FF, B_bErE          ;[ 8,2]
||      GMPY4   .M1     A_b0y1r0y0, A_00010001, A_y1y0          ;[ 8,2]
||      AND     .S1X    A_b2y3r2y2, B_00FF00FF, A_y3y2          ;[ 8,2]

        PACKH2  .L1     A_r2b2,     A_r0b0,     A_r2r0          ;[15,1]
||      ANDN    .S1X    A_b0y1r0y0, B_00FF00FF, A_b0r0          ;[ 9,2]
||      ANDN    .S2     B_bCyDrCyC, B_00FF00FF, B_bCrC          ;[ 9,2]
||      AND     .L2     B_bEyFrEyE, B_00FF00FF, B_yFyE          ;[ 9,2]
||      LDDW    .D2T1   *B_yc++[4], A_b2y3r2y2:A_b0y1r0y0       ;[ 3,3]
||      LDDW    .D1T2   *A_yc[1],   B_bEyFrEyE:B_bCyDrCyC       ;[ 3,3]
||[ A_p]DOTPN2  .M1     A_00010001, A_00010001, A_p             ; pro collapse

  [!A_p]STDW    .D2T2   B_yByA:B_y9y8,          *B_y++[4]       ;[16,1]
||      PACK2   .S1     A_r2b2,     A_r0b0,     A_b2b0          ;[16,1]
||      PACK2   .L1     A_r6b6,     A_r4b4,     A_b6b4          ;[16,1]
||      PACK2   .S2     B_rAbA,     B_r8b8,     B_bAb8          ;[16,1]
||      PACKH2  .L2     B_rAbA,     B_r8b8,     B_rAr8          ;[16,1]
||      STDW    .D1T1   A_y7y6:A_y5y4,          *A_y[1]         ;[10,2]
||      ROTL    .M1     A_b6r6,     8,          A_r6b6          ;[10,2]
||      ROTL    .M2     B_bErE,     8,          B_rEbE          ;[10,2]

  [!A_p]STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb++[2]      ;[17,1]
||[!A_p]STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb++[2]      ;[17,1]
||      PACKH2  .L1     A_r6b6,     A_r4b4,     A_r6r4          ;[17,1]
||      PACKH2  .S2     B_rEbE,     B_rCbC,     B_rErC          ;[17,1]
||      ROTL    .M1     A_b2r2,     8,          A_r2b2          ;[11,2]
||      ROTL    .M2     B_bCrC,     8,          B_rCbC          ;[11,2]
||      ANDN    .S1X    A_b4y5r4y4, B_00FF00FF, A_b4r4          ;[11,2]
||      AND     .L2     B_bCyDrCyC, B_00FF00FF, B_yDyC          ;[11,2]

  [!A_p]STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr++[2]      ;[18,1]
||[!A_p]STDW    .D1T2   B_rErC:B_rAr8,          *A_cr++[2]      ;[18,1]
||      ROTL    .M1     A_b0r0,     8,          A_r0b0          ;[12,2]
||      ANDN    .L2     B_b8y9r8y8, B_00FF00FF, B_b8r8          ;[12,2]
||      ANDN    .S2     B_bAyBrAyA, B_00FF00FF, B_bArA          ;[12,2]
||      ANDN    .L1X    A_b6y7r6y6, B_00FF00FF, A_b6r6          ;[ 6,3]
||      AND     .S1X    A_b4y5r4y4, B_00FF00FF, A_y5y4          ;[ 6,3]
* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage collapsed
        ROTL    .M1     A_b4r4,     8,          A_r4b4          ;[13,3]
||      ROTL    .M2     B_b8r8,     8,          B_r8b8          ;[13,3]
||      AND     .L2     B_b8y9r8y8, B_00FF00FF, B_y9y8          ;[13,3]
||      AND     .D2     B_bAyBrAyA, B_00FF00FF, B_yByA          ;[13,3]
||      RET             B_ret_addr

        STDW    .D1T1   A_y3y2:A_y1y0,          *A_y            ;[14,3]
||      STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]         ;[14,3]
||      PACK2   .S2     B_rEbE,     B_rCbC,     B_bEbC          ;[14,3]
||      ROTL    .M2     B_bArA,     8,          B_rAbA          ;[14,3]

        PACKH2  .L1     A_r2b2,     A_r0b0,     A_r2r0          ;[15,3]

        STDW    .D2T2   B_yByA:B_y9y8,          *B_y            ;[16,3]
||      PACK2   .S1     A_r2b2,     A_r0b0,     A_b2b0          ;[16,3]
||      PACK2   .L1     A_r6b6,     A_r4b4,     A_b6b4          ;[16,3]
||      PACK2   .S2     B_rAbA,     B_r8b8,     B_bAb8          ;[16,3]
||      PACKH2  .L2     B_rAbA,     B_r8b8,     B_rAr8          ;[16,3]

        STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb           ;[17,3]
||      STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb           ;[17,3]
||      PACKH2  .L1     A_r6b6,     A_r4b4,     A_r6r4          ;[17,3]
||      PACKH2  .S2     B_rEbE,     B_rCbC,     B_rErC          ;[17,3]

        STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr           ;[18,3]
||      STDW    .D1T2   B_rErC:B_rAr8,          *A_cr           ;[18,3]
||      MVC     .S2     B_gfpgfr,   GFPGFR

* ========================================================================= *
*   End of file:  img_yc_demux_le16.asm                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


ycbcr422p_.asm/ 1066928953  0     0     0       51660     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.12    Mon Oct 21 15:28:45 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_ycbcr422p_rgb565 -- Planarized YCbCr 4:2:2/4:2:0 to 16-bit      *
*                               RGB 5:6:5 color space conversion.           *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Oct-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called according to this        *
*       C prototype:                                                        *
*                                                                           *
*       void IMG_ycbcr422p_rgb565                                           *
*       (                                                                   *
*         const short         coeff[5],  /* Matrix coefficients.        */  *
*         const unsigned char *y_data,   /* Luminence data  (Y')        */  *
*         const unsigned char *cb_data,  /* Blue color-diff (B'-Y')     */  *
*         const unsigned char *cr_data,  /* Red color-diff  (R'-Y')     */  *
*         unsigned short                                                    *
*                    *restrict rgb_data, /* RGB 5:6:5 packed pixel out. */  *
*         unsigned            num_pixels /* # of luma pixels to process */  *
*       );                                                                  *
*                                                                           *
*       The 'coeff[]' array contains the color-space-conversion matrix      *
*       coefficients.  The 'y_data', 'cb_data' and 'cr_data' pointers       *
*       point to the separate input image planes.  The 'rgb_data' pointer   *
*                                                                           *
*       The kernel is designed to process arbitrary amounts of 4:2:2        *
*       image data, although 4:2:0 image data may be processed as well.     *
*       For 4:2:2 input data, the 'y_data', 'cb_data' and 'cr_data'         *
*       arrays may hold an arbitrary amount of image data, including        *
*       multiple scan lines of image data.                                  *
*                                                                           *
*       For 4:2:0 input data, only a single scan-line (or portion           *
*       thereof) may be processed at a time.  This is achieved by           *
*       calling the function twice using the same row data for              *
*       'cr_data' and 'cb_data', and providing new row data for             *
*       'y_data'.  This is numerically equivalent to replicating the Cr     *
*       and Cb pixels vertically.                                           *
*                                                                           *
*       The coefficients in the coeff array must be in signed Q13 form.     *
*       These coefficients correspond to the following matrix equation:     *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       The output from this kernel is 16-bit RGB in 5:6:5 format.          *
*       The RGB components are packed into halfwords as shown below.        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Red    |  Green   |   Blue   |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*       This kernel can also return the red, green, and blue values in      *
*       the opposite order if a particular application requires it.         *
*       This is achieved by exchanging the 'cb_data' and 'cr_data'          *
*       arguments when calling the function, and by reversing the order     *
*       of coefficients in coeff[1] through coeff[4].  This essentially     *
*       implements the following matrix multiply:                           *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[4] ]   [ Y' -  16 ]     [ B']         *
*           [ coeff[0] coeff[3] coeff[2] ] * [ Cr - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[1] 0.0000   ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       The reversed RGB ordering output by this mode is as follows:        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Blue   |  Green   |   Red    |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs Y'CbCr to RGB conversion.  From the Color      *
*       FAQ, http://home.inforamp.net/~poynton/ColorFAQ.html :              *
*                                                                           *
*           Various scale factors are applied to (B'-Y') and (R'-Y')        *
*           for different applications.  The Y'PbPr scale factors are       *
*           optimized for component analog video.  The Y'CbCr scaling       *
*           is appropriate for component digital video, JPEG and MPEG.      *
*           Kodak's PhotoYCC(tm) uses scale factors optimized for the       *
*           gamut of film colors.  Y'UV scaling is appropriate as an        *
*           intermediate step in the formation of composite NTSC or PAL     *
*           video signals, but is not appropriate when the components       *
*           are keps separate.  Y'UV nomenclature is now used rather        *
*           loosely, and it sometimes denotes any scaling of (B'-Y')        *
*           and (R'-Y').  Y'IQ coding is obsolete.                          *
*                                                                           *
*       This code can perform various flavors of Y'CbCr to RGB              *
*       conversion as long as the offsets on Y, Cb, and Cr are -16,         *
*       -128, and -128, respectively, and the coefficients match the        *
*       pattern shown.                                                      *
*                                                                           *
*       The kernel implements the following matrix form, which involves 5   *
*       unique coefficients:                                                *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*                                                                           *
*       Below are some common coefficient sets, along with the matrix       *
*       equation that they correspond to.   Coefficients are in signed      *
*       Q13 notation, which gives a suitable balance between precision      *
*       and range.                                                          *
*                                                                           *
*       1.  Y'CbCr -> RGB conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  Expected ranges are [16..235] for   *
*           Y' and [16..240] for Cb and Cr.                                 *
*                                                                           *
*           coeff[] = { 0x2000, 0x2BDD, -0x0AC5, -0x1658, 0x3770 };         *
*                                                                           *
*           [ 1.0000    0.0000    1.3707 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.0000   -0.3365   -0.6982 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.0000    1.7324    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       2.  Y'CbCr -> RGB conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  (The matrix       *
*           has been scaled by 255/219.)  Expected ranges are [16..235]     *
*           for Y' and [16..240] for Cb and Cr.                             *
*                                                                           *
*           coeff[] = { 0x2543, 0x3313, -0x0C8A, -0x1A04, 0x408D };         *
*                                                                           *
*           [ 1.1644    0.0000    1.5960 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.1644   -0.3918   -0.8130 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.1644    2.0172    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       3.  Y'CbCr -> BGR conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  This is equivalent to #1 above,     *
*           except that the R, G, and B output order in the packed          *
*           pixels is reversed.  Note:  The 'cr_data' and 'cb_data'         *
*           input arguments must be exchanged for this example as           *
*           indicated under USAGE above.                                    *
*                                                                           *
*           coeff[] = { 0x2000, 0x3770, -0x1658, -0x0AC5, 0x2BDD };         *
*                                                                           *
*           [ 1.0000    0.0000    1.7324 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.6982   -0.3365 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.3707    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       4.  Y'CbCr -> BGR conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  This is           *
*           equivalent to #2 above, except that the R, G, and B output      *
*           order in the packed pixels is reversed.  Note:  The             *
*           'cr_data' and 'cb_data' input arguments must be exchanged       *
*           for this example as indicated under USAGE above.                *
*                                                                           *
*           coeff[] = { 0x2000, 0x408D, -0x1A04, -0x0C8A, 0x3313 };         *
*                                                                           *
*           [ 1.0000    0.0000    2.0172 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.8130   -0.3918 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.5960    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       Other scalings of the color differences (B'-Y') and (R'-Y')         *
*       (sometimes incorrectly referred to as U and V) are supported, as    *
*       long as the color differences are unsigned values centered around   *
*       128 rather than signed values centered around 0, as noted above.    *
*                                                                           *
*       In addition to performing plain color-space conversion, color       *
*       saturation can be adjusted by scaling coeff[1] through coeff[4].    *
*       Similarly, brightness can be adjusted by scaling coeff[0].          *
*       General hue adjustment can not be performed, however, due to the    *
*       two zeros hard-coded in the matrix.                                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       Pixel replication is performed implicitly on chroma data to         *
*       reduce the total number of multiplies required.  The chroma         *
*       portion of the matrix is calculated once for each Cb, Cr pair,      *
*       and the result is added to both Y' samples.                         *
*                                                                           *
*       Matrix Multiplication is performed as a combination of MPY2s and    *
*       DOTP2s.  Saturation to 8bit values is performed using SPACKU4       *
*       which takes in 4 signed 16-bit values and saturates them to         *
*       unsigned 8-bit values.  The output of Matrix Multiplication would   *
*       ideally be in a Q13 format.  This however, cannot be fed directly   *
*       to SPACKU4.                                                         *
*                                                                           *
*       This implies a shift left by 3 bits, which could be pretty          *
*       expensive in terms of the number of shifts to be performed.  Thus,  *
*       to avoid being bottlenecked by so many shifts, the Y, Cr & Cb data  *
*       are shifted left by 3 before multiplication.  This is possible      *
*       because they are 8-bit unsigned data.  Due to this, the output of   *
*       Matrix Multiplication is in a Q16 format, which can be directly     *
*       fed to SPACKU4.                                                     *
*                                                                           *
*       Because the loop accesses four different arrays at three            *
*       different strides, no memory accesses are allowed to parallelize    *
*       in the loop.  No bank conflicts occur, as a result.                 *
*                                                                           *
*       The epilog has been completely removed, while the prolog is left    *
*       as is. However, some cycles of the prolog are performed using the   *
*       kernel cycles to help reduce code-size. The setup code is merged    *
*       along with the prolog for speed.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of luma samples to be processed needs to be a multiple   *
*       of 8.                                                               *
*       The input Y array needs to be double-word aligned.                  *
*       The input Cr and Cb arrays need to be word aligned                  *
*       The output image must be double-word aligned.                       *
*                                                                           *
*   NOTES                                                                   *
*       No bank conflicts occur.                                            *
*                                                                           *
*       Codesize is 952 bytes.                                              *
*                                                                           *
*       Memory bank conflicts will not occurs since the 3 loads and two     *
*       stores happen in different cycles of the loop                       *
*                                                                           *
*       The kernel requires 3 words of stack space.                         *
*                                                                           *
*   CYCLES                                                                  *
*       12 * num_pixels/8 + 50                                              *
*                                                                           *
*   CODESIZE                                                                *
*       952 bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       Poynton, Charles et al.  "The Color FAQ,"  1999.                    *
*           http://home.inforamp.net/~poynton/ColorFAQ.html                 *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_ycbcr422pl_to_rgb565"
        .global _IMG_ycbcr422p_rgb565
_IMG_ycbcr422p_rgb565:

         .asg       B0,         B_k08       ; Constant of 0x08080808
         .asg       B1,         B_loopcnt   ; Loop counter
         .asg       A2,         A_lp0       ; Predicate register, to reduce prolog size
         .asg       B2,         B_rgb_ptr   ; Pointer to output RGB data
         .asg       B3,         B_ret       ; Return address
         .asg       A4,         A_coef      ; Pointer to Co-efficients
         .asg       A4,         A_y_data    ; Pointer to 'Y' data on A datapath
         .asg       B4,         B_y_data    ; Pointer to 'Y' data on B datapath
         .asg       A5,         A_cb_data   ; Pointer to 'Cb' data
         .asg       B5,         B_c2c3      ; g_cb : g_cr register
         .asg       A6,         A_cb_data_in; Input pointer to 'Cb' data
         .asg       B6,         B_cr_data   ; Pointer to 'Cr' data
         .asg       A8,         A_rgb_data  ; Pointer to output RGB data
         .asg       B8,         B_num_pix   ; Number of pixels to be processed
         .asg       B8,         B_cr6420    ; Loaded Word of 'Cr' data
         .asg       A9,         A_g_cr      ; g_cr : g_cr data
         .asg       B9,         B_coef      ; Pointer to Co-efficients
         .asg       B10,        B_reg10     ; Input B10 register; to be stored on stack
         .asg       B11,        B_reg11     ; Input B11 register; to be stored on stack
         .asg       B11,        B_cr6420_   ; Biased Word of 'Cr' data
         .asg       B15,        B_SP        ; Stack pointer, B datapath
         .asg       A16,        A_rgb_ptr   ; Pointer to output RGB data
         .asg       B16,        B_n16       ; Constant 0x00800080
         .asg       A17,        A_k80       ; Constant 0x80808080
         .asg       B17,        B_c0        ; Luma co-efficient
         .asg       A18,        A_k08       ; Constant 0x08080808
         .asg       B18,        B_c1        ; r_cr co-efficient
         .asg       A19,        A_c4        ; b_cb co-efficient
         .asg       B19,        B_msk5      ; Mask to obtain the upper 5 bits of R & B
         .asg       A20,        A_msk6      ; Mask to obtain the upper 6 bits of G
         .asg       B20,        B_k01       ; Constant 0x01010101
         .asg       A21,        A_c2c3      ; g_cb : g_cr register
         .asg       B21,        B_c3c2      ; g_cr : g_cb register on B datapath
         .asg       A22,        A_c3c2      ; g_cr : g_cb register on A datapath
         .asg       B22,        B_y_3210    ; Loaded lower 4 pixels of 'Y' data
         .asg       A23,        A_cb6420_   ; Biased 'Cb' data
         .asg       B23,        B_y_7654    ; Loaded upper 4 pixels of 'Y' data
         .asg       A24,        A_y_10_     ; Lower 2 pixels of 'Y' multiplied by 8
         .asg       B24,        B_no_gie    ; CSR w/ GIE bit cleared
         .asg       B24,        B_cr20      ; Lower 2 samples 'Cr'
         .asg       A25,        A_y_32_     ; Upper 2 pixels of 'Y' multiplied by 8
         .asg       B25,        B_cr64      ; Biased Upper 'Cr' value multiplied by 8
         .asg       A26,        A_cb20      ; Biased Lower 'Cb' value multiplied by 8
         .asg       B26,        B_csr       ; CSR's value
         .asg       A27,        A_cb64      ; Biased Upper 'Cb' value multiplied by 8
         .asg       A28,        A_cb6420    ; Loaded 4 samples of 'Cb'
         .asg       B28,        B_y_54_     ; 'Y' samples multiplied by 8
         .asg       B29,        B_y_76_     ; 'Y' samples multiplied by 8
         .asg       B30,        B_g_cb      ; g_cb co-efficient

         .asg       A0,     A_g_0       ; Generated G pixel in 11:8:13 format
         .asg       A0,         A_y_10      ; Lower 2 pixels of Y after bias
         .asg       A3,         A_g_32      ; Packed G3 and G2 pixels
         .asg       A3,         A_g_2       ; Generated G pixel in 11:8:13 format
         .asg       A3,         A_cg2       ; Additional input to generate G pixels
         .asg       B4,         B_g_7654_   ; Upper 6 bits of Green pixels
         .asg       B4,         B_g_54      ; Packed G5 and G4 pixels
         .asg       B4,         B_g_7654    ; Saturated and packed 8bit values of G
         .asg       B4,         B_g_5       ; Generated G pixel in 11:8:13 format
         .asg       B5,         B_r_b54     ; Generated R & B pixel in 5:6:5 format
         .asg       B5,         B_r_76      ; Packed R7 and R6 pixels
         .asg       B5,         B_r_6       ; Generated R pixel in 11:8:13 format
         .asg       A6,         A_y_32      ; Biased Y pixels
         .asg       A6,         A_r_b32     ; Generated R & B pixel in 5:6:5 format
         .asg       A6,         A_rgb10     ; Final RGB values for pixels 0 & 1
         .asg       A6,         A_y_2_c0    ; Y2 and luma
         .asg       A7,         A_r_3       ; Generated R pixel in 11:8:13 format
         .asg       A7,         A_r_32      ; Packed R3 & R2 pixels
         .asg       A7,     A_r_b10     ; Generated R & B pixel in 5:6:5 format
         .asg       A7,         A_rgb32     ; Final RGB values for pixels 3 & 2
         .asg       A7,         A_y_3_c0    ; Y3 and luma
         .asg       B7,         B_b_54      ; Packed B5 and B4 pixels
         .asg       B7,         B_b_5       ; Generated B pixel in 11:8:13 format
         .asg       B7,         B_b_7654    ; Saturated and packed 8bit values of B
         .asg       B7,         B_b_7654_   ; Upper 5 bits of Blue pixels
         .asg       B7,         B_r_7       ; Generated R pixel in 11:8:13 format
         .asg       A8,         A_r_10      ; Packed R1 and R0 pixels
         .asg       A8,         A_r_3210    ; Saturated and packed 8bit values of R
         .asg       A8,         A_b_1       ; Generated B pixel in 11:8:13 format
         .asg       A8,         A_b_3210__  ;
         .asg       A8,         A_r_3210_   ; Upper 5 bits of generated R pixels
         .asg       A8,         A_r_1       ; Generated R pixel in 11:8:13 format
         .asg       B8,         B_b_7       ; Generated B pixel in 11:8:13 format
         .asg       B8,         B_cg4       ; Additional input to G pixel
         .asg       B8,         B_rgb54     ; Final RGB values for pixels 5 & 4
         .asg       B8,         B_y_54      ; Packed Y5 and Y4
         .asg       A9,         A_g_3210    ; Saturated and packed 8bit values of G
         .asg       A9,         A_r_2       ; Generated R pixel in 11:8:13 format
         .asg       A9,         A_g_1       ; Generated G pixel in 11:8:13 format
         .asg       A9,         A_g_10      ; Packed G1 and G0 pixels
         .asg       A9,         A_b_2       ; Generated B pixel in 11:8:13 format
         .asg       A9,         A_cg0       ; Additional input to G pixel
         .asg       B9,         B_rgb76     ; Final RGB values for pixels 7 & 6
         .asg       B9,         B_g_4       ; Generated G pixel in 11:8:13 format
         .asg       B9,         B_g_6       ; Generated G pixel in 11:8:13 format
         .asg       B9,         B_b_76      ; Packed B7 and B6 pixels
         .asg       B9,         B_r_5       ; Generated R pixel in 11:8:13 format
         .asg       B9,         B_cr6cb6    ; Packed Cr and Cb samples
         .asg       B10,        B_r_7654_   ; Upper 5 bits of generated R pixels
         .asg       B10,        B_r_54      ; Packed R5 and R4 pixels
         .asg       B11,        B_g_76      ; Packed G7 and G6 pixels
         .asg       B11,        B_b_7654__  ; To shift right the B pixels by 3
         .asg       B11,        B_cr4cb4    ; Packed Cr and Cb sample
         .asg       A16,        A_rgb_ptr   ; Final RGB output pointer
         .asg       B16,        B_n16       ; constant 0x00800080
         .asg       A17,        A_k80       ; constant 0x80808080
         .asg       B17,        B_c0        ; Luma = coef[0]
         .asg       A18,        A_k08       ; constant 0x08080808
         .asg       B18,        B_c1        ; r_cr = coef[1]
         .asg       A19,        A_c4        ; b_cb = coef[4]
         .asg       B19,        B_msk5      ; 5 bit mask to get upper 5 bits of R & B
         .asg       A20,        A_msk6      ; 6 bit mask to get upper 6 bits of G
         .asg       B20,        B_k01       ; constant 0x01010101
         .asg       A22,        A_g_3210_   ; Upper 6 bits of generated G pixels
         .asg       A22,        A_cb0cr0    ; Packed Cb and Cr pixels
         .asg       B22,        B_b5_b4     ; Packed B5 and B4 pixels
         .asg       B22,        B_r_7654    ; Saturated and packed 8bit values of R
         .asg       B22,        B_b_6       ; Generated B pixel in 11:8:13 format
         .asg       A23,        A_b_3210_   ; Upper 5 bits of generated B pixels
         .asg       A23,        A_b_32      ; Packed B3 and B2 pixels
         .asg       B23,        B_b7_b6     ; Packed B7 and B6 pixel
         .asg       B23,        B_r_b76     ; Packed R and B pixels
         .asg       B23,        B_b_4       ; Generated B pixel in 11:8:13 format
         .asg       B23,        B_g_7       ; Generated G pixel in 11:8:13 format
         .asg       A24,        A_b1_b0     ; Packed B1 and B0 pixels
         .asg       A24,        A_b_3       ; Generated B pixel in 11:8:13 format
         .asg       B24,        B_r_4       ; Generated R pixel in 11:8:13 format
         .asg       B24,        B_cr4_c1    ; Packed Cr and r_cr
         .asg       B24,        B_y_76      ; Packed Y7 and Y6 pixels
         .asg       A25,        A_b3_b2     ; Packed B3 and B2 pixels
         .asg       A25,        A_b_3210    ; Saturated and packed 8bit values of B
         .asg       A25,        A_cb2cr2    ; Packed Cb and Cr
         .asg       B25,        B_cg6       ; Additional input to G
         .asg       B25,        B_cr6_c1    ; Packed Cr and r_cr
         .asg       A26,        A_g1_g0     ; Packed G1 and G0 pixels
         .asg       B26,        B_r5_r4     ; Packed R5 and R4 pixels
         .asg       B26,        B_y_6_c0    ; Packed Y6 and luma
         .asg       A27,        A_g3_g2     ; Packed G3 and G2 pixels
         .asg       A27,        A_b_0       ; Generated B pixel in 11:8:13 format
         .asg       B27,        B_r7_r6     ; Packed R7 and R6 pixels
         .asg       B27,        B_y_7_c0    ; Packed Y7 and luma
         .asg       A28,        A_r_0       ; Generated R pixel in 11:8:13 format
         .asg       A28,        A_y_0_c0    ; Packed Y0 and luma
         .asg       A28,        A_cb4_c4    ; Packed Cb and b_cb
         .asg       A28,        A_cb6420    ; Loaded Cb pixels
         .asg       B28,        B_g5_g4     ; Packed G5 and G4 pixels
         .asg       B28,        B_y_4_c0    ; Packed Y4 and luma
         .asg       A29,        A_cb6_c4    ; Packed Cb and b_cb
         .asg       A29,        A_b_10      ; Packed B1 and B0
         .asg       A29,        A_y_1_c0    ; Packed Y1 and luma
         .asg       B29,        B_g7_g6     ; Packed G7 and G6
         .asg       B29,        B_y_5_c0    ; Packed Y5 and luma
         .asg       A30,        A_r1_r0     ; Packed R1 and R0
         .asg       A30,        A_cb0_c4    ; Packed Cb and b_cb coef
         .asg       B30,        B_cr0_c1    ; Packed Cr and r_cr coef
         .asg       A31,        A_g_3       ; Generated G pixel in 11:8:13 format
         .asg       A31,        A_r3_r2     ; Packed R3 and R2 pixels
         .asg       A31,        A_cb2_c4    ; Packed Cb and b_cb
         .asg       B31,        B_cr2_c1    ; Packed Cr and r_cr

* ===================== SETUP CODE ======================================== *

         MV   .L1     A_cb_data_in, A_cb_data        ; copy of input Cb ptr
||       MV   .L2x    A_coef,       B_coef           ; copy of Co-ef ptr on B side
||       LDHU .D1T1   *A_coef[4],   A_c4             ; Loading b_cb
||       LDW  .D2T2   *B_cr_data++, B_cr6420         ; loading first 4 Cr pixels
||       MVKL .S1     0x80808080,   A_k80            ; Moving  constant
||       MVC  .S2     CSR,          B_csr            ; Loading contents of CSR


         LDW  .D1T1   *A_cb_data++, A_cb6420         ; loading first 4 Cb pixels
||       LDHU .D2T2   *B_coef[1],   B_c1             ; r_cr = coef[1]
||       AND  .L2     B_csr,        -2,        B_no_gie;clear interrupt enable bit
||       MVKL .S1     0x08080808,   A_k08            ; Loading constant
||       SHRU .S2     B_num_pix,    3,         B_loopcnt; divide num_pix by 8
||       MV   .L1x    B_y_data,     A_y_data         ; copy of Y ptr


         PACK2.S1     A_k08,        A_k08,     A_k08 ; creating constant
||       MVC  .S2     B_no_gie,     CSR              ; disable Interrupts
||       SUB  .L2     B_loopcnt,    2,         B_loopcnt; Sub 2 due to BDEC
||       LDHU .D2T1   *B_coef[3],   A_g_cr           ; g_cr = coef[3]
||       LDDW .D1T2   *A_y_data++,  B_y_7654:B_y_3210; first set of 8 Y samples
||       PACK2.L1     A_k80,        A_k80,     A_k80 ; loading constant


         MV   .L2x    A_k08,        B_k08            ; copy of constant
||       MVKL .S2     0x01010101,   B_k01            ; creating constant
||       MV   .L1     A_rgb_data,   A_rgb_ptr        ; copy of RGB pointer
||       ZERO .D1     A_lp0
||       LDHU .D2T2   *B_coef[2],   B_g_cb           ; g_cb = coef[2]


         PACK2.L2     B_k01,        B_k01,     B_k01 ; creating constant
||       MVKL .S1     0xFCFCFCFC,   A_msk6           ; creating mask for upper 6 bits
||       MVKL .S2     0xF8F8F8F8,   B_msk5           ; creating mask for upper 5 bits
||       STDW .D2T2   B_reg11:B_reg10, *--B_SP       ; Save B10 & B11 onto stack


         PACK2 .L1    A_c4,         A_c4,      A_c4  ; b_cb:b_cb
||       PACK2 .L2    B_msk5,       B_msk5,    B_msk5; creating mask
||       PACK2 .S1    A_msk6,       A_msk6,    A_msk6; creating mask
||       MVKL .S2     0x00800080,   B_n16            ; creating constant
||       LDHU .D2T2   *B_coef[0],   B_c0             ; luma = coef[0]



         XOR   .L1    A_cb6420,     A_k80,     A_cb6420_; applying Cb bias
||       XOR   .S2X   B_cr6420,     A_k80,     B_cr6420_; applying Cr bias
||       PACK2 .L2    B_n16,        B_n16,     B_n16 ; creating constant
||       STW  .D2T2   B_csr,        *-B_SP[1]        ; save CSR



         MPYSU4 .M1   A_cb6420_,    A_k08,     A_cb64:A_cb20; multiply Cb by 8
||       MPYSU4 .M2   B_cr6420_,    B_k08,     B_cr64:B_cr20; multiply Cr by 8


         PACK2 .L2    B_c1,         B_c1,      B_c1  ; r_cr:r_cr
||       MPYU4 .M1X   B_y_3210,     A_k08,     A_y_32_:A_y_10_; multiply Y by 8
||       MPYU4 .M2    B_y_7654,     B_k08,     B_y_76_:B_y_54_; multiply Y by 8

* =========================== PIPE LOOP PROLOG ============================ *
        PACK2 .L2x       B_g_cb,    A_g_cr,     B_c2c3; g_cb:g_cr
||      PACK2 .L1x       A_g_cr,    B_g_cb,     A_c3c2; g_cr: g_cb

        MV    .L1x       B_c2c3,    A_c2c3            ; Copy of g_cb:g_cr
||      PACK2 .L2        B_c0,      B_c0,       B_c0  ; luma:luma
||      MV    .S2x       A_c3c2,    B_c3c2


        PACKH2 .L2X      B_cr64,    A_cb64,     B_cr6cb6; Pack Cr & Cb samples
||      PACK2  .S1X      A_cb20,    B_cr20,     A_cb0cr0;
||      LDW    .D2T2     *B_cr_data++,          B_cr6420; Load next 4 samples of Cr


        SUB2   .D1X      A_y_32_,   B_n16,      A_y_32  ;
||      ADD    .D2x      A_rgb_data,8,          B_rgb_ptr;


        PACKH2  .L1X     A_cb20,    B_cr20,     A_cb2cr2;[15,1]
||      MPY2    .M2      B_cr64,    B_c1,       B_cr6_c1:B_cr4_c1;[15,1]
||      SUB2    .D2      B_y_54_,   B_n16,      B_y_54  ;[15,1]
||      LDW     .D1T1    *A_cb_data++,          A_cb6420;[ 3,2]
||      B       .S2      h_loop_9


        MPY2    .M2     B_cr20,     B_c1,       B_cr2_c1:B_cr0_c1;[16,1]
||      SUB2    .D2     B_y_76_,    B_n16,      B_y_76           ;[16,1]
||      LDDW    .D1T2   *A_y_data++,            B_y_7654:B_y_3210;[ 4,2]


        PACK2   .L2X    B_cr64,     A_cb64,     B_cr4cb4         ;[17,1]
||      MPY2    .M1     A_cb64,     A_c4,       A_cb6_c4:A_cb4_c4;[17,1]
||      MPY2    .M2     B_y_54,     B_c0,       B_y_5_c0:B_y_4_c0;[17,1]


        MPY2    .M1     A_cb20,     A_c4,       A_cb2_c4:A_cb0_c4;[18,1]
||      MPY2    .M2     B_y_76,     B_c0,       B_y_7_c0:B_y_6_c0;[18,1]
||      B       .S2     h_loop_0


        DOTP2   .M1     A_cb2cr2,   A_c2c3,     A_cg2           ;[19,1]
||      DOTP2   .M2     B_cr6cb6,   B_c3c2,     B_cg6           ;[19,1]
||      SUB2    .D1X    A_y_10_,    B_n16,      A_y_10          ;[19,1]


        DOTP2   .M2     B_cr4cb4,   B_c3c2,     B_cg4           ;[20,1]
||      MPY2    .M1X    A_y_32,     B_c0,       A_y_3_c0:A_y_2_c0;[20,1]
||      XOR     .L1     A_cb6420,   A_k80,      A_cb6420_       ;[ 8,2]
||      XOR     .S2X    B_cr6420,   A_k80,      B_cr6420_       ;[ 8,2]
||      B       .S1     o_loop_0

o_loop_0:
        PACKH2  .S2     B_g_7,      B_g_6,      B_g_76          ;[26,1]
||      PACKH2  .S1     A_r_3,      A_r_2,      A_r_32          ;[26,1]
||      ADD     .L2X    B_y_7_c0,   A_cb6_c4,   B_b_7           ;[26,1]
||      ADD     .L1     A_y_2_c0,   A_cg2,      A_g_2           ;[26,1]
||      ADD     .D2     B_y_4_c0,   B_cg4,      B_g_4           ;[26,1]
||      SUB2    .D1X    A_y_32_,    B_n16,      A_y_32          ;[14,2]

        PACKH2  .L2     B_b_7,      B_b_6,      B_b_76          ;[27,1]
||      PACKH2  .S2     B_g_5,      B_g_4,      B_g_54          ;[27,1]
||      PACK2   .S1X    A_cb20,     B_cr20,     A_cb0cr0        ;[15,2]
||      PACKH2  .L1X    A_cb20,     B_cr20,     A_cb2cr2        ;[15,2]
||      MPY2    .M2     B_cr64,     B_c1,       B_cr6_c1:B_cr4_c1;[15,2]
||      SUB2    .D2     B_y_54_,    B_n16,      B_y_54          ;[15,2]
||      LDW     .D1T1   *A_cb_data++,           A_cb6420        ;[ 3,3]

        SPACKU4 .S2     B_b_76,     B_b_54,     B_b_7654        ;[28,1]
||      ADD     .S1     A_y_1_c0,   A_cb0_c4,   A_b_1           ;[28,1]
||      ADD     .L1     A_y_0_c0,   A_cg0,      A_g_0           ;[28,1]
||      PACKH2  .L2X    B_cr64,     A_cb64,     B_cr6cb6        ;[16,2]
||      MPY2    .M2     B_cr20,     B_c1,       B_cr2_c1:B_cr0_c1;[16,2]
||      SUB2    .D2     B_y_76_,    B_n16,      B_y_76          ;[16,2]
||      LDDW    .D1T2   *A_y_data++,            B_y_7654:B_y_3210;[ 4,3]

        AND     .D2     B_b_7654,   B_msk5,     B_b_7654_       ;[29,1]
||      SPACKU4 .S2     B_g_76,     B_g_54,     B_g_7654        ;[29,1]
||      PACKH2  .L1     A_g_3,      A_g_2,      A_g_32          ;[29,1]
||      ADD     .S1     A_y_0_c0,   A_cb0_c4,   A_b_0           ;[29,1]
||      ADD     .D1     A_y_1_c0,   A_cg0,      A_g_1           ;[29,1]
||      PACK2   .L2X    B_cr64,     A_cb64,     B_cr4cb4        ;[17,2]
||      MPY2    .M1     A_cb64,     A_c4,       A_cb6_c4:A_cb4_c4;[17,2]
||      MPY2    .M2     B_y_54,     B_c0,       B_y_5_c0:B_y_4_c0;[17,2]

        AND     .L2X    B_g_7654,   A_msk6,     B_g_7654_       ;[30,1]
||      PACKH2  .L1     A_b_1,      A_b_0,      A_b_10          ;[30,1]
||      ADD     .S1X    A_y_0_c0,   B_cr0_c1,   A_r_0           ;[30,1]
||      ADD     .D1X    A_y_1_c0,   B_cr0_c1,   A_r_1           ;[30,1]
||      MPY2    .M1     A_cb20,     A_c4,       A_cb2_c4:A_cb0_c4;[18,2]
||      MPY2    .M2     B_y_76,     B_c0,       B_y_7_c0:B_y_6_c0;[18,2]

        SPACKU4 .S2     B_r_76,     B_r_54,     B_r_7654        ;[31,1]
||      PACKH2  .L1     A_g_1,      A_g_0,      A_g_10          ;[31,1]
||      PACKH2  .S1     A_r_1,      A_r_0,      A_r_10          ;[31,1]
||      DOTP2   .M1     A_cb2cr2,   A_c2c3,     A_cg2           ;[19,2]
||      DOTP2   .M2     B_cr6cb6,   B_c3c2,     B_cg6           ;[19,2]
||      SUB2    .D1X    A_y_10_,    B_n16,      A_y_10          ;[19,2]

        AND     .L2     B_r_7654,   B_msk5,     B_r_7654_       ;[32,1]
||      SPACKU4 .S1     A_b_32,     A_b_10,     A_b_3210        ;[32,1]
||      DOTP2   .M2     B_cr4cb4,   B_c3c2,     B_cg4           ;[20,2]
||      MPY2    .M1X    A_y_32,     B_c0,       A_y_3_c0:A_y_2_c0;[20,2]
||      XOR     .L1     A_cb6420,   A_k80,      A_cb6420_       ;[ 8,3]
||      XOR     .S2X    B_cr6420,   A_k80,      B_cr6420_       ;[ 8,3]
||      ADD     .D1     A_lp0,      1,          A_lp0

        ROTL    .M2     B_b_7654_,  29,         B_b_7654__      ;[33,1]
||      AND     .L1X    A_b_3210,   B_msk5,     A_b_3210_       ;[33,1]
||      SPACKU4 .S1     A_r_32,     A_r_10,     A_r_3210        ;[33,1]
||      ADD     .L2     B_y_4_c0,   B_cr4_c1,   B_r_4           ;[21,2]
||      ADD     .S2     B_y_5_c0,   B_cr4_c1,   B_r_5           ;[21,2]
||      MPYSU4  .M1     A_cb6420_,  A_k08,      A_cb64:A_cb20   ;[ 9,3]

        SPACKU4 .S1     A_g_32,     A_g_10,     A_g_3210        ;[34,1]
||      ADD     .S2X    B_y_6_c0,   A_cb6_c4,   B_b_6           ;[22,2]
||      ADD     .D2     B_y_6_c0,   B_cr6_c1,   B_r_6           ;[22,2]
||      ADD     .L2     B_y_7_c0,   B_cr6_c1,   B_r_7           ;[22,2]
||      MPYSU4  .M2     B_cr6420_,  B_k08,      B_cr64:B_cr20   ;[10,3]
||      MPYU4   .M1X    B_y_3210,   A_k08,      A_y_32_:A_y_10_ ;[10,3]

        AND     .S1     A_g_3210,   A_msk6,     A_g_3210_       ;[35,1]
||      AND     .L1X    A_r_3210,   B_msk5,     A_r_3210_       ;[35,1]
||      PACKH2  .L2     B_r_7,      B_r_6,      B_r_76          ;[23,2]
||      ADD     .D2X    B_y_4_c0,   A_cb4_c4,   B_b_4           ;[23,2]
||      ADD     .S2X    B_y_5_c0,   A_cb4_c4,   B_b_5           ;[23,2]
||      DOTP2   .M1     A_cb0cr0,   A_c2c3,     A_cg0           ;[23,2]
||      MPYU4   .M2     B_y_7654,   B_k08,      B_y_76_:B_y_54_ ;[11,3]
*


* =========================== PIPE LOOP KERNEL ============================ *
loop:
h_loop_0:
  [A_lp0] MPYU4   .M2X    B_r_7654_,  A_k80,      B_r7_r6:B_r5_r4 ;[36,1] r << 7
||        PACKH2  .L2     B_b_5,      B_b_4,      B_b_54          ;[24,2]
||        PACKH2  .S2     B_r_5,      B_r_4,      B_r_54          ;[24,2]
||        ADD     .L1     A_y_2_c0,   A_cb2_c4,   A_b_2           ;[24,2]
||        ADD     .S1     A_y_3_c0,   A_cb2_c4,   A_b_3           ;[24,2]
||        ADD     .D1     A_y_3_c0,   A_cg2,      A_g_3           ;[24,2]
||        ADD     .D2     B_y_6_c0,   B_cg6,      B_g_6           ;[24,2]
||        MPY2    .M1X    A_y_10,     B_c0,       A_y_1_c0:A_y_0_c0;[24,2]

h_loop_1:
  [A_lp0] ROTL    .M1     A_b_3210_,  29,         A_b_3210__      ;[37,1]
||[A_lp0] MPYU4   .M2     B_g_7654_,  B_k08,      B_g7_g6:B_g5_g4 ;[37,1] g << 3
||        PACKH2  .S1     A_b_3,      A_b_2,      A_b_32          ;[25,2]
||        ADD     .S2     B_y_5_c0,   B_cg4,      B_g_5           ;[25,2]
||        ADD     .L2     B_y_7_c0,   B_cg6,      B_g_7           ;[25,2]
||        ADD     .L1X    A_y_2_c0,   B_cr2_c1,   A_r_2           ;[25,2]
||        ADD     .D1X    A_y_3_c0,   B_cr2_c1,   A_r_3           ;[25,2]
||        LDW     .D2T2   *B_cr_data++,           B_cr6420        ;[ 1,4]

h_loop_2:
          MPYU4   .M2     B_b_7654__, B_k01,      B_b7_b6:B_b5_b4 ;[38,1] b >> 3
||        MPYU4   .M1     A_r_3210_,  A_k80,      A_r3_r2:A_r1_r0 ;[38,1] r << 7
||        PACKH2  .S2     B_g_7,      B_g_6,      B_g_76          ;[26,2]
||        PACKH2  .S1     A_r_3,      A_r_2,      A_r_32          ;[26,2]
||        ADD     .L2X    B_y_7_c0,   A_cb6_c4,   B_b_7           ;[26,2]
||        ADD     .L1     A_y_2_c0,   A_cg2,      A_g_2           ;[26,2]
||        ADD     .D2     B_y_4_c0,   B_cg4,      B_g_4           ;[26,2]
||        SUB2    .D1X    A_y_32_,    B_n16,      A_y_32          ;[14,3]

h_loop_3:
          MPYU4   .M1     A_g_3210_,  A_k08,      A_g3_g2:A_g1_g0 ;[39,1] g << 3
||        PACKH2  .L2     B_b_7,      B_b_6,      B_b_76          ;[27,2]
||        PACKH2  .S2     B_g_5,      B_g_4,      B_g_54          ;[27,2]
||        PACK2   .S1X    A_cb20,     B_cr20,     A_cb0cr0        ;[15,3]
||        PACKH2  .L1X    A_cb20,     B_cr20,     A_cb2cr2        ;[15,3]
||        MPY2    .M2     B_cr64,     B_c1,       B_cr6_c1:B_cr4_c1;[15,3]
||        SUB2    .D2     B_y_54_,    B_n16,      B_y_54          ;[15,3]
||        LDW     .D1T1   *A_cb_data++,           A_cb6420        ;[ 3,4]

h_loop_4:
          MPYU4   .M1X    A_b_3210__, B_k01,      A_b3_b2:A_b1_b0 ;[40,1] b >> 3
||        SPACKU4 .S2     B_b_76,     B_b_54,     B_b_7654        ;[28,2]
||        ADD     .S1     A_y_1_c0,   A_cb0_c4,   A_b_1           ;[28,2]
||        ADD     .L1     A_y_0_c0,   A_cg0,      A_g_0           ;[28,2]
||        PACKH2  .L2X    B_cr64,     A_cb64,     B_cr6cb6        ;[16,3]
||        MPY2    .M2     B_cr20,     B_c1,       B_cr2_c1:B_cr0_c1;[16,3]
||        SUB2    .D2     B_y_76_,    B_n16,      B_y_76          ;[16,3]
||        LDDW    .D1T2   *A_y_data++,            B_y_7654:B_y_3210;[ 4,4]

h_loop_5:
          AND     .D2     B_b_7654,   B_msk5,     B_b_7654_       ;[29,2]
||        SPACKU4 .S2     B_g_76,     B_g_54,     B_g_7654        ;[29,2]
||        PACKH2  .L1     A_g_3,      A_g_2,      A_g_32          ;[29,2]
||        ADD     .S1     A_y_0_c0,   A_cb0_c4,   A_b_0           ;[29,2]
||        ADD     .D1     A_y_1_c0,   A_cg0,      A_g_1           ;[29,2]
||        PACK2   .L2X    B_cr64,     A_cb64,     B_cr4cb4        ;[17,3]
||        MPY2    .M1     A_cb64,     A_c4,       A_cb6_c4:A_cb4_c4;[17,3]
||        MPY2    .M2     B_y_54,     B_c0,       B_y_5_c0:B_y_4_c0;[17,3]

h_loop_6:
          BDEC    .S2     loop,       B_loopcnt                   ;[42,1]
||        ADDAH   .D2     B_b7_b6,    B_r7_r6,    B_r_b76         ;[42,1] (r<<8)|(b>>3)
||        AND     .L2X    B_g_7654,   A_msk6,     B_g_7654_       ;[30,2]
||        PACKH2  .L1     A_b_1,      A_b_0,      A_b_10          ;[30,2]
||        ADD     .S1X    A_y_0_c0,   B_cr0_c1,   A_r_0           ;[30,2]
||        ADD     .D1X    A_y_1_c0,   B_cr0_c1,   A_r_1           ;[30,2]
||        MPY2    .M1     A_cb20,     A_c4,       A_cb2_c4:A_cb0_c4;[18,3]
||        MPY2    .M2     B_y_76,     B_c0,       B_y_7_c0:B_y_6_c0;[18,3]

h_loop_7:
          ADD     .L2     B_r_b76,    B_g7_g6,    B_rgb76         ;[43,1]
||        ADDAH   .D2     B_b5_b4,    B_r5_r4,    B_r_b54         ;[43,1] (r<<8)|(b>>3)
||        SPACKU4 .S2     B_r_76,     B_r_54,     B_r_7654        ;[31,2]
||        PACKH2  .L1     A_g_1,      A_g_0,      A_g_10          ;[31,2]
||        PACKH2  .S1     A_r_1,      A_r_0,      A_r_10          ;[31,2]
||        DOTP2   .M1     A_cb2cr2,   A_c2c3,     A_cg2           ;[19,3]
||        DOTP2   .M2     B_cr6cb6,   B_c3c2,     B_cg6           ;[19,3]
||        SUB2    .D1X    A_y_10_,    B_n16,      A_y_10          ;[19,3]

h_loop_8:
          ADD     .D2     B_r_b54,    B_g5_g4,    B_rgb54         ;[44,1]
||        ADDAH   .D1     A_b3_b2,    A_r3_r2,    A_r_b32         ;[44,1] (r<<8)|(b>>3)
||        AND     .L2     B_r_7654,   B_msk5,     B_r_7654_       ;[32,2]
||        SPACKU4 .S1     A_b_32,     A_b_10,     A_b_3210        ;[32,2]
||        DOTP2   .M2     B_cr4cb4,   B_c3c2,     B_cg4           ;[20,3]
||        MPY2    .M1X    A_y_32,     B_c0,       A_y_3_c0:A_y_2_c0;[20,3]
||        XOR     .L1     A_cb6420,   A_k80,      A_cb6420_       ;[ 8,4]
||        XOR     .S2X    B_cr6420,   A_k80,      B_cr6420_       ;[ 8,4]

h_loop_9:
  [A_lp0] STDW    .D2T2   B_rgb76:B_rgb54,        *B_rgb_ptr++[2] ;[45,1]
||[A_lp0] ADDAH   .D1     A_b1_b0,    A_r1_r0,    A_r_b10         ;[45,1] (r<<8)|(b>>3)
||[A_lp0] ROTL    .M2     B_b_7654_,  29,         B_b_7654__      ;[33,2]
||[A_lp0] AND     .L1X    A_b_3210,   B_msk5,     A_b_3210_       ;[33,2]
||[A_lp0] SPACKU4 .S1     A_r_32,     A_r_10,     A_r_3210        ;[33,2]
||        ADD     .L2     B_y_4_c0,   B_cr4_c1,   B_r_4           ;[21,3]
||        ADD     .S2     B_y_5_c0,   B_cr4_c1,   B_r_5           ;[21,3]
||        MPYSU4  .M1     A_cb6420_,  A_k08,      A_cb64:A_cb20   ;[ 9,4]

h_loop_10:
  [A_lp0] ADD     .L1     A_r_b10,    A_g1_g0,    A_rgb10         ;[46,1]
||[A_lp0] ADD     .D1     A_r_b32,    A_g3_g2,    A_rgb32         ;[46,1]
||[A_lp0] SPACKU4 .S1     A_g_32,     A_g_10,     A_g_3210        ;[34,2]
||        ADD     .S2X    B_y_6_c0,   A_cb6_c4,   B_b_6           ;[22,3]
||        ADD     .D2     B_y_6_c0,   B_cr6_c1,   B_r_6           ;[22,3]
||        ADD     .L2     B_y_7_c0,   B_cr6_c1,   B_r_7           ;[22,3]
||        MPYSU4  .M2     B_cr6420_,  B_k08,      B_cr64:B_cr20   ;[10,4]
||        MPYU4   .M1X    B_y_3210,   A_k08,      A_y_32_:A_y_10_ ;[10,4]

h_loop_11:
  [A_lp0] STDW    .D1T1   A_rgb32:A_rgb10,        *A_rgb_ptr++[2] ;[47,1]
||[A_lp0] AND     .S1     A_g_3210,   A_msk6,     A_g_3210_       ;[35,2]
||[A_lp0] AND     .L1X    A_r_3210,   B_msk5,     A_r_3210_       ;[35,2]
||        PACKH2  .L2     B_r_7,      B_r_6,      B_r_76          ;[23,3]
||        ADD     .D2X    B_y_4_c0,   A_cb4_c4,   B_b_4           ;[23,3]
||        ADD     .S2X    B_y_5_c0,   A_cb4_c4,   B_b_5           ;[23,3]
||        DOTP2   .M1     A_cb0cr0,   A_c2c3,     A_cg0           ;[23,3]
||        MPYU4   .M2     B_y_7654,   B_k08,      B_y_76_:B_y_54_ ;[11,4]

* =========================== PIPE LOOP EPILOG ============================ *

        LDDW      .D2T2   *B_SP++,    B_reg11:B_reg10         ; Restore Regs 11 & 10

        BNOP      .S2     B_ret,      4                       ; Return to caller
||      LDW       .D2T2   *-B_SP[3],  B_csr                   ;

        MVC       .S2     B_csr,      CSR                     ; Restore CSR

; ===== Branch occurs =====
; ===== Interrupts may occur here =====

* ========================================================================= *
*   End of file:  img_ycbcr422p_rgb565.asm                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
