!<arch>
boundary.sa/    1066928952  0     0     0       8423      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:18 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       IMG_boundary -- Returns coordinates of IMG_boundary pixels.         *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and is called as follows:               *
*                                                                           *
*           void IMG_boundary                                               *
*           (                                                               *
*               const unsigned char *restrict i_data,                       *
*               int rows, int cols,                                         *
*               int *restrict o_coord,                                      *
*               int *restrict o_grey                                        *
*           );                                                              *
*                                                                           *
*       The arguments are defined as follows:                               *
*                                                                           *
*           i_data   Input images that is cols-by-rows in size.             *
*           rows     Height of the input image                              *
*           cols     Width of the input image                               *
*           o_coord  Array to write output coordinates to                   *
*           o_grey   Array to write output grey levels to                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine scans an image looking for non-zero pixels.            *
*       The locations of those pixels are stored out to the o_coord         *
*       as packed Y/X pairs, with Y in the upper half, and X in             *
*       the lower half.  The grey levels encountered are stored             *
*       in the o_grey array in parallel.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least one row is being processed.                                *
*       Input is word aligned.                                              *
*       Input is a multiple of 4 pixels wide.                               *
*       Output buffers o_coord and o_grey start in different banks          *
*       and are word-aligned.                                               *
*       No more than 32764 rows or 32764 columns are being processed.       *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer and inner loops are collapsed together.                       *
*       Inner loop is unrolled to process four pixels per iteration.        *
*       Packed coordinate value is updated directly, rather than            *
*       by repacking x, y every time it's needed.                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_boundary"
        .global _IMG_boundary
_IMG_boundary: .cproc  A_i_data,  B_rows,  A_cols,  B_o_coord, A_o_grey 
              .no_mdep
            .reg            A_cols4,    A_r_step,   A_x
            .reg            A_c0, A_c1, A_c2, A_c3, A_i
            .reg            B_p0, B_p1, B_p2, B_p3, B_p3210

            NEG     .1      A_cols,     A_r_step
            MVKLH   .1      0,          A_r_step    ; r_step = 0x10000-cols
            SHR     .1      A_cols,     2,          A_cols4
            MPYU    .1X     B_rows,     A_cols4,    A_i
            ZERO    .1      A_c0
            MV              A_cols4,    A_x

            .mptr   A_i_data,  input  + 0, 4
            .mptr   B_o_coord, output + 0, 0
            .mptr   A_o_grey,  output + 4, 0
loop:       .trip   4, 32764*32764/4, 1
            ADD     .1      A_c0,       1,          A_c1
            ADD     .1      A_c0,       2,          A_c2
            ADD     .1      A_c0,       3,          A_c3
            ;       ;       ;           ;           ;
            LDW     .D1T2   *A_i_data++,            B_p3210
            SHRU    .2      B_p3210,    24,         B_p3
            EXTU    .2      B_p3210,    8,  24,     B_p2
            EXTU    .2      B_p3210,    16, 24,     B_p1
            EXTU    .2      B_p3210,    24, 24,     B_p0
    [B_p0]  STW     .D1T2   B_p0,       *A_o_grey++
    [B_p0]  STW     .D2T1   A_c0,       *B_o_coord++
    [B_p1]  STW     .D1T2   B_p1,       *A_o_grey++
    [B_p1]  STW     .D2T1   A_c1,       *B_o_coord++
    [B_p2]  STW     .D1T2   B_p2,       *A_o_grey++
    [B_p2]  STW     .D2T1   A_c2,       *B_o_coord++
    [B_p3]  STW     .D1T2   B_p3,       *A_o_grey++
    [B_p3]  STW     .D2T1   A_c3,       *B_o_coord++
            ADD     .1      A_c0,       4,          A_c0
            SUB     .1      A_x,        1,          A_x
    [!A_x]  ADD     .1      A_c0,       A_r_step,   A_c0
    [!A_x]  MV      .1      A_cols4,    A_x

            SUB     .1      A_i,        1,          A_i
    [ A_i]  B               loop

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_boundary.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

conv_3x3.sa/    1066928952  0     0     0       20061     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Mon May 20 01:32:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_conv_3x3    -- 3x3 convolution                                  *
*                                                                           *
*   REVISION DATE                                                           *
*       30-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_conv_3x3   (    const unsigned char *restrict inptr,       *
*                                  unsigned char *restrict outptr,          *
*                                           int            x_dim,           *
*                            const          char *restrict mask,            *
*                                           int            shift)           *
*                                                                           *
*      The convolution routine accepts three rows of 'x_dim' input points   *
*      and performs some operation on each.  A total of 'x_dim' outputs     *
*      are written to the output array. The 'mask' array has the 3 by 3     *
*      array of coefficients.                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      The convolution kernel accepts three rows of 'x_dim' input points    *
*      and produces one output row of 'x_dim' points using the input mask   *
*      of 3 by 3. The user defined shift value is used to shift the convo-  *
*      lution value, down to the byte range. The convolution sum is also    *
*      range limited to 0..255. The shift amount is non-zero for low pass   *
*      filters, and zero for high pass and sharpening filters.              *
*                                                                           *
*                                                                           *
*      The following is the C code model for the algorithm:                 *
*                                                                           *
*                                                                           *
*      void IMG_conv_3x3(   const unsigned char *restrict inptr,            *
*                                unsigned char *restrict outptr,            *
*                                         int            x_dim,             *
*                          const          char *restrict mask,              *
*                                         int            shift)             *
*      {                                                                    *
*           const   unsigned char   *IN1,*IN2,*IN3;                         *
*           unsigned char           *OUT;                                   *
*                                                                           *
*           short    pix10,  pix20,  pix30;                                 *
*           short    mask10, mask20, mask30;                                *
*                                                                           *
*           int      sum,      sum00,  sum11;                               *
*           int      i;                                                     *
*           int      sum22,    j;                                           *
*                                                                           *
*           IN1      =   inptr;                                             *
*           IN2      =   IN1 + x_dim;                                       *
*           IN3      =   IN2 + x_dim;                                       *
*           OUT      =   outptr;                                            *
*                                                                           *
*           for (j = 0; j < x_dim ; j++)                                    *
*           {                                                               *
*               sum = 0;                                                    *
*                                                                           *
*               for (i = 0; i < 3; i++)                                     *
*               {                                                           *
*                   pix10  =   IN1[i];                                      *
*                   pix20  =   IN2[i];                                      *
*                   pix30  =   IN3[i];                                      *
*                                                                           *
*                   mask10 =   mask[i];                                     *
*                   mask20 =   mask[i + 3];                                 *
*                   mask30 =   mask[i + 6];                                 *
*                                                                           *
*                   sum00  =   pix10 * mask10;                              *
*                   sum11  =   pix20 * mask20;                              *
*                   sum22  =   pix30 * mask30;                              *
*                                                                           *
*                   sum   +=   sum00 + sum11+ sum22;                        *
*               }                                                           *
*                                                                           *
*               IN1++;                                                      *
*               IN2++;                                                      *
*               IN3++;                                                      *
*                                                                           *
*               sum = (sum >> shift);                                       *
*               if ( sum <  0  )       sum = 0;                             *
*               if ( sum > 255 )       sum = 255;                           *
*               *OUT++   =       sum;                                       *
*           }                                                               *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*      The inner loop that computes the convolution sum is completely       *
*      unrolled and 8 output pixels are computed together. The mask         *
*      values are loaded and packed as double words.                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*      x_dim must be a multiple of 8.                                       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_conv_3x3"
        .global _IMG_conv_3x3
_IMG_conv_3x3: .cproc A_INPTR, B_OUTPTR, A_inputcols, A_mask, A_shift 
              .no_mdep

        .reg     A_IN1,                B_IN2,                B_IN3
        .reg     A_OPTR,               B_mask,               A_h22word
        .reg     A_mask00,             A_mask01,             A_mask02
        .reg     B_mask10,             B_mask11,             B_mask12
        .reg     A_mask20,             B_mask21,             B_mask22

        .reg     A_d00:A_h00word,      A_d01:A_h01word,      A_d02:A_h02word
        .reg     B_d10:B_h10word,      B_d11:B_h11word,      B_d12:B_h12word
        .reg     A_d20:A_h20word,      B_d21:B_h21word,      B_d22:B_h22word
        .reg     A_ones

        .reg     A_line01:A_line00,    A_line03:A_line02,    A_line05:A_line04
        .reg     B_line11:B_line10,    A_line13,B_line12,    A_line15:A_line14
        .reg     B_line21:B_line20,    B_line23:B_line22,    B_line25:B_line24

        .reg     A_prodA1:A_prodA0,    A_prodA3:A_prodA2,    A_prodA5:A_prodA4
        .reg     A_prodA7:A_prodA6,    A_prodA9:A_prodA8,    A_prodA11:A_prodA10
        .reg     B_prodB1:B_prodB0,    B_prodB3:B_prodB2,    B_prodB5:B_prodB4

        .reg     B_prodB7:B_prodB6,    B_prodB9:B_prodB8,    B_prodB11:B_prodB10
        .reg     A_prodC1:A_prodC0,    A_prodC3:A_prodC2,    B_prodC5:B_prodC4
        .reg     B_prodC7:B_prodC6,    A_prodC9:A_prodC8,    B_prodC11:B_prodC10

        .reg    B_sum0a, B_sum0b, B_sum0c, B_sum0d
        .reg    A_sum0e, A_sum0f, A_sum0g, A_sum0h
        .reg    A_sum1a, A_sum1b, A_sum1c, A_sum1d
        .reg    B_sum1e, B_sum1f, B_sum1g, B_sum1h
        .reg    B_sum2a, B_sum2b, B_sum2c, B_sum2d, B_sum2e
        .reg    A_sum2f, A_sum2g, A_sum2h
        .reg    A_sum3a, A_sum3b, A_sum3c
        .reg    B_sum3d, B_sum3e, B_sum3f, B_sum3g, B_sum3h

        .reg     A_pixel01,            B_pixel23,            A_pixel45
        .reg     A_pixel23,            A_pixel67,            B_pixel67
        .reg     B_count,              B_roundval
        .reg     A_outword1:A_outword0
        .reg     B_inputcols

        MVK     .2      0,              B_roundval
        PACK2   .2      B_roundval,     B_roundval,  B_roundval

        MV      .2      A_mask,                      B_mask

        LDB             *+A_mask[0],    A_mask00
        LDB             *+A_mask[1],    A_mask01
        LDB             *+A_mask[2],    A_mask02
        LDB             *+B_mask[3],    B_mask10
        LDB             *+B_mask[4],    B_mask11
        LDB             *+B_mask[5],    B_mask12
        LDB             *+A_mask[6],    A_mask20
        LDB             *+B_mask[7],    B_mask21
        LDB             *+B_mask[8],    B_mask22

        PACK2   .1      A_mask00,   A_mask00,   A_h00word;(0,mask00,0,mask00)
        PACK2   .1      A_mask01,   A_mask01,   A_h01word;(0,mask01,0,mask01)
        PACKL4  .1      A_h00word,  A_h00word,  A_h00word;Prepare word
        PACKL4  .1      A_h01word,  A_h01word,  A_h01word;Prepare word

        PACK2   .1      A_mask02,   A_mask02,   A_h02word;(0,mask02,0,mask02)
        PACK2   .2      B_mask10,   B_mask10,   B_h10word;(0,mask10,0,mask10)
        PACKL4  .1      A_h02word,  A_h02word,  A_h02word;Prepare word
        PACKL4  .2      B_h10word,  B_h10word,  B_h10word;Prepare word

        PACK2   .2      B_mask11,   B_mask11,   B_h11word;(0,mask11,0,mask11)
        PACK2   .2      B_mask12,   B_mask12,   B_h12word;(0,mask12,0,mask12)
        PACKL4  .2      B_h11word,  B_h11word,  B_h11word;Prepare word
        PACKL4  .2      B_h12word,  B_h12word,  B_h12word;Prepare word

        PACK2   .1      A_mask20,   A_mask20,   A_h20word;(0,mask20,0,mask20)
        PACK2   .2      B_mask21,   B_mask21,   B_h21word;(0,mask21,0,mask21)
        PACKL4  .1      A_h20word,  A_h20word,  A_h20word;Prepare word
        PACKL4  .2      B_h21word,  B_h21word,  B_h21word;Prepare word

        PACK2   .2      B_mask22,   B_mask22,   B_h22word;(0,mask22,0,mask22)
        PACKL4  .2      B_h22word,  B_h22word,  B_h22word;Prepare word

        MV      .1X     B_h22word,              A_h22word;h22word to B side

        MV      .1      A_INPTR,                A_IN1
        MV      .2      A_inputcols,            B_inputcols
        ADD     .2      A_IN1,      B_inputcols,B_IN2
        ADD     .2      B_IN2,      B_inputcols,B_IN3

        MV      .2      B_OUTPTR,               A_OPTR
        SHRU    .2      B_inputcols,3,          B_count
        SUB     .2      B_count,    2,          B_count

loop:  .trip 2
* ------------------------------------------------------------------------- *
*  load pixels                                                              *
* ------------------------------------------------------------------------- *
        LDNDW   .D1T1 *A_IN1++(1),    A_line01:A_line00
        LDNDW   .D2T2 *B_IN2++(2),    B_line11:B_line10
        LDNDW   .D2T2 *B_IN3++(1),    B_line21:B_line20

        LDNDW   .D1T1 *A_IN1++(1),    A_line03:A_line02
;       LDNDW   .D2T2 *B_IN2++(1),    B_line13:B_line12
        LDNDW   .D2T2 *B_IN3++(1),    B_line23:B_line22

        LDNDW   .D1T1 *A_IN1++(6),    A_line05:A_line04
        LDNDW   .D2T1 *B_IN2++(6),    A_line15:A_line14
        LDNDW   .D2T2 *B_IN3++(6),    B_line25:B_line24

        SHRMB   .2    B_line11,     B_line10,   B_line12
        SHLMB   .1    A_line14,     A_line15,   A_line13

* ------------------------------------------------------------------------- *
*  multiply pixels with filter mask                                         *
* ------------------------------------------------------------------------- *

        MPYUS4  .1      A_line00,   A_h00word,  A_prodA1:A_prodA0
        MPYUS4  .1      A_line01,   A_h00word,  A_prodA3:A_prodA2
        MPYUS4  .1      A_line02,   A_h01word,  A_prodA5:A_prodA4
        MPYUS4  .1      A_line03,   A_h01word,  A_prodA7:A_prodA6
        MPYUS4  .1      A_line04,   A_h02word,  A_prodA9:A_prodA8
        MPYUS4  .1      A_line05,   A_h02word,  A_prodA11:A_prodA10

        MPYUS4  .2      B_line10,   B_h10word,  B_prodB1:B_prodB0
        MPYUS4  .2      B_line11,   B_h10word,  B_prodB3:B_prodB2
        MPYUS4  .2      B_line12,   B_h11word,  B_prodB5:B_prodB4
        MPYUS4  .2X     A_line13,   B_h11word,  B_prodB7:B_prodB6
        MPYSU4  .2X     B_h12word,  A_line14,   B_prodB9:B_prodB8
        MPYSU4  .2X     B_h12word,  A_line15,   B_prodB11:B_prodB10

        MPYSU4  .1X     A_h20word,  B_line20,   A_prodC1:A_prodC0
        MPYSU4  .1X     A_h20word,  B_line21,   A_prodC3:A_prodC2
        MPYUS4  .2      B_line22,   B_h21word,  B_prodC5:B_prodC4
        MPYUS4  .2      B_line23,   B_h21word,  B_prodC7:B_prodC6
        MPYSU4  .1X     A_h22word,  B_line24,   A_prodC9:A_prodC8
        MPYSU4  .2      B_h22word,  B_line25,   B_prodC11:B_prodC10

* ------------------------------------------------------------------------- *
*  sum up all products                                                      *
* ------------------------------------------------------------------------- *

        ADD2    .2      B_roundval, B_prodC4,   B_sum0a
        ADD2    .2      B_sum0a,    B_prodB0,   B_sum0b
        ADD2    .2      B_sum0b,    B_prodB4,   B_sum0c
        ADD2    .2      B_sum0c,    B_prodB8,   B_sum0d
        ADD2    .1      A_prodA4,   A_prodA8,   A_sum0e
        ADD2    .1      A_sum0e,    A_prodC0,   A_sum0f
        ADD2    .1      A_sum0f,    A_prodC8,   A_sum0g
        ADD2    .1      A_sum0g,    A_prodA0,   A_sum0h
        ADD2    .1X     B_sum0d,    A_sum0h,    A_pixel01

        ADD2    .1      A_prodA9,   A_prodA5,   A_sum1a
        ADD2    .1      A_sum1a,    A_prodC1,   A_sum1b
        ADD2    .1      A_sum1b,    A_prodC9,   A_sum1c
        ADD2    .1      A_sum1c,    A_prodA1,   A_sum1d
        ADD2    .2      B_prodB9,   B_roundval, B_sum1e
        ADD2    .2      B_sum1e,    B_prodC5,   B_sum1f
        ADD2    .2      B_sum1f,    B_prodB1,   B_sum1g
        ADD2    .2      B_sum1g,    B_prodB5,   B_sum1h
        ADD2    .2X     B_sum1h,    A_sum1d,    B_pixel23

        ADD2    .2      B_roundval, B_prodC6,   B_sum2a
        ADD2    .2      B_sum2a,    B_prodB2,   B_sum2b
        ADD2    .2      B_sum2b,    B_prodB6,   B_sum2c
        ADD2    .2      B_sum2c,    B_prodB10,  B_sum2d
        ADD2    .2      B_sum2d,    B_prodC10,  B_sum2e
        ADD2    .1      A_prodC2,   A_prodA2,   A_sum2f
        ADD2    .1      A_sum2f,    A_prodA6,   A_sum2g
        ADD2    .1      A_sum2g,    A_prodA10,  A_sum2h
        ADD2    .1X     A_sum2h,    B_sum2e,    A_pixel45

        ADD2    .1      A_prodA11,  A_prodA7,   A_sum3a
        ADD2    .1      A_sum3a,    A_prodC3,   A_sum3b
        ADD2    .1      A_sum3b,    A_prodA3,   A_sum3c
        ADD2    .2      B_prodB11,  B_roundval, B_sum3d
        ADD2    .2      B_sum3d,    B_prodC7,   B_sum3e
        ADD2    .2      B_sum3e,    B_prodB3,   B_sum3f
        ADD2    .2      B_sum3f,    B_prodB7,   B_sum3g
        ADD2    .2      B_sum3g,    B_prodC11,  B_sum3h
        ADD2    .2X     B_sum3h,    A_sum3c,    B_pixel67

* ------------------------------------------------------------------------- *
*  right shift, saturate to 0..255 and pack                                 *
* ------------------------------------------------------------------------- *
        SHR2    .1      A_pixel01,  A_shift,    A_pixel01
        SHR2    .1X     B_pixel23,  A_shift,    A_pixel23
        SHR2    .1      A_pixel45,  A_shift,    A_pixel45
        SHR2    .1X     B_pixel67,  A_shift,    A_pixel67

        SPACKU4 .1      A_pixel23,  A_pixel01,  A_outword0
        SPACKU4 .1      A_pixel67,  A_pixel45,  A_outword1
        STNDW           A_outword1:A_outword0,  *A_OPTR++(8)
        BDEC            loop,   B_count

        .return;
        .endproc

*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*


corr_3x3.sa/    1066928952  0     0     0       14116     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sun Mar 17 07:44:18 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       corr_3x3: 3x3 correlation with rounding for 8 bit data              *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_corr_3x3                                               *
*           (                                                               *
*               const unsigned char *i_data,       // input image       //  *
*               int        *restrict o_data,       // output image      //  *
*               const unsigned char  mask[3][3],   // convolution mask  //  *
*               int                  x_dim,        // width of image    //  *
*               int                  n_out         // number of outputs //  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The correlation performs a point by point multiplication of the     *
*       3 by 3 mask with the input image.  The result of the nine           *
*       multiplications are then summed up together to produce a            *
*       convolution sum.  This sum is then stored to the output array.      *
*                                                                           *
*       The image mask to be correlated is typically part of the input      *
*       image and indicates the area of the best match between the          *
*       input image and mask.  The mask is moved one column at a time,      *
*       advancing the mask over the portion of the row specified by         *
*       'n_out'.  When 'n_out' is larger than 'x_dim', multiple rows        *
*       will be processed.                                                  *
*                                                                           *
*       An application may call this kernel once per row to calculate       *
*       the correlation for an entire image:                                *
*                                                                           *
*           for (i = 0; i < rows; i++)                                      *
*           {                                                               *
*               IMG_corr_3x3(&i_data[i * x_dim], &o_data[i * n_out],        *
*                           mask, x_dim, n_out);                            *
*           }                                                               *
*                                                                           *
*       Alternately, the kernel may be invoked for multiple rows at         *
*       a time, although the two outputs at the end of each row will        *
*       have meaningless values.  For example:                              *
*                                                                           *
*           IMG_corr_3x3(i_data, o_data, mask, x_dim, 2 * x_dim);           *
*                                                                           *
*       This will produce two rows of outputs into 'o_data'.  The           *
*       outputs at locations o_data[x_dim - 2], o_data[x_dim - 1],          *
*       o_data[2*x_dim - 2] and o_data[2*x_dim - 1] will have               *
*       meaningless values.  This is harmless, although the application     *
*       will have to account for this when interpreting the results.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The array pointed to by o_data does not alias with the array        *
*       pointed to by i_data or mask.                                       *
*                                                                           *
*       The number of outputs 'n_out' must be a multiple of 8.  In cases    *
*       where 'n_out' is not a multiple of 8, most applications can safely  *
*       round 'n_out' up to the next multiple of 8 and ignore the extra     *
*       outputs.  This kernel does not round 'n_out' up for the user.       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This kernel places no restrictions on the alignment of its input.   *
*                                                                           *
*       No bank conflicts occur.                                            *
*                                                                           *
*       This code assumes a LITTLE ENDIAN configuration.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loops are unrolled completely, and the outer loop is      *
*       unrolled 8 times.                                                   *
*                                                                           *
*       We use 3 DOTPU4s to calculate the 3 rows of each output pixel.      *
*       We then accumulate the 3 DOTPU4s to a 32-bit result and store       *
*       them out.  (Note that only 3 of every 4 8-bit MPYs in the DOTPU4    *
*       is actually used.  The fourth MPY is unused.)                       *
*                                                                           *
*       We use non-aligned loads and stores to avoid alignment issues.      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_corr_3x3_32"
        .global _IMG_corr_3x3
_IMG_corr_3x3:    .cproc  A_row0, B_o_ptr, A_mask, B_x_dim, A_i

        .reg            A_h7654:A_h3210, A_h8765, A_h6543, A_h8
        .reg            B_l2_9876:B_l2_5432,    B_l2_7654:B_l2_3210
        .reg            B_l1_9876:B_l1_5432,    B_l1_7654:B_l1_3210
        .reg            B_l0_9876:B_l0_5432,    B_l0_7654:B_l0_3210
        .reg            A_h2_210_,  A_h1_210_,  A_h0_210_
        .reg            A_h2__210,  A_h1__210,  A_h0__210
        .reg            B_o7_r2,    B_o6_r2,    B_o5_r2,    B_o4_r2
        .reg            A_o3_r2,    A_o2_r2,    A_o1_r2,    A_o0_r2
        .reg            B_o7_r1,    B_o6_r1,    B_o5_r1,    B_o4_r1
        .reg            A_o3_r1,    A_o2_r1,    A_o1_r1,    A_o0_r1
        .reg            B_o7_r0,    B_o6_r0,    B_o5_r0,    B_o4_r0
        .reg            A_o3_r0,    A_o2_r0,    A_o1_r0,    A_o0_r0
        .reg            B_o7_r21,   B_o6_r21,   B_o5_r21,   B_o4_r21
        .reg            A_o3_r21,   A_o2_r21,   A_o1_r21,   A_o0_r21
        .reg            B_o7:B_o6,  B_o5:B_o4,  A_o3:A_o2,  A_o1:A_o0
        .reg            A_row1,     A_row2
        .no_mdep

        SHR     .1      A_i,        3,          A_i
        SUB     .1      A_i,        2,          A_i

        LDNDW   .D1T1   *A_mask(0), A_h7654:A_h3210
        LDBU    .D1T1   *A_mask(8), A_h8

        ; h2_210 is 876
        ; h1_210 is 543
        ; h0_210 is 210
        SHRMB   .1      A_h8,       A_h7654,    A_h8765
        CLR     .1      A_h8765,    0,  7,      A_h2_210_
        ROTL    .1      A_h2_210_,  24,         A_h2__210

        SHLMB   .1      A_h3210,    A_h7654,    A_h6543
        CLR     .1      A_h6543,    24, 31,     A_h1__210
        ROTL    .1      A_h1__210,  8,          A_h1_210_

        CLR     .1      A_h3210,    24, 31,     A_h0__210
        ROTL    .1      A_h0__210,  8,          A_h0_210_

        ADD     .1X     A_row0,     B_x_dim,    A_row1
        ADD     .1X     A_row1,     B_x_dim,    A_row2

loop:   .trip   1
        LDNDW   .D1T2   *+A_row2(2),    B_l2_9876:B_l2_5432
        LDNDW   .D1T2   *+A_row1(2),    B_l1_9876:B_l1_5432
        LDNDW   .D1T2   *+A_row0(2),    B_l0_9876:B_l0_5432
        LDNDW   .D1T2   *A_row2++(8),   B_l2_7654:B_l2_3210
        LDNDW   .D1T2   *A_row1++(8),   B_l1_7654:B_l1_3210
        LDNDW   .D1T2   *A_row0++(8),   B_l0_7654:B_l0_3210

                        ;           ;           ;

        DOTPU4  .2X     B_l2_9876,  A_h2_210_,  B_o7_r2
        DOTPU4  .2X     B_l2_9876,  A_h2__210,  B_o6_r2
        DOTPU4  .2X     B_l2_7654,  A_h2_210_,  B_o5_r2
        DOTPU4  .2X     B_l2_7654,  A_h2__210,  B_o4_r2
        DOTPU4  .1X     B_l2_5432,  A_h2_210_,  A_o3_r2
        DOTPU4  .1X     B_l2_5432,  A_h2__210,  A_o2_r2
        DOTPU4  .1X     B_l2_3210,  A_h2_210_,  A_o1_r2
        DOTPU4  .1X     B_l2_3210,  A_h2__210,  A_o0_r2

        DOTPU4  .2X     B_l1_9876,  A_h1_210_,  B_o7_r1
        DOTPU4  .2X     B_l1_9876,  A_h1__210,  B_o6_r1
        DOTPU4  .2X     B_l1_7654,  A_h1_210_,  B_o5_r1
        DOTPU4  .2X     B_l1_7654,  A_h1__210,  B_o4_r1
        DOTPU4  .1X     B_l1_5432,  A_h1_210_,  A_o3_r1
        DOTPU4  .1X     B_l1_5432,  A_h1__210,  A_o2_r1
        DOTPU4  .1X     B_l1_3210,  A_h1_210_,  A_o1_r1
        DOTPU4  .1X     B_l1_3210,  A_h1__210,  A_o0_r1

        DOTPU4  .2X     B_l0_9876,  A_h0_210_,  B_o7_r0
        DOTPU4  .2X     B_l0_9876,  A_h0__210,  B_o6_r0
        DOTPU4  .2X     B_l0_7654,  A_h0_210_,  B_o5_r0
        DOTPU4  .2X     B_l0_7654,  A_h0__210,  B_o4_r0
        DOTPU4  .1X     B_l0_5432,  A_h0_210_,  A_o3_r0
        DOTPU4  .1X     B_l0_5432,  A_h0__210,  A_o2_r0
        DOTPU4  .1X     B_l0_3210,  A_h0_210_,  A_o1_r0
        DOTPU4  .1X     B_l0_3210,  A_h0__210,  A_o0_r0

        ADD             B_o7_r2,    B_o7_r1,    B_o7_r21
        ADD             B_o6_r2,    B_o6_r1,    B_o6_r21
        ADD             B_o5_r2,    B_o5_r1,    B_o5_r21
        ADD             B_o4_r2,    B_o4_r1,    B_o4_r21
        ADD             A_o3_r2,    A_o3_r1,    A_o3_r21
        ADD             A_o2_r2,    A_o2_r1,    A_o2_r21
        ADD             A_o1_r2,    A_o1_r1,    A_o1_r21
        ADD             A_o0_r2,    A_o0_r1,    A_o0_r21

        ADD             B_o7_r21,   B_o7_r0,    B_o7
        ADD             B_o6_r21,   B_o6_r0,    B_o6
        ADD             B_o5_r21,   B_o5_r0,    B_o5
        ADD             B_o4_r21,   B_o4_r0,    B_o4
        ADD             A_o3_r21,   A_o3_r0,    A_o3
        ADD             A_o2_r21,   A_o2_r0,    A_o2
        ADD             A_o1_r21,   A_o1_r0,    A_o1
        ADD             A_o0_r21,   A_o0_r0,    A_o0

        STNDW           B_o7:B_o6,   *+B_o_ptr[3]
        STNDW           B_o5:B_o4,   *+B_o_ptr[2]
        STNDW           A_o3:A_o2,   *+B_o_ptr[1]
        STNDW           A_o1:A_o0,   *B_o_ptr++[4]

        BDEC            loop,   A_i

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_corr_3x3.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
corr_gen.sa/    1066928952  0     0     0       17949     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Fri Mar 15 19:16:10 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           IMG_corr_gen                                                    *
*                                                                           *
*     REVISION DATE                                                         *
*         30-Sep-1999                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_corr_gen                                                   *
*       (                                                                   *
*           short   *x,                                                     *
*           short   *h,                                                     *
*           short   *y,                                                     *
*           int     m,                                                      *
*           int     x_dim                                                   *
*       );                                                                  *
*                                                                           *
*       x[]   : Input pixel array.                                          *
*               Must be word aligned.                                       *
*       h[M]  : Input 1xM mask array                                        *
*       y[]   : Output array of correlation sum                             *
*               Must be double-word aligned.                                *
*       M     : Length of filter.                                           *
*       x_dim : Width of input image                                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The routine performs a generalized correlation with a 1 by M tap    *
*       filter. It can be called repetitively to form an arbitrary MxN 2D   *
*       generalized correlation kernel. The correlation sum is stored as    *
*       half words. The input pixel, and mask data is assumed to come in    *
*       as shorts.  No restrictions apply to x_dim and M.                   *
*                                                                           *
*       If the width of the input image is x_dim and the mask is M then     *
*       the output array must have at-least a dimension of (x_dim - m + 8). *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_corr_gen(short *x, short *h, short *y, int M, int x_dim)   *
*       {                                                                   *
*           iters = x_dim - M;                                              *
*           for (j = 0; j < iters; j++)                                     *
*           {                                                               *
*               sum =  y[j];                                                *
*               for (i = 0; i < M; i++)                                     *
*               {                                                           *
*                   sum += xptr[i + j] * hptr[i];                           *
*               }                                                           *
*               y[j] = sum;                                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*    TECHNIQUES                                                             *
*        It is advisable to software pipeline the loop that is expected to  *
*        iterate the most number of times. In the case of generalized       *
*        correlation since the number of filter taps M is not known         *
*        a priori the loop order interchange optimization is used and the   *
*        inner and outer loops of the natural C code are exchanged. If the  *
*        # of taps M is even then it is completely computed by using an     *
*        optimal 2 tap filter implementation. If M is odd then upto M - 1   *
*        even taps are computed using the 2 tap filter section and then a   *
*        1 tap filter section is used for odd tap.                          *
*                                                                           *
*        2 tap filter section:                                              *
*        The 2 tap filter section assumes that the input array is word      *
*        aligned. In order to minimize the load bandwidth the first word    *
*        is pre-loaded. Four words are read in and the last read is then    *
*        moved in as the new data allowing for data re-use. The dotp2       *
*        instructions allow for the first four even output samples to be    *
*        computed. Pack instructions then re-align  the input data so that  *
*        odd samples may be computed without re-loading data using          *
*        non-aligned loads.                                                 *
*                                                                           *
*        1 tap filter case and odd M filter case:                           *
*        For the 1 tap filter case the code jumps to the start of the 1 tap *
*        filter case, and for the odd tap filter case the 2 tap filter      *
*        section is iterated for as many times as possible and the last odd *
*        tap is computed using the 1 tap section.                           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*        Array x[] must be word aligned, array y[ ] must be double-word     *
*        aligned, and array h[ ] must be half-word aligned.                 *
*                                                                           *
*    NOTES                                                                  *
*        This code is ENDIAN NEUTRAL.                                       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_corr_gen"
        .global _IMG_corr_gen
_IMG_corr_gen:  .cproc A_x,  B_h, A_y, B_m, A_x_dim

            .no_mdep

            ; regs outside loop

            .reg  B_hptr, A_tmp0, A_tmp1, A_iters
            .reg  A_k,    B_i,    B_jmp

            ; regs for outer LOOPI

            .reg   B_h0, A_h1, B_h1h0, A_h1h0
            .reg   B_xptr, A_xptr, A_j, B_yptr
            .reg   A_yptr, B_zptr, A_zptr

            ;regs for inner LOOPJ

            .reg   B_x3x2, A_x5x4, B_x7x6, A_x9x8
            .reg   A_sum0, B_sum2, A_sum4, B_sum6
            .reg   B_x2x1, A_x4x3, B_x6x5, A_x8x7
            .reg   B_sum1, B_sum3, A_sum5, A_sum7
            .reg   B_sum10,B_sum32,A_sum54,A_sum76
            .reg   B_word1:B_word0, A_word3:A_word2
            .reg   B_stor1:B_stor0, A_stor3:A_stor2
            .reg   A_x1x0

           ; regs outside LOOPOD

             .reg  A_h0,  B_sum_zero, B_sum_one
             .reg  A_tmp, A_yiptr, B_yiptr, A_ziptr
             .reg  B_ziptr, A_od,  B_tmp1,  B_xword0
             .reg  A_xword1, A_h0x0, A_h0x1, B_h0x3, B_h0x2
             .reg  A_sum1_s, A_sum_zero, B_sum3_s
             .reg  B_y3y2,A_y1y0, A_z3z2:A_z1z0
             .reg  B_h0word, A_h0word, A_hptr,B_z3z2

          MV.2      B_h,       B_hptr              ; filter pointer
          ADD       B_h,       2,         A_hptr   ;

          SUB.1x    A_x_dim,    B_m,      A_tmp0   ; tmp0 = x - m
          AND.1     A_tmp0,     1,        A_tmp1   ; odd/even
          SUB.1     A_tmp0,     A_tmp1,   A_iters  ; deduct 1 if odd

          ZERO.1    A_k                            ; k = 0
          SUB.2x    B_m,       A_tmp1,  B_i        ; i = m - 1
          SUB.2     B_m,       1,       B_jmp      ; if (m==1) jmp = 0
[!B_jmp]  B.2       SKIP                           ; if (!jmp) B END

          ADD.1     A_iters,    8,      A_iters    ; 8 outputs
          SHR.2     B_i,        1,       B_i       ; 2 filter coeffs
          LDH.D2T2  *B_hptr++[2],  B_h0            ; h0 = *hptr++
          LDH.D1T1  *A_hptr++[2],  A_h1            ; h1 = *hptr++

LOOPI:

         PACK2.1x   A_h1,      B_h0,    A_h1h0     ; h1h0
         MV.2x      A_h1h0,    B_h1h0              ; copy

         LDH.D2T2  *B_hptr++[2],  B_h0             ; h0 = *hptr++
         LDH.D1T1  *A_hptr++[2],  A_h1             ; h1 = *hptr++

         ADDAH.1    A_x,       A_k,     A_xptr     ; x[0], x[2]...
         LDW.D1T1  *A_xptr++,  A_x1x0              ; x1x0 first word
         ADD.1      A_k,       2,       A_k        ; k += 2

         MV.2x      A_xptr,    B_xptr              ; xptr
         ADD.1x     B_xptr,    4,       A_xptr     ; xptr

         SHR.1      A_iters,   3,       A_j        ; j >> 3
         SUB.1      A_j,       2,       A_j        ;

         MV.2x      A_y,       B_yptr              ; yptr = y
         ADD.1x     B_yptr,    8,       A_yptr     ; yptr = &y[8]
         MV.2x      A_y,       B_zptr              ;
         ADD.1x     B_zptr,    8,       A_zptr     ; zptr = z

         .mptr   B_zptr, A_x+0, 16
         .mptr   A_zptr, A_x+4, 16
         .mptr   B_yptr, A_x+0, 16
         .mptr   A_yptr, A_x+4, 16

LOOPJ:   .trip 16

         LDW.D2T2 *B_xptr++[2],  B_x3x2            ; x3x2
         LDW.D1T1 *A_xptr++[2],  A_x5x4            ; x5x4
         LDW.D2T2 *B_xptr++[2],  B_x7x6            ; x7x6
         LDW.D1T1 *A_xptr++[2],  A_x9x8            ; x9x8

         DOTP2.1   A_h1h0,  A_x1x0,  A_sum0        ; h0x0 + h1x1
         DOTP2.2   B_h1h0,  B_x3x2,  B_sum2        ; h0x2 + h1x3
         DOTP2.1   A_h1h0,  A_x5x4,  A_sum4        ; h0x4 + h1x5
         DOTP2.2   B_h1h0,  B_x7x6,  B_sum6        ; h0x6 + h1x7


         PACKLH2.2x  B_x3x2,  A_x1x0,  B_x2x1      ; x2x1
         PACKLH2.1x  A_x5x4,  B_x3x2,  A_x4x3      ; x4x3
         PACKLH2.2x  B_x7x6,  A_x5x4,  B_x6x5      ; x6x5
         PACKLH2.1x  A_x9x8,  B_x7x6,  A_x8x7      ; x8x7

         DOTP2.2    B_h1h0,  B_x2x1,  B_sum1       ; h0x1 + h1x2
         DOTP2.2    B_h1h0,  A_x4x3,  B_sum3       ; h0x3 + h1x4
         DOTP2.1    A_h1h0,  B_x6x5,  A_sum5       ; h0x5 + h1x6
         DOTP2.1    A_h1h0,  A_x8x7,  A_sum7       ; h0x7 + h1x8

         PACK2.2x   B_sum1,  A_sum0,  B_sum10      ; sum1:sum0
         PACK2.2    B_sum3,  B_sum2,  B_sum32      ; sum3:sum2
         PACK2.1    A_sum5,  A_sum4,  A_sum54      ; sum5:sum4
         PACK2.1x   A_sum7,  B_sum6,  A_sum76      ; sum7:sum6

         LDDW.D2T2  *B_yptr++[2], B_word1:B_word0  ; prev1:prev0
         LDDW.D1T1  *A_yptr++[2], A_word3:A_word2  ; prev3:prev2

         ADD2.2    B_word0,   B_sum10,  B_stor0    ; prev10 + sum10
         ADD2.2    B_word1,   B_sum32,  B_stor1    ; prev32 + sum32
         ADD2.1    A_word2,   A_sum54,  A_stor2    ; prev54 + sum54
         ADD2.1    A_word3,   A_sum76,  A_stor3    ; prev76 + sum76

         STDW.D2T2    B_stor1:B_stor0,  *B_zptr++[2]; zptr[0]= stor1:stor0
         STDW.D1T1    A_stor3:A_stor2,  *A_zptr++[2]; zptr[1]= stor3:stor2

         MV.1      A_x9x8,    A_x1x0               ; x1x0 = x9x8

         BDEC.1    LOOPJ,   A_j                    ; if j > 0 Branch


[B_i]    SUB.2       B_i,           1,            B_i   ; if (i) i--
[B_i]    B.2         LOOPI                              ; if (i) B LOOPI


[!A_tmp1]   B.1         END                                ; if (even) end

SKIP:
            SUB        B_m,          1,            A_tmp ; tmp = m - 1
            MPY        A_tmp,        2,            A_tmp ; Scale for HWORD
            ADD        A_x,          A_tmp,        A_xptr; xptr = &x[m-1]
            ADD        B_h,          A_tmp,        B_hptr; hptr = &h[m-1]

            LDH        *B_hptr,      B_h0                ; h0 = h[m-1]
            MV          B_h0,        A_h0                ; Make h0 copy

            MV      A_xptr,      B_xptr                  ; Make xptr copy
            ADD     A_xptr,      4,         A_xptr       ; A_xptr = &x[2]

            MV      A_y,         A_yiptr                 ; A_yiptr = &y[0]
            ADD     A_y,         4,         B_yiptr      ; B_yiptr = &y[2]
            MV      A_y,         A_ziptr                 ; A_ziptr = &y[0]
            ADD     A_y,         4,         B_ziptr      ; B_ziptr = &y[2]


            SUB     A_iters,     4,         A_od         ; Iterate 4M times
            SHRU    A_od,         2,        A_od         ; od >> 2

            ADD     .L1     A_iters,     1,         A_tmp
            AND     .L2x    A_tmp,       3,         B_tmp1

LOOPOD:     .trip  16

            LDW     *B_xptr++[2],   B_xword0             ; x1x0 load
            LDW     *A_xptr++[2],   A_xword1             ; x3x2 load

            MPY      A_h0,     B_xword0,    A_h0x0       ; h0x0 = h0 * x0
            MPYLH    A_h0,     B_xword0,    A_h0x1       ; h0x1 = h0 * x1
            MPY      B_h0,     A_xword1,    B_h0x2       ; h0x2 = h0 * x2
            MPYLH    B_h0,     A_xword1,    B_h0x3       ; h0x3 = h0 * x3

            SHL      A_h0x1,   16,          A_sum1_s     ; h0x1 << 16
            ADD      A_sum1_s, A_h0x0,      A_sum_zero   ; h0x1 | h0x0
            SHL      B_h0x3,   16,          B_sum3_s     ; h0x3 << 16
            ADD      B_sum3_s, B_h0x2,      B_sum_one    ; h0x3 | h0x2

            LDW      *A_yiptr++[2], A_y1y0               ; prev0
            LDW      *B_yiptr++[2], B_y3y2               ; prev1

            ADD2      A_y1y0,       A_sum_zero,   A_z1z0 ; add2 to prev0
            ADD2      B_y3y2,       B_sum_one,    B_z3z2 ; add2 to prev1

            STW       A_z1z0,       *A_ziptr++[2]        ; pres0 store
            STW       B_z3z2,       *B_ziptr++[2]        ; pres1 store

[A_od]      SUB       A_od,     1,      A_od             ; if (od) od--
[A_od]      B         LOOPOD                             ; if (od) B LOOPOD

END:

            SUB    .L1x      A_x_dim,    B_m,    A_h0    ; x_dim - m
            ZERO             A_z1z0                      ; z1z0 = 0
            ZERO             A_z3z2                      ; z3z2 = 0
            ADDAH  .D1       A_y,    A_h0,     A_xptr    ; y[x_dim - m]
            ADD    .L2x      A_xptr,  2,       B_xptr    ; odd/even
            STNDW  .D1T1     A_z3z2:A_z1z0, *A_xptr++
            STNDW  .D1T1     A_z3z2:A_z1z0, *A_xptr++

            .return
            .endproc


*==============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*

dilate_bin.sa/  1066928952  0     0     0       15408     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon May 20 02:48:57 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_dilate_bin--This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_dilate_bin                                                 *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_dilate_bin()implements binary dilation using an    *
*       arbitrary 3x3 mask.  The dilation operator generates output pixels  *
*       by ORing the pixels under the input mask together to generate       *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 0;                                                     *
*           if (mask[0][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result |= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result |= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result |= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the dilation operation.       *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 dilation mask is applied to 32 output pixels                *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           dilation operation.                                             *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_dilate_bin"
        .global _IMG_dilate_bin
_IMG_dilate_bin:.cproc  A_ir0,  B_out_data,  A_mask, B_cols 

        .no_mdep

        .reg  B_q8:B_p8
        .reg  B_q7:B_p7
        .reg  B_q5:B_p5
        .reg  B_q4:B_p4
        .reg  B_q2:B_p2
        .reg  B_q1:B_p1
        .reg  B_p6h:B_p6
        .reg  B_p3h:B_p3
        .reg  B_p0h:B_p0
        .reg  B_rslt_:B_rslt
        .reg  A_q8:A_p8
        .reg  A_q7:A_p7
        .reg  A_q5:A_p5
        .reg  A_q4:A_p4
        .reg  A_q2:A_p2
        .reg  A_q1:A_p1
        .reg  A_m7654:A_m3210
        .reg  A_p6h:A_p6
        .reg  A_p3h:A_p3
        .reg  A_p0h:A_p0
        .reg  B_m8
        .reg  B_m7654
        .reg  B_m7
        .reg  B_m6
        .reg  B_m5
        .reg  B_m4
        .reg  B_ir1
        .reg  B_ir2
        .reg  B_ir0
        .reg  B_m3
        .reg  B_rA
        .reg  B_rB
        .reg  B_rC
        .reg  B_rD
        .reg  B_i
        .reg  A_m3
        .reg  A_m2
        .reg  A_m1
        .reg  A_m0
        .reg  A_ir1
        .reg  A_ir2
        .reg  A_out_data
        .reg  A_i
        .reg  A_m4
        .reg  A_rA
        .reg  A_rB
        .reg  A_rC
        .reg  A_rD
        .reg  A_rslt

        LDNDW.D1T1  *A_mask,    A_m7654:A_m3210
        LDB  .D1T2  *A_mask[8], B_m8
        MV   .2X    A_m7654,    B_m7654
        SHR         B_m8,       31,         B_m8        ; -(mask[8]<0)
        SHR         B_m7654,    31,         B_m7        ; -(mask[7]<0)
        EXT  .2     B_m7654,    8,  31,     B_m6        ; -(mask[6]<0)
        EXT         B_m7654,    16, 31,     B_m5        ; -(mask[5]<0)
        EXT         B_m7654,    24, 31,     B_m4        ; -(mask[4]<0)
        SHR         A_m3210,    31,         A_m3        ; -(mask[3]<0)
        EXT         A_m3210,    8,  31,     A_m2        ; -(mask[2]<0)
        EXT         A_m3210,    16, 31,     A_m1        ; -(mask[1]<0)
        EXT  .1     A_m3210,    24, 31,     A_m0        ; -(mask[0]<0)

        ADD         A_ir0,      B_cols,     B_ir1       ; Row 1 ptr
        ADD         B_ir1,      B_cols,     B_ir2       ; Row 2 ptr
        ADD         A_ir0,      4,          B_ir0       ; Row 0 twin ptr
        ADD         B_ir1,      4,          A_ir1       ; Row 1 twin ptr
        ADD         B_ir2,      4,          A_ir2       ; Row 2 twin ptr
        MV          B_out_data, A_out_data              ; Partition MV

        SHR         B_cols,     3,          A_i         ; i = cols>>3
        SUB         A_i,        2,          B_i         ; Adjust for BDEC

        MV          B_m4,       A_m4                    ; Partition MV.
        MV          A_m3,       B_m3                    ; Partition MV.

loop:
        ; Even iterations of 'i'
        LDNDW.D2T2  *B_ir2++(8),B_p6h:B_p6              ; p6 = in[2*cols + i]
        LDNDW.D2T2  *B_ir1++(8),B_p3h:B_p3              ; p3 = in[1*cols + i]
        LDNDW.D1T2  *A_ir0++(8),B_p0h:B_p0              ; p0 = in[0*cols + i]

        SHR         B_p6h:B_p6, 2,          B_q8:B_p8   ; p8 = p6l >> 2
        SHR         B_p6h:B_p6, 1,          B_q7:B_p7   ; p7 = p6l >> 1
        SHR         B_p3h:B_p3, 2,          B_q5:B_p5   ; p5 = p3l >> 2
        SHR         B_p3h:B_p3, 1,          B_q4:B_p4   ; p4 = p3l >> 1
        SHR         B_p0h:B_p0, 2,          B_q2:B_p2   ; p2 = p0l >> 2
        SHR         B_p0h:B_p0, 1,          B_q1:B_p1   ; p1 = p0l >> 1

        ANDN        B_p6,       B_m6,       B_rA        ; rA = p6 & m6
        ANDN        B_p3,       B_m3,       B_rB        ; rB = p3 & m3
        ANDN .2X    B_p0,       A_m0,       B_rC        ; rC = p0 & m0

[!B_m8] OR          B_p8,       B_rA,       B_rA        ; if (!m8) rA |= p8
[!B_m7] OR          B_p7,       B_rA,       B_rA        ; if (!m7) rA |= p7
[!B_m5] OR          B_p5,       B_rB,       B_rB        ; if (!m5) rB |= p5
[!A_m4] OR          B_p4,       B_rB,       B_rB        ; if (!m4) rB |= p4
[!A_m2] OR          B_p2,       B_rC,       B_rC        ; if (!m2) rC |= p2
[!A_m1] OR          B_p1,       B_rC,       B_rC        ; if (!m1) rC |= p1
        OR          B_rA,       B_rB,       B_rD
        OR          B_rC,       B_rD,       B_rslt      ; rslt = rA | rB | rC

        ; Odd iterations of 'i'
        LDNDW.D1T1  *A_ir2++(8),A_p6h:A_p6              ; p6 = in[2*cols + i]
        LDNDW.D1T1  *A_ir1++(8),A_p3h:A_p3              ; p3 = in[1*cols + i]
        LDNDW.D2T1  *B_ir0++(8),A_p0h:A_p0              ; p0 = in[0*cols + i]

        SHR         A_p6h:A_p6, 2,          A_q8:A_p8   ; p8 = p6l >> 2
        SHR         A_p6h:A_p6, 1,          A_q7:A_p7   ; p7 = p6l >> 1
        SHR         A_p3h:A_p3, 2,          A_q5:A_p5   ; p5 = p3l >> 2
        SHR         A_p3h:A_p3, 1,          A_q4:A_p4   ; p4 = p3l >> 1
        SHR         A_p0h:A_p0, 2,          A_q2:A_p2   ; p2 = p0l >> 2
        SHR         A_p0h:A_p0, 1,          A_q1:A_p1   ; p1 = p0l >> 1

        ANDN .1X    A_p6,       B_m6,       A_rA        ; rA = p6 & m6
        ANDN        A_p3,       A_m3,       A_rB        ; rB = p3 & m3
        ANDN        A_p0,       A_m0,       A_rC        ; rC = p0 & m0

[!B_m8] OR          A_p8,       A_rA,       A_rA        ; if (m8) rA |= p8
[!B_m7] OR          A_p7,       A_rA,       A_rA        ; if (m7) rA |= p7
[!B_m5] OR          A_p5,       A_rB,       A_rB        ; if (m5) rB |= p5
[!A_m4] OR          A_p4,       A_rB,       A_rB        ; if (m4) rB |= p4
[!A_m2] OR          A_p2,       A_rC,       A_rC        ; if (m2) rC |= p2
[!A_m1] OR          A_p1,       A_rC,       A_rC        ; if (m1) rC |= p1
        OR          A_rA,       A_rB,       A_rD
        OR   .1     A_rC,       A_rD,       A_rslt      ; rslt = rA | rB | rC

        ROTL .2X    A_rslt,     0,          B_rslt_     ; Partition MV.
        STNDW.D1T2  B_rslt_:B_rslt, *A_out_data++(8)    ; out[i] = rslt.

        BDEC    .2      loop,           B_i

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_dilate_bin.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
erode_bin.sa/   1066928952  0     0     0       15412     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Mon May 20 02:51:37 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_erode_bin-- This code performs 3x3 binary dilation              *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_erode_bin                                                  *
*       (                                                                   *
*           const unsigned char *restrict in_data,   /* Incoming image  */  *
*           unsigned char       *restrict out_data,  /* Filtered output */  *
*           const char          *restrict mask,      /* Filter mask     */  *
*           int cols  /* Number of columns to process, in bytes.        */  *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_erode_bin() implements binary erosion using an     *
*       arbitrary 3x3 mask.  The erosion operator generates output pixels   *
*       by ANDing the pixels under the input mask together to generate      *
*       the output pixel.  The input mask specifies whether one or more     *
*       pixels from the input are to be ignored.                            *
*                                                                           *
*       In pseudo-code, the filtering operation for a pixel at (x, y)       *
*       works like so:                                                      *
*                                                                           *
*           result = 1;                                                     *
*           if (mask[0][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[0][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[0][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[1][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[1][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[1][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           if (mask[2][0] != DONT_CARE) result &= input[y + 0][x + 0];     *
*           if (mask[2][1] != DONT_CARE) result &= input[y + 1][x + 1];     *
*           if (mask[2][2] != DONT_CARE) result &= input[y + 2][x + 2];     *
*           output[y][x] = result;                                          *
*                                                                           *
*       For this code, "DONT_CARE" is specified by a negative value         *
*       in the input mask.  Non-negative values in the mask cause the       *
*       corresponding pixel to be included in the erosion operation.        *
*                                                                           *
*       Note that this code operates on a bitmap where each pixel is        *
*       represented as a single bit within a byte or word.  Although        *
*       the pseudo-code above operates only on one pixel at a time,         *
*       with a single pixel in each array element, this implementation      *
*       operates on a bitmap which contains 8 pixels in each byte.          *
*                                                                           *
*       Pixels are organized within each byte such that the pixel with      *
*       the smallest index is in the LSB position, and the pixel with       *
*       the largest index is in the MSB position.  (That is, the code       *
*       assumes a LITTLE ENDIAN bit ordering.)                              *
*                                                                           *
*       Note that the "cols" argument actually specifies the number of      *
*       BYTES in the output, not the number of columns.  The number of      *
*       columns is 8 times this argument.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 3x3 erosion mask is applied to 32 output pixels                 *
*       simultaneously.  This is done with 32-bit-wide bitwise              *
*       operators in the register file.  In order to do this, the code      *
*       reads in a 34-bit-wide input window, and 40-bit operations          *
*       are used to manipulate the pixels initially.                        *
*                                                                           *
*       Because the code reads a 34-bit context for each 32-bits of         *
*       output, the input needs to be one byte longer than the output       *
*       in order to make the rightmost two pixels well-defined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1.  Negative values in the mask specify "DONT_CARE", and non-       *
*           negative values specify that pixels are included in the         *
*           erosion operation.                                              *
*                                                                           *
*       2.  The input image needs to have a multiple of 64 pixels(bits)     *
*           per row.  Therefore, "cols" must be a multiple of 8.            *
*                                                                           *
*   NOTES                                                                   *
*       Little Endian                                                       *
*                                                                           *
*       "Digital Image Processing: Principles and Applications"             *
*       by Gregory A. Baxes, Chapter 5                                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_erode_bin"
        .global _IMG_erode_bin
_IMG_erode_bin: .cproc  A_ir0,  B_out_data,  A_mask, B_cols 

        .no_mdep

        .reg  B_q8:B_p8
        .reg  B_q7:B_p7
        .reg  B_q5:B_p5
        .reg  B_q4:B_p4
        .reg  B_q2:B_p2
        .reg  B_q1:B_p1
        .reg  B_p6h:B_p6
        .reg  B_p3h:B_p3
        .reg  B_p0h:B_p0
        .reg  B_rslt_:B_rslt
        .reg  A_q8:A_p8
        .reg  A_q7:A_p7
        .reg  A_q5:A_p5
        .reg  A_q4:A_p4
        .reg  A_q2:A_p2
        .reg  A_q1:A_p1
        .reg  A_m7654:A_m3210
        .reg  A_p6h:A_p6
        .reg  A_p3h:A_p3
        .reg  A_p0h:A_p0
        .reg  B_m8
        .reg  B_m7654
        .reg  B_m7
        .reg  B_m6
        .reg  B_m5
        .reg  B_m4
        .reg  B_ir1
        .reg  B_ir2
        .reg  B_ir0
        .reg  B_m3
        .reg  B_rA
        .reg  B_rB
        .reg  B_rC
        .reg  B_rD
        .reg  B_i
        .reg  A_m3
        .reg  A_m2
        .reg  A_m1
        .reg  A_m0
        .reg  A_ir1
        .reg  A_ir2
        .reg  A_out_data
        .reg  A_i
        .reg  A_m4
        .reg  A_rA
        .reg  A_rB
        .reg  A_rC
        .reg  A_rD
        .reg  A_rslt

        LDNDW.D1T1  *A_mask,    A_m7654:A_m3210
        LDB  .D1T2  *A_mask[8], B_m8
        MV   .2X    A_m7654,    B_m7654
        SHR         B_m8,       31,         B_m8        ; -(mask[8]<0)
        SHR         B_m7654,    31,         B_m7        ; -(mask[7]<0)
        EXT  .2     B_m7654,    8,  31,     B_m6        ; -(mask[6]<0)
        EXT         B_m7654,    16, 31,     B_m5        ; -(mask[5]<0)
        EXT         B_m7654,    24, 31,     B_m4        ; -(mask[4]<0)
        SHR         A_m3210,    31,         A_m3        ; -(mask[3]<0)
        EXT         A_m3210,    8,  31,     A_m2        ; -(mask[2]<0)
        EXT         A_m3210,    16, 31,     A_m1        ; -(mask[1]<0)
        EXT  .1     A_m3210,    24, 31,     A_m0        ; -(mask[0]<0)

        ADD         A_ir0,      B_cols,     B_ir1       ; Row 1 ptr
        ADD         B_ir1,      B_cols,     B_ir2       ; Row 2 ptr
        ADD         A_ir0,      4,          B_ir0       ; Row 0 twin ptr
        ADD         B_ir1,      4,          A_ir1       ; Row 1 twin ptr
        ADD         B_ir2,      4,          A_ir2       ; Row 2 twin ptr
        MV          B_out_data, A_out_data              ; Partition MV

        SHR         B_cols,     3,          A_i         ; i = cols>>3
        SUB         A_i,        2,          B_i         ; Adjust for BDEC

        MV          B_m4,       A_m4                    ; Partition MV.
        MV          A_m3,       B_m3                    ; Partition MV.

loop:
        ; Even iterations of 'i'
        LDNDW.D2T2  *B_ir2++(8),B_p6h:B_p6              ; p6 = in[2*cols + i]
        LDNDW.D2T2  *B_ir1++(8),B_p3h:B_p3              ; p3 = in[1*cols + i]
        LDNDW.D1T2  *A_ir0++(8),B_p0h:B_p0              ; p0 = in[0*cols + i]

        SHR         B_p6h:B_p6, 2,          B_q8:B_p8   ; p8 = p6l >> 2
        SHR         B_p6h:B_p6, 1,          B_q7:B_p7   ; p7 = p6l >> 1
        SHR         B_p3h:B_p3, 2,          B_q5:B_p5   ; p5 = p3l >> 2
        SHR         B_p3h:B_p3, 1,          B_q4:B_p4   ; p4 = p3l >> 1
        SHR         B_p0h:B_p0, 2,          B_q2:B_p2   ; p2 = p0l >> 2
        SHR         B_p0h:B_p0, 1,          B_q1:B_p1   ; p1 = p0l >> 1

        OR          B_p6,       B_m6,       B_rA        ; rA = p6 | m6
        OR          B_p3,       B_m3,       B_rB        ; rB = p3 | m3
        OR   .2X    B_p0,       A_m0,       B_rC        ; rC = p0 | m0

[!B_m8] AND         B_p8,       B_rA,       B_rA        ; if (!m8) rA &= p8
[!B_m7] AND         B_p7,       B_rA,       B_rA        ; if (!m7) rA &= p7
[!B_m5] AND         B_p5,       B_rB,       B_rB        ; if (!m5) rB &= p5
[!A_m4] AND         B_p4,       B_rB,       B_rB        ; if (!m4) rB &= p4
[!A_m2] AND         B_p2,       B_rC,       B_rC        ; if (!m2) rC &= p2
[!A_m1] AND         B_p1,       B_rC,       B_rC        ; if (!m1) rC &= p1
        AND         B_rA,       B_rB,       B_rD
        AND         B_rC,       B_rD,       B_rslt      ; rslt = rA & rB & rC

        ; Odd iterations of 'i'
        LDNDW.D1T1  *A_ir2++(8),A_p6h:A_p6              ; p6 = in[2*cols + i]
        LDNDW.D1T1  *A_ir1++(8),A_p3h:A_p3              ; p3 = in[1*cols + i]
        LDNDW.D2T1  *B_ir0++(8),A_p0h:A_p0              ; p0 = in[0*cols + i]

        SHR         A_p6h:A_p6, 2,          A_q8:A_p8   ; p8 = p6l >> 2
        SHR         A_p6h:A_p6, 1,          A_q7:A_p7   ; p7 = p6l >> 1
        SHR         A_p3h:A_p3, 2,          A_q5:A_p5   ; p5 = p3l >> 2
        SHR         A_p3h:A_p3, 1,          A_q4:A_p4   ; p4 = p3l >> 1
        SHR         A_p0h:A_p0, 2,          A_q2:A_p2   ; p2 = p0l >> 2
        SHR         A_p0h:A_p0, 1,          A_q1:A_p1   ; p1 = p0l >> 1

        OR   .1X    A_p6,       B_m6,       A_rA        ; rA = p6 | m6
        OR          A_p3,       A_m3,       A_rB        ; rB = p3 | m3
        OR          A_p0,       A_m0,       A_rC        ; rC = p0 | m0

[!B_m8] AND         A_p8,       A_rA,       A_rA        ; if (!m8) rA &= p8
[!B_m7] AND         A_p7,       A_rA,       A_rA        ; if (!m7) rA &= p7
[!B_m5] AND         A_p5,       A_rB,       A_rB        ; if (!m5) rB &= p5
[!A_m4] AND         A_p4,       A_rB,       A_rB        ; if (!m4) rB &= p4
[!A_m2] AND         A_p2,       A_rC,       A_rC        ; if (!m2) rC &= p2
[!A_m1] AND         A_p1,       A_rC,       A_rC        ; if (!m1) rC &= p1
        AND         A_rA,       A_rB,       A_rD
        AND  .1     A_rC,       A_rD,       A_rslt      ; rslt = rA & rB & rC

        ROTL .2X    A_rslt,     0,          B_rslt_     ; Partition MV.
        STNDW.D1T2  B_rslt_:B_rslt, *A_out_data++(8)    ; out[i] = rslt.

        BDEC    .2      loop,           B_i

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_erode_bin.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
errdif_bin.sa/  1066928952  0     0     0       19347     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Mon Jan  7 20:16:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_errdif_bin -- Binary Floyd-Steinberg Error Diffusion.           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*               void IMG_errdif_bin                                         *
*               (                                                           *
*                   unsigned char *restrict errdif_data,                    *
*                   int           cols,                                     *
*                   int           rows,                                     *
*                   short         *restrict err_buf,                        *
*                   unsigned char thresh                                    *
*               )                                                           *
*                                                                           *
*       errdif_data:     Input/Output image ptr                             *
*       cols:            Number of columns (Width). Must be >= 2.           *
*       rows:            Number of rows    (Height)                         *
*       err_buf[cols+1]: Buffer where one row of errors is to be saved      *
*       thresh:          Threshold in the range [0x00, 0xFF]                *
*                                                                           *
*       errdif_data[] is used for both input and output and the number      *
*       of colums, cols, must be at least 2.  No restriction on number      *
*       of rows.                                                            *
*                                                                           *
*       err_buf[], additional buffer, should be provided with               *
*       initialized to all-zero's for the first call with an image.         *
*       The subsequent call with the same image should provide this         *
*       kernel the returned err_buf The size of err_buf should be           *
*       (cols+1)*Half-Word.                                                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code implements the Binary Floyd-Steinberg error diffusion      *
*       filter.  The filter kernel used is this one:                        *
*                                                                           *
*                                   +---+                                   *
*                                 P | 7 |                                   *
*                           +---+---+---+                                   *
*                           | 3 | 5 | 1 |                                   *
*                           +---+---+---+                                   *
*                                                                           *
*                                                                           *
*       Pixels are processed from left-to-right, top-to-bottom.  Each       *
*       pixel is compared against a user-defined threshold.  Pixels         *
*       that are larger than the threshold are set to 255, and pixels       *
*       that are smaller or equal to the threshold are set to 0.  The       *
*       error value for the pixel (eg. the difference between the           *
*       thresholded pixel and its original grey level) is propagated to     *
*       the neighboring pixels according to the filter above.  This         *
*       error propagation diffuses the error over a larger area, hence      *
*       the term "error diffusion."                                         *
*                                                                           *
*       The following C code illustrates the algorithm.  The C code is      *
*       a general implementation without restrictions.  This version        *
*       may have restriction as noted in the ASSUMPTIONS below.             *
*                                                                           *
*       void IMG_errdif_bin                                                 *
*       (                                                                   *
*          unsigned char *restrict                                          *
*                        errdif_data,    /* Input/Output image ptr      */  *
*          int           cols,           /* Number of columns (Width)   */  *
*          int           rows,           /* Number of rows    (Height)  */  *
*          short         *restrict                                          *
*                        err_buf,        /* row-to-row error buffer.    */  *
*          unsigned char thresh          /* Threshold from [0x00, 0xFF] */  *
*       )                                                                   *
*       {                                                                   *
*          int   x, i, y;        /* Loop counters                       */  *
*          int   F;              /* Current pixel value at [x,y]        */  *
*          int   errA;           /* Error value at [x-1, y-1]           */  *
*          int   errB;           /* Error value at [  x, y-1]           */  *
*          int   errC;           /* Error value at [x+1, y-1]           */  *
*          int   errE;           /* Error value at [x-1,   y]           */  *
*          int   errF;           /* Error value at [  x,   y]           */  *
*                                                                           *
*          /* --------------------------------------------------------- */  *
*          /*  Step through rows of pixels.                             */  *
*          /* --------------------------------------------------------- */  *
*          for (y = 0, i = 0; y < rows; y++)                                *
*          {                                                                *
*             /* ------------------------------------------------------ */  *
*             /*  Start off with our initial errors set to zero at      */  *
*             /*  the start of the line since we do not have any        */  *
*             /*  pixels to the left of the row.  These error terms     */  *
*             /*  are maintained within the inner loop.                 */  *
*             /* ------------------------------------------------------ */  *
*             errA = 0; errE = 0;                                           *
*             errB = err_buf[0];                                            *
*                                                                           *
*             /* ------------------------------------------------------ */  *
*             /*  Step through pixels in each row.                      */  *
*             /* ------------------------------------------------------ */  *
*             for (x = 0; x < cols; x++, i++)                               *
*             {                                                             *
*                /* --------------------------------------------------- */  *
*                /*  Load the error being propagated from pixel 'C'     */  *
*                /*  from our error buffer.  This was calculated        */  *
*                /*  during the previous line.                          */  *
*                /* --------------------------------------------------- */  *
*                errC = err_buf[x+1];                                       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Load our pixel value to quantize.                  */  *
*                /* --------------------------------------------------- */  *
*                F = errdif_data[i];                                        *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Calculate our resulting pixel.  If we assume       */  *
*                /*  that this pixel will be set to zero, this also     */  *
*                /*  doubles as our error term.                         */  *
*                /* --------------------------------------------------- */  *
*                errF = F + ((errE*7 + errA + errB*5 + errC*3) >> 4);       *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Set pixels that are larger than the threshold to   */  *
*                /*  255, and pixels that are smaller than the          */  *
*                /*  threshold to 0.                                    */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  errdif_data[i] = 0xFF;                 *
*                else                errdif_data[i] = 0;                    *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  If the pixel was larger than the threshold, then   */  *
*                /*  we need subtract 255 from our error.  In any       */  *
*                /*  case, store the error to the error buffer.         */  *
*                /* --------------------------------------------------- */  *
*                if (errF > thresh)  err_buf[x] = errF = errF - 0xFF;       *
*                else                err_buf[x] = errF;                     *
*                                                                           *
*                /* --------------------------------------------------- */  *
*                /*  Propagate error terms for the next pixel.          */  *
*                /* --------------------------------------------------- */  *
*                errE = errF;                                               *
*                errA = errB;                                               *
*                errB = errC;                                               *
*             }                                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Constants, 7, 5, 3, 1 for multiplication are shifted left 12 to     *
*       avoid 'SHR 4' operation in the critical path.                       *
*                                                                           *
*       The processing of the filter itself is inverted so that the         *
*       errors from previous pixels "propagate into" a given pixel at       *
*       the time the pixel is processed, rather than "accumulate into"      *
*       a pixel as its neighbors are processed.  This allows us to          *
*       keep our image as an 8-bit image, and reduces the number of         *
*       accesses to the image array.  The inverted filter kernel            *
*       performs identically to the kernel's original form.  In this        *
*       form, the weights specify the weighting assigned to the errors      *
*       coming from the neighboring pixels.                                 *
*                                                                           *
*                           +---+---+---+                                   *
*                           | 1 | 5 | 3 |                                   *
*                           +---+---+---+                                   *
*                           | 7 | P                                         *
*                           +---+                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of columns must be at least 2.                           *
*                                                                           *
*       err_buf[] must be initialized to zeros for the first call and       *
*       the returned err_buf should be provided for the next call.          *
*                                                                           *
*   NOTES                                                                   *
*       This function is Endian neutral.                                    *
*       No special alignment of data arrays is expected.                    *
*                                                                           *
*   SOURCE                                                                  *
*       Floyd-Steinberg Error Diffusion.                                    *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_errdif_bin"
        .global _IMG_errdif_bin
_IMG_errdif_bin:       .cproc  A_rgb_r, A_w, A_y, B_errbuf0, B_thrsh
*---------------------------- *Uchar  int  int  *short     Uchar
        .no_mdep

        .reg  A_errbuf_r, A_errbuf_w, B_rgb_r, A_rgb_w, A_x, B_y
        .reg  B_errA, B_errE, B_errB, A_errC, A_errE_, A_out, B_outX
        .reg  B_eE7, B_errEA, B_eB5, A_eC3, B_errEAC, B_errAll
        .reg  B_errSft, B_F, B_big, B_F7, A_F7, A_eC3F7
        .reg  B_k5, A_k3, B_k7, A_k7, B_neg

;------- Set up addresses and loop counters

        MV      .2X     A_rgb_r,      B_rgb_r
        SUB     .2      A_y,          1,          B_y

        MV      .1      A_rgb_r,      A_rgb_w
        MVK     .2      -1785,        B_neg
        SHL     .2      B_neg,        12,         B_neg

        MVK     .2      5000h,        B_k5      ; 5 << 12
        MVK     .1      3000h,        A_k3      ; 3 << 12
        MVK     .2      7000h,        B_k7      ; 7 << 12

y_start:
        SUB     .1      A_w,          1,        A_x
        MV      .1X     B_errbuf0,              A_errbuf_w
        ADD     .1X     B_errbuf0,    2,        A_errbuf_r

        ZERO    .2      B_errA
        ZERO    .2      B_errAll
        ZERO    .1      A_F7
        LDH     .D2T2   *B_errbuf0, B_errB
        ZERO    .2      B_big

x_start: .trip 2

        LDH     .D1T1   *A_errbuf_r++,          A_errC
        LDBU    .D2T2   *B_rgb_r++,             B_F

        MPY     .2      B_errB,     B_k5,       B_eB5
        MPY     .1      A_errC,     A_k3,       A_eC3
        ADD     .2      B_eB5,      B_errA,     B_errEA
        ADD     .1      A_eC3,      A_F7,       A_eC3F7
        ADD     .2X     B_errEA,    A_eC3F7,    B_errEAC

        MPYHL   .2      B_errAll,   B_k7,       B_eE7
        MPY     .2      B_F,        B_k7,       B_F7
        MV      .1X     B_F7,       A_F7

        ADD     .2      B_errEAC,   B_eE7,      B_errAll
 [B_big]ADD     .2      B_neg,      B_errAll,   B_errAll

        SHR     .2      B_errAll,   16 ,        B_errSft
        ADD     .2      B_errSft,   B_F,        B_errE

        CMPGT   .2      B_errE,     B_thrsh,    B_big
        SUB     .2      B_thrsh,    B_errE,     B_outX
        SHRU    .1X     B_outX,     24,         A_out
        SUB     .1X     B_errE,     A_out,      A_errE_

        STH     .D1T1   A_errE_,    *A_errbuf_w++
        STB     .D1T1   A_out,      *A_rgb_w++

        SHL     .2      B_errB,     12,         B_errA
        MV      .2X     A_errC,     B_errB

  [A_x] BDEC             x_start,   A_x,

  [B_y] BDEC             y_start,   B_y

        .return
        .endproc

* ========================================================================== *
*   End of file:  img_errdif_bin.sa                                          *
* -------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================== *

fdct_8x8.sa/    1066928952  0     0     0       43576     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Thu Sep  6 18:49:09 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_fdct_8x8 -- 8x8 Block FDCT With Rounding, Little Endian         *
*                                                                           *
*   REVISION DATE                                                           *
*       26-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_fdct_8x8(short fdct_data[], unsigned num_fdcts)        *
*                                                                           *
*       The fdct routine accepts a list of 8x8 pixel blocks and performs    *
*       FDCTs on each.  The array should be laid out identically to         *
*       "fdct_data[num_fdcts][8][8]".  All operations in this array are     *
*       performed entirely in-place.                                        *
*                                                                           *
*       Input values are stored in shorts, and may be in the range          *
*       [-512,511].  Larger input values may result in overflow.            *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_fdct_8x8 function implements a Chen FDCT. Output values are *
*       rounded, providing improved accuracy.  Input terms are expected     *
*       to be signed 11Q0 values, producing signed 15Q0 results.  (A        *
*       smaller dynamic range may be used on the input, producing a         *
*       correspondingly smaller output range.  Typical applications         *
*       include processing signed 9Q0 and unsigned 8Q0 pixel data,          *
*       producing signed 13Q0 or 12Q0 outputs, respectively.)  No           *
*       saturation is performed.                                            *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_fdcts == 0'.  The early-exit case performs no accesses    *
*       to the fdct_data[] array.                                           *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_fdct_8x8(short *dct_data, unsigned num_fdcts)              *
*       {                                                                   *
*           /* ---------------------------------------------------- */      *
*           /*  Set up the cosine coefficients c1..c7.              */      *
*           /* ---------------------------------------------------- */      *
*           const unsigned short c1 = 0x1F62, c3 = 0x1A9B;                  *
*           const unsigned short c5 = 0x11C7, c7 = 0x063E;                  *
*           const unsigned short c2 = 0x29CF, c6 = 0x1151;                  *
*           const unsigned short C4 = 0xB505;                               *
*           const unsigned short C1 = 0xFB15, C2 = 0xA73D;                  *
*           const unsigned short C3 = 0xD4DB, C5 = 0x8E3A;                  *
*           const unsigned short C6 = 0x4546, C7 = 0x31F1;                  *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Intermediate calculations.                          */      *
*           /* ---------------------------------------------------- */      *
*           short f0, f1, f2, f3;   /* Spatial domain samples.      */      *
*           short f4, f5, f6, f7;   /* Spatial domain samples.      */      *
*           short g0, g1, h0, h1;   /* Even-half intermediate.      */      *
*           short p0, p1;           /* Even-half intermediate.      */      *
*           short r0, r1, r0_,r1_;  /* Even-half intermediate.      */      *
*           short P0, P1, R0, R1;   /* Even-half intermediate.      */      *
*           short g2, g3, h2, h3;   /* Odd-half intermediate.       */      *
*           short q1a,s1a;          /* Odd-half intermediate.       */      *
*           short q0, q1, s0, s1;   /* Odd-half intermediate.       */      *
*           short Q0, Q1, S0, S1;   /* Odd-half intermediate.       */      *
*           short F0, F1, F2, F3;   /* Freq. domain results.        */      *
*           short F4, F5, F6, F7;   /* Freq. domain results.        */      *
*           short F0r,F1r,F2r,F3r;  /* Rounded, truncated results.  */      *
*           short F4r,F5r,F6r,F7r;  /* Rounded, truncated results.  */      *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Input and output pointers, loop control.            */      *
*           /* ---------------------------------------------------- */      *
*           unsigned i, j;                                                  *
*           short    *dct_io_ptr;                                           *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Outer vertical loop -- Process each 8x8 block.      */      *
*           /* ---------------------------------------------------- */      *
*           dct_io_ptr = dct_data;                                          *
*           for (i = 0; i < num_fdcts; i++)                                 *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Perform Vertical 1-D FDCT pass on columns       */      *
*               /*  within each block.                              */      *
*               /* ------------------------------------------------ */      *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Load the spatial-domain samples.            */      *
*                   /* -------------------------------------------- */      *
*                   f0 = dct_io_ptr[ 0];                                    *
*                   f1 = dct_io_ptr[ 8];                                    *
*                   f2 = dct_io_ptr[16];                                    *
*                   f3 = dct_io_ptr[24];                                    *
*                   f4 = dct_io_ptr[32];                                    *
*                   f5 = dct_io_ptr[40];                                    *
*                   f6 = dct_io_ptr[48];                                    *
*                   f7 = dct_io_ptr[56];                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 1: Separate into even and odd halves. */      *
*                   /* -------------------------------------------- */      *
*                   g0 = f0 + f7;               g1 = f1 + f6;               *
*                   h1 = f2 + f5;               h0 = f3 + f4;               *
*                   g3 = f2 - f5;               g2 = f3 - f4;               *
*                   h2 = f0 - f7;               h3 = f1 - f6;               *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 2                                     */      *
*                   /* -------------------------------------------- */      *
*                   p0 = g0 + h0;               r0 = g0 - h0;               *
*                   p1 = g1 + h1;               r1 = g1 - h1;               *
*                                                                           *
*                   q1a = g2 + g2;                                          *
*                   s1a = h2 + h2;                                          *
*                   q1  = (q1a * C4 + 0x8000) >> 16;                        *
*                   s1  = (s1a * C4 + 0x8000) >> 16;                        *
*                                                                           *
*                   s0 = h3 + g3;                                           *
*                   q0 = h3 - g3;                                           *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 3                                     */      *
*                   /* -------------------------------------------- */      *
*                   P0 = p0 + p1;                                           *
*                   P1 = p0 - p1;                                           *
*                   r0_= r0 + r0;                                           *
*                   r1_= r1 + r1;                                           *
*                   R1 = (C6 * r1_+ C2 * r0_+ 0x8000) >> 16;                *
*                   R0 = (C6 * r0_- C2 * r1_+ 0x8000) >> 16;                *
*                                                                           *
*                   Q1 = q1 + q0;               Q0 = q1 - q0;               *
*                   S1 = s1 + s0;               S0 = s1 - s0;               *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Stage 4                                     */      *
*                   /* -------------------------------------------- */      *
*                   F0 = P0;                    F4 = P1;                    *
*                   F2 = R1;                    F6 = R0;                    *
*                                                                           *
*                   F1 = (C7 * Q1 + C1 * S1 + 0x8000) >> 16;                *
*                   F7 = (C7 * S1 - C1 * Q1 + 0x8000) >> 16;                *
*                   F5 = (C3 * Q0 + C5 * S0 + 0x8000) >> 16;                *
*                   F3 = (C3 * S0 - C5 * Q0 + 0x8000) >> 16;                *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the frequency domain results.         */      *
*                   /* -------------------------------------------- */      *
*                   dct_io_ptr[ 0] = F0;                                    *
*                   dct_io_ptr[ 8] = F1;                                    *
*                   dct_io_ptr[16] = F2;                                    *
*                   dct_io_ptr[24] = F3;                                    *
*                   dct_io_ptr[32] = F4;                                    *
*                   dct_io_ptr[40] = F5;                                    *
*                   dct_io_ptr[48] = F6;                                    *
*                   dct_io_ptr[56] = F7;                                    *
*                                                                           *
*                   dct_io_ptr++;                                           *
*               }                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Update pointer to next 8x8 FDCT block.          */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr += 56;                                           *
*           }                                                               *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Perform Horizontal 1-D FDCT on each 8x8 block.      */      *
*           /* ---------------------------------------------------- */      *
*           dct_io_ptr = dct_data;                                          *
*           for (i = 0; i < 8 * num_fdcts; i++)                             *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Load the spatial-domain samples.                */      *
*               /* ------------------------------------------------ */      *
*               f0 = dct_io_ptr[0];                                         *
*               f1 = dct_io_ptr[1];                                         *
*               f2 = dct_io_ptr[2];                                         *
*               f3 = dct_io_ptr[3];                                         *
*               f4 = dct_io_ptr[4];                                         *
*               f5 = dct_io_ptr[5];                                         *
*               f6 = dct_io_ptr[6];                                         *
*               f7 = dct_io_ptr[7];                                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 1:  Separate into even and odd halves.    */      *
*               /* ------------------------------------------------ */      *
*               g0 = f0 + f7;               g1 = f1 + f6;                   *
*               h2 = f0 - f7;               h3 = f1 - f6;                   *
*               h1 = f2 + f5;               h0 = f3 + f4;                   *
*               g3 = f2 - f5;               g2 = f3 - f4;                   *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 2                                         */      *
*               /* ------------------------------------------------ */      *
*               p0 = g0 + h0 + 4;           p1 = g1 + h1;                   *
*               r0 = g0 - h0;               r1 = g1 - h1;                   *
*                                                                           *
*               q1a= (g2 * C4 + 0x8000) >> 16;                              *
*               s1a= (h2 * C4 + 0x8000) >> 16;                              *
*               q1 = q1a + q1a;                                             *
*               s1 = s1a + s1a;                                             *
*                                                                           *
*               s0 = h3 + g3;                                               *
*               q0 = h3 - g3;                                               *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 3                                         */      *
*               /* ------------------------------------------------ */      *
*               P0 = p0 + p1;                                               *
*               P1 = p0 - p1;                                               *
*               R1 = (c6 * r1 + c2 * r0 + 0x8000) >> 16;                    *
*               R0 = (c6 * r0 - c2 * r1 + 0x8000) >> 16;                    *
*                                                                           *
*               Q1 = q1 + q0;               Q0 = q1 - q0;                   *
*               S1 = s1 + s0;               S0 = s1 - s0;                   *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Stage 4                                         */      *
*               /* ------------------------------------------------ */      *
*               F0 = P0;                    F4 = P1;                        *
*               F2 = R1;                    F6 = R0;                        *
*                                                                           *
*               F1 = (c7 * Q1 + c1 * S1 + 0x8000) >> 16;                    *
*               F7 = (c7 * S1 - c1 * Q1 + 0x8000) >> 16;                    *
*               F5 = (c3 * Q0 + c5 * S0 + 0x8000) >> 16;                    *
*               F3 = (c3 * S0 - c5 * Q0 + 0x8000) >> 16;                    *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Round and truncate values.                      */      *
*               /*                                                  */      *
*               /*  Note: F0 and F4 have different rounding since   */      *
*               /*  no MPYs have been applied to either term.       */      *
*               /* ------------------------------------------------ */      *
*               F0r = F0 >>  3;                                             *
*               F1r = F1;                                                   *
*               F2r = F2;                                                   *
*               F3r = F3;                                                   *
*               F4r = F4 >>  3;                                             *
*               F5r = F5;                                                   *
*               F6r = F6;                                                   *
*               F7r = F7;                                                   *
*                                                                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Store the results                               */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr[0] = F0r;                                        *
*               dct_io_ptr[1] = F1r;                                        *
*               dct_io_ptr[2] = F2r;                                        *
*               dct_io_ptr[3] = F3r;                                        *
*               dct_io_ptr[4] = F4r;                                        *
*               dct_io_ptr[5] = F5r;                                        *
*               dct_io_ptr[6] = F6r;                                        *
*               dct_io_ptr[7] = F7r;                                        *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Update pointer to next FDCT row.                */      *
*               /* ------------------------------------------------ */      *
*               dct_io_ptr += 8;                                            *
*           }                                                               *
*                                                                           *
*           return;                                                         *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop nest in the vertical pass has been collapsed into a        *
*       single-level loop.  Both vertical and horizontal loops have         *
*       been software pipelined.                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*                                                                           *
*   NOTES                                                                   *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term becomes an even power of two for the butterflies which    *
*       calculate the terms "F0", "F4", "s0", and "q0".                     *
*                                                                           *
*   SOURCE                                                                  *
*       Chen FDCT.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_fdct_8x8"
        .global _IMG_fdct_8x8
_IMG_fdct_8x8   .cproc  A_dct_data,     B_num_dcts

; ============================ SYMBOLIC CONSTANTS ============================
        .asg            0x1F62,     cst_c1  ; Cosine term c1
        .asg            0x29CF,     cst_c2  ; Cosine term c2
        .asg            0x1A9B,     cst_c3  ; Cosine term c3
        .asg            0x11C7,     cst_c5  ; Cosine term c5
        .asg            0x1151,     cst_c6  ; Cosine term c6
        .asg            0x063E,     cst_c7  ; Cosine term c7
        .asg            0xFB15,     cst_C1  ; Cosine term C1
        .asg            0xA73D,     cst_C2  ; Cosine term C1
        .asg            0xD4DB,     cst_C3  ; Cosine term C1
        .asg            0xB505,     cst_C4  ; Cosine term C4
        .asg            0x8E3A,     cst_C5  ; Cosine term C1
        .asg            0x4546,     cst_C6  ; Cosine term C1
        .asg            0x31F1,     cst_C7  ; Cosine term C1
; ============================ SYMBOLIC REGISTERS ============================
        .reg            A_i_ptr,    B_o_ptr
        .reg            A_io_ptr,   B_io_ptr
        .reg            B_i,        B_iv,       B_ih
        .reg            A_C1C7,     B_C1C7
        .reg                        B_C2C6
        .reg            A_C3C5,     B_C3C5
        .reg            A_C4__,     B_C4__
        .reg            A___C4,     B___C4
        .reg            A_C5C3
        .reg            A_C6C2
        .reg                        B_C7C1
        .reg            A_c1c7
        .reg            A_c2c6
        .reg            A_c3c5
        .reg            A_c5c3
        .reg            A_c6c2
        .reg            A_c7c1
        .reg            B_f6f7:B_f4f5
        .reg            B_f2f3:B_f0f1
        .reg            B_F7F6:B_F5F4
        .reg            B_F3F2:B_F1F0
        .reg            A_f7f6:A_f5f4
        .reg            A_f3f2:A_f1f0
        .reg            A_F7F6:A_F5F4
        .reg            A_F3F2:A_F1F0
        .reg            B_fix
        ;.reg            A_fix
        .reg            B_fix_
        .reg            B_f1f1
        .reg            B_f2f2
        .reg            B_f5f5
        .reg            B_f6f6
        .reg            B_g1g1
        .reg            B_h3h3
        .reg            B_h1h1
        .reg            B_g3g3
        .reg            B_s0s0
        .reg            B_q0q0
        .reg            B_p1p1
        .reg            B_r1r1
        .reg            B_r1r1_
        .reg            B_r1r0_
        .reg            B_r0r1_
        .reg            B_g2h2
        .reg            Bxs0q0
        .reg            B_q1
        .reg            B_s1
        .reg            B_s1q1
        .reg            B_F2
        .reg            B_F6
        .reg            B_S1Q1
        .reg            B_S0Q0
        .reg            B_F1
        .reg            B_F7
        .reg            B_F3
        .reg            B_F5
        .reg            B_F1F1
        .reg            B_F3F3
        .reg            B_F5F5
        .reg            B_F7F7
        .reg            B_f7f6
        .reg            B_f3f2
        .reg            B_g0g1
        .reg            B_h2h3
        .reg            B_h0h1
        .reg            B_g2g3
        .reg            B_p0p1
        .reg            B_r0r1
        .reg            B_q1_
        .reg            B_s1_
        .reg            B_s1q1_
        .reg            B_s0
        .reg            B_q0
        .reg            B_s0q0
        .reg            B_F0F0
        .reg            B_F4F4
        .reg            A_fix_
        .reg            A_f0f0
        .reg            A_f4f4
        .reg            A_f7f7
        .reg            A_f3f3
        .reg            A_g0g0
        .reg            A_h2h2
        .reg            A_h0h0
        .reg            A_g2g2
        .reg            A_p0p0
        .reg            A_r0r0
        .reg            A_r0r0_
        .reg            A_r0r1_
        .reg            A_g2g2_
        .reg            A_h2h2_
        .reg            Axg2h2
        .reg            A_g2h2
        .reg            A_q1
        .reg            A_s1
        .reg            A_s1q1
        .reg            A_F2
        .reg            A_F6
        .reg            A_S1Q1
        .reg            A_S0Q0
        .reg            A_F1
        .reg            A_F7
        .reg            A_F3
        .reg            A_F5
        .reg            A_s0s0
        .reg            A_q0q0
        .reg            Axs0q0
        .reg            A_F0F0
        .reg            A_F4F4
        .reg            A_F2F2
        .reg            A_F6F6
        .reg            A_dc_rnd
        .reg            A_f4f5
        .reg            A_f0f1
        .reg            A_g0g1
        .reg            A_h2h3
        .reg            A_h0h1
        .reg            A_g2g3
        .reg            A_p0p1
        .reg            A_r0r1
        .reg            A_q1_
        .reg            A_s1_
        .reg            A_s1q1_
        .reg            A_s0
        .reg            A_q0
        .reg            A_s0q0
        .reg            A_p0p0_
        .reg            A_p1p1
        .reg            A_F0F0_
        .reg            A_F4F4_

; =========================== MEMORY DEPENDENCIES ============================
        .no_mdep                        ; Assume "don't alias" by default.
        .mdep           s0, l0          ;\
        .mdep           s1, l0          ; |
        .mdep           s2, l0          ; |
        .mdep           s3, l0          ; |__ Final v_loop stores to first
        .mdep           s4, l0          ; |   h_loop load.
        .mdep           s5, l0          ; |
        .mdep           s6, l0          ; |
        .mdep           s7, l0          ;/
        .mdep           s0, l1          ;\
        .mdep           s1, l1          ; |
        .mdep           s2, l1          ; |
        .mdep           s3, l1          ; |__ Final v_loop stores to second
        .mdep           s4, l1          ; |   h_loop load.
        .mdep           s5, l1          ; |
        .mdep           s6, l1          ; |
        .mdep           s7, l1          ;/
        .mdep           s0, l2          ;\
        .mdep           s1, l2          ; |
        .mdep           s2, l2          ; |
        .mdep           s3, l2          ; |__ Final v_loop stores to third
        .mdep           s4, l2          ; |   h_loop load.
        .mdep           s5, l2          ; |
        .mdep           s6, l2          ; |
        .mdep           s7, l2          ;/
        .mdep           s0, l3          ;\
        .mdep           s1, l3          ; |
        .mdep           s2, l3          ; |
        .mdep           s3, l3          ; |__ Final v_loop stores to fourth
        .mdep           s4, l3          ; |   h_loop load.
        .mdep           s5, l3          ; |
        .mdep           s6, l3          ; |
        .mdep           s7, l3          ;/
; ============================================================================

        SHL     .2      B_num_dcts, 2,          B_i
 [!B_i] B               abort
        SUB     .2      B_i,        2,          B_iv
        MV      .2      B_iv,       B_ih

        ADDAW   .1      A_dct_data, 12,         A_i_ptr
        MV      .2X     A_i_ptr,                B_o_ptr

        ZERO    .1      A_C4__                                  ; set up cst 0

        MVKLH   .1      cst_C4,     A_C4__                      ; const C4
        MV      .2X     A_i_ptr,    B_o_ptr

        MVKL    .1      cst_C5,     A_C3C5                      ; const C5

        MVKL    .1      cst_C2,     A_C6C2                      ; const C2

        MVKLH   .1      cst_C6,     A_C6C2                      ; const C6
        MVKL    .2      cst_C7,     B_C1C7                      ; const C7
        SWAP2   .1      A_C4__,     A___C4                      ; swapped pair

        MVKLH   .2      cst_C1,     B_C1C7                      ; const C1
        MVKLH   .1      cst_C3,     A_C3C5                      ; const C3

        MVKL    .2      0x0101011D, B_fix                       ; ptr fix cst.
        ROTL    .2X     A_C6C2,     16,         B_C2C6          ; swapped pair
        ROTL    .1      A_C3C5,     16,         A_C5C3          ; swapped pair

        MVKH    .2      0x0101011D, B_fix                       ; ptr fix cst.
        SWAP2   .2      B_C1C7,     B_C7C1                      ; swapped pair
        ROTL    .2X     A_C3C5,     0,          B_C3C5          ; swapped pair
        ROTL    .1X     B_C1C7,     0,          A_C1C7          ; swapped pair

        .mptr           A_i_ptr,    dct_data + 64,  4
        .mptr           B_o_ptr,    dct_data + 64,  4

        ;  Vertical loop
v_loop: .trip   4
        SHR     .1X     B_fix,      24,         A_fix_
        SHR     .2      B_fix,      24,         B_fix_
        ROTL    .2      B_fix,      8,          B_fix

        LDW     .D1T1   *-A_i_ptr  [12],        A_f0f0
        LDW     .D1T2   *-A_i_ptr  [ 8],        B_f1f1
        LDW     .D1T2   *-A_i_ptr  [ 4],        B_f2f2
        LDW     .D1T1   *+A_i_ptr  [ 4],        A_f4f4
        LDW     .D1T2   *+A_i_ptr  [ 8],        B_f5f5
        LDW     .D1T2   *+A_i_ptr  [12],        B_f6f6
        LDW     .D1T1   *+A_i_ptr  [16],        A_f7f7
        LDW     .D1T1   * A_i_ptr++[A_fix_],    A_f3f3

; First butterfly, SIMD'd across datapaths

        ADD2    .1      A_f0f0,     A_f7f7,     A_g0g0
        ADD2    .2      B_f1f1,     B_f6f6,     B_g1g1
        ADD2    .2      B_f2f2,     B_f5f5,     B_h1h1
        ADD2    .1      A_f3f3,     A_f4f4,     A_h0h0
        SUB2    .1      A_f3f3,     A_f4f4,     A_g2g2
        SUB2    .2      B_f2f2,     B_f5f5,     B_g3g3
        SUB2    .2      B_f1f1,     B_f6f6,     B_h3h3
        SUB2    .1      A_f0f0,     A_f7f7,     A_h2h2

        ADD2    .2      B_h3h3,     B_g3g3,     B_s0s0
        SUB2    .2      B_h3h3,     B_g3g3,     B_q0q0

        ADD2    .1      A_g0g0,     A_h0h0,     A_p0p0
        ADD2    .2      B_g1g1,     B_h1h1,     B_p1p1
        SUB2    .2      B_g1g1,     B_h1h1,     B_r1r1
        SUB2    .1      A_g0g0,     A_h0h0,     A_r0r0

        ADD2    .2      B_r1r1,     B_r1r1,     B_r1r1_
        ADD2    .1      A_r0r0,     A_r0r0,     A_r0r0_

        PACKH2  .1X     A_r0r0_,    B_r1r1_,    A_r0r1_
        PACK2   .2X     B_r1r1_,    A_r0r0_,    B_r1r0_

        ADD2    .1      A_g2g2,     A_g2g2,     A_g2g2_
        ADD2    .1      A_h2h2,     A_h2h2,     A_h2h2_
        PACKH2  .1      A_g2g2_,    A_h2h2_,    A_g2h2
        PACK2   .1      A_g2g2_,    A_h2h2_,    Axg2h2

        ROTL    .2      B_r1r0_,    16,         B_r0r1_
        MV      .2X     Axg2h2,     B_g2h2


; A-datapath copy

        ;  Stage 2
        DOTPRSU2.1      A_g2h2,     A_C4__,     A_q1
        DOTPRSU2.1      A_g2h2,     A___C4,     A_s1
        PACK2   .1      A_s1,       A_q1,       A_s1q1

        PACKH2  .2      B_s0s0,     B_q0q0,     Bxs0q0

        ;  Stage 3
        DOTPRSU2.1X     A_r0r1_,    B_C2C6,     A_F2
        DOTPNRSU2.1     A_r0r1_,    A_C6C2,     A_F6

        ADD2    .1X     A_s1q1,     Bxs0q0,     A_S1Q1
        SUB2    .1X     A_s1q1,     Bxs0q0,     A_S0Q0

        ;  Stage 4
        DOTPRSU2.1      A_S1Q1,     A_C1C7,     A_F1
        DOTPNRSU2.1X    A_S1Q1,     B_C7C1,     A_F7
        DOTPNRSU2.1     A_S0Q0,     A_C3C5,     A_F3
        DOTPRSU2.1      A_S0Q0,     A_C5C3,     A_F5

; B-datapath copy
        ;  Stage 1

        ;  Stage 2

        DOTPRSU2.2X     B_g2h2,     A_C4__,     B_q1
        DOTPRSU2.2X     B_g2h2,     A___C4,     B_s1
        PACK2   .2      B_s1,       B_q1,       B_s1q1

        PACK2   .2      B_s0s0,     B_q0q0,     B_s0q0

        ;  Stage 3
        DOTPRSU2.2      B_r0r1_,    B_C2C6,     B_F2
        DOTPNRSU2.2X    B_r0r1_,    A_C6C2,     B_F6

        ADD2    .2      B_s1q1,     B_s0q0,     B_S1Q1
        SUB2    .2      B_s1q1,     B_s0q0,     B_S0Q0

        ;  Stage 4
        DOTPRSU2.2      B_S1Q1,     B_C1C7,     B_F1
        DOTPNRSU2.2     B_S1Q1,     B_C7C1,     B_F7
        DOTPNRSU2.2     B_S0Q0,     B_C3C5,     B_F3
        DOTPRSU2.2X     B_S0Q0,     A_C5C3,     B_F5


; Recombine
        ADD2    .1X     A_p0p0,     B_p1p1,     A_F0F0
        SUB2    .1X     A_p0p0,     B_p1p1,     A_F4F4

        PACK2   .2X     B_F1,       A_F1,       B_F1F1
        PACK2   .1X     A_F2,       B_F2,       A_F2F2
        PACK2   .2X     B_F3,       A_F3,       B_F3F3
        PACK2   .2X     B_F5,       A_F5,       B_F5F5
        PACK2   .1X     A_F6,       B_F6,       A_F6F6
        PACK2   .2X     B_F7,       A_F7,       B_F7F7

        STW     .D2T1   A_F0F0,     *-B_o_ptr  [12]{s0}
        STW     .D2T2   B_F1F1,     *-B_o_ptr  [ 8]{s1}
        STW     .D2T1   A_F2F2,     *-B_o_ptr  [ 4]{s2}
        STW     .D2T1   A_F4F4,     *+B_o_ptr  [ 4]{s3}
        STW     .D2T2   B_F5F5,     *+B_o_ptr  [ 8]{s4}
        STW     .D2T1   A_F6F6,     *+B_o_ptr  [12]{s5}
        STW     .D2T2   B_F7F7,     *+B_o_ptr  [16]{s6}
        STW     .D2T2   B_F3F3,     * B_o_ptr++[B_fix_]{s7}

        BDEC    .2      v_loop,     B_iv
******************************************************************************

        SUBAW   .2      B_o_ptr,    16,         B_io_ptr
        ADD     .1X     B_io_ptr,   -16,        A_io_ptr
        MV      .2X     A_C4__,     B_C4__

        MVK     .1      4,          A_dc_rnd
        PACK2   .1      A_dc_rnd,   A_dc_rnd,   A_dc_rnd    ; 0x00040004

        SHRU2   .1      A_C6C2,     2,          A_c6c2
        SHRU2   .1      A_C5C3,     3,          A_c5c3
        SHRU2   .1      A_C3C5,     3,          A_c3c5
        SHRU2   .1      A_C1C7,     3,          A_c1c7
        ROTL    .1      A_c1c7,     16,         A_c7c1
        ROTL    .1      A_c6c2,     16,         A_c2c6

        ; Horiz loop

        .mptr           A_io_ptr,   dct_data + 120,  -32
        .mptr           B_io_ptr,   dct_data + 112,  -32
h_loop: .trip   4

; A-datapath copy
        LDDW    .D1T1   *+A_io_ptr  [1]{l0},    A_f7f6:A_f5f4
        LDDW    .D1T1   * A_io_ptr--[4]{l1},    A_f3f2:A_f1f0
        ROTL    .1      A_f5f4,     16,         A_f4f5
        SWAP2   .1      A_f1f0,     A_f0f1

        ;  Stage 1
        ADD2    .1      A_f0f1,     A_f7f6,     A_g0g1
        SUB2    .1      A_f0f1,     A_f7f6,     A_h2h3
        ADD2    .1      A_f3f2,     A_f4f5,     A_h0h1
        SUB2    .1      A_f3f2,     A_f4f5,     A_g2g3

        ;  Stage 2
        ADD2    .1      A_g0g1,     A_h0h1,     A_p0p1
        SUB2    .1      A_g0g1,     A_h0h1,     A_r0r1

        DOTPRSU2.1      A_g2g3,     A_C4__,     A_q1_
        DOTPRSU2.1      A_h2h3,     A_C4__,     A_s1_
        PACK2   .1      A_s1_,      A_q1_,      A_s1q1_
        ADD2    .1      A_s1q1_,    A_s1q1_,    A_s1q1

        ADD     .1      A_h2h3,     A_g2g3,     A_s0
        SUB     .1      A_h2h3,     A_g2g3,     A_q0
        PACK2   .1      A_s0,       A_q0,       A_s0q0

        ;  Stage 3
        DOTPRSU2.1      A_r0r1,     A_c2c6,     A_F2
        DOTPNRSU2.1     A_r0r1,     A_c6c2,     A_F6

        ADD2    .1      A_s1q1,     A_s0q0,     A_S1Q1
        SUB2    .1      A_s1q1,     A_s0q0,     A_S0Q0

        ;  Stage 4
        DOTPRSU2 .1     A_S1Q1,     A_c1c7,     A_F1
        DOTPNRSU2.1     A_S1Q1,     A_c7c1,     A_F7
        DOTPNRSU2.1     A_S0Q0,     A_c3c5,     A_F3
        DOTPRSU2 .1     A_S0Q0,     A_c5c3,     A_F5

; B-datapath copy
        LDDW    .D2T2   *+B_io_ptr  [1]{l2},    B_f6f7:B_f4f5
        LDDW    .D2T2   * B_io_ptr--[4]{l3},    B_f2f3:B_f0f1
        ROTL    .2      B_f6f7,     16,         B_f7f6
        SWAP2   .2      B_f2f3,     B_f3f2

        ;  Stage 1
        ADD2    .2      B_f0f1,     B_f7f6,     B_g0g1
        SUB2    .2      B_f0f1,     B_f7f6,     B_h2h3
        ADD2    .2      B_f3f2,     B_f4f5,     B_h0h1
        SUB2    .2      B_f3f2,     B_f4f5,     B_g2g3

        ;  Stage 2
        ADD2    .2      B_g0g1,     B_h0h1,     B_p0p1
        SUB2    .2      B_g0g1,     B_h0h1,     B_r0r1

        DOTPRSU2.2      B_g2g3,     B_C4__,     B_q1_
        DOTPRSU2.2      B_h2h3,     B_C4__,     B_s1_
        PACK2   .2      B_s1_,      B_q1_,      B_s1q1_
        ADD2    .2      B_s1q1_,    B_s1q1_,    B_s1q1

        ADD     .2      B_h2h3,     B_g2g3,     B_s0
        SUB     .2      B_h2h3,     B_g2g3,     B_q0
        PACK2   .2      B_s0,       B_q0,       B_s0q0


        ;  Stage 3
        DOTPRSU2.2X     B_r0r1,     A_c2c6,     B_F2
        DOTPNRSU2.2X    B_r0r1,     A_c6c2,     B_F6

        ADD2    .2      B_s1q1,     B_s0q0,     B_S1Q1
        SUB2    .2      B_s1q1,     B_s0q0,     B_S0Q0

        ;  Stage 4
        DOTPRSU2 .2X    B_S1Q1,     A_c1c7,     B_F1
        DOTPNRSU2.2X    B_S1Q1,     A_c7c1,     B_F7
        DOTPNRSU2.2X    B_S0Q0,     A_c3c5,     B_F3
        DOTPRSU2 .2X    B_S0Q0,     A_c5c3,     B_F5


; F0, F4 terms straddle datapaths.
        PACKH2  .1X     A_p0p1,     B_p0p1,     A_p0p0_
        PACK2   .1X     A_p0p1,     B_p0p1,     A_p1p1
        ADD2    .1      A_p0p0_,    A_dc_rnd,   A_p0p0
        ADD2    .1      A_p0p0,     A_p1p1,     A_F0F0_
        SUB2    .1      A_p0p0,     A_p1p1,     A_F4F4_
        SHR2    .2X     A_F0F0_,    3,          B_F0F0
        SHR2    .2X     A_F4F4_,    3,          B_F4F4

; Store A-datapath
        PACK2   .1      A_F7,       A_F6,       A_F7F6
        PACKLH2 .1X     A_F5,       B_F4F4,     A_F5F4
        PACK2   .1      A_F3,       A_F2,       A_F3F2
        PACKLH2 .1X     A_F1,       B_F0F0,     A_F1F0

        STDW    .D1T1   A_F7F6:A_F5F4,          *+A_io_ptr[5]
        STDW    .D1T1   A_F3F2:A_F1F0,          *+A_io_ptr[4]

; Store B-datapath
        PACK2   .2      B_F7,       B_F6,       B_F7F6
        PACK2   .2      B_F5,       B_F4F4,     B_F5F4
        PACK2   .2      B_F3,       B_F2,       B_F3F2
        PACK2   .2      B_F1,       B_F0F0,     B_F1F0

        STDW    .D2T2   B_F7F6:B_F5F4,          *+B_io_ptr[5]
        STDW    .D2T2   B_F3F2:B_F1F0,          *+B_io_ptr[4]

        BDEC    .2      h_loop,     B_ih
******************************************************************************
abort:
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_fdct_8x8.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
histogram.sa/   1066928952  0     0     0       24990     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Mon Sep 10 11:45:05 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_histogram                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       26-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_histogram(unsigned char * image, int  n, int  accumulate,  *
*                         unsigned short * t_hist, unsigned short * hist);  *
*                                                                           *
*               image      =  input image data                              *
*               n          =  number of points                              *
*               accumulate =  defines add/subtract from existing            *
*               IMG_histogram: takes values 1, -1                           *
*               t_hist     =  temporary IMG_histogram bins (1024)           *
*               hist       =  running IMG_histogram bins (256)              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code takes a IMG_histogram of an array of n, 8 bit inputs. It  *
*       returns the IMG_histogram of 256 bins at 16 bit precision. It can   *
*       either add  or subtract to an existing IMG_histogram, using the     *
*       'accumulate' control.                                               *
*                                                                           *
*       It requires some temporary storage for 4 temporary histograms,      *
*       which are later summed together.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       It is assumed that the temporary array of data, t_hist is           *
*       initialised to zero. The input array of image data must be          *
*       aligned to a 4 byte boundary and n must be a multiple of 8. The     *
*       maximum number of pixels that can be profiled in each bin is        *
*       65535 in the main IMG_histogram and the maximum n is 262143.        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur in this code in the optimized        *
*       forms of hand assembly and serial assembly.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       This code operates on four interleaved IMG_histogram bins. The loop *
*       is divided into two halves. The even half operates on even          *
*       words full of pixels and the odd half operates on odd words.        *
*       Both halves operate on the same 4 IMG_histogram bins. This          *
*       introduces a memory dependency which ordinarily would degrade       *
*       performance. To break the memory depenencies, the two halves        *
*       forward their results to each other.                                *
*                                                                           *
*       Exact memory access ordering obviates the need to predicate         *
*       stores The algorithm is ordered as follows:                         *
*                                                                           *
*       1.  Load from IMG_histogram for even half                           *
*       2.  Store odd_bin to IMG_histogram for odd half (previous itn.)     *
*       3.  if data_even == previous data_odd increment even_bin by 2       *
*           else increment even_bin by 1, forward to odd                    *
*       4.  Load from IMG_histogram for odd half (current itn.)             *
*       5.  Store even_bin to IMG_histogram for even half                   *
*       6.  if data_odd == previous data_even increment odd_bin by 2        *
*           else increment odd_bin by 1, forward to even                    *
*       7.  goto 1.                                                         *
*                                                                           *
*       With this particular ordering, forwarding is necessary between      *
*       even/odd halves when pixels in adjacent halves need to be           *
*       placed in the same bin.                                             *
*                                                                           *
*       The store is never predicated and occurs speculatively              *
*       as it will be overwritten by the next value containing the          *
*       extra forwarded value.                                              *
*                                                                           *
*       The four histograms are interleaved with each bin spaced four       *
*       half-words apart and each IMG_histogram starting in a different     *
*       memory bank. This allows the four IMG_histogram accesses to proceed *
*       in any order without worrying about bank conflicts.  The            *
*       diagram below illustrates this:  (addresses are halfword            *
*       offsets)                                                            *
*                                                                           *
*           0       1       2       3       4       5       6   ...         *
*       | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...         *
*       | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...         *
*                                                                           *
*       These are then summed together at the end in blocks of 4            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_histogram"
        .global _IMG_histogram
_IMG_histogram: .cproc  A_img, B_n, A_accumulate, B_t_hist, A_hist 
*=========================== memory dependencies ==============================*
    .no_mdep       ; memory dependencies
    .mdep  x0, y0  ; dependency from 1st STH to next LDH
    .mdep  y0, z0  ; dependency from 1st LDH to next STH
    .mdep  z0, w0  ; dependency from 2nd STH to next LDH
    .mdep  w0, x0  ; dependency from 2nd LDH back to 1st STH
    .mdep  y0, x0  ; back dependency from 1st STH to next LDH
    .mdep  z0, y0  ; back dependency from 1st LDH to next STH
    .mdep  w0, z0  ; back dependency from 2nd STH to next LDH
    .mdep  x0, w0  ; back dependency from 2nd LDH back to 1st STH

    .mdep  x1, y1  ; same for thread 1
    .mdep  y1, z1
    .mdep  z1, w1
    .mdep  w1, x1
    .mdep  y1, x1
    .mdep  z1, y1
    .mdep  w1, z1
    .mdep  x1, w1

    .mdep  x2, y2  ; same for thread 2
    .mdep  y2, z2
    .mdep  z2, w2
    .mdep  w2, x2
    .mdep  y2, x2
    .mdep  z2, y2
    .mdep  w2, z2
    .mdep  x2, w2

    .mdep  x3, y3  ; same for thread 3
    .mdep  y3, z3
    .mdep  z3, w3
    .mdep  w3, x3
    .mdep  y3, x3
    .mdep  z3, y3
    .mdep  w3, z3
    .mdep  x3, w3


    .mdep  w0, _y0
    .mdep  w1, _y1
    .mdep  w2, _y2
    .mdep  w3, _y3

    .mdep  w0, i0
    .mdep  w0, i1
    .mdep  w0, i2
    .mdep  w0, i3
    .mdep  w1, i0
    .mdep  w1, i1
    .mdep  w1, i2
    .mdep  w1, i3
    .mdep  w2, i0
    .mdep  w2, i1
    .mdep  w2, i2
    .mdep  w2, i3
    .mdep  w3, i0
    .mdep  w3, i1
    .mdep  w3, i2
    .mdep  w3, i3

    .mdep  _y0, i0
    .mdep  _y0, i1
    .mdep  _y0, i2
    .mdep  _y0, i3
    .mdep  _y1, i0
    .mdep  _y1, i1
    .mdep  _y1, i2
    .mdep  _y1, i3
    .mdep  _y2, i0
    .mdep  _y2, i1
    .mdep  _y2, i2
    .mdep  _y2, i3
    .mdep  _y3, i0
    .mdep  _y3, i1
    .mdep  _y3, i2
    .mdep  _y3, i3

    .mdep  _x0, w0
    .mdep  _x1, w1
    .mdep  _x2, w2
    .mdep  _x3, w3
    .mdep  _x0, y0
    .mdep  _x1, y1
    .mdep  _x2, y2
    .mdep  _x3, y3
*========================= register defs ======================================*
;   .reg   A_img   ; pointer to even words in image
    .reg   B_img   ; pointer to odd words in image
    .reg   A_pix   ; 4 packed even pixels
    .reg   B_pix   ; 4 packed odd pixels
    .reg   A_hst0  ; pointer to interleaved IMG_histogram 0
    .reg   A_hst1  ; pointer to interleaved IMG_histogram 1
    .reg   B_hst2  ; pointer to interleaved IMG_histogram 2
    .reg   B_hst3  ; pointer to interleaved IMG_histogram 3

    .reg   A_px0e  ; pixel 0 in "even" half of IMG_histogram process
    .reg   A_px1e  ; pixel 1 in "even" half of IMG_histogram process
    .reg   A_px2e  ; pixel 2 in "even" half of IMG_histogram process
    .reg   B_px3e  ; pixel 3 in "even" half of IMG_histogram process
    .reg   A_bn0e  ; bin for pixel 0 in "even" half of hist proc
    .reg   A_bn1e  ; bin for pixel 1 in "even" half of hist process
    .reg   B_bn2e  ; bin for pixel 2 in "even" half of hist process
    .reg   B_bn3e  ; bin for pixel 3 in "even" half of hist process
    .reg   A_bc0e  ; bin copy for pixel 0 in "even" half of hist process
    .reg   A_bc1e  ; bin copy for pixel 1 in "even" half of hist process
    .reg   B_bc2e  ; bin copy for pixel 2 in "even" half of hist process
    .reg   B_bc3e  ; bin copy for pixel 3 in "even" half of hist process
    .reg   A_eq0e  ; equality detection for hist 0 odd->even forwarding
    .reg   A_eq1e  ; equality detection for hist 1 odd->even forwarding
    .reg   B_eq2e  ; equality detection for hist 2 odd->even forwarding
    .reg   B_eq3e  ; equality detection for hist 3 odd->even forwarding
    .reg   A_hs0e  ; hist 0 value for "even" half
    .reg   A_hs1e  ; hist 1 value for "even" half
    .reg   B_hs2e  ; hist 2 value for "even" half
    .reg   B_hs3e  ; hist 3 value for "even" half
    .reg   A_hf0e  ; hist 0 value for "even" half with forwarding added
    .reg   A_hf1e  ; hist 1 value for "even" half with forwarding added
    .reg   B_hf2e  ; hist 2 value for "even" half with forwarding added
    .reg   B_hf3e  ; hist 3 value for "even" half with forwarding added
    .reg   A_ha0e  ; hist 0 value for "even" half after accumulation
    .reg   A_ha1e  ; hist 1 value for "even" half after accumulation
    .reg   B_ha2e  ; hist 2 value for "even" half after accumulation
    .reg   B_ha3e  ; hist 3 value for "even" half after accumulation

    .reg   B_px0o  ; pixel 0 in "odd" half of IMG_histogram process
    .reg   B_px1o  ; pixel 1 in "odd" half of IMG_histogram process
    .reg   B_px2o  ; pixel 2 in "odd" half of IMG_histogram process
    .reg   B_px3o  ; pixel 3 in "odd" half of IMG_histogram process
    .reg   A_bn0o  ; bin for pixel 0 in "odd" half of hist process
    .reg   A_bn1o  ; bin for pixel 1 in "odd" half of hist process
    .reg   B_bn2o  ; bin for pixel 2 in "odd" half of hist process
    .reg   B_bn3o  ; bin for pixel 3 in "odd" half of hist process
    .reg   A_bc0o  ; bin copy for pixel 0 in "odd" half of hist process
    .reg   A_bc1o  ; bin copy for pixel 1 in "odd" half of hist process
    .reg   B_bc2o  ; bin copy for pixel 2 in "odd" half of hist process
    .reg   B_bc3o  ; bin copy for pixel 3 in "odd" half of hist process
    .reg   A_eq0o  ; equality detection for hist 0 even->odd forwarding
    .reg   A_eq1o  ; equality detection for hist 1 even->odd forwarding
    .reg   B_eq2o  ; equality detection for hist 2 even->odd forwarding
    .reg   B_eq3o  ; equality detection for hist 3 even->odd forwarding
    .reg   A_hs0o  ; hist 0 value for "odd" half
    .reg   A_hs1o  ; hist 1 value for "odd" half
    .reg   B_hs2o  ; hist 2 value for "odd" half
    .reg   B_hs3o  ; hist 3 value for "odd" half
    .reg   A_hf0o  ; hist 0 value for "odd" half with forwarding added
    .reg   A_hf1o  ; hist 1 value for "odd" half with forwarding added
    .reg   B_hf2o  ; hist 2 value for "odd" half with forwarding added
    .reg   B_hf3o  ; hist 3 value for "odd" half with forwarding added
    .reg   A_ha0o  ; hist 0 value for "odd" half after accumulation
    .reg   A_ha1o  ; hist 1 value for "odd" half after accumulation
    .reg   B_ha2o  ; hist 2 value for "odd" half after accumulation
    .reg   B_ha3o  ; hist 3 value for "odd" half after accumulation

    .reg   A_i     ; loop counter
    .reg   B_hist_in_o              ; pntr to odd IMG_histogram addresses
    .reg   A_hist_in_e              ; pntr to even IMG_histogram addresses
    .reg   B_hist                   ; total hist ptnr read

    .reg   B_new_bin32              ; tmp for cross path balancing
    .reg   A_new_bin32:A_new_bin10  ; main bin plus sub bins
    .reg   A_sum10, B_sum32         ; 2 bin sums
    .reg   A_sum0, A_sum1           ; sub sums
    .reg   B_sum2, B_sum3           ; sub sums
    .reg   B_sum7654, A_sum3210     ; sums of 4 sub bins
    .reg   B_sumfedc, A_sumba98     ; sums of 4 sub bins
    .reg   B_main_bin32:B_main_bin10; 4 main bins
    .reg   A_1010, B_1010           ; constant to sum together contents
    .reg   A_bin32:A_bin10          ; 4 bins for bin 4*i
    .reg   B_bin76:B_bin54          ; 4 bins for bin 4*i+1
    .reg   A_binba:A_bin98          ; 4 bins for bin 4*i+2
    .reg   B_binfe:B_bindc          ; 4 bins for bin 4*i+3
*==============================================================================*
        MV   .1    B_n,      A_i
        ADD  .2X   A_img,    4,   B_img
        MV   .1    B_t_hist,      A_hst0
        ADD  .1X   B_t_hist, 2,   A_hst1
        ADD  .2    B_t_hist, 4,   B_hst2
        ADD  .2    B_t_hist, 6,   B_hst3

        LDH  .D1T1 *A_hst0[1],           A_ha0o   ;
        LDH  .D1T1 *A_hst1[1],           A_ha1o   ;
        LDH  .D2T2 *B_hst2[1],           B_ha2o   ;
        LDH  .D2T2 *B_hst3[1],           B_ha3o   ;
        MVK  .1    1,        A_bc0o
        MVK  .1    1,        A_bc1o
        MVK  .2    1,        B_bc2o
        MVK  .2    1,        B_bc3o

        .mptr A_img,   a+0, 8 ;bank 0: stride 2 words
        .mptr B_img,   a+4, 8 ;bank 1: stride 2 words

        .mptr A_hist0, h+0, 0 ;bank 0 lo: stride 0 shorts
        .mptr A_hist1, h+2, 0 ;bank 0 hi: stride 0 shorts
        .mptr B_hist2, h+4, 0 ;bank 1 lo: stride 0 shorts
        .mptr B_hist3, h+6, 0 ;bank 1 hi: stride 0 shorts
LOOP_H: .trip 32
        LDW  .D1T1 *A_img++[2], A_pix            ;@80 Load even-word pixels
        EXTU .1    A_pix,    24, 24,   A_px0e    ; Extract pixel 0
        MPY  .1    4,        A_px0e,   A_bn0e    ; Set offset into hist0
        EXTU .1    A_pix,    16, 24,   A_px1e    ; Extract pixel 1
        MPY  .1    4,        A_px1e,   A_bn1e    ; Set offset into hist1
        EXTU .1    A_pix,    8, 24,    A_px2e    ; Extract pixel 2
        MPY  .2X   4,        A_px2e,   B_bn2e    ; Set offset into hist2
        SHRU .2X   A_pix,    24,       B_px3e    ; Extract pixel 3
        MPY  .2    4,        B_px3e,   B_bn3e    ; Set offset into hist3

        CMPEQ.1    A_bn0e,   A_bc0o,   A_eq0e    ; Odd->Even fwd comp 0
        CMPEQ.1    A_bn1e,   A_bc1o,   A_eq1e    ; Odd->Even fwd comp 1
        CMPEQ.2    B_bn2e,   B_bc2o,   B_eq2e    ; Odd->Even fwd comp 2
        CMPEQ.2    B_bn3e,   B_bc3o,   B_eq3e    ; Odd->Even fwd comp 3

        LDH  .D1T1 *A_hst0[A_bn0e]{x0}, A_hs0e   ;@10  Load from hist0
        LDH  .D1T1 *A_hst1[A_bn1e]{x1}, A_hs1e   ;@14  Load from hist1
        LDH  .D2T2 *B_hst2[B_bn2e]{x2}, B_hs2e   ;@18  Load from hist2
        LDH  .D2T2 *B_hst3[B_bn3e]{x3}, B_hs3e   ;@1C  Load from hist3

        STH  .D1T1 A_ha0o, *A_hst0[A_bc0o]{y0}   ;@10  Store odd hist0
        STH  .D1T1 A_ha1o, *A_hst1[A_bc1o]{y1}   ;@14  Store odd hist1
        STH  .D2T2 B_ha2o, *B_hst2[B_bc2o]{y2}   ;@18  Store odd hist2
        STH  .D2T2 B_ha3o, *B_hst3[B_bc3o]{y3}   ;@1C  Store odd hist3

        ADD  .1    A_hs0e,   A_eq0e,   A_hf0e    ; forwarding for hist0
        ADD  .1    A_hs1e,   A_eq1e,   A_hf1e    ; forwarding for hist1
        ADD  .2    B_hs2e,   B_eq2e,   B_hf2e    ; forwarding for hist2
        ADD  .2    B_hs3e,   B_eq3e,   B_hf3e    ; forwarding for hist3
        ADD  .1    A_hf0e,   1,        A_ha0e    ; Accumulate for hist0
        ADD  .1    A_hf1e,   1,        A_ha1e    ; Accumulate for hist1
        ADD  .2    B_hf2e,   1,        B_ha2e    ; Accumulate for hist2
        ADD  .2    B_hf3e,   1,        B_ha3e    ; Accumulate for hist3

        MPY  .1    1,        A_bn0e,   A_bc0e    ; copy of bin 0 (l2l)
        MPY  .1    1,        A_bn1e,   A_bc1e    ; copy of bin 1 (l2l)
        MPY  .2    1,        B_bn2e,   B_bc2e    ; copy of bin 2 (l2l)
        MPY  .2    1,        B_bn3e,   B_bc3e    ; copy of bin 3 (l2l)

        LDW  .D2T2 *B_img++[2],        B_pix     ;@80 Load odd-word pixels

        EXTU .2    B_pix,    24, 24,   B_px0o    ; Extract pixel 0
        MPY  .1X   4,        B_px0o,   A_bn0o    ; Set offset into hist0
        EXTU .2    B_pix,    16, 24,   B_px1o    ; Extract pixel 1
        MPY  .1X   4,        B_px1o,   A_bn1o    ; Set offset into hist1
        EXTU .2    B_pix,    8, 24,    B_px2o    ; Extract pixel 2
        MPY  .2    4,        B_px2o,   B_bn2o    ; Set offset into hist2
        SHRU .2    B_pix,    24,       B_px3o    ; Extract pixel 3
        MPY  .2    4,        B_px3o,   B_bn3o    ; Set offset into hist3

        CMPEQ.1    A_bn0o,   A_bc0e,   A_eq0o    ; Even->Odd fwd comp 0
        CMPEQ.1    A_bn1o,   A_bc1e,   A_eq1o    ; Even->Odd fwd comp 1
        CMPEQ.2    B_bn2o,   B_bc2e,   B_eq2o    ; Even->Odd fwd comp 2
        CMPEQ.2    B_bn3o,   B_bc3e,   B_eq3o    ; Even->Odd fwd comp 3

        LDH  .D1T1 *A_hst0[A_bn0o]{z0}, A_hs0o   ;@10 Load odd histo 0
        LDH  .D1T1 *A_hst1[A_bn1o]{z1}, A_hs1o   ;@14 Load odd histo 1
        LDH  .D2T2 *B_hst2[B_bn2o]{z2}, B_hs2o   ;@18 Load odd histo 2
        LDH  .D2T2 *B_hst3[B_bn3o]{z3}, B_hs3o   ;@1C Load odd histo 3

        STH  .D1T1 A_ha0e,   *A_hst0[A_bc0e]{w0} ;@10 Store even hist0
        STH  .D1T1 A_ha1e,   *A_hst1[A_bc1e]{w1} ;@14 Store even hist1
        STH  .D2T2 B_ha2e,   *B_hst2[B_bc2e]{w2} ;@18 Store even hist2
        STH  .D2T2 B_ha3e,   *B_hst3[B_bc3e]{w3} ;@1C Store even hist3

        ADD  .1    A_hs0o,   A_eq0o,   A_hf0o    ; forwarding for hist0
        ADD  .1    A_hs1o,   A_eq1o,   A_hf1o    ; forwarding for hist1
        ADD  .2    B_hs2o,   B_eq2o,   B_hf2o    ; forwarding for hist2
        ADD  .2    B_hs3o,   B_eq3o,   B_hf3o    ; forwarding for hist3

        ADD  .1    A_hf0o,   1,        A_ha0o    ; Accumulate for hist0
        ADD  .1    A_hf1o,   1,        A_ha1o    ; Accumulate for hist1
        ADD  .2    B_hf2o,   1,        B_ha2o    ; Accumulate for hist2
        ADD  .2    B_hf3o,   1,        B_ha3o    ; Accumulate for hist3

        MPY  .1    1,        A_bn0o,   A_bc0o    ; copy of bin 0 (l2l)
        MPY  .1    1,        A_bn1o,   A_bc1o    ; copy of bin 1 (l2l)
        MPY  .2    1,        B_bn2o,   B_bc2o    ; copy of bin 2 (l2l)
        MPY  .2    1,        B_bn3o,   B_bc3o    ; copy of bin 3 (l2l)

[A_i]   SUB  .1    A_i,      8,        A_i       ; Loop control.
[A_i]   B          LOOP_H

        STH  .D1T1 A_ha0o, *A_hst0[A_bc0o]{_y0}  ;@10  Store odd hist0
        STH  .D1T1 A_ha1o, *A_hst1[A_bc1o]{_y1}  ;@14  Store odd hist1
        STH  .D2T2 B_ha2o, *B_hst2[B_bc2o]{_y2}  ;@18  Store odd hist2
        STH  .D2T2 B_ha3o, *B_hst3[B_bc3o]{_y3}  ;@1C  Store odd hist3

        MVK  .1    62,     A_i
        MV   .1    A_hst0, A_hist_in_e
        ADD  .2X   A_hst0, 8, B_hist_in_o

        MV   .2X   A_hist, B_hist

        PACK2.1    A_accumulate, A_accumulate, A_1010   ;add or subtract to main
        MV   .2X   A_1010,     B_1010

        .mptr A_hist_in_e, a+0, 32
        .mptr B_hist_in_o, a+8, 32
        .mptr A_hist,      b+0, 8
        .mptr B_hist,      b+0, 8
LOOP_S: .trip  64
*==============================================================================*
        LDDW .D1T1 *A_hist_in_e++[2]{i0}, A_bin32:A_bin10  ; tmp bins 3..0
        LDDW .D2T2 *B_hist_in_o++[2]{i1}, B_bin76:B_bin54  ; tmp bins 7..4

        ADD2 .1    A_bin10, A_bin32,   A_sum3210           ;
        DOTP2.1    A_1010,  A_sum3210, A_sum0              ; sum bins 3..0
        ADD2 .2    B_bin76, B_bin54,   B_sum7654           ;
        DOTP2.1X   A_1010,  B_sum7654, A_sum1              ; sum bins 7..4
        PACK2.1    A_sum1,  A_sum0,    A_sum10             ; pack sums

        LDDW .D1T1 *A_hist_in_e++[2]{i2}, A_binba:A_bin98  ; tmp bins B..8
        LDDW .D2T2 *B_hist_in_o++[2]{i3}, B_binfe:B_bindc  ; tmp bins F..C

        ADD2 .1    A_binba, A_bin98,   A_sumba98           ;
        DOTP2.2X   B_1010,  A_sumba98, B_sum2              ; sum bins B..8
        ADD2 .2    B_binfe, B_bindc,   B_sumfedc           ;
        DOTP2.2    B_sumfedc, B_1010,  B_sum3              ; sum bins F..C
        PACK2.2    B_sum3,  B_sum2,    B_sum32             ; pack sums

        LDDW .D1T2 *A_hist++[1], B_main_bin32:B_main_bin10 ; main bins 3..0
        ADD2 .2    B_sum32, B_main_bin32, B_new_bin32      ; accumulate 3, 2
        ADD2 .1X   A_sum10, B_main_bin10, A_new_bin10      ; accumulate 1, 0
        MV   .1X   B_new_bin32, A_new_bin32                ; partitioning
        STDW .D2T1 A_new_bin32:A_new_bin10, *B_hist++[1]   ; update bins 3..0

        BDEC       LOOP_S,  A_i

          .return
          .endproc

* ========================================================================= *
*   End of file:  img_histogram.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
idct_8x8_0.sa/  1066928952  0     0     0       59433     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Wed Aug 29 10:29:39 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_idct_8x8_12q4 -- IEEE-1180/1990 Compliant IDCT, Little Endian.  *
*                                                                           *
*   REVISION DATE                                                           *
*       01-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_idct_8x8_12q4(short idct_data[], unsigned num_idcts)   *
*                                                                           *
*       The IMG_idct_8x8_12q4 routine accepts a list of 8x8 DCT coeffient blocks *
*       and performs IDCTs on each.  The array should be aligned to a       *
*       64-bit boundary, and be laid out equivalently to the C array        *
*       idct_data[num_idcts][8][8].  The input data should be in 12Q4       *
*       format.                                                             *
*                                                                           *
*       The routine operates entirely in-place, requiring no additional     *
*       storage for intermediate results.                                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_idct_8x8_12q4 algorithm performs an IEEE-1180 compliant IDCT, *
*       complete with rounding and saturation to signed 9-bit quantities.   *
*       The input coefficients are assumed to be signed 16-bit DCT          *
*       coefficients in 12Q4 format.                                        *
*                                                                           *
*       void IMG_idct_8x8_12q4(short idct_data[], unsigned num_idcts)       *
*       {                                                                   *
*           /* -------------------------------------------------------- */  *
*           /*  Cosine Constants (Q16, scaled down by sqrt(2)).         */  *
*           /* -------------------------------------------------------- */  *
*           const unsigned short C0 = 0xB505;                               *
*           const unsigned short C1 = 0xB18B, C2 = 0xA73D;                  *
*           const unsigned short C3 = 0x9683, C5 = 0x6492;                  *
*           const unsigned short C6 = 0x4546, C7 = 0x2351;                  *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Intermediate values (used in both loops).               */  *
*           /* -------------------------------------------------------- */  *
*           short F0, F1, F2, F3, F4, F5, F6, F7;  /* stage 0           */  *
*           short P0, P1, R0, R1, Q0, Q1, S0, S1;  /* stage 1           */  *
*           short p0, p1, r0, r1, q0, q1, s0, s1;  /* stage 2           */  *
*           short g0, g1, g2, g3, h0, h1, h2, h3;  /* stage 3           */  *
*           short f0, f1, f2, f3, f4, f5, f6, f7;  /* stage 4           */  *
*           short f0r,f1r,f2r,f3r,f4r,f5r,f6r,f7r; /* rounded           */  *
*           int   f0s,f1s,f2s,f3s,f4s,f5s,f6s,f7s; /* saturated         */  *
*           int   f0t,f1t,f2t,f3t,f4t,f5t,f6t,f7t; /* truncated         */  *
*           int   i, j;                            /* loop counts       */  *
*           short (*idct)[8][8] = (short (*)[8][8])idct_data;               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Vertical Pass                                           */  *
*           /*                                                          */  *
*           /*  This pass performs a single 8-pt IDCT per iteration.    */  *
*           /*  Inputs are in 12Q4 format, and results of this pass     */  *
*           /*  are in 11Q5 format. (Actually, the results are halfway  */  *
*           /*  between 11Q5 and 12Q4 due to the scaling by sqrt(2).)   */  *
*           /*                                                          */  *
*           /*  The outer loop steps between IDCT blocks, whereas the   */  *
*           /*  inner loop focuses on columns within each IDCT block.   */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < num_idcts; i++)                                 *
*           {                                                               *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 0:  Load in freq-domain coefficients.     */  *
*                   /* ------------------------------------------------ */  *
*                   F0 = idct[i][0][j];                                     *
*                   F1 = idct[i][1][j];                                     *
*                   F2 = idct[i][2][j];                                     *
*                   F3 = idct[i][3][j];                                     *
*                   F4 = idct[i][4][j];                                     *
*                   F5 = idct[i][5][j];                                     *
*                   F6 = idct[i][6][j];                                     *
*                   F7 = idct[i][7][j];                                     *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 1 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   P0 = F0;                P1 = F4;                        *
*                   R1 = F2;                R0 = F6;                        *
*                                                                           *
*                   Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;                    *
*                   Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;                    *
*                   S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;                    *
*                   S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 2 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   p0 = ((int)P0 + (int)P1 + 1 ) >> 1;                     *
*                   p1 = ((int)P0 - (int)P1     ) >> 1;                     *
*                   r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;                    *
*                   r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;                    *
*                                                                           *
*                   s1 = (S1 + S0);         q1 = (Q1 + Q0);                 *
*                   s0 = (S1 - S0);         q0 = (Q1 - Q0);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 3 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   g0 = (p0 + r0);         g1 = (p1 + r1);                 *
*                   h0 = (p0 - r0);         h1 = (p1 - r1);                 *
*                                                                           *
*                   h2 = s1;                g2 = q1;                        *
*                   g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;                    *
*                   h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   f0 = (g0 + h2);         f7 = (g0 - h2);                 *
*                   f1 = (g1 + h3);         f6 = (g1 - h3);                 *
*                   f2 = (h1 + g3);         f5 = (h1 - g3);                 *
*                   f3 = (h0 + g2);         f4 = (h0 - g2);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 5:  Write sample-domain results.          */  *
*                   /* ------------------------------------------------ */  *
*                   idct[i][0][j] = f0;                                     *
*                   idct[i][1][j] = f1;                                     *
*                   idct[i][2][j] = f2;                                     *
*                   idct[i][3][j] = f3;                                     *
*                   idct[i][4][j] = f4;                                     *
*                   idct[i][5][j] = f5;                                     *
*                   idct[i][6][j] = f6;                                     *
*                   idct[i][7][j] = f7;                                     *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           /* -------------------------------------------------------- */  *
*           /*  Horizontal Pass                                         */  *
*           /*                                                          */  *
*           /*  This performs one IDCT per iteration on the 11Q5        */  *
*           /*  results from the previous pass.  Both horizontal and    */  *
*           /*  vertical passes are scaled down by sqrt(2) -- the net   */  *
*           /*  effect of which is that the IDCT results generated by   */  *
*           /*  this pass (prior to saturation) are also 11Q5 results,  */  *
*           /*  only with no sqrt(2) factors remaining.                 */  *
*           /*                                                          */  *
*           /*  The IDCT butterflies in this pass are identical to the  */  *
*           /*  ones in the vertical pass, except for an additional     */  *
*           /*  rounding value which is added into the DC term early    */  *
*           /*  in the flow graph.                                      */  *
*           /*                                                          */  *
*           /*  The 11Q5 sample-domain terms are saturated to 9Q7       */  *
*           /*  values, and then truncated to 9Q0 results before        */  *
*           /*  storing.                                                */  *
*           /*                                                          */  *
*           /*  The outer loop steps between IDCT blocks, whereas the   */  *
*           /*  inner loop focuses on rows within each IDCT block.      */  *
*           /* -------------------------------------------------------- */  *
*           for (i = 0; i < num_idcts; i++)                                 *
*           {                                                               *
*               for (j = 0; j < 8; j++)                                     *
*               {                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 0:  Load in freq.-domain coefficients.    */  *
*                   /* ------------------------------------------------ */  *
*                   F0 = idct[i][j][0];                                     *
*                   F1 = idct[i][j][1];                                     *
*                   F2 = idct[i][j][2];                                     *
*                   F3 = idct[i][j][3];                                     *
*                   F4 = idct[i][j][4];                                     *
*                   F5 = idct[i][j][5];                                     *
*                   F6 = idct[i][j][6];                                     *
*                   F7 = idct[i][j][7];                                     *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 1 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   P0 = F0;                P1 = F4;                        *
*                   R1 = F2;                R0 = F6;                        *
*                                                                           *
*                   Q1 = (F1*C7 - F7*C1 + 0x8000) >> 16;                    *
*                   Q0 = (F5*C3 - F3*C5 + 0x8000) >> 16;                    *
*                   S0 = (F5*C5 + F3*C3 + 0x8000) >> 16;                    *
*                   S1 = (F1*C1 + F7*C7 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 2 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   p0 = (((int)P0 + (int)P1 + 1) >> 1) + 15;               *
*                   p1 = (((int)P0 - (int)P1    ) >> 1) + 16;               *
*                   r1 = (R1*C6 - R0*C2 + 0x8000) >> 16;                    *
*                   r0 = (R1*C2 + R0*C6 + 0x8000) >> 16;                    *
*                                                                           *
*                   s1 = (S1 + S0);         q1 = (Q1 + Q0);                 *
*                   s0 = (S1 - S0);         q0 = (Q1 - Q0);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 3 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   g0 = (p0 + r0);         g1 = (p1 + r1);                 *
*                   h0 = (p0 - r0);         h1 = (p1 - r1);                 *
*                                                                           *
*                   h2 = s1;                g2 = q1;                        *
*                   g3 = (s0*C0 - q0*C0 + 0x8000) >> 16;                    *
*                   h3 = (s0*C0 + q0*C0 + 0x8000) >> 16;                    *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4 of signal flow graph.                   */  *
*                   /* ------------------------------------------------ */  *
*                   f0 = (g0 + h2);         f7 = (g0 - h2);                 *
*                   f1 = (g1 + h3);         f6 = (g1 - h3);                 *
*                   f2 = (h1 + g3);         f5 = (h1 - g3);                 *
*                   f3 = (h0 + g2);         f4 = (h0 - g2);                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.1:  Q-pt adjust: Bit 15 is don't-care.  */  *
*                   /* ------------------------------------------------ */  *
*                   f0r = f0 + f0;          f7r = f7 + f7;                  *
*                   f1r = f1 + f1;          f6r = f6 + f6;                  *
*                   f2r = f2 + f2;          f5r = f5 + f5;                  *
*                   f3r = f3 + f3;          f4r = f4 + f4;                  *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.2:  Saturate results to 9Q6.            */  *
*                   /* ------------------------------------------------ */  *
*                   f0s = f0r>0x3FFF? 0x3FFF : f0r<-0x4000? -0x4000 : f0r;  *
*                   f1s = f1r>0x3FFF? 0x3FFF : f1r<-0x4000? -0x4000 : f1r;  *
*                   f2s = f2r>0x3FFF? 0x3FFF : f2r<-0x4000? -0x4000 : f2r;  *
*                   f3s = f3r>0x3FFF? 0x3FFF : f3r<-0x4000? -0x4000 : f3r;  *
*                   f4s = f4r>0x3FFF? 0x3FFF : f4r<-0x4000? -0x4000 : f4r;  *
*                   f5s = f5r>0x3FFF? 0x3FFF : f5r<-0x4000? -0x4000 : f5r;  *
*                   f6s = f6r>0x3FFF? 0x3FFF : f6r<-0x4000? -0x4000 : f6r;  *
*                   f7s = f7r>0x3FFF? 0x3FFF : f7r<-0x4000? -0x4000 : f7r;  *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 4.3:  Truncate results to 9Q0.            */  *
*                   /* ------------------------------------------------ */  *
*                   f0t = f0s >> 6;         f7t = f7s >> 6;                 *
*                   f1t = f1s >> 6;         f6t = f6s >> 6;                 *
*                   f2t = f2s >> 6;         f5t = f5s >> 6;                 *
*                   f3t = f3s >> 6;         f4t = f4s >> 6;                 *
*                                                                           *
*                   /* ------------------------------------------------ */  *
*                   /*  Stage 5:  Store sample-domain results.          */  *
*                   /* ------------------------------------------------ */  *
*                   idct[i][j][0] = f0t;                                    *
*                   idct[i][j][1] = f1t;                                    *
*                   idct[i][j][2] = f2t;                                    *
*                   idct[i][j][3] = f3t;                                    *
*                   idct[i][j][4] = f4t;                                    *
*                   idct[i][j][5] = f5t;                                    *
*                   idct[i][j][6] = f6t;                                    *
*                   idct[i][j][7] = f7t;                                    *
*               }                                                           *
*           }                                                               *
*           return;                                                         *
*       }                                                                   *
*                                                                           *
*       Note:  This code guarantees correct operation, even in the case     *
*       that 'num_idcts == 0'.  In that case, the function performs no      *
*       operation at all.  Also, the serial-assembly code imposes           *
*       additional data alignment restrictions that are not present in      *
*       the C code above.                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       All levels of looping are collapsed into single loops which are     *
*       pipelined.  The outer loop focuses on 8-pt IDCTs, whereas the       *
*       inner loop controls the column-pointer to handle jumps between      *
*       IDCT blocks.  (The column-pointer adjustment is handled by a        *
*       four-phase rotating "fixup" constant which takes the place of       *
*       the original inner-loop.)                                           *
*                                                                           *
*       Additional section-specific optimization notes are provided below.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*       The input array must be aligned on a double-word boundary.          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur.                                     *
*                                                                           *
*       The input array must be aligned on a double-word boundary.          *
*                                                                           *
*       The code may perform speculative reads. The speculatively accessed  *
*       data is ignored.                                                    *
*                                                                           *
*   NOTES                                                                   *
*       The cosine terms have all been scaled by sqrt(2), so that the       *
*       "c4" term is basically an even power of 2.                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"

        .sect ".text:_idct_8x8"
        .global _IMG_idct_8x8_12q4
_IMG_idct_8x8_12q4 .cproc A_data, B_count

; =========================== MEMORY DEPENDENCIES ============================
        .no_mdep                        ; Assume "don't alias" by default.
        .mdep           s0, l0          ;\
        .mdep           s1, l0          ; |
        .mdep           s2, l0          ; |
        .mdep           s3, l0          ; |__ Final v_loop stores to first
        .mdep           s4, l0          ; |   h_loop load.
        .mdep           s5, l0          ; |
        .mdep           s6, l0          ; |
        .mdep           s7, l0          ;/
        .mdep           s0, l1          ;\
        .mdep           s1, l1          ; |
        .mdep           s2, l1          ; |
        .mdep           s3, l1          ; |__ Final v_loop stores to second
        .mdep           s4, l1          ; |   h_loop load.
        .mdep           s5, l1          ; |
        .mdep           s6, l1          ; |
        .mdep           s7, l1          ;/
        .mdep           s0, l2          ;\
        .mdep           s1, l2          ; |
        .mdep           s2, l2          ; |
        .mdep           s3, l2          ; |__ Final v_loop stores to third
        .mdep           s4, l2          ; |   h_loop load.
        .mdep           s5, l2          ; |
        .mdep           s6, l2          ; |
        .mdep           s7, l2          ;/
        .mdep           s0, l3          ;\
        .mdep           s1, l3          ; |
        .mdep           s2, l3          ; |
        .mdep           s3, l3          ; |__ Final v_loop stores to fourth
        .mdep           s4, l3          ; |   h_loop load.
        .mdep           s5, l3          ; |
        .mdep           s6, l3          ; |
        .mdep           s7, l3          ;/
; ====================== SYMBOLIC CONSTANT ASSIGNMENTS =======================
            .asg        0xB505,     cst_c0  ; cos term c0 (scaled by sqrt(2))
            .asg        0xB18B,     cst_c1  ; cos term c1 (scaled by sqrt(2))
            .asg        0xA73D,     cst_c2  ; cos term c2 (scaled by sqrt(2))
            .asg        0x9683,     cst_c3  ; cos term c3 (scaled by sqrt(2))
            .asg        0x8000,     cst_c4  ; cos term c4 (scaled by sqrt(2))
            .asg        0x6492,     cst_c5  ; cos term c5 (scaled by sqrt(2))
            .asg        0x4546,     cst_c6  ; cos term c6 (scaled by sqrt(2))
            .asg        0x2351,     cst_c7  ; cos term c7 (scaled by sqrt(2))
            .asg        0x0101011D, cst_fix ; Pointer fixup constant (v_loop)
            .asg        0x000F0010, cst_rnd ; Rounding constant (h_loop)
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
            .reg    B_ok            ; Flag:  True if # of IDCTs > 0.

            .reg    A_C00           ; Q15 cosing term  C0 duplicated twice
            .reg    A_C17           ; Q15 cosine terms C1, C7
            .reg    A_C35,  B_C35   ; Q15 cosine terms C3, C5
            .reg    A_C26           ; Q15 cosine terms C2, C6
            .reg    A_C53           ; Q15 cosine terms C5, C3
            .reg    A_C62           ; Q15 cosine terms C6, C2
            .reg    A_C71           ; Q15 cosine terms C7, C1

            .reg    B_rnd,  A_rnd   ; Rounding term for vertical pass
            .reg    B_k_neg         ; Constant: 0x0000FFFF
            .reg    A_k_neg         ; Constant: 0x0000FFFF

            .reg    B_fx1,  A_fx2   ; Pointer fixup values
            .reg    B_fxp,  A_fxp   ; Magic fixup value

            .reg    B_F76:B_F54     ; Input cols 4..7 within even row
            .reg    B_F32:B_F10     ; Input cols 0..3 within even row
            .reg    A_F76:A_F54     ; Input cols 4..7 within odd row
            .reg    A_F32:A_F10     ; Input cols 0..3 within odd row

            .reg    B_f10r, B_f32r, B_f54r, B_f76r
            .reg    A_f10r, A_f32r, A_f54r, A_f76r
            .reg    B_f10s, B_f32s, B_f54s, B_f76s
            .reg    A_f10s, A_f32s, A_f54s, A_f76s
            .reg    B_f76t:B_f54t   ; Output cols 4, 5, 6, 7
            .reg    B_f32t:B_f10t   ; Output cols 0, 1, 2, 3
            .reg    A_f76t:A_f54t   ; Output cols 4, 5, 6, 7
            .reg    A_f32t:A_f10t   ; Output cols 0, 1, 2, 3

            .reg    B_F00           ; Input row 0 from two adj. cols
            .reg    B_F11           ; Input row 1 from two adj. cols
            .reg    B_F22           ; Input row 2 from two adj. cols
            .reg    B_F33           ; Input row 3 from two adj. cols
            .reg    B_F44           ; Input row 4 from two adj. cols
            .reg    B_F55           ; Input row 5 from two adj. cols
            .reg    B_F66           ; Input row 6 from two adj. cols
            .reg    B_F77           ; Input row 7 from two adj. cols

            .reg    A_f00           ; Packed output data, row 0
            .reg    A_f11           ; Packed output data, row 1
            .reg    A_f22           ; Packed output data, row 2
            .reg    A_f33           ; Packed output data, row 3
            .reg    A_f44           ; Packed output data, row 4
            .reg    A_f55           ; Packed output data, row 5
            .reg    A_f66           ; Packed output data, row 6
            .reg    A_f77           ; Packed output data, row 7

            .reg    B_i             ; Loop counters
            .reg    B_i_ptr         ; Generic input pointer
            .reg    A_i_ptr         ; Generic input pointer
            .reg    A_o_ptr         ; Generic output pointer

            ; Miscellaneous intermediate values
            .reg    B_F40,      A_F40
            .reg    B_F0n4,     A_F0n4
            .reg    B_F04,      A_F04,        B_F04x
            .reg    B_F17,      A_F17,        B_F17x
            .reg    B_F26,      A_F26,        B_F26x
            .reg    B_F53,      A_F53,        B_F53x

            .reg    B_Q0,       A_Q0
            .reg    B_S0Q0,     A_S0Q0
            .reg    B_Q1,       A_Q1
            .reg    B_S1Q1,     A_S1Q1
            .reg    B_S0,       A_S0
            .reg    B_S1,       A_S1

            .reg    B_p0,       A_p0
            .reg    B_p1,       A_p1
            .reg    B_r0,       A_r0
            .reg    B_r1,       A_r1
            .reg    B_p0p1,     A_p0p1
            .reg    B_r0r1,     A_r0r1
            .reg    B_s0q0,     A_s0q0

            .reg    B_g3,       A_g3
            .reg    B_h3,       A_h3
            .reg    B_g0g1,     A_g0g1
            .reg    B_h0h1,     A_h0h1
            .reg    B_h2g2,     A_h2g2
            .reg    B_g2g3,     A_g2g3
            .reg    B_h2h3,     A_h2h3

            .reg    B_f01,      A_f01
            .reg    B_f32,      A_f32
            .reg    B_f45,      A_f45
            .reg    B_f76,      A_f76

            .reg    B_k_fix
            .reg    B_p0p1_t,   A_p0p1_t


            ; ============================================================= ;
            ;  Double check that we're doing at least 1 IDCT.               ;
            ; ============================================================= ;

            MV       .2     B_count,        B_ok
[!B_ok]     B               idct_8x8_abort

            ; ============================================================= ;
            ;   Cosine terms and other constants for IDCTs                  ;
            ;                                                               ;
            ;   The Q16 cosine terms are named C0 thru C7, and are packed   ;
            ;   together with two cosine terms in each word.  These terms   ;
            ;   are scaled down by sqrt(2).                                 ;
            ;                                                               ;
            ;   The constant 0x0000FFFF is used for 'negating' the F0       ;
            ;   term with an XOR, as part of one of the butterflies.  The   ;
            ;   XPND2 instruction generates this constant from the two      ;
            ;   LSBs of one of the convenient cosine constants laying       ;
            ;   around.                                                     ;
            ; ============================================================= ;

            MVKL     .1     cst_c0,         A_C00
            PACK2    .1     A_C00,          A_C00,          A_C00

            MVKL     .1     cst_c1,         A_C71
            MVKLH    .1     cst_c7,         A_C71
            PACKLH2  .1     A_C71,          A_C71,          A_C17

            MVKL     .1     cst_c2,         A_C62
            MVKLH    .1     cst_c6,         A_C62
            ROTL     .1     A_C62,          16,             A_C26

            MVKL     .2     cst_c5,         B_C35
            MVKLH    .2     cst_c3,         B_C35
            MV       .1X    B_C35,          A_C35
            ROTL     .1     A_C35,          16,             A_C53

            XPND2    .1     A_C62,          A_k_neg     ; A_k_neg = 0x0000FFFF



            ; ============================================================= ;
            ;   Chen IDCT, Vertical Pass.                                   ;
            ;                                                               ;
            ;   This pass performs two IDCTs per iteration.  IDCT terms     ;
            ;   are read in pairs using LDWs and stored as pairs with       ;
            ;   STWs.                                                       ;
            ;                                                               ;
            ;   The nested loop structure has been collapsed into a single  ;
            ;   loop to provide the greatest benefit from software-         ;
            ;   pipelining.  The outer loop has been replaced by a pointer  ;
            ;   update to provide the appropriate pointer motion.           ;
            ;                                                               ;
            ;   Pointer updates are performed with a four-phase "fixup"     ;
            ;   sequence which alternates between fixup values of 1, 1,     ;
            ;   1, and 29, thus moving between the four pairs of columns    ;
            ;   and between IDCT blocks.                                    ;
            ; ============================================================= ;

            ; Vertical-pass magic pointer update constant
            MVKL     .2     cst_fix,        B_k_fix
            MVKH     .2     cst_fix,        B_k_fix


            ; Trip count is 4 times the number of IDCTs.
            SHL      .2     B_count,        2,              B_i
            SUB      .2     B_i,            2,              B_i ; Adj. for BDEC
            MV       .2     B_i,            B_count


            ; Pointer setup
            MV       .2X    A_data,         B_i_ptr
            MV       .1     A_data,         A_o_ptr
            ADD      .1     A_data,         8,              A_data
            .mptr           B_i_ptr,        data,           4
            .mptr           A_o_ptr,        data,           4

            ; ============================================================= ;
            ;   Start of Vertical Pass                                      ;
            ; ============================================================= ;
v_loop:    .trip   4

            ; ============================================================= ;
            ;   Pointer update/control                                      ;
            ; ============================================================= ;
            SHR      .2     B_k_fix,        24,             B_fx1
            SHR      .1X    B_k_fix,        24,             A_fx2
            ROTL     .2     B_k_fix,        8,              B_k_fix

            ; ============================================================= ;
            ;   Load data for both IDCTs (Stage 0)                          ;
            ; ============================================================= ;
            LDW      .D2T2  *+B_i_ptr  [   28],             B_F77
            LDW      .D2T2  *+B_i_ptr  [   24],             B_F66
            LDW      .D2T2  *+B_i_ptr  [   20],             B_F55
            LDW      .D2T2  *+B_i_ptr  [   16],             B_F44
            LDW      .D2T2  *+B_i_ptr  [   12],             B_F33
            LDW      .D2T2  *+B_i_ptr  [    8],             B_F22
            LDW      .D2T2  *+B_i_ptr  [    4],             B_F11
            LDW      .D2T2  * B_i_ptr++[B_fx1],             B_F00

            ; ============================================================= ;
            ;   IDCT #1, Even-numbered columns                              ;
            ; ============================================================= ;

            ; ------------------------------------------------------------- ;
            ;  Swizzle data into position for butterflies.                  ;
            ; ------------------------------------------------------------- ;
            PACK2    .2     B_F11,          B_F77,          B_F17
            PACK2    .2     B_F55,          B_F33,          B_F53
            PACK2    .2     B_F22,          B_F66,          B_F26
            PACK2    .2     B_F00,          B_F44,          B_F04

            ; ------------------------------------------------------------- ;
            ;  Stage 1                                                      ;
            ; ------------------------------------------------------------- ;
            DOTPNRSU2.2X    B_F17,          A_C71,          B_Q1
            DOTPNRSU2.2X    B_F53,          A_C35,          B_Q0
            DOTPRSU2 .2X    B_F53,          A_C53,          B_S0
            DOTPRSU2 .2X    B_F17,          A_C17,          B_S1

            ; ------------------------------------------------------------- ;
            ;  Stage 2                                                      ;
            ; ------------------------------------------------------------- ;
            ROTL     .2     B_F04,          16,             B_F40
            XOR      .2X    B_F04,          A_k_neg,        B_F0n4
            AVG2     .2     B_F40,          B_F0n4,         B_p0p1

            DOTPRSU2 .2X    B_F26,          A_C26,          B_r0
            DOTPNRSU2.2X    B_F26,          A_C62,          B_r1
            PACK2    .2     B_r0,           B_r1,           B_r0r1

            PACK2    .2     B_S0,           B_Q0,           B_S0Q0
            PACK2    .2     B_S1,           B_Q1,           B_S1Q1
            SUB2     .2     B_S1Q1,         B_S0Q0,         B_s0q0
            ADD2     .2     B_S1Q1,         B_S0Q0,         B_h2g2

            ; ------------------------------------------------------------- ;
            ;  Stage 3                                                      ;
            ; ------------------------------------------------------------- ;
            ADD2     .2     B_p0p1,         B_r0r1,         B_g0g1
            SUB2     .2     B_p0p1,         B_r0r1,         B_h0h1

            DOTPNRSU2.2X    B_s0q0,         A_C00,          B_g3
            DOTPRSU2 .2X    B_s0q0,         A_C00,          B_h3

            ; ------------------------------------------------------------- ;
            ;  Stage 4: Final butterfly                                     ;
            ; ------------------------------------------------------------- ;
            PACKHL2  .2     B_h2g2,         B_h3,           B_h2h3
            PACK2    .2     B_h2g2,         B_g3,           B_g2g3

            ADD2     .2     B_g0g1,         B_h2h3,         B_f01
            ADD2     .2     B_h0h1,         B_g2g3,         B_f32
            SUB2     .2     B_h0h1,         B_g2g3,         B_f45
            SUB2     .2     B_g0g1,         B_h2h3,         B_f76

            ; ============================================================= ;
            ;   IDCT #2, Odd-numbered columns                               ;
            ; ============================================================= ;

            ; ------------------------------------------------------------- ;
            ;  Swizzle data into position for butterflies.                  ;
            ; ------------------------------------------------------------- ;
            PACKH2   .2     B_F11,          B_F77,          B_F17x
            PACKH2   .2     B_F55,          B_F33,          B_F53x
            PACKH2   .2     B_F22,          B_F66,          B_F26x
            PACKH2   .2     B_F00,          B_F44,          B_F04x

            MV       .1X    B_F17x,         A_F17
            MV       .1X    B_F53x,         A_F53
            ROTL     .1X    B_F26x,         0,              A_F26
            ROTL     .1X    B_F04x,         16,             A_F40


            ; ------------------------------------------------------------- ;
            ;  Stage 1                                                      ;
            ; ------------------------------------------------------------- ;
            DOTPNRSU2.1     A_F17,          A_C71,          A_Q1
            DOTPNRSU2.1     A_F53,          A_C35,          A_Q0
            DOTPRSU2 .1     A_F53,          A_C53,          A_S0
            DOTPRSU2 .1     A_F17,          A_C17,          A_S1

            ; ------------------------------------------------------------- ;
            ;  Stage 2                                                      ;
            ; ------------------------------------------------------------- ;
            XOR      .1X    B_F04x,         A_k_neg,        A_F0n4
            AVG2     .1     A_F40,          A_F0n4,         A_p0p1

            DOTPRSU2 .1     A_F26,          A_C26,          A_r0
            DOTPNRSU2.1     A_F26,          A_C62,          A_r1
            PACK2    .1     A_r0,           A_r1,           A_r0r1

            PACK2    .1     A_S0,           A_Q0,           A_S0Q0
            PACK2    .1     A_S1,           A_Q1,           A_S1Q1
            SUB2     .1     A_S1Q1,         A_S0Q0,         A_s0q0
            ADD2     .1     A_S1Q1,         A_S0Q0,         A_h2g2

            ; ------------------------------------------------------------- ;
            ;  Stage 3                                                      ;
            ; ------------------------------------------------------------- ;
            ADD2     .1     A_p0p1,         A_r0r1,         A_g0g1
            SUB2     .1     A_p0p1,         A_r0r1,         A_h0h1

            DOTPNRSU2.1     A_s0q0,         A_C00,          A_g3
            DOTPRSU2 .1     A_s0q0,         A_C00,          A_h3

            ; ------------------------------------------------------------- ;
            ;  Stage 4: Final butterfly                                     ;
            ; ------------------------------------------------------------- ;
            PACKHL2  .1     A_h2g2,         A_h3,           A_h2h3
            PACK2    .1     A_h2g2,         A_g3,           A_g2g3

            ADD2     .1     A_g0g1,         A_h2h3,         A_f01
            ADD2     .1     A_h0h1,         A_g2g3,         A_f32
            SUB2     .1     A_h0h1,         A_g2g3,         A_f45
            SUB2     .1     A_g0g1,         A_h2h3,         A_f76

            ; ============================================================= ;
            ;   Store data for both IDCTs (Stage 5)                         ;
            ; ============================================================= ;
            PACKH2   .1X    A_f76,          B_f76,          A_f77
            PACK2    .1X    A_f76,          B_f76,          A_f66
            PACK2    .1X    A_f45,          B_f45,          A_f55
            PACKH2   .1X    A_f45,          B_f45,          A_f44
            PACKH2   .1X    A_f32,          B_f32,          A_f33
            PACK2    .1X    A_f32,          B_f32,          A_f22
            PACK2    .1X    A_f01,          B_f01,          A_f11
            PACKH2   .1X    A_f01,          B_f01,          A_f00

            STW      .D1T1  A_f77,          *+A_o_ptr  [   28]{s0}
            STW      .D1T1  A_f66,          *+A_o_ptr  [   24]{s1}
            STW      .D1T1  A_f55,          *+A_o_ptr  [   20]{s2}
            STW      .D1T1  A_f44,          *+A_o_ptr  [   16]{s3}
            STW      .D1T1  A_f33,          *+A_o_ptr  [   12]{s4}
            STW      .D1T1  A_f22,          *+A_o_ptr  [    8]{s5}
            STW      .D1T1  A_f11,          *+A_o_ptr  [    4]{s6}
            STW      .D1T1  A_f00,          * A_o_ptr++[A_fx2]{s7}

            ; ============================================================= ;
            ;   Looping.                                                    ;
            ; ============================================================= ;

            .if 1
            BDEC     .2     v_loop,         B_i
            .else
            SUB      .2     B_i,            1,              B_i
     [B_i]  B               v_loop
            .endif

            ; ============================================================= ;
            ;   End of Vertical Pass                                        ;
            ; ============================================================= ;


            ; ============================================================= ;
            ;   Chen IDCT, Horizontal Pass.                                 ;
            ;                                                               ;
            ;   This pass performs two IDCTs per iteration.  IDCT terms     ;
            ;   are read in groups of four using LDDWs and stored in        ;
            ;   groups of four using STDWs.                                 ;
            ;                                                               ;
            ;   The nested loop structure has been collapsed into a single  ;
            ;   loop to provide the greatest benefit from software-         ;
            ;   pipelining.  No changes were necessary to the pointer       ;
            ;   motion.                                                     ;
            ; ============================================================= ;


            ; Trip count is 4 times the number of IDCTs.
            MV       .2     B_count,        B_i

            ; Constant 0x0000FFFF
            XPND2    .2X    A_C62,          B_k_neg

            ; Rounding terms
            MVK      .2     0x0010,         B_rnd
            MVKLH    .2     0x000F,         B_rnd

            ; Point B_i_ptr at row 0, A_i_ptr at row 1
            ADD      .2X    A_data,         8,              B_i_ptr
            SUB      .1     A_data,         8,              A_i_ptr
            .mptr           B_i_ptr,        data,           16
            .mptr           A_i_ptr,        data,           16

            ; ============================================================= ;
            ;   Start of Horizontal Pass                                    ;
            ; ============================================================= ;
h_loop:     .trip   4

            ; ============================================================= ;
            ;   IDCT #1 -- Odd numbered rows.                               ;
            ; ============================================================= ;

            ; ------------------------------------------------------------- ;
            ;  Stage 0:  Load coefficients for odd-numbered row             ;
            ; ------------------------------------------------------------- ;
            LDDW     .D2T2  *+B_i_ptr[1]{l0},               B_F76:B_F54
            LDDW     .D2T2  *+B_i_ptr[0]{l1},               B_F32:B_F10

            ; ------------------------------------------------------------- ;
            ;  Swizzle data into position for butterflies.                  ;
            ; ------------------------------------------------------------- ;
            PACKH2   .2     B_F10,          B_F76,          B_F17
            PACKH2   .2     B_F54,          B_F32,          B_F53
            PACK2    .2     B_F32,          B_F76,          B_F26
            PACK2    .2     B_F54,          B_F10,          B_F40

            ; ------------------------------------------------------------- ;
            ;  Stage 1                                                      ;
            ; ------------------------------------------------------------- ;
            DOTPNRSU2.2X    B_F17,          A_C71,          B_Q1
            DOTPNRSU2.2X    B_F53,          A_C35,          B_Q0
            DOTPRSU2 .2X    B_F53,          A_C53,          B_S0
            DOTPRSU2 .2X    B_F17,          A_C17,          B_S1

            ; ------------------------------------------------------------- ;
            ;  Stage 2                                                      ;
            ; ------------------------------------------------------------- ;
            ROTL     .2     B_F40,          16,             B_F04
            XOR      .2     B_F04,          B_k_neg,        B_F0n4
            AVG2     .2     B_F40,          B_F0n4,         B_p0p1_t
            ADD2     .2     B_p0p1_t,       B_rnd,          B_p0p1

            DOTPRSU2 .2     B_F26,          A_C26,          B_r0
            DOTPNRSU2.2     B_F26,          A_C62,          B_r1
            PACK2    .2     B_r0,           B_r1,           B_r0r1

            PACK2    .2     B_S0,           B_Q0,           B_S0Q0
            PACK2    .2     B_S1,           B_Q1,           B_S1Q1
            SUB2     .2     B_S1Q1,         B_S0Q0,         B_s0q0
            ADD2     .2     B_S1Q1,         B_S0Q0,         B_h2g2

            ; ------------------------------------------------------------- ;
            ;  Stage 3                                                      ;
            ; ------------------------------------------------------------- ;
            ADD2     .2     B_p0p1,         B_r0r1,         B_g0g1
            SUB2     .2     B_p0p1,         B_r0r1,         B_h0h1

            DOTPNRSU2.2X    B_s0q0,         A_C00,          B_g3
            DOTPRSU2 .2X    B_s0q0,         A_C00,          B_h3

            ; ------------------------------------------------------------- ;
            ;  Stage 4:  Final butterfly                                    ;
            ; ------------------------------------------------------------- ;
            PACKHL2  .2     B_h2g2,         B_h3,           B_h2h3
            PACK2    .2     B_h2g2,         B_g3,           B_g2g3

            ADD2     .2     B_g0g1,         B_h2h3,         B_f01
            ADD2     .2     B_h0h1,         B_g2g3,         B_f32
            SUB2     .2     B_h0h1,         B_g2g3,         B_f45
            SUB2     .2     B_g0g1,         B_h2h3,         B_f76

            ROTL     .2     B_f01,          17,             B_f10r
            ADD      .2     B_f32,          B_f32,          B_f32r
            ROTL     .2     B_f45,          17,             B_f54r
            ADD      .2     B_f76,          B_f76,          B_f76r

            SADD2    .2     B_f10r,         B_f10r,         B_f10s
            SADD2    .2     B_f32r,         B_f32r,         B_f32s
            SADD2    .2     B_f54r,         B_f54r,         B_f54s
            SADD2    .2     B_f76r,         B_f76r,         B_f76s

            SHR2     .2     B_f10s,         7,              B_f10t
            SHR2     .2     B_f32s,         7,              B_f32t
            SHR2     .2     B_f54s,         7,              B_f54t
            SHR2     .2     B_f76s,         7,              B_f76t

            ; ------------------------------------------------------------- ;
            ;   Stage 5:  Store sample-domain results.                      ;
            ; ------------------------------------------------------------- ;
            STDW     .D2T2  B_f76t:B_f54t,  *+B_i_ptr  [1]
            STDW     .D2T2  B_f32t:B_f10t,  * B_i_ptr++[4]

            ; ============================================================= ;
            ;   IDCT #2 -- Odd numbered rows.                               ;
            ; ============================================================= ;

            ; ------------------------------------------------------------- ;
            ;  Stage 0:  Load coefficients for even-numbered row            ;
            ; ------------------------------------------------------------- ;
            LDDW     .D1T1  *+A_i_ptr[1]{l2},               A_F76:A_F54
            LDDW     .D1T1  *+A_i_ptr[0]{l3},               A_F32:A_F10

            ; ------------------------------------------------------------- ;
            ;  Swizzle data into position for butterflies.                  ;
            ; ------------------------------------------------------------- ;
            PACKH2   .1     A_F10,          A_F76,          A_F17
            PACKH2   .1     A_F54,          A_F32,          A_F53
            PACK2    .1     A_F32,          A_F76,          A_F26
            PACK2    .1     A_F54,          A_F10,          A_F40

            ; Top half of signal flow graph


            ; ------------------------------------------------------------- ;
            ;  Stage 1                                                      ;
            ; ------------------------------------------------------------- ;
            DOTPNRSU2.1     A_F17,          A_C71,          A_Q1
            DOTPNRSU2.1     A_F53,          A_C35,          A_Q0
            DOTPRSU2 .1     A_F53,          A_C53,          A_S0
            DOTPRSU2 .1     A_F17,          A_C17,          A_S1

            ; ------------------------------------------------------------- ;
            ;  Stage 2                                                      ;
            ; ------------------------------------------------------------- ;
            ROTL     .1     A_F40,          16,             A_F04
            XOR      .1X    A_F04,          B_k_neg,        A_F0n4
            AVG2     .1     A_F40,          A_F0n4,         A_p0p1_t
            ADD2     .1X    A_p0p1_t,       B_rnd,          A_p0p1

            DOTPRSU2 .1     A_F26,          A_C26,          A_r0
            DOTPNRSU2.1     A_F26,          A_C62,          A_r1
            PACK2    .1     A_r0,           A_r1,           A_r0r1

            PACK2    .1     A_S0,           A_Q0,           A_S0Q0
            PACK2    .1     A_S1,           A_Q1,           A_S1Q1
            SUB2     .1     A_S1Q1,         A_S0Q0,         A_s0q0
            ADD2     .1     A_S1Q1,         A_S0Q0,         A_h2g2

            ; ------------------------------------------------------------- ;
            ;  Stage 3                                                      ;
            ; ------------------------------------------------------------- ;
            ADD2     .1     A_p0p1,         A_r0r1,         A_g0g1
            SUB2     .1     A_p0p1,         A_r0r1,         A_h0h1

            DOTPNRSU2.1     A_s0q0,         A_C00,          A_g3
            DOTPRSU2 .1     A_s0q0,         A_C00,          A_h3

            ; ------------------------------------------------------------- ;
            ;  Stage 4:  Final butterfly                                    ;
            ; ------------------------------------------------------------- ;
            PACKHL2  .1     A_h2g2,         A_h3,           A_h2h3
            PACK2    .1     A_h2g2,         A_g3,           A_g2g3

            ADD2     .1     A_g0g1,         A_h2h3,         A_f01
            ADD2     .1     A_h0h1,         A_g2g3,         A_f32
            SUB2     .1     A_h0h1,         A_g2g3,         A_f45
            SUB2     .1     A_g0g1,         A_h2h3,         A_f76

            ROTL     .1     A_f01,          17,             A_f10r
            ADD      .1     A_f32,          A_f32,          A_f32r
            ROTL     .1     A_f45,          17,             A_f54r
            ADD      .1     A_f76,          A_f76,          A_f76r

            SADD2    .1     A_f10r,         A_f10r,         A_f10s
            SADD2    .1     A_f32r,         A_f32r,         A_f32s
            SADD2    .1     A_f54r,         A_f54r,         A_f54s
            SADD2    .1     A_f76r,         A_f76r,         A_f76s

            SHR2     .1     A_f10s,         7,              A_f10t
            SHR2     .1     A_f32s,         7,              A_f32t
            SHR2     .1     A_f54s,         7,              A_f54t
            SHR2     .1     A_f76s,         7,              A_f76t

            ; ------------------------------------------------------------- ;
            ;   Stage 5:  Store sample-domain results.                      ;
            ; ------------------------------------------------------------- ;
            STDW     .D1T1  A_f76t:A_f54t,  *+A_i_ptr  [1]
            STDW     .D1T1  A_f32t:A_f10t,  * A_i_ptr++[4]

            ; ============================================================= ;
            ;   Looping.                                                    ;
            ; ============================================================= ;
            .if 1
            BDEC     .2     h_loop,         B_i
            .else
            SUB      .2     B_i,            1,              B_i
     [B_i]  B               h_loop
            .endif

            ; ============================================================= ;
            ;   End of Vertical Pass                                        ;
            ; ============================================================= ;


idct_8x8_abort:
            .return
            .endproc

* ========================================================================= *
*   End of file:  img_idct_8x8_12q4.sa                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_16x16.sa/   1066928952  0     0     0       36159     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Mon Jan 14 18:41:40 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           mad16x16                                                        *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch,                                                      *
*           int                 h,                                          *
*           int                 v,                                          *
*           unsigned            *restrict match                             *
*       )                                                                   *
*                                                                           *
*       refImg          Reference image.                                    *
*       srcImg[256]     16x16 block image to look for.                      *
*       pitch           Width of reference image.                           *
*       h               Horiz. size of search area.                         *
*       v               Vert.  size of search area. Must be multiple of 2.  *
*       match[2]        Result:                                             *
*                           match[0] is packed x, y.                        *
*                           match[1] is MAD value.                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine returns the location of the minimum absolute           *
*       difference between a 16x16 search block and some block in a         *
*       (h + 16) x (v + 16) search area. h and v are the sizes of the       *
*       search space for the top left coordinate of the search block.       *
*       refImg points to the top left pixel of the search area.             *
*                                                                           *
*            (0,0)          (h,0)      (h+16,0)                             *
*              ;--------------+--------;                                    *
*              ;    search    |        ;                                    *
*              ;    space     |        ;                                    *
*              ;              |        ;        search area                 *
*              ;--------------+        ;        within reference image      *
*            (0,v)          (h,v)      ;                                    *
*              ;                       ;                                    *
*              ;-----------------------;                                    *
*            (0, v+16)                 (v+16,h+16)                          *
*                                                                           *
*       The location is returned relative to the above coordinate system    *
*       as x and y packed in two 16-bit quantities in a 32-bit word:        *
*                                                                           *
*                   31             16 15             0                      *
*                   +----------------+----------------+                     *
*        match[0]:  |       x        |       y        |                     *
*                   +----------------+----------------+                     *
*                                                                           *
*                   31                               0                      *
*                   +---------------------------------+                     *
*        match[1]:  |   SAD value at location x, y    |                     *
*                   +---------------------------------+                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       srcImg and refImg do not alias in memory.                           *
*       The routine is written for Little Endian configuration.             *
*       Two MADS are performed together and hence it is assumed that v      *
*       the vertical dimension is a multiple of 2.                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No special requirements on alignment of arrays is required.         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The two outer loops are merged, the two inner loops are merged.     *
*       The inner loop process 2 lines of 2 search locations in parallel.   *
*       The search is performed in top-to-bottom, left-to-right order,      *
*       with the earliest match taking precedence in the case of ties.      *
*       Further use is made of C64x specific instructions such as SUBABS4   *
*       and DOTPU4. The SUBABS4 takes the absolute difference on four 8     *
*       bit quantities packed into a 32 bit word. The DOTPU4 performs four  *
*       8 bit wide multiplies and adds the results together.                *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       void IMG_mad_16x16                                                  *
*       (                                                                   *
*           const unsigned char *restrict refImg,                           *
*           const unsigned char *restrict srcImg,                           *
*           int pitch, int h, int v,                                        *
*           unsigned int *restrict match                                    *
*       )                                                                   *
*       {                                                                   *
*           int i, j, x, y, matx, maty;                                     *
*           unsigned matpos, matval;                                        *
*                                                                           *
*           matval = ~0U;                                                   *
*           matx   = maty = 0;                                              *
*                                                                           *
*           for (x = 0; x < x; x++)                                         *
*               for (y = 0; y < v; y++)                                     *
*               {                                                           *
*                   unsigned acc = 0;                                       *
*                                                                           *
*                   for (i = 0; i < 16; i++)                                *
*                       for (j = 0; j < 16; j++)                            *
*                           acc += abs(srcImg[i*16 + j] -                   *
*                                      refImg[(i+y)*pitch + x + j]);        *
*                                                                           *
*                   if (acc < matval)                                       *
*                   {                                                       *
*                       matval = acc;                                       *
*                       matx   = x;                                         *
*                       maty   = y;                                         *
*                   }                                                       *
*               }                                                           *
*                                                                           *
*           matpos    = (0xffff0000 & (matx << 16)) |                       *
*                       (0x0000ffff & maty);                                *
*           match[0] = matpos;                                              *
*           match[1] = matval;                                              *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mad_16x16"
        .global _IMG_mad_16x16
_IMG_mad_16x16 .cproc A_ref_img, B_src_img, A_pitch, B_h, A_v, B_match 

          .no_mdep

          .reg    B_matval
          .reg    A_vl,           A_hl,        B_ml
          .reg    A_vl1,          A_bptch,     A_w
          .reg    A_vptch,        A_pitch_8,   A_k0x01010101
          .reg    B_k0x01010101,  A_sub,       B_src_imgcp

          ; variables for master loop

          .reg    B_ref_ri0a:B_ref_ri0b
          .reg    A_ref_ri0c:A_ref_ri0d

          .reg    B_matchi0, A_matchi1
          .reg    A_i,       A_ptch

          ; variables for loopx

          .reg    B_ref_ri1a:B_ref_ri1b
          .reg    A_ref_ri1c:A_ref_ri1d
          .reg    B_srchia:B_srchib
          .reg    A_srchic:A_srchid

          .reg    B_diffi_0a, B_diffi_0b
          .reg    A_diffi_0c, A_diffi_0d
          .reg    B_diffi_1a, B_diffi_1b
          .reg    A_diffi_1c, A_diffi_1d
          .reg    B_sumi0a,   B_sumi0b
          .reg    A_sumi0c,   A_sumi0d
          .reg    B_sumi1a,   B_sumi1b
          .reg    A_sumi1c,   A_sumi1d
          .reg    B_sumi0ab,  A_sumi0cd
          .reg    B_sumi0,    B_sumi1ab
          .reg    A_sumi1cd,  A_sumi1

          .reg    B_ref_ri2a:B_ref_ri2b
          .reg    A_ref_ri2c:A_ref_ri2d
          .reg    B_2srchia:B_2srchib
          .reg    A_2srchic:A_2srchid

          .reg    B_2diffi_0a,  B_2diffi_0b
          .reg    A_2diffi_0c,  A_2diffi_0d
          .reg    B_2diffi_1a,  B_2diffi_1b
          .reg    A_2diffi_1c,  A_2diffi_1d
          .reg    B_2sumi0a,    B_2sumi0b
          .reg    A_2sumi0c,    A_2sumi0d
          .reg    B_2sumi1a,    B_2sumi1b
          .reg    A_2sumi1c,    A_2sumi1d
          .reg    B_2sumi0ab,   A_2sumi0cd
          .reg    B_2sumi0,     B_2sumi1ab
          .reg    A_2sumi1cd,   A_2sumi1

          .reg    B_best,        A_best
          .reg    A_matval:A_matpos
          .reg    A_ffff,  A_subtract
          .reg    B_v

          ;----------------------------------------------------;
          ; Max out the match value. This is done by setting   ;
          ; the initial match value to -1. This is done by     ;
          ; the OR function.                                   ;
          ;----------------------------------------------------;

          OR.2     -1,              B_matval,       B_matval   ;


          ;----------------------------------------------------;
          ; Zero initial position. The coordinate system       ;
          ; assumes top left cooridinate as 0,0. Thus the      ;
          ; search space of horizontal width "H" and vertical  ;
          ; height "V" can be viewed as follows:               ;
          ;                                                    ;
          ;  (0,0)         (H,0)                  (H+16,0)     ;
          ;    ;-----------------------------------------;     ;
          ;    ;              |                          ;     ;
          ;    ;              |                          ;     ;
          ;    ;              |                          ;     ;
          ;    ;--------------|                          ;     ;
          ;  (0,V)          (H,V)                        ;     ;
          ;    ;                                         ;     ;
          ;    ;-----------------------------------------;     ;
          ;  (0, V+16)                            (V+16,H+16)  ;
          ;                                                    ;
          ;----------------------------------------------------;

          ZERO.1    A_matpos                                   ; matpos = 0

          ;----------------------------------------------------;
          ; Set A_ffff to obtain vl from packed coordinate     ;
          ; system used in loop, where cooridinates are        ;
          ; pached as h,v                                      ;
          ;----------------------------------------------------;

          MVKL.1    0x0000ffff,     A_ffff                     ; Constant
          MVKH.1    0x0000ffff,     A_ffff                     ; 0x0000FFFF

          ;----------------------------------------------------;
          ; Set up loop counters                               ;
          ; Vertical loop counts down v..1                     ;
          ; Horiz loop counts  0..h                            ;
          ; Master loop counter ml from hv..1                  ;
          ; Make copy of vertical loop, in vl and vl1 to break ;
          ; dependency between MAD update, and vertical loop   ;
          ; coordinate  reset.                                 ;
          ;----------------------------------------------------;

          MV.2x     A_v,            B_v                        ; Part. move
          MV.1      A_v,            A_vl                       ; vl  = v
          MV.1      A_v,            A_vl1                      ; vl1 = v
          ZERO.1                    A_hl                       ; hl  = 0
          MPY.2     B_v,            B_h,             B_ml      ; ml  = h * v
          ;----------------------------------------------------;
          ; Set up backward address patchup. Each pair of MADS ;
          ; steps forward by 17 rows, including post-increment ;
          ; (17 * pitch). Since we are computing 2 MADS        ;
          ; together we need to step back by 15 rows to        ;
          ; position on the second row. This back patch        ;
          ; "bptch" is for stepping back by 15 rows.           ;
          ;----------------------------------------------------;

          MPY.1      15,          A_pitch,       A_bptch       ; Horz. patch


          ;----------------------------------------------------;
          ; Set up the vertical patchup. To come back to       ;
          ; the starting point one needs to step back by       ;
          ; (15+v) rows. To point to next column advance       ;
          ; by one pixel.Since this will be subtracted         ;
          ; from existing pointer -1 is added because,         ;
          ; when subtracted it increments overall pointer      ;
          ; by 1.                                              ;
          ;----------------------------------------------------;

          ADD.1      A_v,         15,            A_w           ; Vertical
          MPY.1      A_w,         A_pitch,       A_vptch       ; fly back
          ADD.1       -1,         A_vptch,       A_vptch       ; pitch

          ;----------------------------------------------------;
          ; Subtract 8 from pitch to form pitch_8. This value  ;
          ; is needed because the first load increments by     ;
          ; eight bytes. This constant "pitch_8" is less than  ;
          ; the linearizinin pitch by 8 pixels.                ;
          ;----------------------------------------------------;

          SUB.1     A_pitch,      8,             A_pitch_8     ; pitch - 8

          ;----------------------------------------------------;
          ; Further load constant, "0x01010101" so that an     ;
          ; accumulate of the absolute difference can be done. ;
          ; This constant when used with the DOTPU4 instr.     ;
          ; sums up the four bytes in a word.                  ;
          ;----------------------------------------------------;


          MVKL.1    0x01010101,   A_k0x01010101                ; Set up
          MVKL.2    0x01010101,   B_k0x01010101                ; constant
          MVKH.1    0x01010101,   A_k0x01010101                ; "01010101"
          MVKH.2    0x01010101,   B_k0x01010101                ; on both A&B

          ;----------------------------------------------------;
          ; The vertical loop counter decrements by 2 since 2  ;
          ; MAD's are performed every cycle.                   ;
          ;----------------------------------------------------;


          ; flyback. At the end of the inner loop the srcimg   ;
          ; pointer is reset so that the new mad computation   ;
          ; can begin. In addition in order to reuse data      ;
          ; within the loop the src data for row i is loaded   ;
          ; Within the loop the src data for row i+2 is moved  ;
          ; back into row i. The accumulators that perform the ;
          ; 2 MAD computations are zeroed out before the start ;
          ; of the inner loop. The inner loop computes 2 rows  ;
          ; of 16 wide MADS and hence iterates for 8 times     ;
          ;----------------------------------------------------;

M_LOOP:

          ;----------------------------------------------------;
          ; The vertical loop counter "vl" decrements by 2     ;
          ; since 2 MAD's are performed every cycle.           ;
          ;----------------------------------------------------;

          ADD.1        -2,       A_vl,           A_vl          ; vl -= 2

          ;----------------------------------------------------;
          ; The patch amount "ptch" for the pointer is either  ;
          ; vertical patch or horizontal patch. Hence is one   ;
          ; iteration of the vertical loop, is completed,      ;
          ; "vl" is reest to "v".                              ;
          ;----------------------------------------------------;

          MV.1         A_bptch,  A_ptch                        ; ptch = bptch
[!A_vl]   MV.1         A_vptch,  A_ptch                        ; if (!v)
[!A_vl]   MV.1         A_v,      A_vl                          ; ptch = vptch

          ;----------------------------------------------------;
          ; At the end of the inner loop the srcimg pointer is ;
          ; reset so that the new mad computation can begin.   ;
          ;----------------------------------------------------;

          MV.2          B_src_img,              B_src_imgcp    ; Reset src

          ;----------------------------------------------------;
          ; Load row 0 of reference image, outside inner loop  ;
          ;                                                    ;
          ; ref_ri0a:ref_ri0b = p07p06p05p04:p03p02p01p00      ;
          ; ref_ri0c:ref_ri0d = p0Fp0Ep0Dp0C:p0Bp0Ap09p08      ;
          ;                                                    ;
          ; where, p00 means pixel 0 for row 0.                ;
          ; This represents the exact layout, of pixels as     ;
          ; they land. In addition in order to reuse data,     ;
          ; within the software pipelined loop, the first 16   ;
          ; pixels for the source data is loaded using 2       ;
          ; LDNDW's.                                           ;
          ;----------------------------------------------------;

          LDNDW.D1T2   *A_ref_img++(8),         B_ref_ri0a:B_ref_ri0b
          LDNDW.D1T1   *A_ref_img++(A_pitch_8), A_ref_ri0c:A_ref_ri0d

          ;----------------------------------------------------;
          ; The accumulators that perform the 2 MAD,           ;
          ; computations are zeroed out before the start of the;
          ; inner loop. These accumulators are "matchi0" and   ;
          ; "matchi1".                                         ;
          ;----------------------------------------------------;

          ZERO.2         B_matchi0                             ; matchi0 = 0
          ZERO.1         A_matchi1                             ; matchi1 = 1

          ;----------------------------------------------------;
          ; SADS stands for "Sum of Absolute Differences".     ;
          ; The inner loop computes 2 rows of 16 wide SADS. In ;
          ; addition this computation is done for 2 such SAD   ;
          ; candidates and accumulated in "matchi0","matchi1"  ;
          ; In order to compte a "16x16" SAD, 256 individual   ;
          ; SAD computations are rquired for each SAD          ;
          ; candidate.                                         ;
          ;----------------------------------------------------;


          ;----------------------------------------------------;
          ; Since the inner loop, only computes 32 SAD values  ;
          ; per candidate, it iterates 8 times to compute all  ;
          ; 256 values by iterating 8 times. This is specified ;
          ; to the compiler by specifying .trip to be 8. The   ;
          ; inner loop trip counter is "i". Refer C code.      ;
          ;----------------------------------------------------;

          MVK.1          8,          A_i                       ; i = 8

          ;--------------------------------------------------------;
          ; Inner loop works in the following way                  ;
          ; a) Fist load in reference image row i as two chunks    ;
          ; b) Read srch image row i to be loaded as two chunks    ;
          ; c) Compute the sum of absolute differences rowwise     ;
          ;    Namely row i of ref with row i of srch for mad0     ;
          ;    row i+1 with row i of srch for mad1                 ;
          ;    block i    with block i                             ;
          ;    block i + 1 with block i                            ;
          ;    Accumulate adjacent pixels along each row           ;
          ;    Now total up partial accumulations into full accum  ;
          ; d) Now load in ref img row i+2                         ;
          ; e) Read srch image row i+ 1 loaded as two chunks       ;
          ; f) Compute the sum of absolute differences rowwise     ;
          ;    Namely row i+1 of ref with row i+1 of srch          ;
          ;    row i+2 with row i+1 of srch for mad1               ;
          ;    block i+1    with block i+1                         ;
          ;    block i+2 with block i+1                            ;
          ;    Accumulate adjacent pixels within each row (i+1)    ;
          ;    Accumulate adjacent pixels within each row (i+2)    ;
          ;    Now total up partial accumulations into full accum  ;
          ; g) Move row i+2 to row i before branching back         ;
          ;                                                        ;
          ; At the end of the loop perform either vertical adjust  ;
          ; or flyback. Now compare madval against our best matches;
          ; Return packed coordinates as hl:vl                     ;
          ;--------------------------------------------------------;


LOOP_X:   .trip        8

          ;------------------------------------------------------;
          ; Load in reference image, row 1, ..15 using non       ;
          ; aligned format. Load in the source image, while      ;
          ; in theory this can be done using aligned loads,      ;
          ; nonaligned loads work just fine, as the load         ;
          ; bandwidth required is adequate.                      ;
          ;------------------------------------------------------;


          LDNDW.D1T2   *A_ref_img++(8),                 B_ref_ri1a:B_ref_ri1b
          LDNDW.D1T1   *A_ref_img++(A_pitch_8),         A_ref_ri1c:A_ref_ri1d

          LDNDW.D2T2    *B_src_imgcp++,                 B_srchia:B_srchib
          LDNDW.D2T1    *B_src_imgcp++,                 A_srchic:A_srchid

          ;------------------------------------------------------;
          ; Perform first 16 SAD computations for matchi0        ;
          ; Perform first 16 SAD computations for matchi1        ;
          ; Keep these 16 SAD computations uniformly part-       ;
          ; itioned between A and B data paths.                  ;
          ;------------------------------------------------------;

          SUBABS4.2     B_ref_ri0a,    B_srchia,        B_diffi_0a
          SUBABS4.2     B_ref_ri0b,    B_srchib,        B_diffi_0b
          SUBABS4.1     A_ref_ri0c,    A_srchic,        A_diffi_0c
          SUBABS4.1     A_ref_ri0d,    A_srchid,        A_diffi_0d

          SUBABS4.2     B_ref_ri1a,    B_srchia,        B_diffi_1a
          SUBABS4.2     B_ref_ri1b,    B_srchib,        B_diffi_1b
          SUBABS4.1     A_ref_ri1c,    A_srchic,        A_diffi_1c
          SUBABS4.1     A_ref_ri1d,    A_srchid,        A_diffi_1d

          DOTPU4.2      B_diffi_0a,    B_k0x01010101,   B_sumi0a
          DOTPU4.2      B_diffi_0b,    B_k0x01010101,   B_sumi0b
          DOTPU4.1      A_diffi_0c,    A_k0x01010101,   A_sumi0c
          DOTPU4.1      A_diffi_0d,    A_k0x01010101,   A_sumi0d

          DOTPU4.2      B_diffi_1a,    B_k0x01010101,   B_sumi1a
          DOTPU4.2      B_diffi_1b,    B_k0x01010101,   B_sumi1b
          DOTPU4.1      A_diffi_1c,    A_k0x01010101,   A_sumi1c
          DOTPU4.1      A_diffi_1d,    A_k0x01010101,   A_sumi1d

          ADD.2         B_sumi0a,      B_sumi0b,        B_sumi0ab
          ADD.1         A_sumi0c,      A_sumi0d,        A_sumi0cd
          ADD.2x        B_sumi0ab,     A_sumi0cd,       B_sumi0
          ADD.2         B_matchi0,     B_sumi0,         B_matchi0

          ADD.2         B_sumi1a,      B_sumi1b,        B_sumi1ab
          ADD.1         A_sumi1c,      A_sumi1d,        A_sumi1cd
          ADD.1x        A_sumi1cd,     B_sumi1ab,       A_sumi1
          ADD.1         A_matchi1,     A_sumi1,         A_matchi1

          ;-------------------------------------------------------;
          ; Load row 2 and row 3 data from reference image.       ;
          ; Also load row 1 of source image.                      ;
          ;-------------------------------------------------------;


          LDNDW.D1T2   *A_ref_img++(8),                B_ref_ri2a:B_ref_ri2b
          LDNDW.D1T1   *A_ref_img++(A_pitch_8),        A_ref_ri2c:A_ref_ri2d


          LDNDW.D2T2    *B_src_imgcp++,                B_2srchia:B_2srchib
          LDNDW.D2T1    *B_src_imgcp++,                A_2srchic:A_2srchid

          ;-------------------------------------------------------;
          ; Perform second set of sixteen SAD computations, for   ;
          ; matchi0 and matchi1. This will use row 1, and row 2   ;
          ; of the reference image.                               ;
          ;-------------------------------------------------------;


          SUBABS4.2     B_ref_ri1a,    B_2srchia,      B_2diffi_0a
          SUBABS4.2     B_ref_ri1b,    B_2srchib,      B_2diffi_0b
          SUBABS4.1     A_ref_ri1c,    A_2srchic,      A_2diffi_0c
          SUBABS4.1     A_ref_ri1d,    A_2srchid,      A_2diffi_0d


          SUBABS4.2     B_ref_ri2a,    B_2srchia,      B_2diffi_1a
          SUBABS4.2     B_ref_ri2b,    B_2srchib,      B_2diffi_1b
          SUBABS4.1     A_ref_ri2c,    A_2srchic,      A_2diffi_1c
          SUBABS4.1     A_ref_ri2d,    A_2srchid,      A_2diffi_1d


          DOTPU4.2      B_2diffi_0a,   B_k0x01010101,  B_2sumi0a
          DOTPU4.2      B_2diffi_0b,   B_k0x01010101,  B_2sumi0b
          DOTPU4.1      A_2diffi_0c,   A_k0x01010101,  A_2sumi0c
          DOTPU4.1      A_2diffi_0d,   A_k0x01010101,  A_2sumi0d


          DOTPU4.2      B_2diffi_1a,   B_k0x01010101,  B_2sumi1a
          DOTPU4.2      B_2diffi_1b,   B_k0x01010101,  B_2sumi1b
          DOTPU4.1      A_2diffi_1c,   A_k0x01010101,  A_2sumi1c
          DOTPU4.1      A_2diffi_1d,   A_k0x01010101,  A_2sumi1d

          ADD.2         B_2sumi0a,     B_2sumi0b,      B_2sumi0ab
          ADD.1         A_2sumi0c,     A_2sumi0d,      A_2sumi0cd
          ADD.2x        B_2sumi0ab,    A_2sumi0cd,     B_2sumi0
          ADD.2         B_matchi0,     B_2sumi0,       B_matchi0

          ADD.2         B_2sumi1a,     B_2sumi1b,      B_2sumi1ab
          ADD.1         A_2sumi1c,     A_2sumi1d,      A_2sumi1cd
          ADD.1x        A_2sumi1cd,    B_2sumi1ab,     A_2sumi1
          ADD.1         A_matchi1,     A_2sumi1,       A_matchi1

          ;-----------------------------------------------------;
          ; Move row 2 back into row 0, this will be used for   ;
          ; computing the next set of SAD's for matchi0.        ;
          ;-----------------------------------------------------;

          MV.2          B_ref_ri2a,    B_ref_ri0a
          MV.2          B_ref_ri2b,    B_ref_ri0b
          MV.1          A_ref_ri2c,    A_ref_ri0c
          MV.1          A_ref_ri2d,    A_ref_ri0d

[A_i]     ADD.1         A_i,            -1,            A_i
[A_i]     B.1           LOOP_X

          ;----------------------------------------------------;
          ; Reset patch to apply either horizontal patch, or   ;
          ; the vertical patch amount.                         ;
          ;----------------------------------------------------;

          SUB.1        A_ref_img,       A_ptch,        A_ref_img

          ;----------------------------------------------------;
          ; Compare 2 MAD candidates for tyheir minimum value, ;
          ; and prepare packed coordinates, and MAD value      ;
          ; found. Packed coordinates are returned in mat_pos  ;
          ; and minimum MAD value is returned in mat_val       ;
          ;----------------------------------------------------;


          ADD.1        -1,              A_vl1,         A_vl1
          CMPLTU.2     B_matchi0,       B_matval,      B_best
[B_best]  MV.2         B_matchi0,       B_matval
[B_best]  PACK2.1      A_hl,            A_vl1,         A_matpos

          ADD.1       -1,               A_vl1,         A_vl1
          CMPLTU.1x    A_matchi1,       B_matval,      A_best
[A_best]  MV.2x        A_matchi1,       B_matval
[A_best]  PACK2.1      A_hl,            A_vl1,         A_matpos

          ;---------------------------------------------------;
          ; If vertical loop, is completed reset horizontal   ;
          ; loop counter, and reset the vertical loop counter ;
          ;---------------------------------------------------;

[!A_vl1]  ADD.1        A_hl,            1,             A_hl
[!A_vl1]  MV.1         A_v,             A_vl1

          ;---------------------------------------------------;
          ; Decrement master loop by 2. This is because 2     ;
          ; MAD candidates are being performed in parallel.   ;
          ;---------------------------------------------------;


[B_ml]    ADD.2        B_ml,            -2,            B_ml
[B_ml]    B.2          M_LOOP

          ;---------------------------------------------------;
          ;  Correct for the fact that the "v" counter goes   ;
          ; down from V to zero. This is done by taking the   ;
          ; difference from "vl -1" and the existing v. Pack  ;
          ; existing horizontal "h" and new "v", and store    ;
          ; packed coordinate and the resulting MAD value     ;
          ; into the array.                                   ;
          ;---------------------------------------------------;

          MV.2         B_matval,        A_matval
          MV.1         A_v,             A_sub
          SUB.1        A_sub,           1,             A_sub
          AND.1        A_matpos,        A_ffff,        A_vl


          SUB.1        A_sub,           A_vl,          A_vl
          SHL.1        A_ffff,          16,            A_ffff
          AND.1        A_matpos,        A_ffff,        A_matpos
          ADD.1        A_matpos,        A_vl,          A_matpos

          ;---------------------------------------------------;
          ; Store into location passed by user.               ;
          ;---------------------------------------------------;

          STNDW        A_matval:A_matpos,              *B_match

           .return
           .endproc

* ========================================================================= *
*   End of file:  img_mad_16x16.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mad_8x8.sa/     1066928952  0     0     0       19084     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Mon Mar  4 02:24:20 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_mad_8x8 -- Minimum Absolute Difference motion search            *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable and has the following C prototype.       *
*                                                                           *
*       void IMG_mad_8x8                                                    *
*       (                                                                   *
*           const unsigned char * refImg, /* 8x8 Reference Image    */      *
*           const unsigned char * srcImg, /* Pointer to search area */      *
*           int pitch,                    /* Width of source image  */      *
*           int sx, int sy,               /* Search area dimensions */      *
*           unsigned int * motvec         /* Motion vector output   */      *
*       );                                                                  *
*                                                                           *
*       This routine accepts an 8x8 source block and a pointer to           *
*       a window to search within a bitmap.  The pointer "refImg"           *
*       points to the upper left corner of the search window.  The          *
*       parameters "sx" and "sy" describe the dimensions of the search      *
*       area.  The bitmap itself may be wider than the search window.       *
*       It's width is described by the "pitch" argument.                    *
*                                                                           *
*       The search area dimensions specify the range of positions that      *
*       the 8x8 source block is compared to.  This means that the           *
*       actual bitmap area examined extends 7 pixels beyond the right       *
*       and bottom edges of the search area within the reference image.     *
*                                                                           *
*       The best match position and its absolute difference are returned    *
*       in motvec, packed as follows:                                       *
*                                                                           *
*                      31             16 15             0                   *
*                      +----------------+----------------+                  *
*           motvec[0]: |    X offset    |    Y offset    |                  *
*                      +----------------+----------------+                  *
*                                                                           *
*                      31                               0                   *
*                      +---------------------------------+                  *
*           motvec[1]: |   Sum of absolute differences   |                  *
*                      +---------------------------------+                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IMG_mad_8x8 function performs a full search for an 8x8 block    *
*       within a specified search window.  It finds the position within     *
*       the search window that has the Minimum Absolute Difference with     *
*       respect to the given source block.                                  *
*                                                                           *
*       This type of search is useful for video algorithms which use        *
*       motion compensation.  The search performed by this routine is a     *
*       full search, meaning that all possible starting positions from      *
*       [0, 0] to [sx-1, sy-1] are checked for potential matches.           *
*                                                                           *
*       The Absolute Difference metric is calculated by summing the         *
*       absolute values of the differences between pixels in the            *
*       source block and their corresponding pixels for the match           *
*       point being evaluated in the reference image.  Smaller sums         *
*       denote better matches--that is, less overall difference between     *
*       the source block and match point in the reference block.            *
*                                                                           *
*       The algorithm returns the X and Y offsets of the best match         *
*       point, as well as the calculated Absolute Difference for that       *
*       position.  If two match points have equal Absolute Differences,     *
*       the earlier block in the search sequence is returned.  The          *
*       search presently checks in vertical stripes from top to bottom,     *
*       moving from 1 column to the right after each stripe.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input pointers do not alias the output pointer for motvec.      *
*       The source block is on a word boundary.                             *
*       The search area is at least 4 pixels by 4 pixels.                   *
*       The input reference bitmap pitch is at least 8.                     *
*                                                                           *
*   TECHNIQUES                                                              *
*       The two innermost loops are fully unrolled.                         *
*       The two outer loops are coalesced.  The final result is a single    *
*       level of loop nest instead of four levels of loop nest.             *
*                                                                           *
*       Instead of saving the exact [X,Y] of the best match, only the       *
*       loop iteration number is saved.  After the loop, the match          *
*       position is determined by division and modulus operations.          *
*                                                                           *
*       The potent combination SUBABS4 and DOTPU4 are used to compute       *
*       the sum of absolute differences for each block.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global __divu

        .sect ".text:_mad_8x8"
        .global _IMG_mad_8x8
_IMG_mad_8x8 .cproc  A_ref_d, B_src_img, A_p1, B_h_dim, A_v_dim, B_motvec
            .no_mdep

            .reg    B_hv
            .reg    A_i,          A_p7
            .reg    A_p2,           A_p3
            .reg    A_p4,           A_p5,         A_p6
            .reg    A_src_img,      B_v1c
            .reg    A_vfix,         A_hfix,       A_tmp0
            .reg    A_tmp1,         A_k_one, B_k_one
            .reg    B_hl,           A_f,          B_v1
            .reg    A_ref7h:A_ref7l,  B_ref6h:B_ref6l
            .reg    A_ref5h:A_ref5l,  B_ref4h:B_ref4l
            .reg    A_ref3h:A_ref3l,  B_ref2h:B_ref2l
            .reg    A_ref1h:A_ref1l,  B_ref0h:B_ref0l
            .reg    B_src0h,  B_src1h
            .reg    B_src2h,  B_src3h
            .reg    B_src4h,  B_src5h
            .reg    B_src6h,  B_src7h
            .reg    A_src0l,  A_src1l
            .reg    A_src2l,  A_src3l
            .reg    A_src4l,  A_src5l
            .reg    A_src6l,  A_src7l
            .reg    B_mad_7,  A_mad_7
            .reg    B_mad_6,  A_mad_6
            .reg    B_mad_5,  A_mad_5
            .reg    B_mad_4,  A_mad_4
            .reg    B_mad_3,  A_mad_3
            .reg    B_mad_2,  A_mad_2
            .reg    B_mad_1,  A_mad_1
            .reg    B_mad_0,  A_mad_0
            .reg    B_row_6,  A_row_6
            .reg    B_row_5,  A_row_5
            .reg    B_row_4,  A_row_4
            .reg    B_row_3,  A_row_3
            .reg    B_row_2,  A_row_2
            .reg    B_row_1,  A_row_1
            .reg    B_row_0,  A_row_0
            .reg    B_mad1,   A_mad0
            .reg    B_mad,    B_bst
            .reg    B_best_x, B_best_y
            .reg    B_y,      B_madloc
            .reg    B_err7h,  A_err7l
            .reg    B_err6h,  A_err6l
            .reg    B_err5h,  A_err5l
            .reg    B_err4h,  A_err4l
            .reg    B_err3h,  A_err3l
            .reg    B_err2h,  A_err2l
            .reg    B_err1h,  A_err1l
            .reg    B_err0h,  A_err0l
            .reg    A_v_new,  B_v_dim
            .reg    B_bhvl,   B_tmp2
            .reg    B_best, B_best_xy, B_hvl

            MV      .2X     A_v_dim,    B_v_dim
            MPYU    .1X     B_h_dim,    A_v_dim,    A_i
            SUB     .1      A_i,        1,          A_i
            ZERO    .2      B_hvl

            MPYSU           2,          A_p1,       A_p2    ;
            MPYSU           3,          A_p1,       A_p3    ;
            MPYSU           4,          A_p1,       A_p4    ;
            MPYSU           5,          A_p1,       A_p5    ;
            MPYSU           6,          A_p1,       A_p6    ;
            MPYSU           7,          A_p1,       A_p7    ;

            MV      .1X     B_src_img,    A_src_img
            .mptr           B_src_img, src + 0, 0
            .mptr           A_src_img, src + 0, 0
            LDW     .D2T2   *+B_src_img[15],        B_src7h
            LDW     .D1T1   *+A_src_img[14],        A_src7l
            LDW     .D2T2   *+B_src_img[13],        B_src6h
            LDW     .D1T1   *+A_src_img[12],        A_src6l
            LDW     .D2T2   *+B_src_img[11],        B_src5h
            LDW     .D1T1   *+A_src_img[10],        A_src5l
            LDW     .D2T2   *+B_src_img[ 9],        B_src4h
            LDW     .D1T1   *+A_src_img[ 8],        A_src4l
            LDW     .D2T2   *+B_src_img[ 7],        B_src3h
            LDW     .D1T1   *+A_src_img[ 6],        A_src3l
            LDW     .D2T2   *+B_src_img[ 5],        B_src2h
            LDW     .D1T1   *+A_src_img[ 4],        A_src2l
            LDW     .D2T2   *+B_src_img[ 3],        B_src1h
            LDW     .D1T1   *+A_src_img[ 2],        A_src1l
            LDW     .D2T2   *+B_src_img[ 1],        B_src0h
            LDW     .D1T1   *+A_src_img[ 0],        A_src0l

            MVK     .2      0x7FFF,         B_best

            ; hfix -- move to top of next column
            ; hfix = 1 - (v_dim - 1) * pitch = 1 - v_dim * pitch + pitch

            SUB     .1      A_v_dim,    1,          A_v_new
            MPY     .1      A_v_new,    A_p1,       A_tmp0
            SUB     .1      1,          A_tmp0,     A_hfix
            MV      .2      B_v_dim,    B_v1

            MVKL    .2      0x01010101, B_k_one
            MVKH    .2      0x01010101, B_k_one
            MV      .1X     B_k_one,    A_k_one

loop:       .trip           4

*************  Loop Control  *************************************************

            SUB     .2      B_v1,    1,     B_v1
            MV      .1      A_p1,           A_f
  [!B_v1]   MV      .1      A_hfix,         A_f
  [!B_v1]   MV      .2      B_v_dim,        B_v1

*************  Row 7  ********************************************************

            LDNDW   .D1T1  *A_ref_d(A_p7),  A_ref7h:A_ref7l
            SUBABS4 .2X     B_src7h,    A_ref7h,    B_err7h
            SUBABS4 .1      A_src7l,    A_ref7l,    A_err7l
            DOTPU4  .2      B_err7h,    B_k_one,    B_mad_7
            DOTPU4  .1      A_err7l,    A_k_one,    A_mad_7

*************  Row 6  ********************************************************

            LDNDW   .D1T2  *A_ref_d(A_p6),  B_ref6h:B_ref6l
            SUBABS4 .2      B_src6h,    B_ref6h,    B_err6h
            SUBABS4 .1X     A_src6l,    B_ref6l,    A_err6l
            DOTPU4  .2      B_err6h,    B_k_one,    B_row_6
            DOTPU4  .1      A_err6l,    A_k_one,    A_row_6
            ADD     .2      B_row_6,    B_mad_7,    B_mad_6
            ADD     .1      A_row_6,    A_mad_7,    A_mad_6

*************  Row 5  ********************************************************

            LDNDW   .D1T1  *A_ref_d(A_p5),  A_ref5h:A_ref5l
            SUBABS4 .2X     B_src5h,    A_ref5h,    B_err5h
            SUBABS4 .1      A_src5l,    A_ref5l,    A_err5l
            DOTPU4  .2      B_err5h,    B_k_one,    B_row_5
            DOTPU4  .1      A_err5l,    A_k_one,    A_row_5
            ADD     .2      B_row_5,    B_mad_6,    B_mad_5
            ADD     .1      A_row_5,    A_mad_6,    A_mad_5

*************  Row 4  ********************************************************

            LDNDW   .D1T2  *A_ref_d(A_p4),  B_ref4h:B_ref4l
            SUBABS4 .2      B_src4h,    B_ref4h,    B_err4h
            SUBABS4 .1X     A_src4l,    B_ref4l,    A_err4l
            DOTPU4  .2      B_err4h,    B_k_one,    B_row_4
            DOTPU4  .1      A_err4l,    A_k_one,    A_row_4
            ADD     .2      B_row_4,    B_mad_5,    B_mad_4
            ADD     .1      A_row_4,    A_mad_5,    A_mad_4

************  Row 3  ********************************************************

            LDNDW   .D1T1  *A_ref_d(A_p3),  A_ref3h:A_ref3l
            SUBABS4 .2X     B_src3h,    A_ref3h,    B_err3h
            SUBABS4 .1      A_src3l,    A_ref3l,    A_err3l
            DOTPU4  .2      B_err3h,    B_k_one,    B_row_3
            DOTPU4  .1      A_err3l,    A_k_one,    A_row_3
            ADD     .2      B_row_3,    B_mad_4,    B_mad_3
            ADD     .1      A_row_3,    A_mad_4,    A_mad_3

************  Row 2  ********************************************************

            LDNDW   .D1T2  *A_ref_d(A_p2),  B_ref2h:B_ref2l
            SUBABS4 .2      B_src2h,    B_ref2h,    B_err2h
            SUBABS4 .1X     A_src2l,    B_ref2l,    A_err2l
            DOTPU4  .2      B_err2h,    B_k_one,    B_row_2
            DOTPU4  .1      A_err2l,    A_k_one,    A_row_2
            ADD     .2      B_row_2,    B_mad_3,    B_mad_2
            ADD     .1      A_row_2,    A_mad_3,    A_mad_2

************  Row 1  ********************************************************

            LDNDW   .D1T1  *A_ref_d(A_p1),  A_ref1h:A_ref1l
            SUBABS4 .2X     B_src1h,    A_ref1h,    B_err1h
            SUBABS4 .1      A_src1l,    A_ref1l,    A_err1l
            DOTPU4  .2      B_err1h,    B_k_one,    B_row_1
            DOTPU4  .1      A_err1l,    A_k_one,    A_row_1
            ADD     .2      B_row_1,    B_mad_2,    B_mad_1
            ADD     .2X     A_row_1,    B_mad_1,    B_mad_1

************  Row 0  ********************************************************

            LDNDW   .D1T2  *A_ref_d++(A_f), B_ref0h:B_ref0l
            SUBABS4 .2      B_src0h,    B_ref0h,    B_err0h
            SUBABS4 .1X     A_src0l,    B_ref0l,    A_err0l
            DOTPU4  .2      B_err0h,    B_k_one,    B_row_0
            DOTPU4  .1      A_err0l,    A_k_one,    A_row_0
            ADD     .2      B_row_0,    B_mad_1,    B_mad_0
            ADD     .2X     A_row_0,    B_mad_0,    B_mad_0

************  Check for best match  *****************************************

            ADD     .2X     B_mad_0,    A_mad_2,    B_mad
            CMPGT2  .2      B_best,     B_mad,      B_bst
            ADD     .2      B_hvl,      1,          B_hvl
  [B_bst]   MV      .2      B_mad,                  B_best
  [B_bst]   SUB     .2      B_hvl,      1,          B_bhvl

  [A_i]     BDEC    .1      loop,       A_i

            STW             B_best,     *B_motvec[1]

            .call           B_best_x =__divu(B_bhvl,A_v_dim);

            MPYU            B_best_x,   A_v_dim,    B_tmp2
            SUB             B_bhvl,     B_tmp2,     B_best_y
            PACK2           B_best_x,   B_best_y,   B_best_xy
            STW             B_best_xy,  *B_motvec[0]

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_mad_8x8.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
median_3x3.sa/  1066928952  0     0     0       21028     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Thu Apr 18 02:01:26 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_median_3x3                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       04-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_median_3x3                                             *
*           (                                                               *
*              const unsigned char *restrict i_data, /* Input image     */  *
*              int n,                                /* Length of input */  *
*              unsigned char       *restrict o_data  /* Output image    */  *
*           )                                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 3x3 median filter operation on 8-bit         *
*       unsigned values.  The median filter comes under the class           *
*       of non-linear signal processing algorithms.                         *
*                                                                           *
*       Rather than replace the grey level at a pixel by a weighted         *
*       average of the nine pixels including and surrounding it, the        *
*       grey level at each pixel is replaced by the median of the nine      *
*       values.  The median of a set of nine numbers is the middle          *
*       element so that half of the elements in the list are larger and     *
*       half are smaller.  Median filters remove the effects of extreme     *
*       values from data, such as salt and pepper noise, although using     *
*       a wide may result in unacceptable blurring of sharp edges in        *
*       the original image.                                                 *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm without      *
*       restrictions.  The optimized implementations may have               *
*       restrictions, as noted under the "ASSUMPTIONS" below.               *
*                                                                           *
*       void IMG_median_3x3                                                 *
*       (                                                                   *
*           const unsigned char *restrict i_data,                           *
*           int n,                                                          *
*           unsigned char       *restrict o_data                            *
*       )                                                                   *
*       {                                                                   *
*           unsigned char c0h, c1h, c2h; /* "hi",  columns 0..2 */          *
*           unsigned char c0m, c1m, c2m; /* "mid", columns 0..2 */          *
*           unsigned char c0l, c1l, c2l; /* "lo",  columns 0..2 */          *
*           unsigned char h_min;         /* "min" */                        *
*           unsigned char m_mid;         /* "mid" */                        *
*           unsigned char l_max;         /* "max" */                        *
*           unsigned char m_h, m_l, t, out;                                 *
*                                                                           *
*           int i;                                                          *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Start off with a well-defined initial state.        */      *
*           /* ---------------------------------------------------- */      *
*           c1h = c2h = c1m = c2m = c1l = c2l = 127;                        *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Iterate over the input row.                         */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < n; i++)                                         *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Slide the two previous columns of sorted        */      *
*               /*  pixels over by 1.                               */      *
*               /* ------------------------------------------------ */      *
*               c0h = c1h;    c1h = c2h;                                    *
*               c0m = c1m;    c1m = c2m;                                    *
*               c0l = c1l;    c1l = c2l;                                    *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Load in a new column of pixels, and sort into   */      *
*               /*  low, medium, high.                              */      *
*               /* ------------------------------------------------ */      *
*               c2h = i_data[i      ];                                      *
*               c2m = i_data[i +   n];                                      *
*               c2l = i_data[i + 2*n];                                      *
*                                                                           *
*               if (c2l > c2h) { t = c2l; c2l = c2h; c2h = t; }             *
*               if (c2l > c2m) { t = c2l; c2l = c2m; c2m = t; }             *
*               if (c2m > c2h) { t = c2m; c2m = c2h; c2h = t; }             *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the minimum value of the "hi" terms.       */      *
*               /* ------------------------------------------------ */      *
*               h_min = c2h;                                                *
*               if (c1h < h_min) { h_min = c1h; }                           *
*               if (c0h < h_min) { h_min = c0h; }                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the middle value of the "mid" terms.       */      *
*               /* ------------------------------------------------ */      *
*               m_l   = c0m;                                                *
*               m_mid = c1m;                                                *
*               m_h   = c2m;                                                *
*                                                                           *
*               if (m_l   > m_h  ) { t = m_l; m_l = m_h; m_h = t; }         *
*               if (m_l   > m_mid) { m_mid = m_l; }                         *
*               if (m_mid > m_h  ) { m_mid = m_h; }                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the maximum value of the "lo" terms.       */      *
*               /* ------------------------------------------------ */      *
*               l_max = c2l;                                                *
*               if (c1l > l_max) { l_max = c1l; }                           *
*               if (c0l > l_max) { l_max = c0l; }                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Find the middle value of "h_min", "m_mid",      */      *
*               /*  "l_max" into "out".                             */      *
*               /* ------------------------------------------------ */      *
*               out = m_mid;                                                *
*                                                                           *
*               if (h_min > l_max) { t=h_min; h_min = l_max; l_max=t; }     *
*               if (h_min > out  ) { out = h_min; }                         *
*               if (out   > l_max) { out = l_max; }                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Store the resulting pixel.                      */      *
*               /* ------------------------------------------------ */      *
*               o_data[i] = out;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       This implementation uses an incremental sorting technique to        *
*       greatly reduce the number of compares and exchanges necessary       *
*       to sort the image pixels.                                           *
*                                                                           *
*       The main loop reads three new pixels from the input image each      *
*       iteration.  These three pixels form the right edge of the filter    *
*       mask.  The filter data from the previous iteration is "slid         *
*       over" by one pixel to form the complete 3x3 mask.                   *
*                                                                           *
*       As 3-pixel is read in from the image, the pixels are sorted,        *
*       resulting in a "lo", "medium" and "hi" pixel value for that         *
*       column.  The result is that the filter mask is sorted into          *
*       three rows -- a row of "minimums", a row of "middle values",        *
*       and a row of "maximums".                                            *
*                                                                           *
*       The median filter operates from this partially ordered mask.        *
*       It finds the smallest element in the row of "maximums",             *
*       the middle element in the row of "middle values", and               *
*       the largest element in the row of "minimums".  The median           *
*       value of these three values is the median for the entire 3x3        *
*       mask.                                                               *
*                                                                           *
*       This process minimizes compares, as the whole mask does not         *
*       need to be sorted between iterations.  Rather, the partial          *
*       ordering for two of the three columns from one iteration is         *
*       used directly for the next iteration.                               *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The length 'len' must be a multiple of four.                        *
*       The input pointers must be word aligned.                            *
*                                                                           *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Knuth, Donald E.  The_Art_of_Computer_Programming, Vol 3,           *
*           Pg. 180:  "Minimum Comparison Sorting."                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*==============================================================================*
        .sect ".text:_median_3x3"
        .global _IMG_median_3x3
_IMG_median_3x3: .cproc  A_ptr_in, B_n,  A_ptr_out
        .no_mdep
        .reg    A_line0
        .reg    A_x0_3210
        .reg    B_line1
        .reg    B_x1_3210
        .reg    B_line2
        .reg    B_x2_3210
        .reg    B_x1_3210_a
        .reg    B_x2_3210_a
        .reg    A_x0_3210_b
        .reg    A_x1_3210_b
        .reg    B_x1_3210_c
        .reg    B_x2_3210_c
        .reg    A_x01x00
        .reg    A_x00x01
        .reg    A_max0_3210
        .reg    A_x01
        .reg    A_max1_3210
        .reg    A_minmax_3210
        .reg    B_x21x20
        .reg    B_x20x21
        .reg    B_min0_3210
        .reg    B_x21
        .reg    B_min1_3210
        .reg    A_min2_3210
        .reg    B_maxmin_3210
        .reg    A_maxmin_3210
        .reg    B_x11x10
        .reg    B_x10x11
        .reg    B_med0_3210
        .reg    B_x11
        .reg    B_med1_3210
        .reg    B_maxmed_3210_0
        .reg    B_minmed_3210_0
        .reg    B_minmed_3210_1
        .reg    B_medmed_3210
        .reg    A_maxa_3210
        .reg    A_mina_3210
        .reg    A_minb_3210
        .reg    A_med_3210
        .reg    A_med_3210a
        .reg    A_med_3210b
        .reg    B_d1_3210_a
        .reg    B_m1_3210_a
        .reg    B_x1_3210_a0
        .reg    B_x1_3210_a1
        .reg    A_d_med_3210
        .reg    A_m_med_3210
        .reg    A_i
*==============================================================================*
         MV     .1  A_ptr_in,        A_line0
         ADD    .2X B_n,             A_line0,         B_line1
         ADD    .2  B_line1,         B_n,             B_line2

         MVKLH  .1  0x7f7f,          A_x01x00
         MVKLH  .2  0x7f7f,          B_x11x10
         MVKLH  .2  0x7f7f,          B_x21x20

         SHRU   .1X B_n,             2,               A_i
         SUB    .1  A_i,             2,               A_i
*==============================================================================*
LOOP:
         LDW .D1T1  *A_line0++,      A_x0_3210
         LDW .D2T2  *B_line1++,      B_x1_3210
         LDW .D2T2  *B_line2++,      B_x2_3210

         ;-------------sort 3 elements----------------;
         ;  x0_3210_b x1_3210_c x2_3210_c

         CMPGTU4.2  B_x2_3210,       B_x1_3210,       B_d1_3210_a
         XPND4  .2  B_d1_3210_a,     B_m1_3210_a
         AND    .2  B_x2_3210,       B_m1_3210_a,     B_x1_3210_a0
         ANDN   .2  B_x1_3210,       B_m1_3210_a,     B_x1_3210_a1
         OR     .2  B_x1_3210_a0,    B_x1_3210_a1,    B_x1_3210_a
         MINU4  .2  B_x2_3210,       B_x1_3210,       B_x2_3210_a
         MAXU4  .1X A_x0_3210,       B_x1_3210_a,     A_x0_3210_b
         MINU4  .1X A_x0_3210,       B_x1_3210_a,     A_x1_3210_b
         MAXU4  .2X B_x2_3210_a,     A_x1_3210_b,     B_x1_3210_c
         MINU4  .2X B_x2_3210_a,     A_x1_3210_b,     B_x2_3210_c
         ;--------------------------------------------;

         ; form 4 sets of transposed maximums for each output
         PACKLH2.1  A_x0_3210_b,     A_x01x00,        A_max0_3210
         SHLMB  .1  A_x01x00,        A_x0_3210_b,     A_max1_3210

         ; get 4 min of maxes
         MINU4  .1  A_max0_3210,     A_max1_3210,     A_minmax_3210
         MINU4  .1  A_minmax_3210,   A_x0_3210_b,     A_minmax_3210 ;A_max2_3210

         PACKLH2.2  B_x2_3210_c,     B_x21x20,        B_min0_3210
         SHLMB  .2  B_x21x20,        B_x2_3210_c,     B_min1_3210
         MV     .1X B_x2_3210_c,     A_min2_3210

         ; 4 max of mins
         MAXU4  .2  B_min0_3210,     B_min1_3210,     B_maxmin_3210
         MAXU4  .1X A_min2_3210,     B_maxmin_3210,   A_maxmin_3210

         PACKLH2.2  B_x1_3210_c,     B_x11x10,        B_med0_3210
         SHLMB  .2  B_x11x10,        B_x1_3210_c,     B_med1_3210

         ; 4 med of meds
         MAXU4  .2  B_med1_3210,     B_x1_3210_c,     B_maxmed_3210_0 ;med2_3-0
         MINU4  .2  B_med1_3210,     B_x1_3210_c,     B_minmed_3210_0 ;med2_3-0
         MINU4  .2  B_med0_3210,     B_maxmed_3210_0, B_minmed_3210_1
         MAXU4  .2  B_minmed_3210_1, B_minmed_3210_0, B_medmed_3210

         ; final med of medmed minmax and maxmin
         MAXU4  .1X A_maxmin_3210,   B_medmed_3210,   A_maxa_3210
         MINU4  .1X A_maxmin_3210,   B_medmed_3210,   A_mina_3210
         MINU4  .1  A_minmax_3210,   A_maxa_3210,     A_minb_3210
         CMPGTU4.1  A_minb_3210,     A_mina_3210,     A_d_med_3210
         XPND4  .1  A_d_med_3210,    A_m_med_3210
         AND    .1  A_minb_3210,     A_m_med_3210,    A_med_3210a
         ANDN   .1  A_mina_3210,     A_m_med_3210,    A_med_3210b
         OR     .1  A_med_3210a,     A_med_3210b,     A_med_3210

         MVD    .1  A_x0_3210_b,     A_x01x00
         MVD    .2  B_x1_3210_c,     B_x11x10
         MVD    .2  B_x2_3210_c,     B_x21x20

         STW .D1T1  A_med_3210,      *A_ptr_out++

         BDEC   .1  LOOP,            A_i
*==============================================================================*
            .return
            .endproc

* ========================================================================= *
*   End of file:  img_median_3x3.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mpeg2_vld0.sa/  1066928952  0     0     0       33305     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.11    Thu May 23 16:48:52 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_mpeg2_vld_inter                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6400                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Dec-2001                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine takes a bitstream of an MPEG-2 non-intra coded         *
*       macroblock and returns the decoded IDCT coefficients. The routine   *
*       is implemented as specified in the MPEG-2 standard text (ISO/IEC    *
*       13818-2). The routine checks the coded block pattern (cbp),         *
*       performs coefficient decoding inlcuding, variable length decode,    *
*       run-length expansion, inverse zigzag, dequantization, saturation    *
*       and mismatch control.                                               *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_mpeg2_vld_inter                                            *
*       (                                                                   *
*           const short    *restrict Wptr,                                  *
*           short          *restrict outi,                                  *
*           IMG_mpeg2_vld  *restrict Mpeg2v,                                *
*           int            mode_12Q4,                                       *
*           int            num_blocks,                                      *
*           int            bsbuf_words                                      *
*       );                                                                  *
*                                                                           *
*         Wptr:   Pointer to array that contains quantization matrix. The   *
*                 elements of the quantization matrix in *Wptr must be      *
*                 ordered according to the scan pattern used (zigzag or     *
*                 alternate scan). Video format 4:2:0 requires one          *
*                 quantization matrix (64 array elements).  For formats     *
*                 4:2:2 and 4:4:4 two quantization matrices (one for luma   *
*                 and one for chroma) must specified in the array (128      *
*                 array elements).                                          *
*                                                                           *
*         outi:   Pointer to the IDCT coefficients output array             *
*                 (6*64 elements), elements must be set to zero prior to    *
*                 function call.                                            *
*                                                                           *
*         Mpeg2v: Pointer to the context object containing the coding       *
*                 parameters of the MB to be decoded and the current state  *
*                 of the bitstream buffer. The structure is described       *
*                 below.                                                    *
*                                                                           *
*      mode_12Q4: 0: Coefficients are returned in normal 16-bit integer     *
*                 format.                                                   *
*                 Otherwise: Coefficients are returned in 12Q4 format       *
*                 (normal 16-bit integer format left shifted by 4). This    *
*                 mode is useful for directly passing the coefficients      *
*                 into the IMG_idct_8x8 routine.                            *
*                                                                           *
*     num_blocks: Number of blocks that the MB contains. Valid values are   *
*                 6 for 4:2:0, 8 for 4:2:2 and 12 for 4:4:4 format.         *
*                                                                           *
*    bsbuf_words: Size of bitstream buffer in words. Must be a power of 2.  *
*                 Bitstream buffer must be aligned at an address boundary   *
*                 equal to its size in bytes (bitstream buffer is           *
*                 addressed circularly by this routine.)                    *
*                                                                           *
*       The structure Mpeg2v is defined as follows:                         *
*                                                                           *
*C          #ifndef IMG_MPEG2_VLD_STRUCT_                                   *
*C          #define IMG_MPEG2_VLD_STRUCT_ 1                                 *
*C                                                                          *
*C          typedef struct {                                                *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;    // reserved                        *
*C          } IMG_mpeg2_vld;                                                *
*C                                                                          *
*C          #endif                                                          *
*                                                                           *
*       The Mpeg2v variables should  have a fixed layout since they are     *
*       accessed by this routine. If the layout is changed, the             *
*       corresponding changes have to be made in the assembly code too.     *
*                                                                           *
*       The routine sets the fault flag Mpeg2v.fault to 1 if an invalid     *
*       VLC code was encountered or the total run went beyond 63. In        *
*       theses cases the decoder has to resynchronize.                      *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream varaibles in Mpeg2v        *
*       have to be initialized. If bsbuf is a circular buffer and bsptr     *
*       contains the number of bits in the buffer that already have         *
*       been consumed, then next_wptr, bptr, word1, word2, top0 and         *
*       top1 are initialized as follows:                                    *
*                                                                           *
*       1. nextwptr: bsptr may not be a multiple of 32, therefore obtain    *
*       the next lower multiple of 32.                                      *
*                                                                           *
*           next_wptr = (bsptr >> 5);                                       *
*                                                                           *
*       2. bptr: bptr is the bit pointer which points to the current        *
*       bit WITHIN the word pointed to by next_wptr.                        *
*                                                                           *
*           bptr = bsptr & 31;                                              *
*           bptr_cmpl = 32 - bptr;                                          *
*                                                                           *
*       3. word1 and word2: read next 3 words from the bitstream buffer     *
*       (word0 is a temporary variable). bsbuf_words is the size of the     *
*       bitstream buffer in words.                                          *
*                                                                           *
*           word0 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word1 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word2 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*       4. top0 and top1: Shift words word0, word1, word2 by bptr to the    *
*       left so that the current bit becomes the MSB in word0. word0 can    *
*       simply be shifted by bptr; the then empty LSBs of word0 have to be  *
*       filled with the MSBs of word1. To do that the required MSBs are     *
*       brought into the position of empty LSBs of word0 by shifting word1  *
*       to the right by (32-bptr). The result is then copied into word0 by  *
*       an addition. Rather than overwriting word0, top0 is used to hold    *
*       the new bit aligned word. The same procedure is used to obtain      *
*       top1. top0 and top1 contain the next 64 bits of the bitstream.      *
*                                                                           *
*           s1 = word0 << bptr;                                             *
*           s2 = word1 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top0 = s1 + s2;                                                 *
*                                                                           *
*           s3 = word1 << bptr;                                             *
*           s4 = word2 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top1 = s3 + s4;                                                 *
*                                                                           *
*       Note that the routine returns the updated state of the bitstream    *
*       buffer variables, top0, top1, word1, word2, bptr and next_wptr. If  *
*       all other functions which access the bitstream in a decoder system  *
*       maintain the buffer variables in the same way, then the above       *
*       initialization procedure has to be performed only once at the       *
*       beginning.                                                          *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The instruction NORM is used to detect the number of leading zeros  *
*       or ones in a code word. This value together with additional bits    *
*       extracted from the codeword is then used as an index into look-up   *
*       tables to determine the length, run, level and sign. Escape code    *
*       sequences are directly extracted from the code word.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The bitstream must be stored in memory in 32-bit words which are    *
*       in little endian byte order.                                        *
*                                                                           *
*       Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 halfwords behind the weighting matrix should be      *
*       valid (e.g. peripherals). No memory is overwritten,                 *
*       only loads occurr.                                                  *
*                                                                           *
*       Note that the AMR register is set to zero on exit.                  *
*                                                                           *
*   MEMORY REQUIREMENTS                                                     *
*       1792 bytes for the lookup tables                                    *
*       (can be shared with mpeg2_vld_intra)                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global _IMG_len_tbl0
        .global _IMG_rld_table0

        .sect ".text:_mpeg2_vld_inter"
        .global _IMG_mpeg2_vld_inter
_IMG_mpeg2_vld_inter .cproc Wptr, outi, Mpeg2v, m12Q4, num_blocks, bsbuf_size
                    .no_mdep
;                          A4,   B4,   A6,     B6,    A8,         B8

* ========================================================================= *
*  Registers
* ========================================================================= *

    .reg block                      ; block number (0-3: lum, 4, 5: chrom)
    .reg cnt, cnt_sav
    .reg flag
    .reg const1, const24, const31, const32, const63, const128, const36
    .reg const65
    .reg amr_config, csr_bk, no_gie

* ------------------------------------------------------------------------- *
*  coded block pattern
* ------------------------------------------------------------------------- *
    .reg cbp, bcomp, cbp_mask, coded

* ------------------------------------------------------------------------- *
*  Decoding of the first coefficient
* ------------------------------------------------------------------------- *
    .reg tm

* ------------------------------------------------------------------------- *
*  32-bit words at 32-bit boundaries from bitstream buffer bsbuf[]
* ------------------------------------------------------------------------- *
    .reg bsbuf, word0, word1, word2, next_wptr, byte_diff
    .reg word1_rw

* ------------------------------------------------------------------------- *
*  bptr points to the current bit position within the current 32-bit
*  aligned word
* ------------------------------------------------------------------------- *
    .reg bptr, bptr1, bptr_cmpl, bptr0, bptr0_cmpl
    .reg e0, e1, bptr_adj, lz

* ------------------------------------------------------------------------- *
*  top0 and top1 contain the bitstream aligned at the beginning of the
*  VLC to decode
* ------------------------------------------------------------------------- *
    .reg empty1:top0, top0h:top0l, top1, empty:top0_bk
    .reg at1h:at1l, at2, at3, at4h:at4l, at6h:at6l, at7, at8, at9
    .reg more

* ------------------------------------------------------------------------- *
*  Variables for length, run and level decoding
* ------------------------------------------------------------------------- *
    .reg len_tbl_adr, len_c_tbl_adr
    .reg t1, t2, t4, t4b, t5, t7, t8, t9
    .reg sign, rld_left, rld_table_adr, rld_table_adr_1
    .reg run_level
    .reg run, run_bk, len, len_c, len_1
    .reg t3, t3b
    .reg level
    .reg s1, s2, s3, s4, s5, s6, eob_err, nrm, fault
    .reg no_esc, test2, test3

* ------------------------------------------------------------------------- *
*  Variables for de-quantization
* ------------------------------------------------------------------------- *
    .reg level2, level3, level4, level5, level_f
    .reg neg, pos, f1, f3, f5, f4, qW, sum, odd, last_coeff
    .reg Wptr_origin, Wptr_end, Zptr_origin, Zptr
    .reg W, Z, qscl

* ------------------------------------------------------------------------- *
*  Variables for 12Q4
* ------------------------------------------------------------------------- *
    .reg mism_bit, shift_12Q4, mask_12Q4, level6

* ------------------------------------------------------------------------- *
*  Variables for 4:2:2 and 4:4:4 support
* ------------------------------------------------------------------------- *
    .reg cc, chrom_mat

* ========================================================================= *
*  Get bitstream info
* ========================================================================= *
    LDW        *+Mpeg2v[0], bsbuf
    LDW        *+Mpeg2v[1], next_wptr
    LDW        *+Mpeg2v[2], bptr
    LDW        *+Mpeg2v[3], word1
    LDW        *+Mpeg2v[4], word2
    LDW        *+Mpeg2v[5], top0
    LDW        *+Mpeg2v[6], top1
    LDW        *+Mpeg2v[7], Zptr
    LDW        *+Mpeg2v[9], qscl
    LDW        *+Mpeg2v[11], cbp

* ========================================================================= *
*  Setup
* ========================================================================= *

     MVKL    _IMG_len_tbl0,   len_tbl_adr    ; length table
     MVKH    _IMG_len_tbl0,   len_tbl_adr
     MVKL    _IMG_rld_table0, rld_table_adr
     MVKH    _IMG_rld_table0, rld_table_adr

     ADD     1,      rld_table_adr,   rld_table_adr_1

 [!m12Q4]MVK     1,       mism_bit
 [!m12Q4]MVK     20,      shift_12Q4
 [!m12Q4]MVKL    0xFFFF,  mask_12Q4

 [m12Q4] MVK     16,      mism_bit
 [m12Q4] MVK     16,      shift_12Q4
 [m12Q4] MVKL    0xFFF0,  mask_12Q4

     MVK     1,      const1
     MVK     24,     const24
     MVK     31,     const31
     MVK     32,     const32
     MVK     36,     const36
     MVK     63,     const63
     MVK     65,     const65
     MVK    128,     const128

     ADD     Wptr,   const128, Wptr_end
     MV      Wptr,             Wptr_origin
     MV      Zptr,             Zptr_origin

     MVC     CSR,    csr_bk
     AND     csr_bk, -2, no_gie  ; disable all interrupts
     MVC     no_gie, CSR

* ========================================================================= *
*  Setup bitstream pointers: top0h:top0l, top1 contain top bitstream
* ========================================================================= *

     .reserve A5
     LMBD    1, bsbuf_size, amr_config
     SUB     const32, amr_config, amr_config
     SHL     amr_config, 16, amr_config
     ADD     amr_config,  4, amr_config
     MVC     amr_config, AMR

            ADDAW   bsbuf,      next_wptr,  A5

            SHRU    top0,       24,         top0h

            SHL     top0,       8,          t5
            SHRU    top1,       24,         t7
            ADD     t5,         t7,         top0l

            ADD     bptr,       8,          bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word1,      word1_rw
[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ========================================================================= *
*  Block loop setup
* ========================================================================= *

        SUB     num_blocks,  1, num_blocks
        MV      num_blocks,  cnt             ; dec cnt for block loop
        ZERO    fault

block_loop:
         SHL    const1,  cnt,   cbp_mask
         AND    cbp_mask,   cbp,  coded
         ZERO   sum

[!coded] ADD    outi,  const128,     outi    ; start of next 8x8 block
[!coded] B      cont

         MV      Zptr_origin,        Zptr    ; reset Zptr
         MV      Wptr_origin,        Wptr    ; reset Wptr

         SUB     num_blocks, cnt,    block
         CMPLT   block,      4,      flag   ; determine cc
         ZERO    cc
[!flag]  AND     block,      1,      cc
[!flag]  ADD     cc,         1,      cc

        ZERO    chrom_mat
[cc]    CMPGT   num_blocks, 5,       chrom_mat
[chrom_mat]ADD  Wptr_origin, const128, Wptr
        ADD     Wptr,   const128, Wptr_end

        ZERO    eob_err

* ========================================================================= *
*  Decode first coefficient
* ========================================================================= *
        SHRU    top0h, 7, tm
[!tm]   B       ac_loop_init

* ------------------------------------------------------------------------- *
*  Length computation: len=2, len_c=30
* ------------------------------------------------------------------------- *

* ------------------------------------------------------------------------- *
*  advance bitstream
* ------------------------------------------------------------------------- *
            SHL     top0h:top0l, 2,         at6h:at6l
            SHRU    top1,        30,        at7

            ADD     at6l,       at7,        top0l

            ADD     bptr,        2,          bptr1
            CMPGT   bptr1,       const31,    test2

[test2]     MV      word1,       word1_rw
[test2]     MV      word2,       word1
[test2]     LDW     *A5++,       word2

            AND     bptr1,       const31,    bptr
            SUB     const32,     bptr,       bptr_cmpl

            SHL     word1,       bptr,       at8
            SHRU    word2,       bptr_cmpl,  at9
            ADD     at8,         at9,        top1

* ------------------------------------------------------------------------- *
*  Run-Level "normal" code decode: run=0, level=1
* ------------------------------------------------------------------------- *
            EXTU    top0h,   25, 31,  neg         ; extract sign bit
            MV      at6h,             top0h       ; now update

* ------------------------------------------------------------------------- *
*  De-quantization
* ------------------------------------------------------------------------- *

            MVK      3,     level2
[neg]       MVK     -3,     level2

            LDH     *Wptr++,  W

            MPY     qscl,     W,        qW
            MPY     qW,       level2,   level4

[neg]       ADD     level4,   const31,  level4  ; add rounding constant
            SSHL    level4,   15,       level5  ; saturate
            SHR     level5,   shift_12Q4, level6
            AND     level6,   mask_12Q4,  level_f

            ADD     sum,      level_f,  sum     ; for mismatch contol

            ADD     Zptr,     1,        Zptr

            STH     level_f,  *outi

* ========================================================================= *
*  Decode AC coefficients
* ========================================================================= *

ac_loop_init:

            NORM    top0h:top0l,   nrm

ac_loop:    .trip 1

* ------------------------------------------------------------------------- *
*  Length computation
* ------------------------------------------------------------------------- *

            SHL     top0h:top0l,  nrm,    at1h:at1l  ; all leading 0s/1s

            SHL     nrm,    4,    at2                ; sub-table index

            ADD     len_tbl_adr,  at2,      at3
            SHRU    at1h:at1l,    const36,  at4h:at4l  ; 4 extra bits

            LDBU    *at3[at4l],   len                  ; get length

            SUB     const32,      len,     len_c

* ------------------------------------------------------------------------- *
*  advance bitstream
* ------------------------------------------------------------------------- *
            SHL     top0h:top0l,  len,      at6h:at6l

            NORM    at6h:at6l,    nrm                      ; hi8:lo32
            SHRU    top1,         len_c,    at7
            SHRU    top0h:top0l,  8,        empty:top0_bk

            MV      at6h,         top0h
            ADD     at6l,         at7,      top0l

            ADD     bptr,       len,        bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word1,      word1_rw
[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       at8
            SHRU    word2,      bptr_cmpl,  at9
            ADD     at8,        at9,        top1

* ------------------------------------------------------------------------- *
*  Run-Level escape code decode
* ------------------------------------------------------------------------- *
            SUB     len,        const24,        no_esc
            EXTU    top0_bk,    6,      26,     run
            EXT     top0_bk,    12,     20,     level

* ------------------------------------------------------------------------- *
*  Run-Level "normal" code decode
* ------------------------------------------------------------------------- *
            SUB     len,        5,          rld_left
            CMPLT   len,        5,          test3
[test3]     ZERO    rld_left

            SHL     len,        5,          t2
            SHL     top0_bk,    rld_left,   t3    ; align last 5 bits to MSB
            SHRU    t3,         27,         t3    ; keep last 5 bits inc sign
            ADD     t2,         t3,         t4    ; add to sub-table index

            ADD     t4,         t4,         t4b   ; entries are half-words
[no_esc]    LDB     *rld_table_adr[t4b],    level ; access
[no_esc]    LDB     *rld_table_adr_1[t4b],  run   ; A_rld_table_adr+1

* ------------------------------------------------------------------------- *

            CMPGT   run,    const63,     eob_err

* ------------------------------------------------------------------------- *
*  De-quantization
* ------------------------------------------------------------------------- *

            CMPLT   level,    0,        sign

            MPY     level,    2,        level2

[!sign]     ADD     level2,   1,        level3
[sign]      SUB     level2,   1,        level3

[!eob_err]  LDH     *++Wptr[run],       W
[!eob_err]  ADD     Wptr,     2,        Wptr
[!eob_err]  CMPGT   Wptr,     Wptr_end, eob_err

            MPY     qscl,     W,        qW
            MPY     qW,       level3,   level4

[sign]      ADD     level4,   const31,  level4  ; add rounding constant
            SSHL    level4,   15,       level5  ; saturate
            SHR     level5,   shift_12Q4, level6
            AND     level6,   mask_12Q4,  level_f

[!eob_err]  ADD     sum,      level_f,  sum     ; for mismatch contol

[!eob_err]  LDB     *++Zptr[run],       Z
            ADD     Zptr,     1,        Zptr

[!eob_err]  STH     level_f,  *+outi[Z]

[!eob_err]  B       ac_loop

* ========================================================================= *
*  Block loop:
* ========================================================================= *
mismatch:
            ADD     outi,  const128,     outi    ; start of next 8x8 block

* ------------------------------------------------------------------------- *
*  Mismatch control: if sum is even, toggle last bit of last coefficient
* ------------------------------------------------------------------------- *
            AND     mism_bit,   sum,    odd
[!odd]      LDH     *-outi[1],          last_coeff
[!odd]      XOR     mism_bit,           last_coeff, last_coeff
[!odd]      STH     last_coeff,         *-outi[1]

        CMPGT      run,      const65, fault
[!fault]CMPGT      Wptr,     Wptr_end,fault
[fault] B          exit

cont:
[cnt]       BDEC    block_loop,  cnt

* ========================================================================= *
*  Exit: update bistream pointer
* ========================================================================= *
exit:
        SUB        A5,          bsbuf, byte_diff
        SHR        byte_diff,   2,     next_wptr

        SHRU       top0h:top0l, 8,    empty1:top0
        SHL        top0l,       24,   e0
        SHRU       top1,        8,    e1
        ADD        e0,          e1,   top1

        SUB        bptr,        8,    bptr
        CMPLT      bptr,        0,    lz
[lz]    MV         word1,             word2
[lz]    MV         word1_rw,          word1
[lz]    ADD        bptr,     const32, bptr

[lz]    SUBAW      A5,          1,     A5
[lz]    SUB        A5,          bsbuf, byte_diff
[lz]    SHR        byte_diff,   2,     next_wptr

        STW        next_wptr,   *+Mpeg2v[1]
        STW        bptr,        *+Mpeg2v[2]
        STW        word1,       *+Mpeg2v[3]
        STW        word2,       *+Mpeg2v[4]
        STW        top0,        *+Mpeg2v[5]
        STW        top1,        *+Mpeg2v[6]
        STW        fault,       *+Mpeg2v[12]

        ZERO    amr_config
        MVC     amr_config, AMR

        MVC     csr_bk,     CSR     ; restore interrupts

    .endproc

* ========================================================================= *
*   End of file:  ti_mpeg2_vld_inter                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mpeg2_vld1.sa/  1066928952  0     0     0       37136     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.14    Wed May  1 18:09:35 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_mpeg2_vld_intra                                                 *
*                                                                           *
*   PLATFORM                                                                *
*       C6400                                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Dec-2001                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine takes a bitstream of an MPEG-2 intra coded macroblock  *
*       and returns the decoded IDCT coefficients. The routine is           *
*       implemented as specified in the MPEG-2 standard text (ISO/IEC       *
*       13818-2). The routine checks the coded block pattern (cbp),         *
*       performs DC and AC decoding inlcuding, variable length decode,      *
*       run-length expansion, inverse zigzag, dequantization, saturation    *
*       and mismatch control.                                               *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_mpeg2_vld_intra                                            *
*       (                                                                   *
*           const short    *restrict Wptr,                                  *
*           short          *restrict outi,                                  *
*           IMG_mpeg2_vld  *restrict Mpeg2v,                                *
*           int            dc_pred[3],                                      *
*           int            mode_12Q4,                                       *
*           int            num_blocks,                                      *
*           int            bsbuf_words                                      *
*       );                                                                  *
*                                                                           *
*         Wptr:   Pointer to array that contains quantization matrix. The   *
*                 elements of the quantization matrix in *Wptr must be      *
*                 ordered according to the scan pattern used (zigzag or     *
*                 alternate scan). Video format 4:2:0 requires one          *
*                 quantization matrix (64 array elements).  For formats     *
*                 4:2:2 and 4:4:4 two quantization matrices (one for luma   *
*                 and one for chroma) must specified in the array (128      *
*                 array elements).                                          *
*                                                                           *
*         outi:   Pointer to the IDCT coefficients output array             *
*                 (6*64 elements), elements must be set to zero prior to    *
*                 function call.                                            *
*                                                                           *
*         Mpeg2v: Pointer to the context object containing the coding       *
*                 parameters of the MB to be decoded and the current state  *
*                 of the bitstream buffer. The structure is described       *
*                 below.                                                    *
*                                                                           *
*        dc_pred: Intra DC prediction array, the first element of dc_pred   *
*                 is the DC prediction for Y, the second for Cr and the     *
*                 third for Cb.                                             *
*                                                                           *
*      mode_12Q4: 0: Coefficients are returned in normal 16-bit integer     *
*                 format.                                                   *
*                 Otherwise: Coefficients are returned in 12Q4 format       *
*                 (normal 16-bit integer format left shifted by 4). This    *
*                 mode is useful for directly passing the coefficients      *
*                 into the IMG_idct_8x8 routine.                            *
*                                                                           *
*     num_blocks: Number of blocks that the MB contains. Valid values are   *
*                 6 for 4:2:0, 8 for 4:2:2 and 12 for 4:4:4 format.         *
*                                                                           *
*    bsbuf_words: Size of bitstream buffer in words. Must be a power of 2.  *
*                 Bitstream buffer must be aligned at an address boundary   *
*                 equal to its size in bytes (bitstream buffer is           *
*                 addressed circularly by this routine.)                    *
*                                                                           *
*       The structure Mpeg2v is defined as follows:                         *
*                                                                           *
*C        #ifndef IMG_MPEG2_VLD_STRUCT_                                     *
*C        #define IMG_MPEG2_VLD_STRUCT_ 1                                   *
*C                                                                          *
*C        typedef struct {                                                  *
*C            unsigned int  *bsbuf;      // pointer to bitstream buffer     *
*C            unsigned int  next_wptr;   // next word to read from buffer   *
*C            unsigned int  bptr;        // bit position within word        *
*C            unsigned int  word1;       // word aligned buffer             *
*C            unsigned int  word2;       // word aligned buffer             *
*C            unsigned int  top0;        // top 32 bits of bitstream        *
*C            unsigned int  top1;        // next 32 bits of bitstream       *
*C            const unsigned char *scan; // inverse zigzag scan matrix      *
*C            unsigned int  intravlc;    // intra_vlc_format                *
*C            unsigned int  quant_scale; // quant_scale                     *
*C            unsigned int  dc_prec;     // intra_dc_precision              *
*C            unsigned int  cbp;         // coded_block_pattern             *
*C            unsigned int  fault;       // fault condition (returned)      *
*C            unsigned int  reserved;    // reserved                        *
*C        } IMG_mpeg2_vld;                                                  *
*C                                                                          *
*C        #endif                                                            *
*                                                                           *
*       The Mpeg2v variables should have a fixed layout since they are      *
*       accessed by this routine.  If the layout is changed, the            *
*       corresponding changes have to be made in the assembly code too.     *
*                                                                           *
*       The routine sets the fault flag Mpeg2v.fault to 1 if an invalid     *
*       VLC code was encountered or the total run went beyond 63. In        *
*       theses cases the decoder has to resynchronize.                      *
*                                                                           *
*       The required lookup tables for this routine are provided in         *
*       IMGLIB and are linked in automatically when linking against         *
*       IMGLIB.                                                             *
*                                                                           *
*       Before calling the routine the bitstream variables in Mpeg2v        *
*       have to be initialized. If bsbuf is a circular buffer and bsptr     *
*       contains the number of bits in the buffer that already have         *
*       been consumed, then next_wptr, bptr, word1, word2, top0 and         *
*       top1 are initialized as follows:                                    *
*                                                                           *
*       1. nextwptr: bsptr may not be a multiple of 32, therefore obtain    *
*       the next lower multiple of 32.                                      *
*                                                                           *
*           next_wptr = (bsptr >> 5);                                       *
*                                                                           *
*       2. bptr: bptr is the bit pointer which points to the current        *
*       bit WITHIN the word pointed to by next_wptr.                        *
*                                                                           *
*           bptr = bsptr & 31;                                              *
*           bptr_cmpl = 32 - bptr;                                          *
*                                                                           *
*       3. word1 and word2: read next 3 words from the bitstream buffer     *
*       (word0 is a temporary variable). bsbuf_words is the size of the     *
*       bitstream buffer in words.                                          *
*                                                                           *
*           word0 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word1 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*           word2 = bsbuf[next_wptr];                                       *
*           next_wptr = (next_wptr + 1) & (bsbuf_words-1);                  *
*                                                                           *
*       4. top0 and top1: Shift words word0, word1, word2 by bptr to the    *
*       left so that the current bit becomes the MSB in word0. word0 can    *
*       simply be shifted by bptr; the then empty LSBs of word0 have to be  *
*       filled with the MSBs of word1. To do that the required MSBs are     *
*       brought into the position of empty LSBs of word0 by shifting word1  *
*       to the right by (32-bptr). The result is then copied into word0 by  *
*       an addition. Rather than overwriting word0, top0 is used to hold    *
*       the new bit aligned word. The same procedure is used to obtain      *
*       top1. top0 and top1 contain the next 64 bits of the bitstream.      *
*                                                                           *
*           s1 = word0 << bptr;                                             *
*           s2 = word1 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top0 = s1 + s2;                                                 *
*                                                                           *
*           s3 = word1 << bptr;                                             *
*           s4 = word2 >> bptr_cmpl;  /* unsigned right-shift */            *
*           top1 = s3 + s4;                                                 *
*                                                                           *
*       Note that the routine returns the updated state of the bitstream    *
*       buffer variables, top0, top1, word1, word2, bptr and next_wptr. If  *
*       all other functions which access the bitstream in a decoder system  *
*       maintain the buffer variables in the same way, then the above       *
*       initialization procedure has to be performed only once at the       *
*       beginning.                                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*       The instruction NORM is used to detect the number of leading zeros  *
*       or ones in a code word. This value together with additional bits    *
*       extracted from the codeword is then used as an index into look-up   *
*       tables to determine the length, run, level and sign. Escape code    *
*       sequences are directly extracted from the code word.                *
*                                                                           *
*       DC coefficients are decoded without lookup tables by exploiting     *
*       the relatively simple relationship between the number of leading    *
*       zeros and dc_size and the length of the code word.                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The bitstream must be stored in memory in 32-bit words which are    *
*       in little endian byte order.                                        *
*                                                                           *
*       Wptr is allowed to overrun once (to detect total run overrun), so   *
*       maximum overrun that can occur is 66 (Error mark). Therefore,       *
*       in memory 66+1 halfwords behind the weighting matrix should be      *
*       valid (e.g. peripherals). No memory is overwritten,                 *
*       only loads occurr.                                                  *
*                                                                           *
*       Note that the AMR register is set to zero on exit.                  *
*                                                                           *
*   DATA SIZE                                                               *
*       3584 bytes for the lookup tables                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global _IMG_len_tbl0
        .global _IMG_rld_table0

        .global _IMG_len_tbl1
        .global _IMG_rld_table1

        .sect ".text:_mpeg2_vld_intra"
        .global _IMG_mpeg2_vld_intra
_IMG_mpeg2_vld_intra .cproc Wptr, outi, Mpeg2v, dc_pred, m12Q4, num_blocks, bsbuf_size
                    .no_mdep
;                           A4,   B4,   A6,     B6,     A8,    B8,         A10
* ========================================================================= *
*  Registers                                                                *
* ========================================================================= *

    .reg block                      ; block number (0-3: lum, 4, 5: chrom)
    .reg cnt, cnt_sav
    .reg flag
    .reg const1, const24, const31, const32, const63
    .reg const128, const36, const65
    .reg amr_config, csr_bk, no_gie

* ------------------------------------------------------------------------- *
*  coded block pattern                                                      *
* ------------------------------------------------------------------------- *
    .reg cbp, bcomp, cbp_mask, coded

* ------------------------------------------------------------------------- *
*  32-bit words at 32-bit boundaries from bitstream buffer bsbuf[]          *
* ------------------------------------------------------------------------- *
    .reg bsbuf, word0, word1, word2, next_wptr, byte_diff
    .reg word1_rw

* ------------------------------------------------------------------------- *
*  bptr points to the current bit position within the current 32-bit        *
*  aligned word
* ------------------------------------------------------------------------- *
    .reg bptr, bptr1, bptr_cmpl, bptr0, bptr0_cmpl
    .reg e0, e1, bptr_adj, lz

* ------------------------------------------------------------------------- *
*  top0 and top1 contain the bitstream aligned at the beginning of the      *
*  VLC to decode                                                            *
* ------------------------------------------------------------------------- *
    .reg empty1:top0, top0h:top0l, top1, empty:top0_bk
    .reg at1h:at1l, at2, at3, at4h:at4l, at6h:at6l, at7, at8, at9
    .reg more

* ------------------------------------------------------------------------- *
*  Variables for intra DC decoding                                          *
* ------------------------------------------------------------------------- *
    .reg cc, a_cc0, a_cc1, b, c, d, dc_size, b_1
    .reg dc_diff, val, half_range, pred, test0
    .reg intra_dc_precision

* ------------------------------------------------------------------------- *
*  Variables for length, run and level decoding                             *
* ------------------------------------------------------------------------- *
    .reg len_tbl_adr, len_c_tbl_adr
    .reg t1, t2, t4, t4b, t5, t6, t7, t8, t9
    .reg sign, rld_left, rld_table_adr, rld_table_adr_1
    .reg run_level
    .reg run, len, len_c, len_1
    .reg t3, t3b
    .reg level
    .reg s1, s2, s3, s4, s5, s6, eob_err, nrm, fault
    .reg no_esc, test2, test3
    .reg intra_vlc_format

* ------------------------------------------------------------------------- *
*  Variables for de-quantization                                            *
* ------------------------------------------------------------------------- *
    .reg level2, level3, level4, level5, level_f
    .reg neg, pos, f1, f3, f5, f4, qW, sum, odd, last_coeff
    .reg Wptr_origin, Wptr_end, Zptr_origin, Zptr
    .reg W, Z, qscl

* ------------------------------------------------------------------------- *
*  Variables for 12Q4                                                       *
* ------------------------------------------------------------------------- *
    .reg mism_bit, shift_12Q4, mask_12Q4, level6

* ------------------------------------------------------------------------- *
*  Variables for 4:2:2 and 4:4:4 support                                    *
* ------------------------------------------------------------------------- *
    .reg chrom_mat

* ========================================================================= *
*  Get bitstream info                                                       *
* ========================================================================= *
    LDW        *+Mpeg2v[0], bsbuf
    LDW        *+Mpeg2v[1], next_wptr
    LDW        *+Mpeg2v[2], bptr
    LDW        *+Mpeg2v[3], word1
    LDW        *+Mpeg2v[4], word2
    LDW        *+Mpeg2v[5], top0
    LDW        *+Mpeg2v[6], top1
    LDW        *+Mpeg2v[7], Zptr
    LDW        *+Mpeg2v[8], intra_vlc_format
    LDW        *+Mpeg2v[9], qscl
    LDW        *+Mpeg2v[10], intra_dc_precision
    LDW        *+Mpeg2v[11], cbp

* ========================================================================= *
*  Setup                                                                    *
* ========================================================================= *

[!intra_vlc_format] MVKL    _IMG_len_tbl0,   len_tbl_adr    ; length table
[!intra_vlc_format] MVKH    _IMG_len_tbl0,   len_tbl_adr
[!intra_vlc_format] MVKL    _IMG_rld_table0, rld_table_adr
[!intra_vlc_format] MVKH    _IMG_rld_table0, rld_table_adr

[intra_vlc_format]  MVKL    _IMG_len_tbl1,   len_tbl_adr    ; length table
[intra_vlc_format]  MVKH    _IMG_len_tbl1,   len_tbl_adr
[intra_vlc_format]  MVKL    _IMG_rld_table1, rld_table_adr
[intra_vlc_format]  MVKH    _IMG_rld_table1, rld_table_adr

        ADD     1,      rld_table_adr,   rld_table_adr_1

 [!m12Q4]MVK     1,       mism_bit
 [!m12Q4]MVK     20,      shift_12Q4
 [!m12Q4]MVKL    0xFFFF,  mask_12Q4

 [m12Q4] MVK     16,      mism_bit
 [m12Q4] MVK     16,      shift_12Q4
 [m12Q4] MVKL    0xFFF0,  mask_12Q4
 [m12Q4] SUB     intra_dc_precision, 4, intra_dc_precision

        MVK     1,      const1
        MVK     24,     const24
        MVK     31,     const31
        MVK     32,     const32
        MVK     36,     const36
        MVK     63,     const63
        MVK     65,     const65
        MVK    128,     const128

        ADD     Wptr,   const128, Wptr_end
        MV      Wptr,             Wptr_origin
        MV      Zptr,             Zptr_origin

        MVC     CSR,    csr_bk
        AND     csr_bk, -2, no_gie  ; disable all interrupts
        MVC     no_gie, CSR

* ========================================================================= *
*  Setup bitstream pointers: top0h:top0l, top1 contain top bitstream        *
* ========================================================================= *
         .reserve A5
         LMBD    1, bsbuf_size, amr_config
         SUB     const32, amr_config, amr_config
         SHL     amr_config, 16, amr_config
         ADD     amr_config,  4, amr_config
         MVC     amr_config, AMR

            ADDAW   bsbuf,      next_wptr,  A5

            SHRU    top0,       24,         top0h

            SHL     top0,       8,          t5
            SHRU    top1,       24,         t7
            ADD     t5,         t7,         top0l

            ADD     bptr,       8,          bptr1
            CMPGT   bptr1,      const31,    test2

[test2]     MV      word1,      word1_rw
[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr1,      const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       t8
            SHRU    word2,      bptr_cmpl,  t9
            ADD     t8,         t9,         top1

* ========================================================================= *
*  Block loop setup                                                         *
* ========================================================================= *

         SUB     num_blocks,  1, num_blocks
         MV      num_blocks,  cnt             ; dec cnt for block loop
         ZERO    fault

block_loop:
         SHL    const1,     cnt,   cbp_mask
         AND    cbp_mask,   cbp,   coded
         ZERO   sum

[!coded] ADD    outi,  const128,     outi      ; set to next 8x8 block
[!coded] B      cont

         MV      Zptr_origin,        Zptr    ; reset Zptr
         MV      Wptr_origin,        Wptr    ; reset Wptr

         SUB     num_blocks, cnt,    block
         CMPLT   block,      4,      flag    ; determine cc
         ZERO    cc
[!flag]  AND     block,      1,      cc
[!flag]  ADD     cc,         1,      cc

        ZERO    chrom_mat
[cc]    CMPGT   num_blocks, 5,       chrom_mat
[chrom_mat]ADD  Wptr_origin, const128, Wptr
        ADD     Wptr,   const128, Wptr_end

         ZERO    eob_err

* ========================================================================= *
*  Decode intra DC coefficient                                              *
* ========================================================================= *

* ------------------------------------------------------------------------- *
*  Intra DC: decode dct_size and len (luminance and chrominance)            *
* ------------------------------------------------------------------------- *
        ZERO    a_cc0
        ZERO    a_cc1
        SHRU    top0h:top0l, 8, empty1:top0     ; LMBD takes 32 bit only
        LMBD    0,          top0,   b
        SHRU    top0,       30,     c
        SHRU    top0,       29,     d

        ADD     b,          1,      len

[!cc]   ADD     b,          2,      dc_size
[!cc]   CMPGT   b,          8,      a_cc0                 ; >=9
[!cc]   SHRU    b,          1,      b
[!cc]   SUB     d,          4,      d

[cc]    ADD     b,          1,      dc_size
[cc]    CMPGT   b,          9,      a_cc1                 ; >=10
[cc]    MVK     1,          d                             ; anything !=0

[!b]    ADD     len,        1,      len
[!c]    SUB     dc_size,    1,      dc_size
[!d]    SUB     dc_size,    3,      dc_size
[a_cc0] MVK     9,          len
[a_cc0] MVK     11,         dc_size
[a_cc1] MVK     10,         len
[a_cc1] MVK     11,         dc_size

* ------------------------------------------------------------------------- *
*  Intra DC: obtain QFS[0] from dc_size and dc_differential                 *
* ------------------------------------------------------------------------- *

            ZERO    dc_diff
            SHL     top0,       len,        t1
[dc_size]   SUB     dc_size,    1,          t2
[dc_size]   SHL     const1,     t2,         half_range
[dc_size]   SUB     const32,    dc_size,    t3
[dc_size]   SHRU    t1,         t3,         dc_diff

            ZERO    test0
[dc_size]   CMPLT   dc_diff,    half_range, test0
[test0]     ADD     dc_diff,    1,          t4
[test0]     SHL     half_range, 1,          t5
[test0]     SUB     t4,         t5,         dc_diff

            LDW     *dc_pred[cc], pred
            ADD     pred,         dc_diff,  val
            STW     val,          *dc_pred[cc]

* ------------------------------------------------------------------------- *
*  Intra DC: de-quantization and store result                               *
* ------------------------------------------------------------------------- *
           SUB     3,          intra_dc_precision,     t1
           SHL     val,        t1,     val
           STH     val,        *outi

* ------------------------------------------------------------------------- *
*  Intra DC: mismatch control                                               *
* ------------------------------------------------------------------------- *
            ADD     sum,    val,    sum

* ------------------------------------------------------------------------- *
*  Intra DC: advance bitstream                                              *
* ------------------------------------------------------------------------- *
            ADD     len,        dc_size,    len
            SUB     const32,    len,        len_c

            SHL     top0h:top0l,  len,      at6h:at6l
            SHRU    top1,         len_c,    at7

            MV      at6h,         top0h
            ADD     at6l,         at7,      top0l

            ADD     bptr,       len,        bptr
            CMPGT   bptr,       const31,    test2

[test2]     MV      word1,      word1_rw
[test2]     MV      word2,      word1
[test2]     LDW     *A5++,      word2

            AND     bptr,       const31,    bptr
            SUB     const32,    bptr,       bptr_cmpl

            SHL     word1,      bptr,       at8
            SHRU    word2,      bptr_cmpl,  at9
            ADD     at8,        at9,        top1

* ------------------------------------------------------------------------- *
*  Intra DC: update pointers  (can be done before)                          *
* ------------------------------------------------------------------------- *
            ADD     Wptr,   2,  Wptr
            ADD     Zptr,   1,  Zptr

* ========================================================================= *
*  Decode AC coefficients                                                   *
* ========================================================================= *

             MV      top0h:top0l,   at6h:at6l

ac_loop:    .trip 1

* ------------------------------------------------------------------------- *
*  Length computation                                                       *
* ------------------------------------------------------------------------- *
            NORM    at6h:at6l,    nrm

            SHL     at6h:at6l,    nrm,     at1h:at1l  ; leading 0s/1s
            MPY     nrm,          -16,     at2        ; sub-table index

            SUB     len_tbl_adr,  at2,     at3
            SHRU    at1h:at1l,    const36, at4h:at4l  ; 4 extra bits

            LDBU    *at3[at4l],   len                 ; get length

            SUB     const32,      len,     len_c

* ------------------------------------------------------------------------- *
*  advance bitstream                                                        *
* ------------------------------------------------------------------------- *
            SHL     top0h:top0l,  len,        at6h:at6l

            SHRU    top1,         len_c,      at7

            SHRU    top0h:top0l,  8,          empty:top0_bk

            MV      at6h,         top0h
            ADD     at6l,         at7,        top0l

            ADD     bptr,         len,        bptr1
            CMPGT   bptr1,        const31,    test2

[test2]     MV      word1,        word1_rw
[test2]     MV      word2,        word1
[test2]     LDW     *A5++,        word2

            AND     bptr1,        const31,    bptr
            SUB     const32,      bptr,       bptr_cmpl

            SHL     word1,        bptr,       at8
            SHRU    word2,        bptr_cmpl,  at9
            ADD     at8,          at9,        top1

* ------------------------------------------------------------------------- *
*  Run-Level escape code decode                                             *
* ------------------------------------------------------------------------- *
            SUB     len,        const24,        no_esc
            EXTU    top0_bk,    6,      26,     run
            EXT     top0_bk,    12,     20,     level

* ------------------------------------------------------------------------- *
*  Run-Level "normal" code decode                                           *
* ------------------------------------------------------------------------- *
            SUB     len,        5,          rld_left
            CMPLT   len,        5,          test3
[test3]     ZERO    rld_left

            SHL     len,        5,          t2
            SHL     top0_bk,    rld_left,   t3    ; align last 5 bits to MSB
            SHRU    t3,         27,         t3    ; keep last 5 bits inc sign
            ADD     t2,         t3,         t4    ; add to sub-table index

            ADD     t4,         t4,         t4b   ; entries are half-words
[no_esc]    LDB     *rld_table_adr[t4b],    level ; access
[no_esc]    LDB     *rld_table_adr_1[t4b],  run   ; A_rld_table_adr+1

* ------------------------------------------------------------------------- *

            CMPGT   run,    const63,     eob_err

* ------------------------------------------------------------------------- *
*  De-quantization                                                          *
* ------------------------------------------------------------------------- *

            CMPLT   level,    0,        sign

            MPY     level,    2,        level2

[!eob_err]  LDH     *++Wptr[run],       W
[!eob_err]  ADD     Wptr,     2,        Wptr
[!eob_err]  CMPGT   Wptr,     Wptr_end, eob_err

            MPY     qscl,     W,        qW
            MPY     qW,       level2,   level4

[sign]      ADD     level4,   const31,  level4    ; add rounding constant
            SSHL    level4,   15,       level5    ; saturate
            SHR     level5,   shift_12Q4, level6
            AND     level6,   mask_12Q4,  level_f

[!eob_err]  ADD     sum,      level_f,  sum       ; mismatch contol

[!eob_err]  LDB     *++Zptr[run],       Z
            ADD     Zptr,     1,        Zptr

[!eob_err]  STH     level_f,  *+outi[Z]

[!eob_err]  B       ac_loop

* ========================================================================= *
*  Block loop:                                                              *
* ========================================================================= *
mismatch:
            ADD     outi,  const128,     outi      ; set to next 8x8 block

* ------------------------------------------------------------------------- *
*  Mismatch control: if sum is even, toggle last bit of last coefficient
* ------------------------------------------------------------------------- *
            AND     mism_bit,   sum,    odd
[!odd]      LDH     *-outi[1],          last_coeff
[!odd]      XOR     mism_bit,           last_coeff, last_coeff
[!odd]      STH     last_coeff,         *-outi[1]  ; of last coefficient

        CMPGT      run,      const65, fault
[!fault]CMPGT      Wptr,     Wptr_end,fault
[fault] B          exit

cont:
[cnt]       BDEC    block_loop,     cnt

* ========================================================================= *
*  Exit: update bistream pointer                                            *
* ========================================================================= *
exit
        SUB        A5,          bsbuf, byte_diff
        SHR        byte_diff,   2,     next_wptr

        SHRU       top0h:top0l, 8,    empty1:top0
        SHL        top0l,       24,   e0
        SHRU       top1,        8,    e1
        ADD        e0,          e1,   top1

        SUB        bptr,        8,    bptr
        CMPLT      bptr,        0,    lz
[lz]    MV         word1,             word2
[lz]    MV         word1_rw,          word1
[lz]    ADD        bptr,     const32, bptr

[lz]    SUBAW      A5,          1,     A5
[lz]    SUB        A5,          bsbuf, byte_diff
[lz]    SHR        byte_diff,   2,     next_wptr

        STW        next_wptr,   *+Mpeg2v[1]
        STW        bptr,        *+Mpeg2v[2]
        STW        word1,       *+Mpeg2v[3]
        STW        word2,       *+Mpeg2v[4]
        STW        top0,        *+Mpeg2v[5]
        STW        top1,        *+Mpeg2v[6]
        STW        fault,       *+Mpeg2v[12]

        ZERO    amr_config
        MVC     amr_config, AMR

        MVC     csr_bk,     CSR     ; restore interrupts

    .endproc

* ========================================================================= *
*   End of file:  IMG_mpeg2_vld_intra                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
perimeter.sa/   1066928952  0     0     0       20292     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 08:26:12 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_perimeter                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Sep-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           int IMG_perimeter                                               *
*           (                                                               *
*               const unsigned char *restrict in,  /* Input image    */     *
*               int cols,                          /* Width of input */     *
*               unsigned char       *restrict out  /* Output image   */     *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine produces the boundary of a binary image.  It           *
*       echoes the boundary pixels with a value of 0xFF and sets the        *
*       other pisels as 0.  Detection of the boundary of a binary image     *
*       is a segmentation problem and is done by examining spatial          *
*       locality of the neighboring pixels.  This is done by using the      *
*       four connectivity algorithm                                         *
*                                                                           *
*                                                                           *
*                       pix_up                                              *
*              pix_lft pix_cent pix_rgt                                     *
*                       pix_dn                                              *
*                                                                           *
*       The output pixel at location pix_cent is echoed as a boundary       *
*       pixel if pix_cent is non-zero and any one of its four               *
*       neighbors is zero.  The four neighbors are shown and stand          *
*       for the following:                                                  *
*                                                                           *
*             pix_up:  top pixel                                            *
*             pix_lft: left pixel                                           *
*             pix_rgt: right pixel                                          *
*             pix_dn:  bottom pixel                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input must be a multiple of 16 pixels across, and be            *
*       on a double-word boundary.                                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts are expected for this kernel.                     *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16 times.  Split-compares are used to          *
*       find boundary pixels, with comparison results reused between        *
*       adjacent comparisons.  Also, multiplies replace some of the         *
*       conditional operations to reduce the bottleneck on the              *
*       predication registers as well as on the L, S, and D units.          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_perimeter"
        .global _IMG_perimeter
_IMG_perimeter:      .cproc   A_img_in, B_incols, A_img_out

             .no_mdep
             .mdep    st_a, st_c
             .mdep    st_a, st_d
             .mdep    st_b, st_c
             .mdep    st_b, st_d
             .mdep    st_a, ld
             .mdep    ld,   st_c

             .reg     A_bot_zero,   B_bot_zero,        A_byte_ptr
             .reg     A_optr,       B_optr,            B_mlft0
             .reg     A_sum,        A_mid_rt_const,    B_mid_lf_const
             .reg     A_FF,         B_FF
             .reg     B_i,          A_top_ptr,         A_bot_ptr
             .reg     A_mid_ptr,    B_top_ptr,         B_mid_ptr
             .reg     B_bot_ptr,    B_mid_rt_const,    A_mid_lf_const

;  Variables within the loop

             .reg     A_top_word1:A_top_word0,  A_mid_word1:A_mid_word0
             .reg     A_bot_word1:A_bot_word0,  B_top_word3:B_top_word2
             .reg     B_mid_word3:B_mid_word2,  B_bot_word3:B_bot_word2

             .reg     A_midval00,        A_midval01,       B_midval02
             .reg     B_midval03,        A_midval01_s,     B_midval03_s
             .reg     A_midval_w0,       B_midval_w1,      A_upval00
             .reg     A_upval01,         B_upval02,        B_upval03
             .reg     A_upval01_s,       B_upval03_s,      A_upval_w0
             .reg     B_upval_w1,        A_botval00,       A_botval01
             .reg     B_botval02,        B_botval03,       A_botval01_s
             .reg     B_botval03_s,      A_botval_w0,      B_botval_w1
             .reg     A_midval_k0,       B_midval_k1,      A_midval_rt_tmp0
             .reg     B_midval_rt_tmp1,  A_midval_lt_tmp0, B_midval_lt_tmp1
             .reg     B_mrt0,            A_mlft1,          A_mrt1
             .reg     A_mid_right_val0,  A_mid_left_val0,  B_mid_left_val1
             .reg     B_mid_right_val1,  B_updnval1,       B_rgtlft1
             .reg     B_udrl1,           B_udrlm1,         A_updnval0
             .reg     A_rgtlft0,         A_udrl0,          A_udrlm0
             .reg     A_count0,          B_count1,         A_count
             .reg     A_udrlm_s,         A_pixel1:A_pixel0
             .reg     B_udrl_r,          B_pixel3:B_pixel2

; Variables ouside the loop

             .reg     A_offset, A_pix0,  B_pix1

             ;-------------------------------------------------------------;
             ; A_bot_zero and B_bot_zero are equal to 0 and are used       ;
             ; for performing compares against zero. sum is used to        ;
             ; count the number of boundary pixels found. byte_ptr         ;
             ; is used to provide left context. A_optr and B-optr          ;
             ; are used to store output pixels. i is loo[p counter         ;
             ; and iterates incols/16 times. top_ptr, mid_ptr and bot      ;
             ; ptr are used to load double word wide data on top, mid      ;
             ; and bottom lines.                                           ;
             ;-------------------------------------------------------------;


             ZERO.1   A_bot_zero
             ZERO.2   B_bot_zero
             ZERO.2   B_mlft0
             ZERO.1   A_sum

             ADD.1    A_img_in,          16,            A_byte_ptr
             MV.1     A_img_out,         A_optr
             ADD.2    A_optr,            8,             B_optr

             MVK.1    0x80,                             A_mid_rt_const
             MV.2x    A_mid_rt_const,                   B_mid_rt_const

             MVK.1    0xFF,                             A_FF
             MVK.2    0xFF,                             B_FF

             SHRU.2   B_incols,          4,             B_i
             SUB      B_i,               1,             B_i
             SUB.1x   A_img_in,          B_incols,      A_top_ptr
             ADD.1x   A_img_in,          B_incols,      A_bot_ptr
             ADD.1    A_img_in,          0,             A_mid_ptr

             ADD.2x   A_top_ptr,         8,             B_top_ptr
             ADD.2x   A_bot_ptr,         8,             B_bot_ptr
             ADD.2x   A_mid_ptr,         8,             B_mid_ptr

             .mptr    A_top_ptr,         top + 0,       16
             .mptr    B_top_ptr,         top + 8,       16
             .mptr    A_mid_ptr,         mid + 0,       16
             .mptr    B_mid_ptr,         mid + 8,       16
             .mptr    A_bot_ptr,         bot + 0,       16
             .mptr    B_bot_ptr,         bot + 8,       16
             .mptr    A_byte_ptr,        mid + 16,      16
LOOP:        .trip 1

             ;------------------------------------------------------------;
             ;  top_word1:top_word0 loads to the top line                 ;
             ;  mid_word1:mid_word0 loads to the mid line                 ;
             ;  bot_word1:bot_word0 loads to the bottom line              ;
             ;  top_word3:top_word2 loads to the top line                 ;
             ;  mid_word3:mid_word2 loads to the mid line                 ;
             ;  bot_word3:bot_word2 loads to the bottom line              ;
             ;------------------------------------------------------------;

             LDDW.D1T1 *A_top_ptr++[2],    A_top_word1:A_top_word0
             LDDW.D1T1 *A_mid_ptr++[2],    A_mid_word1:A_mid_word0
             LDDW.D1T1 *A_bot_ptr++[2],    A_bot_word1:A_bot_word0
             LDDW.D2T2 *B_top_ptr++[2],    B_top_word3:B_top_word2
             LDDW.D2T2 *B_mid_ptr++[2],    B_mid_word3:B_mid_word2
             LDDW.D2T2 *B_bot_ptr++[2],    B_bot_word3:B_bot_word2

             ;------------------------------------------------------------;
             ; Check which of the middle pixels > 0 and set 8 bit         ;
             ; result in midval_w0 and midval_w1 for the first and        ;
             ; second set of 8 pixels.                                    ;
             ;------------------------------------------------------------;

             CMPGTU4.1 A_mid_word0,       A_bot_zero,   A_midval00
             CMPGTU4.1 A_mid_word1,       A_bot_zero,   A_midval01
             CMPGTU4.2 B_mid_word2,       B_bot_zero,   B_midval02
             CMPGTU4.2 B_mid_word3,       B_bot_zero,   B_midval03
             MPY.1     A_midval01,        -16,          A_midval01_s
             MPY.2     B_midval03,        -16,          B_midval03_s
             SUB.1     A_midval00,        A_midval01_s, A_midval_w0
             SUB.2     B_midval02,        B_midval03_s, B_midval_w1

             ;-----------------------------------------------------------;
             ; Check which of the top pixels is equal to 0 and set       ;
             ; 8 bit mask in upval_w0 and upval_w1 for the first         ;
             ; and second set of 8 pixels.                               ;
             ;-----------------------------------------------------------;

             CMPEQ4.1  A_top_word0,       A_bot_zero,   A_upval00
             CMPEQ4.1  A_top_word1,       A_bot_zero,   A_upval01
             CMPEQ4.2  B_top_word2,       B_bot_zero,   B_upval02
             CMPEQ4.2  B_top_word3,       B_bot_zero,   B_upval03
             MPY.1     A_upval01,         -16,          A_upval01_s
             MPY.2     B_upval03,         -16,          B_upval03_s
             SUB.1     A_upval00,         A_upval01_s,  A_upval_w0
             SUB.2     B_upval02,         B_upval03_s,  B_upval_w1

             ;----------------------------------------------------------;
             ; Check which of the bot pixels is equal to 0 and set      ;
             ; 8 bit mask in botval_w0 and botval_w1 for the first      ;
             ; and second set of 8 pixels                               ;
             ;----------------------------------------------------------;

             CMPEQ4.1  A_bot_word0,       A_bot_zero,   A_botval00
             CMPEQ4.1  A_bot_word1,       A_bot_zero,   A_botval01
             CMPEQ4.2  B_bot_word2,       B_bot_zero,   B_botval02
             CMPEQ4.2  B_bot_word3,       B_bot_zero,   B_botval03
             MPY.1     A_botval01,        -16,          A_botval01_s
             MPY.2     B_botval03,        -16,          B_botval03_s
             SUB.1     A_botval00,        A_botval01_s, A_botval_w0
             SUB.2     B_botval02,        B_botval03_s, B_botval_w1

             ;---------------------------------------------------------;
             ; Since cmpeq4 was used on the mid pixels take the        ;
             ; NOT to check for greater than 0 and limit result        ;
             ; to 8 bit mask. In addition shift left and right         ;
             ; by 1 and use left and right context bytes to set        ;
             ; the 8th and 1st bit. For the first set of 8 pixels      ;
             ; rt0: right context lt0: left context                    ;
             ; For the 2nd set of 8 bytes                              ;
             ; rt1: rigyht context and lt1: left context               ;
             ;---------------------------------------------------------;
             ANDN      A_FF,               A_midval_w0,  A_midval_k0
             ANDN      B_FF,               B_midval_w1,  B_midval_k1

             SHRU.1    A_midval_k0,        1,            A_mid_right_val0
             SHRU.2    B_midval_k1,        1,            B_mid_right_val1
             ADD.1     A_midval_k0,        A_midval_k0,  A_mid_left_val0
             ADD.2     B_midval_k1,        B_midval_k1,  B_mid_left_val1

            ;----------------------------------------------------------;
            ; lt0: 0,15,...... rt0: 8, 24,....lt1:7,23,..rt1: 16,32    ;
            ; If any one of these context bits is set then set 8th     ;
            ; bit for rt context using 0x80 and 1st bit using left     ;
            ; for lft context using 0x01                               ;
            ;----------------------------------------------------------;

             AND.2     B_mid_word2,        B_FF,        B_mrt0
             SHRU.1    A_mid_word1,        24,          A_mlft1
             LDBU.D1T1 *A_byte_ptr++[16],   A_mrt1

 [!B_mrt0]   ADD.1     A_mid_right_val0,      A_mid_rt_const,  A_mid_right_val0
 [!B_mlft0]  ADD.1     A_mid_left_val0,       1,               A_mid_left_val0
 [!A_mrt1]   ADD.2     B_mid_right_val1,      B_mid_rt_const,  B_mid_right_val1
 [!A_mlft1]  ADD.2     B_mid_left_val1,       1,               B_mid_left_val1

            ;----------------------------------------------------------;
            ; Perform logical (top | bot | lft | right) & mid          ;
            ; Use xpnd4 to expand the bit-map and bitc4 to count       ;
            ; count the # of boundary pixels.                          ;
            ;----------------------------------------------------------;

             OR.1     A_upval_w0,           A_botval_w0,     A_updnval0
             OR.1     A_mid_right_val0,     A_mid_left_val0, A_rgtlft0
             OR.1     A_updnval0,           A_rgtlft0,       A_udrl0
             AND.1    A_udrl0,              A_midval_w0,     A_udrlm0

             OR.2     B_upval_w1,           B_botval_w1,     B_updnval1
             OR.2     B_mid_right_val1,     B_mid_left_val1, B_rgtlft1
             OR.2     B_updnval1,           B_rgtlft1,       B_udrl1
             AND.2    B_udrl1,              B_midval_w1,     B_udrlm1


             SHRU.2   B_mid_word3,          24,              B_mlft0
             BITC4.1  A_udrlm0,             A_count0
             BITC4.2  B_udrlm1,             B_count1
             ADD.1x   A_count0,             B_count1,        A_count
             ADD.1    A_sum,                A_count,         A_sum

             XPND4.1  A_udrlm0,             A_pixel0
             SHRU.1   A_udrlm0,             4,               A_udrlm_s
             XPND4.1  A_udrlm_s,            A_pixel1
             AND.1    A_pixel0,             A_mid_word0,     A_pixel0
             AND.1    A_pixel1,             A_mid_word1,     A_pixel1
             STDW.D1T1 A_pixel1:A_pixel0,    *A_optr++[2]{st_a}

             XPND4.2  B_udrlm1,             B_pixel2
             SHRU.2   B_udrlm1,             4,               B_udrl_r
             XPND4.2  B_udrl_r,             B_pixel3
             AND.2    B_pixel2,             B_mid_word2,     B_pixel2
             AND.2    B_pixel3,             B_mid_word3,     B_pixel3
             STDW.D2T2 B_pixel3:B_pixel2,    *B_optr++[2]{st_b}


 [B_i]       BDEC.2    LOOP, B_i

             LDBU.D1T1 *A_img_out{ld},      A_pix0
             SHRU.2     B_udrl_r,           3,               B_pix1
             SUB.2      B_incols,            1,              A_offset
 [A_pix0]    SUB.1      A_sum,               1,              A_sum
 [B_pix1]    SUB.1      A_sum,               1,              A_sum

             STB.D1T1   A_bot_zero,         *A_img_out{st_c}
             STB.D1T1   A_bot_zero,         *+A_img_out[A_offset]{st_d}

             .return  A_sum
             .endproc

* ========================================================================= *
*   End of file:  img_perimeter.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
pix_expand.sa/  1066928952  0     0     0       8238      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Wed Aug 29 10:30:18 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_expand                                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_pix_expand                                                 *
*       (                                                                   *
*           int n,                                    /* # of elements */   *
*           const unsigned char *restrict in_data,    /* Input data    */   *
*           short               *restrict out_data    /* Output data   */   *
*       )                                                                   *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The code takes an array of bytes and promotes them to half-words    *
*       by zero-extension.                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code, without              *
*       restrictions.  The assembly code has restrictions, as noted below.  *
*                                                                           *
*       void IMG_pix_expand                                                 *
*       (                                                                   *
*           int n,                                                          *
*           const unsigned char *restrict in_data,                          *
*           short               *restrict out_data                          *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < n; i++)                                         *
*               out_data[i] =  in_data[i];                                  *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays must be double-word (8-byte) aligned.       *
*                                                                           *
*       The input must be at least 16 elements long and contain a           *
*       multiple of 16 elements.                                            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16 times, loading bytes with LDDW.  It uses    *
*       UNPKHU4 and UNPKLU4 to unpack the data and store the results with   *
*       STDW.                                                               *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                  .sect    ".data:copyright_p"
        .sect ".text:_pix_expand"
        .global _IMG_pix_expand
_IMG_pix_expand  .cproc A_n, B_i0, A_o0
        .no_mdep
        .reg  B_p_FE:B_p_DC, A_p_BA:A_p_98, B_p_76:B_p_54, A_p_32:A_p_10
        .reg  B_p_FEDC:B_p_BA98, A_p_7654:A_p_3210
        .reg  A_i1, B_o1, A_i

        SHRU             A_n,  4, A_i
        SUB              A_i,  1, A_i
        ADD              B_i0, 8, A_i1
        ADD              A_o0, 8, B_o1

        .mptr            B_i0, in  + 0, 16
        .mptr            A_i1, in  + 8, 16
        .mptr            A_o0, out + 0, 32
        .mptr            B_o1, out + 8, 32
loop:
        LDDW      .D1    *A_i1++[2], B_p_FEDC:B_p_BA98
        LDDW      .D2    *B_i0++[2], A_p_7654:A_p_3210

        UNPKHU4          B_p_FEDC, B_p_FE
        UNPKLU4          B_p_FEDC, B_p_DC
        UNPKHU4          B_p_BA98, A_p_BA
        UNPKLU4          B_p_BA98, A_p_98
        UNPKHU4          A_p_7654, B_p_76
        UNPKLU4          A_p_7654, B_p_54
        UNPKHU4          A_p_3210, A_p_32
        UNPKLU4          A_p_3210, A_p_10

        STDW             B_p_FE:B_p_DC, *B_o1[2]
        STDW             A_p_BA:A_p_98, *A_o0[2]
        STDW      .D2    B_p_76:B_p_54, *B_o1++[4]
        STDW      .D1    A_p_32:A_p_10, *A_o0++[4]

  [A_i] BDEC             loop, A_i
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_pix_expand.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
pix_sat.sa/     1066928952  0     0     0       7319      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 18:51:44 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_pix_sat                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       22-May-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           void IMG_pix_sat                                                *
*           (                                                               *
*               int n,                            /* Number of pixels */    *
*               const short   *restrict in_data,  /* Incoming data    */    *
*               unsigned char *restrict out_data  /* Outgoing data    */    *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_pix_sat() takes signed 16-bit input pixels and     *
*       saturates them to unsigned 8-bit results.  Pixel values above       *
*       255 are clamped to 255, and values below 0 are clamped to 0.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input must be a multiple of 32 pixels long.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The input and output data must be double-word aligned.              *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"


        .sect ".text:_pix_sat"
        .global _IMG_pix_sat
_IMG_pix_sat     .cproc  A_n,    B_i_data,   A_o_data
        .no_mdep
        .reg            A_i
        .reg            A_i_data,       B_o_data
        .reg            B_FE:B_DC,      B_BA:B_98
        .reg            B_76:B_54,      B_32:B_10
        .reg            A_FE:A_DC,      A_BA:A_98
        .reg            A_76:A_54,      A_32:A_10
        .reg            B_FEDC:B_BA98,  B_7654:B_3210
        .reg            A_FEDC:A_BA98,  A_7654:A_3210

        SHRU    .1      A_n,            5,              A_i
 [!A_i] B               done
        SUB     .1      A_i,            1,              A_i

        MV      .1X     B_i_data,       A_i_data

        .mptr           A_i_data,       in + 0,         64
        .mptr           B_i_data,       in + 0,         64
        .mptr           A_o_data,       out+ 0,         32
        .mptr           B_o_data,       out+ 0,         32
loop    .trip   1
        LDDW    .D2T1   *+B_i_data  [7], A_FE:A_DC
        LDDW    .D2T1   *+B_i_data  [6], A_BA:A_98
        LDDW    .D2T1   *+B_i_data  [5], A_76:A_54
        LDDW    .D2T1   *+B_i_data  [4], A_32:A_10
        LDDW    .D1T2   *+A_i_data  [3], B_FE:B_DC
        LDDW    .D1T2   *+A_i_data  [2], B_BA:B_98
        LDDW    .D1T2   *+A_i_data  [1], B_76:B_54
        LDDW    .D1T2   * A_i_data++[8], B_32:B_10

        MV      .2X     A_i_data,       B_i_data
        MV      .2X     A_o_data,       B_o_data

        SPACKU4 .2      B_FE,           B_DC,           B_FEDC
        SPACKU4 .2      B_BA,           B_98,           B_BA98
        SPACKU4 .2      B_76,           B_54,           B_7654
        SPACKU4 .2      B_32,           B_10,           B_3210
        SPACKU4 .1      A_FE,           A_DC,           A_FEDC
        SPACKU4 .1      A_BA,           A_98,           A_BA98
        SPACKU4 .1      A_76,           A_54,           A_7654
        SPACKU4 .1      A_32,           A_10,           A_3210

        STDW    .D2T1   A_FEDC:A_BA98,  *+B_o_data  [3]
        STDW    .D2T1   A_7654:A_3210,  *+B_o_data  [2]
        STDW    .D1T2   B_FEDC:B_BA98,  *+A_o_data  [1]
        STDW    .D1T2   B_7654:B_3210,  * A_o_data++[4]

 [ A_i] BDEC    .1      loop,           A_i

done:
        .return
        .endproc

* ========================================================================= *
*   End of file:  img_pix_sat.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

quantize.sa/    1066928952  0     0     0       20219     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Tue Mar 12 15:59:18 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_quantize -- Matrix Quantization w/ Rounding, Little Endian      *
*                                                                           *
*   REVISION DATE                                                           *
*       04-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short           *data,      /* Data to be quantized.        */  *
*           unsigned short  num_blks,   /* Number of 64-element blocks. */  *
*           unsigned short  blk_sz,     /* Block size (multiple of 16). */  *
*           const short     *recip_tbl, /* Quant. values (reciprocals). */  *
*           int             q_pt        /* Q-point of Quant values.     */  *
*       )                                                                   *
*                                                                           *
*       The number of blocks, num_blks, must be at least 1.  The block      *
*       size (number of elements in each block) must be at least 16,        *
*       and a multiple of 16.  The Q-point, q_pt, controls rounding and     *
*       final truncation; it must be in the range from 0 <= q_pt <= 31.     *
*                                                                           *
*       Both input arrays, data[] and recip_tbl[], must be word aligned.    *
*       The data[] array must be 'num_blks * blk_sz' elements, and the      *
*       recip_tbl[] array must be 'blk_sz' elements.                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The function IMG_quantize() quantizes matrices by multiplying their *
*       contents with a second matrix that contains reciprocals of the      *
*       quantization terms.  This step corresponds to the quantization      *
*       that is performed in 2-D DCT-based compression techniques,          *
*       although IMG_quantize() may be used on any signed 16-bit data using *
*       signed 16-bit quantization terms.                                   *
*                                                                           *
*       IMG_quantize() multiplies the contents of the quantization matrix   *
*       with the data being quantized.  Therefore, it may be used for       *
*       inverse quantization as well, by setting the Q-point                *
*       appropriately.                                                      *
*                                                                           *
*       The following C code describes the general implementation of        *
*       IMG_quantize().                                                     *
*                                                                           *
*       void IMG_quantize                                                   *
*       (                                                                   *
*           short           *data,      /* Data to be quantized.        */  *
*           unsigned short  num_blks,   /* Number of 64-element blocks. */  *
*           unsigned short  blk_size,   /* Block size (multiple of 16). */  *
*           const short     *recip_tbl, /* Quant. values (reciprocals). */  *
*           int             q_pt        /* Q-point of Quant values.     */  *
*       )                                                                   *
*       {                                                                   *
*           short recip;                                                    *
*           int i, j, k, quot, round;                                       *
*                                                                           *
*           round = q_pt ? 1 << (q_pt - 1) : 0;                             *
*                                                                           *
*           for (i = 0; i < blk_size; i++)                                  *
*           {                                                               *
*               recip   = recip_tbl[i];                                     *
*               k       = i;                                                *
*               for (j = 0; j < num_blks; j++)                              *
*               {                                                           *
*                   quot    = data[k] * recip + round;                      *
*                   data[k] = quot >> q_pt;                                 *
*                   k      += blk_size;                                     *
*               }                                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has restrictions, as noted above.  *
*                                                                           *
*   TECHNIQUES                                                              *
*       The outer loop is unrolled 16 times to allow greater amounts        *
*       of work to be performed in the inner loop.                          *
*                                                                           *
*       Reciprocals and data terms are loaded in pairs with word-wide       *
*       loads, making better use of the availably memory bandwidth.         *
*                                                                           *
*       The inner loop steps through individual blocks, while the           *
*       outer loop steps through reciprocals for quantization.  This        *
*       eliminates redundant loads for the quantization terms.              *
*                                                                           *
*       The direction of travel for the inner loop oscillates with each     *
*       iteration of the outer loop to simplify pointer updating in the     *
*       outer loop and reduce register pressure.  (eg.  in the first iter.  *
*       of the outer loop, the inner loop steps forward through memory; in  *
*       the second iter. of the outer loop, the inner loop steps backwards  *
*       through memory, etc.)                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The recip_tbl[] and data[] must be word aligned.                    *
*       The block size, blk_sz, must be a multiple of 16.                   *
*       The number of blocks, num_blks, must be at least 1.                 *
*       The Q-point, q_pt, must be in the range 0 <= q_pt <= 31.            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts should occur, regardless of the relative          *
*       orientation of r_tbl[] and data[].                                  *
*                                                                           *
*   NOTES                                                                   *
*       Interrupts are disabled throughout most of the function.            *
*       Input arrays must be word-aligned for correct operation.            *
*       No checking is performed on the input arguments for correctness.    *
*                                                                           *
*   SOURCE                                                                  *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_quantize"
        .global _IMG_quantize
_IMG_quantize    .cproc  A_data, B_num_blks, A_blk_sz, B_r_tbl, A_q_pt

        .no_mdep
; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .reg    A_i                          ; Outer loop counter
        .reg    B_j                          ; Inner loop counter
        .reg    A_shift                      ; q_pt - 1
        .reg    B_r_ptr, A_r_ptr             ; Reciprocal table pointers
        .reg    B_di_ptr, A_di_ptr           ; data[] pointer, input
        .reg    B_do_ptr, A_do_ptr           ; data[] pointer, output
        .reg    B_r_FE:B_r_DC, A_r_BA:A_r_98 ; Reciprocal terms 15 .. 8
        .reg    B_r_76:B_r_54, A_r_32:A_r_10 ; Reciprocal terms  7 .. 0
        .reg    B_d_FE:B_d_DC, A_d_BA:A_d_98 ; Data terms 15 .. 8
        .reg    B_d_76:B_d_54, A_d_32:A_d_10 ; Data terms  7 .. 0
        .reg    B_qp_F:B_qp_E, B_qp_D:B_qp_C ; Quotient (product) 15 .. 12
        .reg    A_qp_B:A_qp_A, A_qp_9:A_qp_8 ; Quotient (product) 11 ..  8
        .reg    B_qp_7:B_qp_6, B_qp_5:B_qp_4 ; Quotient (product)  7 ..  4
        .reg    A_qp_3:A_qp_2, A_qp_1:A_qp_0 ; Quotient (product)  3 ..  0
        .reg    B_qr_F,B_qr_E, B_qr_D,B_qr_C ; Quotient (rounded) 15 .. 12
        .reg    A_qr_B,A_qr_A, A_qr_9,A_qr_8 ; Quotient (rounded) 11 ..  8
        .reg    B_qr_7,B_qr_6, B_qr_5,B_qr_4 ; Quotient (rounded)  7 ..  4
        .reg    A_qr_3,A_qr_2, A_qr_1,A_qr_0 ; Quotient (rounded)  3 ..  0
        .reg    B_qt_F,B_qt_E, B_qt_D,B_qt_C ; Quotient (trunc'd) 15 .. 12
        .reg    A_qt_B,A_qt_A, A_qt_9,A_qt_8 ; Quotient (trunc'd) 11 ..  8
        .reg    B_qt_7,B_qt_6, B_qt_5,B_qt_4 ; Quotient (trunc'd)  7 ..  4
        .reg    A_qt_3,A_qt_2, A_qt_1,A_qt_0 ; Quotient (trunc'd)  3 ..  0
        .reg    B_q_FE:B_q_DC, A_q_BA:A_q_98 ; Final quotient terms 15 .. 8
        .reg    B_q_76:B_q_54, A_q_32:A_q_10 ; Final quotient terms  7 .. 0
        .reg    B_rnd,  A_rnd                ; Rounding term, 1 << (q_pt-1)
        .reg    B_q_pt                       ; Q-point
        .reg    B_fix, A_fix                 ; Block-to-block pointer fixup
        .reg    A_r_end
; ========================================================================= ;

[B_num_blks] B  ok      ; early exit if num_blks == 0
        .return
ok:
        ; Initialize data[] pointers
        MV      .1      A_data,     A_di_ptr
        ADD     .2X     A_data,     8,          B_di_ptr
        MV      .1      A_di_ptr,   A_do_ptr
        MV      .2      B_di_ptr,   B_do_ptr

        ; Initialize r_tbl[] pointers
        MV      .1X     B_r_tbl,    A_r_ptr
        ADD     .2      B_r_tbl,    8,          B_r_ptr

        MV      .2X     A_q_pt,     B_q_pt

        ; Initialize rounding term
        SUB     .1      A_q_pt,     1,          A_shift
        MVK     .1      1,          A_rnd
        SHL     .1      A_rnd,      A_shift,    A_rnd     ; rnd = 1<<(q_pt-1)
        MV      .2X     A_rnd,      B_rnd



        ; Initialize block-to-block fixup pointers.
        SHL     .1      A_blk_sz,   1,          A_fix
        SHL     .2      A_blk_sz,   1,          B_fix

        ADD             A_r_ptr,    A_fix,      A_r_end

        SHRU            A_blk_sz,   4,          A_i
        MPYU    .2      A_i,        B_num_blks, B_j
        SUB     .2      B_j,        2,          B_j

        .mptr           B_r_ptr,    r_tbl+4,    32
        .mptr           A_r_ptr,    r_tbl+0,    32
        .mptr           B_r_ptr,    r_tbl+8,    32
        .mptr           A_r_ptr,    r_tbl+0,    32
        .mptr           B_di_ptr,   d_tbl+8,    32
        .mptr           A_di_ptr,   d_tbl+0,    32
        .mptr           B_do_ptr,   d_tbl+8,    32
        .mptr           A_do_ptr,   d_tbl+0,    32
j_loop: .trip   2
        LDDW    .D2T2   *+B_r_ptr  [2],         B_r_FE:B_r_DC ; Recip F,E,D,C
        LDDW    .D1T1   *+A_r_ptr  [2],         A_r_BA:A_r_98 ; Recip B,A,9,8
        LDDW    .D2T2   * B_r_ptr++[4],         B_r_76:B_r_54 ; Recip 7,6,5,4
        LDDW    .D1T1   * A_r_ptr++[4],         A_r_32:A_r_10 ; Recip 3,2,1,0

        CMPLTU  .1      A_r_ptr,    A_r_end,    A_i
 [!A_i] SUB     .2      B_r_ptr,    B_fix,      B_r_ptr ; (outer) update r_ptr
 [!A_i] SUB     .1      A_r_ptr,    A_fix,      A_r_ptr ; (outer) update r_ptr

        LDDW    .D2T2   *+B_di_ptr  [2],        B_d_FE:B_d_DC ; Data  F,E,D,C
        LDDW    .D1T1   *+A_di_ptr  [2],        A_d_BA:A_d_98 ; Data  B,A,9,8
        LDDW    .D2T2   * B_di_ptr++[4],        B_d_76:B_d_54 ; Data  7,6,5,4
        LDDW    .D1T1   * A_di_ptr++[4],        A_d_32:A_d_10 ; Data  3,2,1,0

        MPY2    .2      B_d_FE,     B_r_FE,     B_qp_F:B_qp_E ; qp[n]=d[n]*r[n]
        MPY2    .2      B_d_DC,     B_r_DC,     B_qp_D:B_qp_C ; qp[n]=d[n]*r[n]
        MPY2    .1      A_d_BA,     A_r_BA,     A_qp_B:A_qp_A ; qp[n]=d[n]*r[n]
        MPY2    .1      A_d_98,     A_r_98,     A_qp_9:A_qp_8 ; qp[n]=d[n]*r[n]
        MPY2    .2      B_d_76,     B_r_76,     B_qp_7:B_qp_6 ; qp[n]=d[n]*r[n]
        MPY2    .2      B_d_54,     B_r_54,     B_qp_5:B_qp_4 ; qp[n]=d[n]*r[n]
        MPY2    .1      A_d_32,     A_r_32,     A_qp_3:A_qp_2 ; qp[n]=d[n]*r[n]
        MPY2    .1      A_d_10,     A_r_10,     A_qp_1:A_qp_0 ; qp[n]=d[n]*r[n]

        ADD     .2      B_qp_F,     B_rnd,      B_qr_F  ; qp_F=qr_F+rnd
        ADD     .2      B_qp_E,     B_rnd,      B_qr_E  ; qp_E=qr_E+rnd
        ADD     .2      B_qp_D,     B_rnd,      B_qr_D  ; qp_D=qr_D+rnd
        ADD     .2      B_qp_C,     B_rnd,      B_qr_C  ; qp_C=qr_C+rnd
        ADD     .1      A_qp_B,     A_rnd,      A_qr_B  ; qp_B=qr_B+rnd
        ADD     .1      A_qp_A,     A_rnd,      A_qr_A  ; qp_A=qr_A+rnd
        ADD     .1      A_qp_9,     A_rnd,      A_qr_9  ; qp_9=qr_9+rnd
        ADD     .1      A_qp_8,     A_rnd,      A_qr_8  ; qp_8=qr_8+rnd
        ADD     .2      B_qp_7,     B_rnd,      B_qr_7  ; qp_7=qr_7+rnd
        ADD     .2      B_qp_6,     B_rnd,      B_qr_6  ; qp_6=qr_6+rnd
        ADD     .2      B_qp_5,     B_rnd,      B_qr_5  ; qp_5=qr_5+rnd
        ADD     .2      B_qp_4,     B_rnd,      B_qr_4  ; qp_4=qr_4+rnd
        ADD     .1      A_qp_3,     A_rnd,      A_qr_3  ; qp_3=qr_3+rnd
        ADD     .1      A_qp_2,     A_rnd,      A_qr_2  ; qp_2=qr_2+rnd
        ADD     .1      A_qp_1,     A_rnd,      A_qr_1  ; qp_1=qr_1+rnd
        ADD     .1      A_qp_0,     A_rnd,      A_qr_0  ; qp_0=qr_0+rnd

        SHR     .2      B_qr_F,     B_q_pt,     B_qt_F  ; qt_F=qr_F>>q_pt
        SHR     .2      B_qr_E,     B_q_pt,     B_qt_E  ; qt_E=qr_E>>q_pt
        SHR     .2      B_qr_D,     B_q_pt,     B_qt_D  ; qt_D=qr_D>>q_pt
        SHR     .2      B_qr_C,     B_q_pt,     B_qt_C  ; qt_C=qr_C>>q_pt
        SHR     .1      A_qr_B,     A_q_pt,     A_qt_B  ; qt_B=qr_B>>q_pt
        SHR     .1      A_qr_A,     A_q_pt,     A_qt_A  ; qt_A=qr_A>>q_pt
        SHR     .1      A_qr_9,     A_q_pt,     A_qt_9  ; qt_9=qr_9>>q_pt
        SHR     .1      A_qr_8,     A_q_pt,     A_qt_8  ; qt_8=qr_8>>q_pt
        SSHVR   .2      B_qr_7,     B_q_pt,     B_qt_7  ; qt_7=qr_7>>q_pt
        SSHVR   .2      B_qr_6,     B_q_pt,     B_qt_6  ; qt_6=qr_6>>q_pt
        SSHVR   .2      B_qr_5,     B_q_pt,     B_qt_5  ; qt_5=qr_5>>q_pt
        SSHVR   .2      B_qr_4,     B_q_pt,     B_qt_4  ; qt_4=qr_4>>q_pt
        SSHVR   .1      A_qr_3,     A_q_pt,     A_qt_3  ; qt_3=qr_3>>q_pt
        SSHVR   .1      A_qr_2,     A_q_pt,     A_qt_2  ; qt_2=qr_2>>q_pt
        SSHVR   .1      A_qr_1,     A_q_pt,     A_qt_1  ; qt_1=qr_1>>q_pt
        SSHVR   .1      A_qr_0,     A_q_pt,     A_qt_0  ; qt_0=qr_0>>q_pt

        PACK2   .2      B_qt_F,     B_qt_E,     B_q_FE  ; Packed quot F,E
        PACK2   .2      B_qt_D,     B_qt_C,     B_q_DC  ; Packed quot D,C
        PACK2   .1      A_qt_B,     A_qt_A,     A_q_BA  ; Packed quot B,A
        PACK2   .1      A_qt_9,     A_qt_8,     A_q_98  ; Packed quot 9,8
        PACK2   .2      B_qt_7,     B_qt_6,     B_q_76  ; Packed quot 7,6
        PACK2   .2      B_qt_5,     B_qt_4,     B_q_54  ; Packed quot 5,4
        PACK2   .1      A_qt_3,     A_qt_2,     A_q_32  ; Packed quot 3,2
        PACK2   .1      A_qt_1,     A_qt_0,     A_q_10  ; Packed quot 1,0

        STDW    .D2T2   B_q_FE:B_q_DC,  *+B_do_ptr  [2] ; Quot. F,E,D,C
        STDW    .D1T1   A_q_BA:A_q_98,  *+A_do_ptr  [2] ; Quot. B,A,9,8
        STDW    .D2T2   B_q_76:B_q_54,  * B_do_ptr++[4] ; Quot. 7,6,5,4
        STDW    .D1T1   A_q_32:A_q_10,  * A_do_ptr++[4] ; Quot. 3,2,1,0

        BDEC            j_loop, B_j

        .return
        .endproc

* ========================================================================= *
*   End of file:  img_quantize.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sad_16x16.sa/   1066928952  0     0     0       7104      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:21 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_16x16 -- Sum of Absolute Differences on single 16x16 block  *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_16x16                                              *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 16x16 source block */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 16x16 source block (srcImg),      *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 16x16 region pointed to in the     *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 16x16 region.     *
*       It returns the final accumulation.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Some versions of this kernel may assume that srcImg is double-      *
*       word aligned.                                                       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_16x16"
        .global _IMG_sad_16x16
_IMG_sad_16x16   .cproc A_srcImg, B_refImg, A_pitch
                .no_mdep

            .reg            B_srcImg, B_p, B_s3, B_s2, A_s1, A_s0
            .reg            B_sFEDC:B_sBA98, A_s7654:A_s3210
            .reg            B_rFEDC:B_rBA98, A_r7654:A_r3210
            .reg            B_dFEDC,B_dBA98, A_d7654,A_d3210
            .reg            A_retval, B_sad, A_sad, i, B_k1, A_k1

            MVK     .1      0x0101,     A_k1
            PACK2   .1      A_k1,       A_k1,       A_k1
            ADD     .2X     A_srcImg,   8,          B_srcImg
            MV      .2X     A_pitch,    B_p
            MVK             15,         i
            ZERO            A_sad
            ZERO            B_sad
loop:       .trip           16,         16,         16

            LDDW    .D2T2   * B_srcImg++( 16),      B_sFEDC:B_sBA98
            LDDW    .D1T1   * A_srcImg++( 16),      A_s7654:A_s3210
            LDNDW   .D1T2   *+B_refImg  (  8),      B_rFEDC:B_rBA98
            LDNDW   .D2T1   * B_refImg++(B_p),      A_r7654:A_r3210

            SUBABS4         B_sFEDC,    B_rFEDC,    B_dFEDC
            SUBABS4         B_sBA98,    B_rBA98,    B_dBA98
            SUBABS4         A_s7654,    A_r7654,    A_d7654
            SUBABS4         A_s3210,    A_r3210,    A_d3210

            DOTPU4          B_dFEDC,    A_k1,       B_s3
            DOTPU4          B_dBA98,    A_k1,       B_s2
            DOTPU4          A_d7654,    A_k1,       A_s1
            DOTPU4          A_d3210,    A_k1,       A_s0

            ADD             B_sad,      B_s3,       B_sad
            ADD             B_sad,      B_s2,       B_sad
            ADD             A_sad,      A_s1,       A_sad
            ADD             A_sad,      A_s0,       A_sad

   [i]      BDEC            loop,       i

            ADD             A_sad,      B_sad,      A_retval

            .return         A_retval
            .endproc

* ========================================================================= *
*   End of file: img_sad_16x16.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
sad_8x8.sa/     1066928952  0     0     0       7099      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Mon Mar  4 02:24:22 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       IMG_sad_8x8   -- Sum of Absolute Differences on single 8x8 block    *
*                                                                           *
*   USAGE                                                                   *
*       unsigned IMG_sad_8x8                                                *
*       (                                                                   *
*           const unsigned char *restrict srcImg,  /* 8x8 source block   */ *
*           const unsigned char *restrict refImg,  /* Reference image    */ *
*           int pitch                              /* Width of ref image */ *
*       );                                                                  *
*                                                                           *
*       The code accepts a pointer to the 8x8 source block (srcImg),        *
*       and a pointer to the upper-left corner of a target position in      *
*       a reference image (refImg).  The width of the reference image       *
*       is given by the pitch argument.                                     *
*                                                                           *
*       The function returns the sum of the absolute differences            *
*       between the source block and the 8x8 region pointed to in the       *
*       reference image.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The algorithm takes the difference between the pixel values in      *
*       the source image block and the corresponding pixels in the          *
*       reference image.  It then takes the absolute values of these        *
*       differences, and accumulates them over the entire 8x8 region.       *
*       It returns the final accumulation.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Some versions of this kernel may assume that srcImg is double-      *
*       word aligned.                                                       *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_sad_8x8"
        .global _IMG_sad_8x8
_IMG_sad_8x8 .cproc A_srcImg, B_refImg, A_pitch
            .no_mdep

            .reg            B_srcImg, B_s3, B_s2, A_s1, A_s0, B_pitch
            .reg            B_s7654:B_s3210, A_s7654:A_s3210
            .reg            B_r7654:B_r3210, A_r7654:A_r3210
            .reg            B_d7654,B_d3210, A_d7654,A_d3210
            .reg            A_retval, B_sad, A_sad, i, B_k1, A_k1

            MVK     .1      0x0101,     A_k1
            PACK2   .1      A_k1,       A_k1,       A_k1
            ADD     .2X     A_srcImg,   8,          B_srcImg
            MV      .2X     A_pitch,    B_pitch
            MVK             3,          i
            ZERO            A_sad
            ZERO            B_sad
loop:       .trip           3,          3,          3

            LDDW    .D1T2   * A_srcImg++( 16),      B_s7654:B_s3210
            LDDW    .D2T1   * B_srcImg++( 16),      A_s7654:A_s3210
            LDNDW   .D1T2   * B_refImg++(B_pitch),  B_r7654:B_r3210
            LDNDW   .D2T1   * B_refImg++(B_pitch),  A_r7654:A_r3210

            SUBABS4         B_s7654,    B_r7654,    B_d7654
            SUBABS4         B_s3210,    B_r3210,    B_d3210
            SUBABS4         A_s7654,    A_r7654,    A_d7654
            SUBABS4         A_s3210,    A_r3210,    A_d3210

            DOTPU4          B_d7654,    A_k1,       B_s3
            DOTPU4          B_d3210,    A_k1,       B_s2
            DOTPU4          A_d7654,    A_k1,       A_s1
            DOTPU4          A_d3210,    A_k1,       A_s0

            ADD             B_sad,      B_s3,       B_sad
            ADD             B_sad,      B_s2,       B_sad
            ADD             A_sad,      A_s1,       A_sad
            ADD             A_sad,      A_s0,       A_sad

   [i]      BDEC            loop,       i

            ADD             A_sad,      B_sad,      A_retval

            .return         A_retval
            .endproc

* ========================================================================= *
*   End of file: sad_16x16_p.sa                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

sobel.sa/       1066928952  0     0     0       26865     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Fri Oct 25 00:16:59 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_sobel, Little Endian.                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_sobel                                                      *
*       (                                                                   *
*           const unsigned char *in_data,      /* Input image data  */      *
*           unsigned char       *out_data,     /* Output image data */      *
*           short cols, short rows             /* Image dimensions  */      *
*       )                                                                   *
*                                                                           *
*       The IMG_sobel filter is applied to the input image. The input image *
*       dimensions are given by the arguments 'cols' and 'rows'.  The       *
*       output image is 'cols' pixels wide and 'rows - 2' pixels tall.      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       To see how the implementation is going to work on the input         *
*       buffer, lets imagine we have the following input buffer:            *
*       lets imagine we have the following input buffer:                    *
*                                                                           *
*               yyyyyyyyyyyyyyyy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yxxxxxxxxxxxxxxy                                            *
*               yyyyyyyyyyyyyyyy                                            *
*                                                                           *
*       The output buffer would be:                                         *
*                                                                           *
*               tXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXz                                            *
*               zXXXXXXXXXXXXXXt                                            *
*                                                                           *
*       Where:                                                              *
*                                                                           *
*           X = IMG_sobel(x)    The algorithm is applied to that pixel.     *
*                           The correct output is obtained, the data        *
*                           around the pixels we work on is used            *
*                                                                           *
*           t               Whatever was in the output buffer in that       *
*                           position is kept there.                         *
*                                                                           *
*           z = IMG_sobel(y)    The algorithm is applied to that pixel.     *
*                           The output is not meaningful, because the       *
*                           necessary data to process the pixel is not      *
*                           available.  This is because for each output     *
*                           pixel we need input pixels from the right and   *
*                           from the left of the output pixel.  But this    *
*                           data doesn't exist.                             *
*                                                                           *
*       This means that we will only process (rows-2) lines.  Then, we      *
*       will process all the pixels inside each line. Even though the       *
*       results for the first and last pixels in each line will not         *
*       be relevant, it makes the control much simpler and ends up          *
*       saving cycles.                                                      *
*                                                                           *
*       Also the first pixel in the first processed line and the            *
*       last pixel in the last processed line will not be computed.         *
*       It is not necessary, since the results would be bogus.              *
*                                                                           *
*       The following horizontal and vertical masks that are                *
*       applied to the input buffer to obtain one output pixel.             *
*                                                                           *
*           Horizontal:                                                     *
*               -1 -2 -1                                                    *
*                0  0  0                                                    *
*                1  2  1                                                    *
*                                                                           *
*           Vertical:                                                       *
*               -1  0  1                                                    *
*               -2  0  2                                                    *
*               -1  0  1                                                    *
*                                                                           *
*       This is a C model of the Sobel implementation.  This C code         *
*       is functionally equivalent to the assembly code without             *
*       restrictions.   The assembly code may impose additional             *
*       restrictions.                                                       *
*                                                                           *
*           void IMG_sobel                                                  *
*           (                                                               *
*               const unsigned char *in,       /* Input image data  */      *
*               unsigned char       *out,      /* Output image data */      *
*               short cols, short rows         /* Image dimensions  */      *
*           )                                                               *
*           {                                                               *
*               /* ------------------------------------------------ */      *
*               /*  Intermediate values.                            */      *
*               /* ------------------------------------------------ */      *
*               int H;    /* Horizontal mask result                 */      *
*               int V;    /* Vertical mask result                   */      *
*               int O;    /* Sum of horizontal and vertical masks   */      *
*               int i;    /* Input pixel offset                     */      *
*               int o;    /* Output pixel offset.                   */      *
*               int xy;   /* Loop counter.                          */      *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Input values.                                   */      *
*               /* ------------------------------------------------ */      *
*               int i00, i01, i02;                                          *
*               int i10,      i12;                                          *
*               int i20, i21, i22;                                          *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Step through the entire image.  We step         */      *
*               /*  through 'rows - 2' rows in the output image,    */      *
*               /*  since those are the only rows that are fully    */      *
*               /*  defined for our filter.                         */      *
*               /* ------------------------------------------------ */      *
*               for (xy = 0, i = cols + 1, o = 1;                           *
*                    xy < cols*(rows-2) - 2;                                *
*                    xy++, i++, o++)                                        *
*               {                                                           *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Read necessary data to process an input     */      *
*                   /*  pixel.  The following instructions are      */      *
*                   /*  written to reflect the position of the      */      *
*                   /*  input pixels in reference to the pixel      */      *
*                   /*  being processed, which would correspond     */      *
*                   /*  to the blank space left in the middle.      */      *
*                   /* -------------------------------------------- */      *
*                   i00=in[i-cols-1]; i01=in[i-cols]; i02=in[i-cols+1];     *
*                   i10=in[i     -1];                 i12=in[i     +1];     *
*                   i20=in[i+cols-1]; i21=in[i+cols]; i22=in[i+cols+1];     *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the horizontal mask.                  */      *
*                   /* -------------------------------------------- */      *
*                   H = -i00 - 2*i01 -   i02 +   i20 + 2*i21 + i22;         *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Apply the vertical mask.                    */      *
*                   /* -------------------------------------------- */      *
*                   V = -i00 +   i02 - 2*i10 + 2*i12 -   i20 + i22;         *
*                                                                           *
*                   O = abs(H) + abs(V);                                    *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  If the result is over 255 (largest valid    */      *
*                   /*  pixel value), saturate (clamp) to 255.      */      *
*                   /* -------------------------------------------- */      *
*                   if (O > 255) O = 255;                                   *
*                                                                           *
*                   /* -------------------------------------------- */      *
*                   /*  Store the result.                           */      *
*                   /* -------------------------------------------- */      *
*                   out[o] = O;                                             *
*               }                                                           *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       Eight output pixels are computed per iteration using loop unrolling *
*       and packed operations.                                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       At least eight output pixels must be processed.                     *
*       The input image width must be even (eg. 'cols' must be even).       *
*                                                                           *
*   NOTES                                                                   *
*       This is a LITTLE ENDIAN implementation.                             *
*       The image arrays do not need to be aligned.                         *
*                                                                           *
*       The values of the left-most and right-most pixels on each line      *
*       of the output are not well-defined.                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
            .sect    ".data:copyright_p"

        .sect ".text:_sobel"
        .global _IMG_sobel
_IMG_sobel:  .cproc  A_in,    B_out,  A_w,   B_h
            .no_mdep

* ========================================================================= *
*   Array access                                                            *
* ========================================================================= *
            .reg B_in, A_out
            .reg A_wD4, A_wD8
            .reg B_wD4, B_wD8

* ========================================================================= *
*   Coeffcients                                                             *
* ========================================================================= *
            .reg A_mult1, A_mult2, A_mult1_b, A_mult2_b
            .reg B_mult1, B_mult2, B_mult1_b, B_mult2_b
            .reg A_f1, A_f2
            .reg B_f1, B_f2

* ========================================================================= *
*   Input pixels                                                            *
* ========================================================================= *
            .reg A_in1_h:A_in1_l                ;   |x|x|x|x|x|x|x|x| | |
            .reg B_tmp2:B_tmp1                  ;   | | |x|x|x|x|x|x|x|x|
            .reg A_in2_l2:A_in2_l               ;   |x|x|x|x|x|x|x|x| | |
            .reg B_in2_h2:B_in2_h               ;   | | |x|x|x|x|x|x|x|x|
            .reg A_in3_h:A_in3_l                ;   |x|x|x|x|x|x|x|x| | |
            .reg B_tmp4:B_tmp3                  ;   | | |x|x|x|x|x|x|x|x|

* ========================================================================= *
*   Temporary values                                                        *
* ========================================================================= *
            .reg A_t1, A_t2, A_t3, A_t4, A_t5, A_t6, A_t7, A_t8, A_t9, A_t10
            .reg A_t11, A_t12
            .reg B_t1, B_t2, B_t3, B_t4, B_t5, B_t6, B_t7, B_t8, B_t9, B_t10
            .reg B_t11, B_t12
            .reg A_H, B_H3, A_H5, B_H7
            .reg A_V2, B_V4, A_V6, B_V8
            .reg A_b1, A_b2, A_b3, A_b4, A_b5, A_b6
            .reg A_u1, A_u2, A_u3, A_u4, A_u5, A_u6, A_u7, A_u8, A_u9, A_u10
            .reg A_u11, A_u12
            .reg B_b1, B_b2, B_b3, B_b4, B_b5, B_b6, B_b7, B_b8
            .reg B_u1, B_u2, B_u3, B_u4, B_u5, B_u6, B_u7, B_u8, B_u9, B_u10
            .reg B_u11, B_u12
            .reg A_b10_h:A_b10_l, A_b11_h:A_b11_l, A_b12_h:A_b12_l
            .reg B_b14_h:B_b14_l, B_b15_h:B_b15_l, B_b13_h:B_b13_l
            .reg A_r9, B_r10, A_r11, B_r12, B_r14:B_r13, B_r15, B_r16

* ========================================================================= *
*   Control                                                                 *
* ========================================================================= *
            .reg A_cnt                          ;  Loop counter
            .reg B_final

* ========================================================================= *
* ========================================================================= *
*   Setup                                                                   *
* ========================================================================= *
            MVKL    0xFEFF,   A_mult1
            MVKLH   0x00FF,   A_mult1           ;  0, -1, -2, -1
            MV      A_mult1,  B_mult1

            MVKL    0x0201,   A_mult2
            MVKLH   0x0001,   A_mult2           ;  0,  1,  2,  1
            MV      A_mult2,  B_mult2

            MVKL    0xFF00,   A_mult1_b
            MVKLH   0xFFFE,   A_mult1_b         ;  -1, -2, -1, 0
            MV      A_mult1_b,B_mult1_b

            MVKL    0x0100,   A_mult2_b
            MVKLH   0x0102,   A_mult2_b         ;  1,  2,  1, 0
            MV      A_mult2_b,B_mult2_b

            MVKL    0x0101,   A_f1
            MVKLH   0x0101,   A_f1              ;  1,  1,  1, 1
            MV      A_f1,     B_f1

            MVKL    0x0202,   A_f2
            MVKLH   0x0202,   A_f2              ;  2,  2,  2, 2
            MV      A_f2,     B_f2

            SHR     A_w,    3,  A_wD8           ;  offset for DW load: line+1
            SHR     A_w,    2,  A_wD4           ;  offset for DW load: line+2
            MV      A_wD8,  B_wD8
            MV      A_wD4,  B_wD4

            SUB     B_h,    2,     B_h
            MPY     A_w,    B_h,   A_cnt
            SHRU    A_cnt,  3,     A_cnt
            MV      A_cnt,  B_final
            SUB     A_cnt,  2,     A_cnt

            ADD     A_in,   2,     B_in
            ADD     B_out,  1,     A_out

* ========================================================================= *
*   Loop                                                                    *
* ========================================================================= *
loop:       .trip      4

            LDNDW.D1T1  *+A_in[A_wD4],  A_in3_h:A_in3_l          ; A load, line 3
            LDNDW.D1T1  *+A_in[A_wD8],  A_in2_l2:A_in2_l         ; A load, line 2
            LDNDW.D1T1  *A_in++,        A_in1_h:A_in1_l          ; A load, line 1

            LDNDW.D2T2 *+B_in[B_wD4],  B_tmp4:B_tmp3            ; B load, line 3
            LDNDW.D2T2 *+B_in[B_wD8],  B_in2_h2:B_in2_h         ; B load, line 2
            LDNDW.D2T2 *B_in++,        B_tmp2:B_tmp1            ; B load, line 1

    ; Horizontal filter mask:

            DOTPSU4.M1  A_mult1_b,        A_in1_l,      A_t1
            DOTPSU4.M1  A_mult1,          A_in1_l,      A_t2
            PACK2       A_t1,             A_t2,         A_t3

            DOTPSU4.M1  A_mult2_b,        A_in3_l,      A_t4
            DOTPSU4.M1  A_mult2,          A_in3_l,      A_t5
            PACK2       A_t4,             A_t5,         A_t6

            ADD2        A_t3,             A_t6,         A_H

            DOTPSU4.M2  B_mult1_b,        B_tmp1,       B_t1
            DOTPSU4.M2  B_mult1,          B_tmp1,       B_t2
            PACK2       B_t1,             B_t2,         B_t3

            DOTPSU4.M2  B_mult2_b,        B_tmp3,       B_t4
            DOTPSU4.M2  B_mult2,          B_tmp3,       B_t5
            PACK2       B_t4,             B_t5,         B_t6

            ADD2        B_t3,             B_t6,         B_H3

            DOTPSU4.M1  A_mult1_b,        A_in1_h,      A_t7
            DOTPSU4.M1  A_mult1,          A_in1_h,      A_t8
            PACK2       A_t7,             A_t8,         A_t9

            DOTPSU4.M1  A_mult2_b,        A_in3_h,      A_t10
            DOTPSU4.M1  A_mult2,          A_in3_h,      A_t11
            PACK2       A_t10,            A_t11,        A_t12

            ADD2        A_t9,             A_t12,        A_H5

            DOTPSU4.M2  B_mult1_b,        B_tmp2,       B_t7
            DOTPSU4.M2  B_mult1,          B_tmp2,       B_t8
            PACK2       B_t7,             B_t8,         B_t9

            DOTPSU4.M2  B_mult2_b,        B_tmp4,       B_t10
            DOTPSU4.M2  B_mult2,          B_tmp4,       B_t11
            PACK2       B_t10,            B_t11,        B_t12

            ADD2        B_t9,             B_t12,        B_H7

            ABS2        A_H,          A_H
            ABS2        B_H3,         B_H3
            ABS2        A_H5,         A_H5
            ABS2        B_H7,         B_H7


    ; Vertical filter mask:

            MPYU4.M1    A_in2_l2,     A_f2,     A_b10_h:A_b10_l
            MPYU4.M1    A_in1_h,      A_f1,     A_b11_h:A_b11_l
            MPYU4.M1    A_in2_l,      A_f2,     A_b12_h:A_b12_l
            MPYU4.M2    B_in2_h,      B_f2,     B_b13_h:B_b13_l
            MPYU4.M2    B_in2_h2,     B_f2,     B_b14_h:B_b14_l
            MPYU4.M2    B_tmp2,       B_f1,     B_b15_h:B_b15_l

            UNPKLU4     A_in1_l,      A_u1
            ADD2        A_u1,         A_b12_l,  A_u2
            UNPKLU4     A_in3_l,      A_u3
            ADD2        A_u2,         A_u3,     A_b1

            UNPKHU4     A_in1_l,      A_u4
            ADD2        A_u4,         A_b12_h,  A_u5
            UNPKHU4     A_in3_l,      A_u6
            ADD2        A_u5,         A_u6,     A_b2

            UNPKLU4     B_tmp1,       B_u1
            ADD2        B_u1,         B_b13_l,  B_u2
            UNPKLU4     B_tmp3,       B_u3
            ADD2        B_u2,         B_u3,     B_b3

            UNPKHU4     B_tmp1,       B_u4
            ADD2        B_u4,         B_b13_h,  B_u5
            UNPKHU4     B_tmp3,       B_u6
            ADD2        B_u5,         B_u6,     B_b4

            ADD2        A_b11_l,      A_b10_l,  A_u7
            UNPKLU4     A_in3_h,      A_u8
            ADD2        A_u7,         A_u8,     A_b5

            ADD2        A_b11_h,      A_b10_h,  A_u9
            UNPKHU4     A_in3_h,      A_u10
            ADD2        A_u9,         A_u10,    A_b6

            ADD2        B_b15_l,      B_b14_l,  B_u7
            UNPKLU4     B_tmp4,       B_u8
            ADD2        B_u7,         B_u8,     B_b7

            ADD2        B_b15_h,      B_b14_h,  B_u9
            UNPKHU4     B_tmp4,       B_u10
            ADD2        B_u9,         B_u10,    B_b8

            SUB2        A_b2,       A_b1,       A_u11
            ABS2        A_u11,      A_V2

            SUB2        B_b4,       B_b3,       B_u11
            ABS2        B_u11,      B_V4

            SUB2        A_b6,       A_b5,       A_u12
            ABS2        A_u12,      A_V6

            SUB2        B_b8,       B_b7,       B_u12
            ABS2        B_u12,      B_V8

            ADD2        A_H,        A_V2,       A_r9
            ADD2        B_H3,       B_V4,       B_r10
            ADD2        A_H5,       A_V6,       A_r11
            ADD2        B_H7,       B_V8,       B_r12

            SPACKU4     B_r10,      A_r9,       B_r13
            SPACKU4     B_r12,      A_r11,      B_r14

            SUB         B_final,    1,          B_final
 [B_final]  STNDW.D1T2  B_r14:B_r13,            *A_out++

            BDEC        loop,       A_cnt


            STNW        B_r13,      *A_out
            EXTU        B_r14,      24, 24,     B_r15
            STB         B_r15,      *++A_out[4]
            EXTU        B_r14,      16, 24,     B_r16
            STB         B_r16,      *++A_out

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_sobel.sa                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2max.sa/  1066928953  0     0     0       15709     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.9     Fri Sep 13 20:46:51 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2max                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2max                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to 255 in the output image.                                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|          _________                                 *
*                      |         |                                          *
*                      |         |                                          *
*             O        |         |                                          *
*             U        |         |                                          *
*             T    th _|. . . . .|                                          *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr      *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using CMPGTU4.  The comparison results (stored in        *
*       cFEDC, cBA98, c7654, and c3210) are expanded to masks using XPND4.  *
*       The results are a set of four masks (xFEDC, xBA98, x7654, and       *
*       x3210) which contain 0xFF in bytes that are greater than the        *
*       threshold, and 0x00 in bytes that are less than or equal to the     *
*       threshold.                                                          *
*                                                                           *
*       To complete the thresholding process, we compute the logical OR     *
*       between our original pixel values and the mask.  This forces        *
*       values above the threshold to 0xFF, and leaves the other values     *
*       unmodified.                                                         *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



;   void IMG_thr_gt2max
;   (
;       const unsigned char *in_data,            /*  Input image data    */
;       unsigned char       *restrict out_data,  /*  Output image data   */
;       short cols, short rows,                  /*  Image dimensions    */
;       unsigned char       threshold            /*  Threshold value     */
;   )
;   {
;       int i, pixels = rows * cols;
;       unsigned thththth;
;
;       _nassert((int)i_data % 8 == 0);
;       _nassert((int)o_data % 8 == 0);
;       _nassert(pixels % 16 == 0);
;       _nassert(pixels      >= 16);
;
;
;       thththth = _pack2(threshold, threshold);
;       thththth = _packl4(thththth, thththth);
;
;       #pragma MUST_ITERATE(4,,4);
;       #pragma UNROLL(4);
;       for (i = 0; i < pixels; i += 4)
;       {
;           unsigned p3p2p1p0, x3x2x1x0;
;           unsigned x3x2x1x0;
;           unsigned t3t2t1t0;
;
;           p3p2p1p0 = _amemd4_const(&in_data[i]);
;           x3x2x1x0 = _xpnd4(_cmpgtu4(p3p2p1p0, thththth));
;
;           _amemd4(&out_data[i]) = p3p2p1p0 | x3x2x1x0;
;       }
;   }

        .sect ".text:_thr_gt2max"
        .global _IMG_thr_gt2max
_IMG_thr_gt2max  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        A_i
            .reg        A_thththth, B_thththth
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_pFEDC:B_pBA98, A_p7654:A_p3210
            .reg        B_cFEDC,B_cBA98, A_c7654,A_c3210
            .reg        B_xFEDC,B_xBA98, A_x7654,A_x3210
            .reg        B_tFEDC:B_tBA98, A_t7654:A_t3210
            .no_mdep


            ; Calculate loop trip counter (unrolled 16x)
            MPY         .1X     A_cols,     B_rows,     A_i
            SHR         .1      A_i,        4,          A_i
            SUB         .1      A_i,        2,          A_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    8,          B_i_ptr
            ADD         .1X     B_o_ptr,    8,          A_o_ptr

            ; Generate packed threshold.
            PACK2       .1      A_th,       A_th,       A_thththth
            PACKL4      .1      A_thththth, A_thththth, A_thththth
            MV          .2X     A_thththth, B_thththth

            ; The main loop!

            .mptr               B_i_ptr,    i_ptr + 8,  16
            .mptr               A_i_ptr,    i_ptr + 0,  16
            .mptr               A_o_ptr,    o_ptr + 8,  16
            .mptr               B_o_ptr,    o_ptr + 0,  16
loop:       .trip       1
            LDDW        .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98
            LDDW        .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210

            CMPGTU4     .2      B_pFEDC,    B_thththth, B_cFEDC
            CMPGTU4     .2      B_pBA98,    B_thththth, B_cBA98
            CMPGTU4     .1      A_p7654,    A_thththth, A_c7654
            CMPGTU4     .1      A_p3210,    A_thththth, A_c3210

            XPND4       .2      B_cFEDC,                B_xFEDC
            XPND4       .2      B_cBA98,                B_xBA98
            XPND4       .1      A_c7654,                A_x7654
            XPND4       .1      A_c3210,                A_x3210

            OR          .2      B_pFEDC,    B_xFEDC,    B_tFEDC
            OR          .2      B_pBA98,    B_xBA98,    B_tBA98
            OR          .1      A_p7654,    A_x7654,    A_t7654
            OR          .1      A_p3210,    A_x3210,    A_t3210

            STDW        .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]
            STDW        .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]

            BDEC                loop,       A_i

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_gt2max.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_gt2thr.sa/  1066928953  0     0     0       13324     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Fri Sep 13 20:48:31 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_gt2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_gt2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                                                    *
*                      |                                                    *
*             O        |                                                    *
*             U        |                                                    *
*             T    th _|. . . . . _________                                 *
*             P        |        /.                                          *
*             U        |      /  .                                          *
*             T        |    /    .                                          *
*                      |  /      .                                          *
*                    0_|/________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_le2thr, IMG_thr_gt2max      *
*       and IMG_thr_le2min for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using MINU4.  This instruction with select the smaller   *
*       value between our input pixels and the threshold value.  The        *
*       result is that input values above the threshold are clamped to the  *
*       threshold value.                                                    *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .sect ".text:_thr_gt2thr"
        .global _IMG_thr_gt2thr
_IMG_thr_gt2thr  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        A_i,        A_thththth
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_pFEDC:B_pBA98, A_p7654:A_p3210
            .reg        B_tFEDC:B_tBA98, A_t7654:A_t3210
            .no_mdep


            ; Calculate loop trip counter (unrolled 16x)
            MPY         .1X     A_cols,     B_rows,     A_i
            SHR         .1      A_i,        4,          A_i
            SUB         .1      A_i,        2,          A_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    8,          B_i_ptr
            ADD         .1X     B_o_ptr,    8,          A_o_ptr

            ; Generate packed threshold.
            PACK2       .1      A_th,       A_th,       A_thththth
            PACKL4      .1      A_thththth, A_thththth, A_thththth

            ; The main loop!

            .mptr               B_i_ptr,    i_ptr + 8,  16
            .mptr               A_i_ptr,    i_ptr + 0,  16
            .mptr               A_o_ptr,    o_ptr + 8,  16
            .mptr               B_o_ptr,    o_ptr + 0,  16
loop:       .trip       1
            LDDW        .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98
            LDDW        .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210

            MINU4       .2X     B_pFEDC,    A_thththth, B_tFEDC
            MINU4       .2X     B_pBA98,    A_thththth, B_tBA98
            MINU4       .1      A_p7654,    A_thththth, A_t7654
            MINU4       .1      A_p3210,    A_thththth, A_t3210

            STDW        .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]
            STDW        .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]

            BDEC                loop,       A_i

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_gt2thr.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
thr_le2min.sa/  1066928953  0     0     0       15709     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Fri Sep 13 20:49:19 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2min                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2min                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are less than or equal to the       *
*       threshold are set to 0 in the output image.                         *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|. . . . . /                                         *
*             P        |         |                                          *
*             U        |         |                                          *
*             T        |         |                                          *
*                      |         |                                          *
*                    0_|_________|__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2thr,     *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using CMPGTU4.  The comparison results (stored in        *
*       cFEDC, cBA98, c7654, and c3210) are expanded to masks using XPND4.  *
*       The results are a set of four masks (xFEDC, xBA98, x7654, and       *
*       x3210) which contain 0xFF in bytes that are greater than the        *
*       threshold, and 0x00 in bytes that are less than or equal to the     *
*       threshold.                                                          *
*                                                                           *
*       To complete the thresholding process, we compute the logical AND    *
*       between our original pixel values and the mask.  This forces        *
*       values less than or equal to the threshold to 0x00, and leaves      *
*       the other values unmodified.                                        *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



;   void IMG_thr_le2min
;   (
;       const unsigned char *in_data,            /*  Input image data    */
;       unsigned char       *restrict out_data,  /*  Output image data   */
;       short cols, short rows,                  /*  Image dimensions    */
;       unsigned char       threshold            /*  Threshold value     */
;   )
;   {
;       int i, pixels = rows * cols;
;       unsigned thththth;
;
;       _nassert((int)i_data % 8 == 0);
;       _nassert((int)o_data % 8 == 0);
;       _nassert(pixels % 16 == 0);
;       _nassert(pixels      >= 16);
;
;
;       thththth = _pack2(threshold, threshold);
;       thththth = _packl4(thththth, thththth);
;
;       #pragma MUST_ITERATE(4,,4);
;       #pragma UNROLL(4);
;       for (i = 0; i < pixels; i += 4)
;       {
;           unsigned p3p2p1p0, x3x2x1x0;
;           unsigned x3x2x1x0;
;           unsigned t3t2t1t0;
;
;           p3p2p1p0 = _amemd4_const(&in_data[i]);
;           x3x2x1x0 = _xpnd4(_cmpgtu4(p3p2p1p0, thththth));
;
;           _amemd4(&out_data[i]) = p3p2p1p0 | x3x2x1x0;
;       }
;   }

        .sect ".text:_thr_le2min"
        .global _IMG_thr_le2min
_IMG_thr_le2min  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        A_i
            .reg        A_thththth, B_thththth
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_pFEDC:B_pBA98, A_p7654:A_p3210
            .reg        B_cFEDC,B_cBA98, A_c7654,A_c3210
            .reg        B_xFEDC,B_xBA98, A_x7654,A_x3210
            .reg        B_tFEDC:B_tBA98, A_t7654:A_t3210
            .no_mdep


            ; Calculate loop trip counter (unrolled 16x)
            MPY         .1X     A_cols,     B_rows,     A_i
            SHR         .1      A_i,        4,          A_i
            SUB         .1      A_i,        2,          A_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    8,          B_i_ptr
            ADD         .1X     B_o_ptr,    8,          A_o_ptr

            ; Generate packed threshold.
            PACK2       .1      A_th,       A_th,       A_thththth
            PACKL4      .1      A_thththth, A_thththth, A_thththth
            MV          .2X     A_thththth, B_thththth

            ; The main loop!

            .mptr               B_i_ptr,    i_ptr + 8,  16
            .mptr               A_i_ptr,    i_ptr + 0,  16
            .mptr               A_o_ptr,    o_ptr + 8,  16
            .mptr               B_o_ptr,    o_ptr + 0,  16
loop:       .trip       1
            LDDW        .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98
            LDDW        .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210

            CMPGTU4     .2      B_pFEDC,    B_thththth, B_cFEDC
            CMPGTU4     .2      B_pBA98,    B_thththth, B_cBA98
            CMPGTU4     .1      A_p7654,    A_thththth, A_c7654
            CMPGTU4     .1      A_p3210,    A_thththth, A_c3210

            XPND4       .2      B_cFEDC,                B_xFEDC
            XPND4       .2      B_cBA98,                B_xBA98
            XPND4       .1      A_c7654,                A_x7654
            XPND4       .1      A_c3210,                A_x3210

            AND         .2      B_pFEDC,    B_xFEDC,    B_tFEDC
            AND         .2      B_pBA98,    B_xBA98,    B_tBA98
            AND         .1      A_p7654,    A_x7654,    A_t7654
            AND         .1      A_p3210,    A_x3210,    A_t3210

            STDW        .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]
            STDW        .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]

            BDEC                loop,       A_i

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_le2min.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

thr_le2thr.sa/  1066928953  0     0     0       13324     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Fri Sep 13 20:39:59 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_thr_le2thr                                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void IMG_thr_le2thr                                                 *
*       (                                                                   *
*           const unsigned char *in_data,     /*  Input image data  */      *
*           unsigned char *restrict out_data, /*  Output image data */      *
*           short cols, short rows,           /*  Image dimensions  */      *
*           unsigned char       threshold     /*  Threshold value   */      *
*       )                                                                   *
*                                                                           *
*       This routine performs a thresholding operation on an input          *
*       image in in_data[] whose dimensions are given in the arguments      *
*       'cols' and 'rows'.  The thresholded pixels are written to the       *
*       output image pointed to by out_data[].  The input and output        *
*       are exactly the same dimensions.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Pixels that are above the threshold value are written to the        *
*       output unmodified.  Pixels that are greater than the threshold      *
*       are set to the threshold value in the output image.                 *
*                                                                           *
*       The exact thresholding function performed is described by           *
*       the following transfer function diagram:                            *
*                                                                           *
*                                                                           *
*                  255_|                                                    *
*                      |                  /                                 *
*                      |                /                                   *
*             O        |              /                                     *
*             U        |            /                                       *
*             T    th _|_________ /                                         *
*             P        |         .                                          *
*             U        |         .                                          *
*             T        |         .                                          *
*                      |         .                                          *
*                    0_|_________.__________                                *
*                      |         |        |                                 *
*                      0        th       255                                *
*                                                                           *
*                              INPUT                                        *
*                                                                           *
*       Please see the IMGLIB functions IMG_thr_gt2thr, IMG_thr_le2min      *
*       and IMG_thr_gt2max for other thresholding functions.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input and output buffers do not alias.                          *
*                                                                           *
*       The input and output buffers must be double-word aligned.           *
*                                                                           *
*       The total number of pixels rows*cols must be at least               *
*       16 and a multiple of 16.                                            *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled 16x.  Packed-data processing techniques        *
*       allow us to process all 16 pixels in parallel.                      *
*                                                                           *
*       Two LDDW instructions load in 16 pixels, designated p0 thru p9      *
*       pA thru pF.  These pixels are packed in the four registers pFEDC,   *
*       pBA98, p7654, and p3210 as follows:                                 *
*                                                                           *
*           Upper double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           pFEDC | pF | pE | pD | pC |    pBA98 | pB | pA | p9 | p8 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*           Lower double-word:                                              *
*                                                                           *
*                31  24   16    8    0          31  24   16    8    0       *
*                 +----+----+----+----+          +----+----+----+----+      *
*           p7654 | p7 | p6 | p5 | p4 |    p3210 | p3 | p2 | p1 | p0 |      *
*                 +----+----+----+----+          +----+----+----+----+      *
*                                                                           *
*       (Note that this diagram assumes a little endian memory              *
*       configuration, although this kernel works equally well in           *
*       either endian mode.)                                                *
*                                                                           *
*       We compare these four words against a packed copy of the threshold  *
*       value.  The packed threshold contains four copies of the threshold  *
*       value, one in each byte, like so:                                   *
*                                                                           *
*                              31  24   16    8    0                        *
*                               +----+----+----+----+                       *
*                      thththth | th | th | th | th |                       *
*                               +----+----+----+----+                       *
*                                                                           *
*       We compare using MAXU4.  This instruction with select the smaller   *
*       value between our input pixels and the threshold value.  The        *
*       result is that input values below the threshold are clamped to the  *
*       threshold value.                                                    *
*                                                                           *
*       The 16 results are then written with two STDWs.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       The input and output arrays must be double-word aligned.            *
*                                                                           *
*       No bank conflicts are expected to occur, although this depends      *
*       on the exact schedule produced by the compiler.                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .sect ".text:_thr_le2thr"
        .global _IMG_thr_le2thr
_IMG_thr_le2thr  .cproc  A_i_ptr, B_o_ptr, A_cols, B_rows, A_th
            .reg        A_i,        A_thththth
            .reg        B_i_ptr,    A_o_ptr
            .reg        B_pFEDC:B_pBA98, A_p7654:A_p3210
            .reg        B_tFEDC:B_tBA98, A_t7654:A_t3210
            .no_mdep


            ; Calculate loop trip counter (unrolled 16x)
            MPY         .1X     A_cols,     B_rows,     A_i
            SHR         .1      A_i,        4,          A_i
            SUB         .1      A_i,        2,          A_i

            ; Calculate twin pointers.
            ADD         .2X     A_i_ptr,    8,          B_i_ptr
            ADD         .1X     B_o_ptr,    8,          A_o_ptr

            ; Generate packed threshold.
            PACK2       .1      A_th,       A_th,       A_thththth
            PACKL4      .1      A_thththth, A_thththth, A_thththth

            ; The main loop!

            .mptr               B_i_ptr,    i_ptr + 8,  16
            .mptr               A_i_ptr,    i_ptr + 0,  16
            .mptr               A_o_ptr,    o_ptr + 8,  16
            .mptr               B_o_ptr,    o_ptr + 0,  16
loop:       .trip       1
            LDDW        .D2T2   *B_i_ptr++[2],          B_pFEDC:B_pBA98
            LDDW        .D1T1   *A_i_ptr++[2],          A_p7654:A_p3210

            MAXU4       .2X     B_pFEDC,    A_thththth, B_tFEDC
            MAXU4       .2X     B_pBA98,    A_thththth, B_tBA98
            MAXU4       .1      A_p7654,    A_thththth, A_t7654
            MAXU4       .1      A_p3210,    A_thththth, A_t3210

            STDW        .D1T2   B_tFEDC:B_tBA98,        *A_o_ptr++[2]
            STDW        .D2T1   A_t7654:A_t3210,        *B_o_ptr++[2]

            BDEC                loop,       A_i

            .return
            .endproc


* ========================================================================= *
*   End of file:  img_thr_le2thr.sa                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
wave_horz.sa/   1066928953  0     0     0       24526     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 18:59:25 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_horz : 1D Wavelet Transform                                *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Jan-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  /* Row of input pixels  */  *
*               const short *restrict qmf,      /* Low-pass QMF filter  */  *
*               const short *restrict mqmf,     /* High-pass QMF filter */  *
*               short       *restrict out_data, /* Row of output data   */  *
*               int                   cols      /* Length of input.     */  *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs a 1D Periodic Orthogonal Wavelet               *
*       decomposition.  This also performs athe row decomposition in a      *
*       2D wavelet transform.  An input signal x[n] is low pass and         *
*       high pass filtered and decimated by two.  This results in a         *
*       reference signal r1[n] which is the decimated output obtained       *
*       by dropping the odd samples of the low pass filtered output and     *
*       a detail signal d[n] obtained by dropping the odd samples of        *
*       the high-pass output.  A circular convolution algorithm is          *
*       implemented and hence the wavelet transform is periodic.  The       *
*       reference signal and the detail signal are half the size of the     *
*       original signal.  The reference signal may then be iterated         *
*       again to perform another scale of multi-resolution analysis.        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The main idea in optimizing the code is to issue one set of         *
*       reads to the x array and to perform low-pass and high pass          *
*       filtering together and to perfrom the filtering operations          *
*       together to maximize the number of multiplies.  The last 6          *
*       elements of the low-pass filter and the first 6 elements of the     *
*       high pass filter use the same input This is used to                 *
*       appropraitely change the output pointer to the low pass filter      *
*       after 6 iterations.  However for the first six iterations           *
*       pointer wrap-around can occurr and hence this creates a             *
*       dependency.  Pre-reading those 6 values outside the array           *
*       prevents the checks that introduce this dependency.  In addtion     *
*       the input data is read as word wide quantities and the low-pass     *
*       and high-pass filter coefficients are stored in registers           *
*       allowing for the input loop to be completely unrolled.  Thus        *
*       the assembly code has only one loop.  A predication register is     *
*       used to reset the low-pass output pointer after three               *
*       iterations.  The merging of the loops in this fashion allows f      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This kernel assumes that the # of filter taps for the qmf and       *
*       mqmf is 8.                                                          *
*                                                                           *
*       Both the filters are assumed to be double-word aligned and have     *
*       8 taps.                                                             *
*                                                                           *
*       The input line is assumed to be word aligned so that LDWs           *
*       may be performed.                                                   *
*                                                                           *
*       This code assumes that filter coefficients are maintained as        *
*       shorts in Q15 format.                                               *
*                                                                           *
*       It also assumes that input data is an array of shorts (16 bit)      *
*       (The input is assumed to be an array of shorts to allow for         *
*       re-using this kernel to perform Multi Resolution Analysis as        *
*       the output of this code will feedback again as input in the         *
*       next stage.)                                                        *
*                                                                           *
*       Since the transform is a dyadic wavelet cols should be a power      *
*       of 2. Cols must also be >=8.                                        *
*                                                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code has no bank conflicts.                                    *
*                                                                           *
*       This code is ENDIAN Neutral.                                        *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*       This code masks interrupts for nearly its entire duration.  As      *
*       a result, the code is interrupt tolerant but not                    *
*       interruptible.                                                      *
*                                                                           *
*       This code can implement the Daubechies D4 filterbank for            *
*       analysis with 4 vansishing moments.  The length of the analyzing    *
*       low-pass and high pass filters is 8 in that case.                   *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without restrictions: *
*       Note that the assembly code is hand optimized and restrictions      *
*       apply as noted under "ASSUMPTIONS".                                 *
*                                                                           *
*           void IMG_wave_horz                                              *
*           (                                                               *
*               const short *restrict in_data,  /* Row of input pixels  */  *
*               const short *restrict qmf,      /* Low-pass QMF filter  */  *
*               const short *restrict mqmf,     /* High-pass QMF filter */  *
*               short       *restrict out_data, /* Row of output data   */  *
*               int                   cols      /* Length of input.     */  *
*           );                                                              *
*                                                                           *
*           {                                                               *
*               int    i, res, iters;                                       *
*               int    j, sum, prod;                                        *
*               short *xptr  = in_data;                                     *
*               short *yptr  = out_data;                                    *
*               short *x_end = &in_data[cols - 1];                          *
*               short  xdata, hdata;                                        *
*               short *xstart;                                              *
*               short *filt_ptr;                                            *
*               int    M = 8;                                               *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  Set our loop trip count and starting x posn.     */     *
*               /*  'xstart' is used in the high-pass filter loop.   */     *
*               /* ------------------------------------------------- */     *
*               iters  = cols;                                              *
*               xstart = in_data + (cols - M)  + 2;                         *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  Low pass filter.  Iterate for cols/2 iterations  */     *
*               /*  generating cols/2 low pass sample points with    */     *
*               /*  the low-pass quadrature mirror filter.           */     *
*               /* ------------------------------------------------- */     *
*               for (i = 0; i < iters; i += 2)                              *
*               {                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Initialize our sum to the rounding value     */     *
*                   /*  and reset our pointer.                       */     *
*                   /* --------------------------------------------- */     *
*                   sum  = Qr;                                              *
*                   xptr = in_data + i;                                     *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Iterate over the taps in our QMF.            */     *
*                   /* --------------------------------------------- */     *
*                   for (j = 0; j < M; j++)                                 *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata =  qmf[j];                                    *
*                       prod  =  xdata * hdata;                             *
*                       sum  += prod;                                       *
*                       if (xptr > x_end) xptr = in_data;                   *
*                   }                                                       *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Adjust the Qpt of our sum and store result.  */     *
*                   /* --------------------------------------------- */     *
*                   res    = (sum >> Qpt);                                  *
*                   *out_data++ = res;                                      *
*               }                                                           *
*                                                                           *
*                                                                           *
*               /* ------------------------------------------------- */     *
*               /*  High pass filter.  Iterate for cols/2 iters      */     *
*               /*  generating cols/2 high pass sample points with   */     *
*               /*  the high-pass quadrature mirror filter.          */     *
*               /* ------------------------------------------------- */     *
*               for (i = 0; i < iters ; i+=2)                               *
*               {                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Initialize our sum and filter pointer.       */     *
*                   /* --------------------------------------------- */     *
*                   sum  = Qr;                                              *
*                   filt_ptr  = mqmf + (M - 1);                             *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Set up our data pointer.  This is slightly   */     *
*                   /*  more complicated due to how the data wraps   */     *
*                   /*  around the edge of the buffer.               */     *
*                   /* --------------------------------------------- */     *
*                   xptr = xstart;                                          *
*                   xstart += 2;                                            *
*                   if (xstart > x_end) xstart = in_data;                   *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Iterate over the taps in our QMF.            */     *
*                   /* --------------------------------------------- */     *
*                   for ( j = 0; j < M; j++)                                *
*                   {                                                       *
*                       xdata = *xptr++;                                    *
*                       hdata = *filt_ptr--;                                *
*                       prod  = xdata * hdata;                              *
*                       if (xptr > x_end) xptr = in_data;                   *
*                       sum  += prod;                                       *
*                   }                                                       *
*                                                                           *
*                   /* --------------------------------------------- */     *
*                   /*  Adjust the Qpt of our sum and store result.  */     *
*                   /* --------------------------------------------- */     *
*                   res = (sum >> Qpt);                                     *
*                   *out_data++ =  res;                                     *
*               }                                                           *
*           }                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

Qr          .set    16384
M           .set     8


        .sect ".text:_wave_horz"
        .global _IMG_wave_horz
_IMG_wave_horz:  .cproc   A_iptr, B_qmf, A_filter, B_optr, A_ish_x_dim

           .no_mdep

          ; Variables outside LOOP

          .reg        B_filter,    A_qmf

          .reg        A_h32:A_h10,   B_h76:B_h54
          .reg        A_l76:A_l54,   B_l32:B_l10

          .reg        B_h67,         B_h45,       A_h23
          .reg        A_h01,         B_M,         A_i
          .reg        B_offset,      A_offset,    B_p
          .reg        A_xiptr,       B_xiptr,     B_x10
          .reg        B_x32,         A_x54,       A_optr
          .reg        A_yptr_h,      B_yptr_l0,   B_yptr_l1
          .reg        B_iptr,        A_qr,        B_qr

          ; Variables within the loop

          .reg        B_sum_h,       A_sum_l,     A_x76
          .reg        B_prod_h10,    B_prod_h32,  A_prod_h54
          .reg        A_prod_h76,    B_prod_l10,  B_prod_l32
          .reg        A_prod_l54,    A_prod_l76,  B_tmph0
          .reg        A_tmph1,       B_tmpl0,     A_tmpl1
          .reg        B_tmp_h,       A_tmp_l,     B_res_hi
          .reg        A_res_low


          ADD.2x      A_filter,    8,           B_filter    ; highpass even ptr
          ADD.1x      B_qmf,       8,           A_qmf       ; lowpass even ptr

          LDDW.D1T1   *A_filter[0], A_h32:A_h10             ; highpass coeff.
          LDDW.D2T2   *B_filter[0], B_h76:B_h54             ; highpass coeff.

          LDDW.D2T2   *B_qmf[0], B_l32:B_l10                ; lowpass coeff.
          LDDW.D1T1   *A_qmf[0], A_l76:A_l54                ; lowpass coeff.

          PACKLH2.2   B_h76,     B_h76,        B_h67        ; swap2
          PACKLH2.2   B_h54,     B_h54,        B_h45        ; swap2
          PACKLH2.1   A_h32,     A_h32,        A_h23        ; swap2
          PACKLH2.1   A_h10,     A_h10,        A_h01        ; swap2

          MVK.2       M,            B_M                     ; M = 8
          SHRU.1      A_ish_x_dim,  1,         A_i          ; i = X >> 1
          SUB.2x      A_ish_x_dim,  B_M,       B_offset     ; off = x - M + 2
          ADD.2       B_offset,     2,         B_offset     ; off
          MV.1x       B_offset,     A_offset                ; Make copy

          MVK.2       3,            B_p                     ; p to switch ptrs
          ADDAH.1     A_iptr,       A_offset,  A_xiptr      ; xiptr = iptr + off
          ADD.2x      A_xiptr,      4,         B_xiptr      ; twin xiptr

          LDW.D1T2   *A_xiptr++[2],  B_x10                  ; Load x10
          LDW.D2T2   *B_xiptr++[2],  B_x32                  ; Load x32
          LDW.D1T1   *A_xiptr++[2],  A_x54                  ; Load x54

          SHRU.2      B_offset,     1,         B_offset     ; off = x - M + 2
          MV.1x       B_offset,     A_offset                ; off >>= 1

          MV.1x       B_optr,       A_optr                  ; Copy optr
          ADDAH.1     A_optr,       A_i,       A_yptr_h     ; y_h  = optr[x >>1]
          ADDAH.2     B_optr,       B_offset,  B_yptr_l0    ; y_lo = optr - off
          MV.2        B_optr,       B_yptr_l1               ; y_l1 = optr


          MV.2x       A_iptr,       B_iptr                  ; B_iptr = iptr
          MVKL.1      Qr,           A_qr                    ; Qr --> A_qr
          MVKH.1      Qr,           A_qr                    ; Qr --> A_qr
          MV.2x       A_qr,         B_qr                    ; A_qr = B_qr


          .mptr       B_iptr,       A_iptr+0,  4            ; Assume worst
          .mptr       A_yptr_h,     A_iptr+0,  2            ; case banking
          .mptr       B_yptr_l0,    A_iptr+0,  2            ; scenario
          .mptr       B_yptr_l1,    A_iptr+0,  2            ; Schedule sep.

LOOP:     .trip       16

          MV.2        B_qr,         B_sum_h                 ; sum_l = qr
          MV.1        A_qr,         A_sum_l                 ; sum_h = qr

          LDW.D2T1    *B_iptr++,     A_x76                  ; Load x76

          DOTP2.2     B_x10,        B_h67,       B_prod_h10 ; x0h7 + x1h6
          DOTP2.2     B_x32,        B_h45,       B_prod_h32 ; x2h5 + x3h4
          DOTP2.1     A_x54,        A_h23,       A_prod_h54 ; x4h3 + x5h2
          DOTP2.1     A_x76,        A_h01,       A_prod_h76 ; x7h0 + x6h1

          DOTP2.2     B_x10,        B_l10,       B_prod_l10 ; x0l0 + x1l1
          DOTP2.2     B_x32,        B_l32,       B_prod_l32 ; x2l2 + x3l3
          DOTP2.1     A_x54,        A_l54,       A_prod_l54 ; x4l4 + x5l5
          DOTP2.1     A_x76,        A_l76,       A_prod_l76 ; x6l6 + x7l7

          ADD.2       B_prod_h10,   B_prod_h32,  B_tmph0    ; tmph0
          ADD.1       A_prod_h54,   A_prod_h76,  A_tmph1    ; tmph1
          ADD.2       B_prod_l10,   B_prod_l32,  B_tmpl0    ; tmph2
          ADD.1       A_prod_l54,   A_prod_l76,  A_tmpl1    ; tmph3

          ADD.2x      B_tmph0,      A_tmph1,     B_tmp_h    ; tmph
          ADD.1x      A_tmpl1,      B_tmpl0,     A_tmp_l    ; tmpl

          ADD.2       B_sum_h,      B_tmp_h,     B_sum_h    ; sum_h
          ADD.1       A_sum_l,      A_tmp_l,     A_sum_l    ; sum_l

          SHR.2       B_sum_h,      15,          B_res_hi   ; res_h
          SHR.1       A_sum_l,      15,          A_res_low  ; res_l

          MV.2        B_x32,        B_x10                   ; x10 = x32
          MV.2x       A_x54,        B_x32                   ; x32 = x54
          MV.1        A_x76,        A_x54                   ; x54 = x76

          STH.D1T2    B_res_hi,      *A_yptr_h++            ; Store *y_hp

[B_p]     STH.D2T1    A_res_low,     *B_yptr_l0++           ; Store *y_lp0
[!B_p]    STH.D2T1    A_res_low,     *B_yptr_l1++           ; Store *y_lp1
[B_p]     SUB.2       B_p,            1,         B_p        ; pred.for LP

[A_i]     SUB.1       A_i,            1,         A_i        ; if (i) i--
[A_i]     B.1         LOOP                                  ; if (i) B LOOP

          .return
          .endproc

* ========================================================================= *
*   End of file:  img_wave_horz.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
wave_vert.sa/   1066928953  0     0     0       33312     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Thu Sep  6 19:00:00 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_wave_vert : Vertical Pass of Wavelet Transform                  *
*                                                                           *
*   REVISION DATE                                                           *
*       08-Feb-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   /* Array of row pointers */    *
*           const short *restrict qmf,       /* Low pass QMF filter   */    *
*           const short *restrict mqmf,      /* High pass QMF filter  */    *
*           short       *restrict out_ldata, /* Low pass output data  */    *
*           short       *restrict out_hdata, /* High pass output data */    *
*           int cols                     /* Length of rows to process */    *
*       );                                                                  *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs the vertical pass of 2D wavelet              *
*       transform It performs a vertical filter on 8 rows which are         *
*       pointed to by the pointers contained in an array of pointers.       *
*       It produces two lines worth of output, one being the low-pass       *
*       and the other being the high pass result. Instead of performing     *
*       a transpose on the column and re-using the wave_horz kernel,        *
*       the vertical filter is traversed over the entire width of the       *
*       line and the low pass and high pass filtering kernels are           *
*       performed together.                                                 *
*                                                                           *
*       This implies that the low-pass and highpass filters be              *
*       overlapped in execution so that the input data array may be         *
*       loaded once and both filters can be exceuted in parallel.           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop that advances along each filter tap is totally       *
*       optimized by unrolling.  Double-word loads are performed, and       *
*       paired multiplies are used to perform four iterations of            *
*       low-pass filter in parallel.                                        *
*                                                                           *
*       For the high-pass kernel, the same loop is reused, in order         *
*       to save codesize.  This is done by loading the filter               *
*       coefficients in a special order.                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Since the wavelet transform is dyadic, the image dimensions         *
*       "rows" and "cols" are assumed to be powers of 2.  No checking       *
*       is done within the code to ensure this.                             *
*                                                                           *
*       The input filters qmf and mqmf are assumed to be word aligned       *
*       and have exactly 8 taps.                                            *
*                                                                           *
*       The output data and input data on any line is assumed to be         *
*       dword-aligned.                                                      *
*                                                                           *
*       The mqmf filter is constructed from the qmf as follows:             *
*                                                                           *
*           status = -1;                                                    *
*           for (i = 0; i < M; i++)                                         *
*           {                                                               *
*               status = status * -1;                                       *
*               hdata  = qmf[i] * status;                                   *
*               filter[i] = hdata;                                          *
*           }                                                               *
*                                                                           *
*       The kernels assume that the number of filter taps is exactly        *
*       8.  In addition data that is loaded for producing out_ldata[0]      *
*       and out_hdata[0] is not identical. The data loaded for              *
*       producing out_hdata[0] produces results at the location             *
*                                                                           *
*           out_lstart = o_im + ((rows >> 1) - 3) * cols                    *
*           out_hstart = o_im + (rows >> 1) * cols                          *
*                                                                           *
*       Where o_im is start of output image, rows is # of rows of the       *
*       input image, and cols is # of cols of the output image.             *
*                                                                           *
*       The following table illustrates how ylptr and yhptr need to be      *
*       updated at the start of each call to this function:                 *
*                                                                           *
*       Call#        out_ldata                  out_hdata                   *
*         1          out_lstart                 out_hstart                  *
*         2          out_lstart + cols          out_hstart + cols           *
*         3          out_lstart + 2*cols        out_hstart + 2*cols         *
*                                                                           *
*       At this point ylptr wraps around to become o_im, while yhptr        *
*       proceeds as usual:                                                  *
*                                                                           *
*         4          o_im                       out_hstart + 3*cols         *
*                                                                           *
*       In addition the kernel accepts a pointer to an array of             *
*       pointers for each input line so that a working buffer of 10         *
*       lines can be used to effectively mix DMA's and processing as        *
*       shown below:                                                        *
*                                                                           *
*       ihptr                        LINE BUFFER                            *
*       ptr0   ---->|-------------------------------------------------|     *
*       ptr1   ---->|-------------------------------------------------|     *
*       ...                                                                 *
*       ptr7   ---->|-------------------------------------------------|     *
*                                                                           *
*       At the start of the kernel 8 input lines are filled to the          *
*       first 8 lines and processing begins.  In the background the next    *
*       two lines are fetched.  The pointers are moved up by 2 namely       *
*       ptr[i] = ptr[i+2] and the last two lines now point to lines 9       *
*       and 10 and processing starts again.  In the background the next     *
*       two lines are brought in the first two lines of the line            *
*       buffer.  Pointers move up again by 2 but now the last two           *
*       pointers to line 0 and 1.  This pattern then repeats.               *
*                                                                           *
*       The first line to begin filtering is always obtained from           *
*       ptr[0], the next from ptr[1] and so on.                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       In order to eliminate bank conflicts succesive lines in the         *
*       line buffer or the pointers to these lines are seperated by         *
*       exactly two banks (one word) so that loads to any succesive         *
*       lines may be parallelized together.                                 *
*                                                                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   C CODE                                                                  *
*       void IMG_wave_vert                                                  *
*       (                                                                   *
*           const short *restrict                                           *
*                       *restrict in_data,   /* Array of row pointers */    *
*           const short *restrict qmf,       /* Low pass QMF filter   */    *
*           const short *restrict mqmf,      /* High pass QMF filter  */    *
*           short       *restrict out_ldata, /* Low pass output data  */    *
*           short       *restrict out_hdata, /* High pass output data */    *
*           int cols                     /* Length of rows to process */    *
*       )                                                                   *
*       {                                                                   *
*           const int M = 8;                                                *
*           int            i, iters, j;                                     *
*           int            sum_h, sum_l;                                    *
*           int            prod_h, prod_l;                                  *
*                                                                           *
*           short          res_h, res_l;                                    *
*           short          xdata, hdata, ldata;                             *
*           short          *filt_ptr;                                       *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  iters: variable for the # of loop iterations.         */    *
*           /*                                                        */    *
*           /*  Both the low pass and the high pass filters produce   */    *
*           /*  'iters' points, which is also the width of the input  */    *
*           /*  line.  The low-pass filter reads filter coefficients  */    *
*           /*  from qmf and the high pass filter reads filter        */    *
*           /*  coefficients from the conjugate mirror filter. In     */    *
*           /*  addition note that the low-pass filter coefficients   */    *
*           /*  are read in increasing order while the high pass the  */    *
*           /*  filter coefficients are read in the opposite order.   */    *
*           /* ------------------------------------------------------ */    *
*           iters = cols;                                                   *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  Since the filters have fractional point coefficients, */    *
*           /*  all math is done using Q15 fixed-point arithmetic.    */    *
*           /*  Qr is the associated round value and is set as        */    *
*           /*  follows:                                              */    *
*           /*                                                        */    *
*           /*      #define Qpt 15                                    */    *
*           /*      #define Qr 16384                                  */    *
*           /*                                                        */    *
*           /*  Low-Pass filter: ihptr contains 8 pointers which      */    *
*           /*  point to input lines. The filters are placed          */    *
*           /*  vertically and input data is read from 8 seperate     */    *
*           /*  lines. Hence data-reuse is not possible when          */    *
*           /*  traversing horizontally. sum_l is initialized to Qr   */    *
*           /*  and contains the low-pass FIR sum at the end of the   */    *
*           /*  j loop. sum_h contains the accumulator result for     */    *
*           /*  the high pass filter in a similar fashion.  M is      */    *
*           /*  assumed to be 8 by all kernels and is # filter taps   */    *
*           /*  for D4.                                               */    *
*           /* ------------------------------------------------------ */    *
*                                                                           *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_l    = Qr;                                              *
*               filt_ptr = qmf;                                             *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   ldata   =  *filt_ptr++;                                 *
*                   prod_l  =  xdata * ldata;                               *
*                   sum_l  +=  prod_l;                                      *
*               }                                                           *
*                                                                           *
*               res_l    = (sum_l >> Qpt);                                  *
*               *out_ldata++ = res_l;                                       *
*           }                                                               *
*                                                                           *
*           /* ------------------------------------------------------ */    *
*           /*  High-Pass filter:  ihptr contains 8 pointers which    */    *
*           /*  point to input lines.  The filters are placed         */    *
*           /*  vertically and input data is read from 8 seperate     */    *
*           /*  lines.  Hence data-reuse is not possible when         */    *
*           /*  traversing horizontally.  sum_h is initialized to     */    *
*           /*  Qr and contains the low-pass FIR sum at the end of    */    *
*           /*  the j loop.  sum_h contains the accumulator result    */    *
*           /*  for the high pass filter in a similar fashion.  M     */    *
*           /*  is # filter taps and is assumed to be 8 by all        */    *
*           /*  kernels.                                              */    *
*           /* ------------------------------------------------------ */    *
*           for ( i = 0; i < iters; i++)                                    *
*           {                                                               *
*               sum_h    = Qr;                                              *
*               filt_ptr = mqmf + M - 1;                                    *
*                                                                           *
*               for ( j = 0; j < M; j++)                                    *
*               {                                                           *
*                   xdata   =  in_data[j][i];                               *
*                   hdata   =  *filt_ptr--;                                 *
*                   prod_h  =  xdata * hdata;                               *
*                   sum_h  +=  prod_h;                                      *
*               }                                                           *
*                                                                           *
*               res_h    = (sum_h >> Qpt);                                  *
*               *out_hdata++ = res_h;                                       *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   BIBLIOGRAPHY                                                            *
*       Mallat, Stephane. "A Wavelet Tour of Signal Processing", pg. 309.   *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
Qr          .set      16384

        .sect ".text:_wave_vert"
        .global _IMG_wave_vert
_IMG_wave_vert:  .cproc A_ihptr, B_qmf, A_filter, B_ylptr, A_yhptr, A_x
            .no_mdep

            ; regs before loopl

            .reg B_ihptr,   A_in0ptr, B_in1ptr
            .reg A_in2ptr,  B_in3ptr, A_in4ptr
            .reg B_in5ptr,  A_in6ptr, B_in7ptr
            .reg A_qmf,     A_l10,    B_l32
            .reg A_l54,     B_l76,    A_iters
            .reg B_qr,      A_l00,    A_l11
            .reg B_l22,     B_l33,    A_l44
            .reg A_l55,     B_l66,    B_l77
            .reg B_l11,     A_l22,    B_l44
            .reg A_l66,     A_yptr,   B_jiters
            .reg B_l55,     A_qr,     B_l00
            .reg A_l33,     A_l77

            ; regs in loopl

            .reg A_xdataI8:A_xdataA0,   B_xdataJ9:B_xdataB1
            .reg A_xdataKA:A_xdataC2,   B_xdataLB:B_xdataD3
            .reg A_xdataMC:A_xdataE4,   B_xdataND:B_xdataF5
            .reg A_xdataOE:A_xdataG6,   B_xdataPF:B_xdataH7

            .reg A_prod1:A_prod0,       B_prod3:B_prod2
            .reg A_prod5:A_prod4,       B_prod7:B_prod6
            .reg A_prod9:A_prod8,       B_prodB:B_prodA
            .reg A_prodD:A_prodC,       B_prodF:B_prodE

            .reg A_mpy1:A_mpy0,         B_mpy3:B_mpy2
            .reg A_mpy5:A_mpy4,         B_mpy7:B_mpy6
            .reg A_mpy9:A_mpy8,         B_mpyB:B_mpyA
            .reg A_mpyD:A_mpyC,         B_mpyF:B_mpyE

            .reg A_prod40,    B_prod26,  A_prod8C
            .reg B_prodAE,    A_prod15,  B_prod37
            .reg A_prod9D,    B_prodBF

            .reg A_mpy40,    B_mpy26,    A_mpy8C
            .reg B_mpyAE,    A_mpy15,    B_mpy37
            .reg A_mpy9D,    B_mpyBF

            .reg A_sum0,     B_sum1,     A_sum2
            .reg B_sum3,     A_sum4,     B_sum5
            .reg A_sum6,     B_sum7,     B_sum_t0
            .reg A_sum_t1,   B_sum_t2,   A_sum_t3

            .reg B_sum_l0,   A_sum_l1,   B_sum_l2
            .reg A_sum_l3,   A_sum_l0s,  B_sum_l1s
            .reg A_sum_l2s,  B_sum_l3s
            .reg B_oword1:B_oword0


            ; regs outside loop

            .reg  B_filter, A_h10,    B_h32
            .reg  A_h54,    B_h76


            ;-------------------------------------------------------------;
            ; Make Partitioning copy of pointer and read in pointer to    ;
            ; eight seperate lines in in0ptr.....in7ptr                   ;
            ;-------------------------------------------------------------;

            MV.2x     A_ihptr,      B_ihptr   ; Partitioning move of pointer
            LDW.D1T1  *+A_ihptr[0], A_in0ptr  ; Pointer to 1st line
            LDW.D2T2  *+B_ihptr[1], B_in1ptr  ; Pointer to 2nd line
            LDW.D1T1  *+A_ihptr[2], A_in2ptr  ; Pointer to 3rd line
            LDW.D2T2  *+B_ihptr[3], B_in3ptr  ; Pointer to 4th line
            LDW.D1T1  *+A_ihptr[4], A_in4ptr  ; Pointer to 5th line
            LDW.D2T2  *+B_ihptr[5], B_in5ptr  ; Pointer to 6th line
            LDW.D1T1  *+A_ihptr[6], A_in6ptr  ; Pointer to 7th line
            LDW.D2T2  *+B_ihptr[7], B_in7ptr  ; Pointer to 8th line

            ;--------------------------------------------------------------;
            ; Make partitioning copy of lowpass filter pointer and read in ;
            ; coefficients as packed words to make use of split multiplies ;
            ; and to minimize register pressure.                           ;
            ;--------------------------------------------------------------;

            MV.1x     B_qmf,       A_qmf      ; Partitioning move of pointer
            LDW.D1T1  *+A_qmf[0],  A_l10      ; Paired l10 read l1 | l0
            LDW.D2T2  *+B_qmf[1],  B_l32      ; Paired l32 read l3 | l2
            LDW.D1T1  *+A_qmf[2],  A_l54      ; Paired l54 read l5 | l4
            LDW.D2T2  *+B_qmf[3],  B_l76      ; Paired l76 read l7 | l6

            PACK2.1    A_l10,      A_l10,   A_l00    ; Packed l0
            PACKH2.1   A_l10,      A_l10,   A_l11    ; Packed l1
            PACK2.2    B_l32,      B_l32,   B_l22    ; Packed l2
            PACKH2.2   B_l32,      B_l32,   B_l33    ; Packed l3
            PACK2.1    A_l54,      A_l54,   A_l44    ; Packed l4
            PACKH2.1   A_l54,      A_l54,   A_l55    ; Packed l5
            PACK2.2    B_l76,      B_l76,   B_l66    ; Packed l6
            PACKH2.2   B_l76,      B_l76,   B_l77    ; Packed l7

            MV.2x      A_l11,      B_l11             ; Part. move
            MV.1x      B_l22,      A_l22             ; Part. move
            MV.2x      A_l44,      B_l44             ; Part. move
            MV.1x      B_l66,      A_l66             ; Part. move
            MV.2x      A_l55,      B_l55             ; Part. move

            MVKL.2     Qr,         B_qr              ; Round factor for Q15
            MVKH.2     Qr,         B_qr              ; Round factor for Q15
            MV.1x      B_qr,       A_qr              ; Round factor

            MV.1x      B_ylptr,    A_yptr            ; Partitioning move
            MVK.2      2,          B_jiters          ;
            MV.2x      A_filter,   B_filter          ;

LOOPJ:      .trip 2,2,2

            SHRU.1    A_x,         2,       A_iters  ; iters = x >> 2
            SUB.1     A_iters,     2,       A_iters  ;

            .mptr   A_in0ptr, in  + 0, 8   ; Assume succesive lines are
            .mptr   B_in1ptr, in  + 8, 8   ; one dword apart so that loads
            .mptr   A_in2ptr, in  + 0, 8   ; to succesivelines may
            .mptr   B_in3ptr, in  + 8, 8   ; parallelize. This allows the
            .mptr   A_in4ptr, in  + 0, 8   ; stores to be performed on
            .mptr   B_in5ptr, in  + 8, 8   ; seperate cycles without
            .mptr   A_in6ptr, in  + 0, 8   ; bank conflicts
            .mptr   B_in7ptr, in  + 8, 8   ; 8 extra dwords of space are
            .mptr   A_yptr,   out + 0, 8   ; needed

LOOPL:      .trip  2

            LDDW.D1T1   *A_in0ptr++, A_xdataI8:A_xdataA0
            LDDW.D2T1   *B_in1ptr++, B_xdataJ9:B_xdataB1
            LDDW.D1T1   *A_in2ptr++, A_xdataKA:A_xdataC2
            LDDW.D2T2   *B_in3ptr++, B_xdataLB:B_xdataD3
            LDDW.D1T1   *A_in4ptr++, A_xdataMC:A_xdataE4
            LDDW.D2T2   *B_in5ptr++, B_xdataND:B_xdataF5
            LDDW.D1T1   *A_in6ptr++, A_xdataOE:A_xdataG6
            LDDW.D2T2   *B_in7ptr++, B_xdataPF:B_xdataH7

            MPY2.1      A_xdataA0,  A_l00,   A_prod1:A_prod0   ; 9
            MPY2.2      B_xdataB1,  B_l11,   B_prod3:B_prod2   ; 10
            MPY2.1      A_xdataC2,  A_l22,   A_prod5:A_prod4   ; 11
            MPY2.2      B_xdataD3,  B_l33,   B_prod7:B_prod6   ; 12

            MPY2.1      A_xdataE4,  A_l44,   A_prod9:A_prod8   ; 13
            MPY2.2      B_xdataF5,  B_l55,   B_prodB:B_prodA   ; 14
            MPY2.1      A_xdataG6,  A_l66,   A_prodD:A_prodC   ; 15
            MPY2.2      B_xdataH7,  B_l77,   B_prodF:B_prodE   ; 16

            MPY2.1      A_xdataI8,  A_l00,   A_mpy1:A_mpy0     ; 17
            MPY2.2      B_xdataJ9,  B_l11,   B_mpy3:B_mpy2     ; 18
            MPY2.1      A_xdataKA,  A_l22,   A_mpy5:A_mpy4     ; 19
            MPY2.2      B_xdataLB,  B_l33,   B_mpy7:B_mpy6     ; 20

            MPY2.1      A_xdataMC,  A_l44,   A_mpy9:A_mpy8     ; 21
            MPY2.2      B_xdataND,  B_l55,   B_mpyB:B_mpyA     ; 22
            MPY2.1      A_xdataOE,  A_l66,   A_mpyD:A_mpyC     ; 23
            MPY2.2      B_xdataPF,  B_l77,   B_mpyF:B_mpyE     ; 24

            ADD.1       A_prod0,    A_prod4,     A_prod40      ; 25
            ADD.2       B_prod2,    B_prod6,     B_prod26      ; 26
            ADD.1       A_prod8,    A_prodC,     A_prod8C      ; 27
            ADD.2       B_prodA,    B_prodE,     B_prodAE      ; 28

            ADD.1       A_prod1,    A_prod5,     A_prod15      ; 29
            ADD.2       B_prod3,    B_prod7,     B_prod37      ; 30
            ADD.1       A_prod9,    A_prodD,     A_prod9D      ; 31
            ADD.2       B_prodB,    B_prodF,     B_prodBF      ; 32

            ADD.1       A_mpy0,     A_mpy4,      A_mpy40       ; 33
            ADD.2       B_mpy2,     B_mpy6,      B_mpy26       ; 34
            ADD.1       A_mpy8,     A_mpyC,      A_mpy8C       ; 35
            ADD.2       B_mpyA,     B_mpyE,      B_mpyAE       ; 36

            ADD.1       A_mpy1,     A_mpy5,      A_mpy15       ; 37
            ADD.2       B_mpy3,     B_mpy7,      B_mpy37       ; 38
            ADD.1       A_mpy9,     A_mpyD,      A_mpy9D       ; 39
            ADD.2       B_mpyB,     B_mpyF,      B_mpyBF       ; 40

            ADD.1       A_prod40,   A_prod8C,    A_sum0        ; 41
            ADD.2       B_prod26,   B_prodAE,    B_sum1        ; 42
            ADD.2x      A_sum0,     B_sum1,      B_sum_t0      ; 43

            ADD.1       A_prod15,   A_prod9D,    A_sum2        ; 44
            ADD.2       B_prod37,   B_prodBF,    B_sum3        ; 45
            ADD.1x      A_sum2,     B_sum3,      A_sum_t1      ; 46

            ADD.1       A_mpy40,    A_mpy8C,     A_sum4        ; 47
            ADD.2       B_mpy26,    B_mpyAE,     B_sum5        ; 48
            ADD.2x      A_sum4,     B_sum5,      B_sum_t2      ; 49

            ADD.1       A_mpy15,    A_mpy9D,     A_sum6        ; 50
            ADD.2       B_mpy37,    B_mpyBF,     B_sum7        ; 51
            ADD.1x      A_sum6,     B_sum7,      A_sum_t3      ; 52

            ADD.2       B_qr,       B_sum_t0,    B_sum_l0      ; 53
            ADD.1       A_qr,       A_sum_t1,    A_sum_l1      ; 54
            ADD.2       B_qr,       B_sum_t2,    B_sum_l2      ; 55
            ADD.1       A_qr,       A_sum_t3,    A_sum_l3      ; 56

            SHR.1x      B_sum_l0,   15,          A_sum_l0s     ; 57
            SHR.2x      A_sum_l1,   15,          B_sum_l1s     ; 58
            SHR.1x      B_sum_l2,   15,          A_sum_l2s     ; 59
            SHR.2x      A_sum_l3,   15,          B_sum_l3s     ; 60

            PACK2.2x    B_sum_l1s,  A_sum_l0s,   B_oword0      ; 61
            PACK2.2x    B_sum_l3s,  A_sum_l2s,   B_oword1      ; 62

            STDW.D1T2   B_oword1:B_oword0,   *A_yptr++         ; 63
            BDEC.1      LOOPL,   A_iters                       ; 64


            MV.1x       B_ihptr,  A_ihptr                      ; Reload

            LDW.D1T1   *+A_ihptr[0],  A_in0ptr                 ; Reload pointer
            LDW.D2T2   *+B_ihptr[1],  B_in1ptr                 ; Reload pointer
            LDW.D1T1   *+A_ihptr[2],  A_in2ptr                 ; Reload pointer
            LDW.D2T2   *+B_ihptr[3],  B_in3ptr                 ; Reload pointer
            LDW.D1T1   *+A_ihptr[4],  A_in4ptr                 ; Reload pointer
            LDW.D2T2   *+B_ihptr[5],  B_in5ptr                 ; Reload pointer
            LDW.D1T1   *+A_ihptr[6],  A_in6ptr                 ; Reload pointer
            LDW.D2T2   *+B_ihptr[7],  B_in7ptr                 ; Reload pointer

            MV.1x      B_filter,      A_filter                 ; Load highpass

            LDW.D1T1   *+A_filter[0],  A_h10                   ; Load h10
            LDW.D2T2   *+B_filter[1],  B_h32                   ; Load h32
            LDW.D1T1   *+A_filter[2],  A_h54                   ; Load h54
            LDW.D2T2   *+B_filter[3],  B_h76                   ; Load x76

            PACKH2.2   B_h76,          B_h76,        B_l00     ;
            PACK2.2    B_h76,          B_h76,        B_l11     ;
            PACKH2.1   A_h54,          A_h54,        A_l22     ;
            PACK2.1    A_h54,          A_h54,        A_l33     ;
            PACKH2.2   B_h32,          B_h32,        B_l44     ;
            PACK2.2    B_h32,          B_h32,        B_l55     ;
            PACKH2.1   A_h10,          A_h10,        A_l66     ;
            PACK2.1    A_h10,          A_h10,        A_l77     ;

            MV.1x      B_l00,          A_l00                   ; Part. move
            MV.2x      A_l33,          B_l33                   ; Part. move
            MV.1x      B_l44,          A_l44                   ;
            MV.2x      A_l77,          B_l77                   ;
            MV.1       A_yhptr,        A_yptr                  ; Part. move

[B_jiters]  SUB.2      B_jiters,     1,             B_jiters
[B_jiters]  B.2        LOOPJ

            .return
            .endproc

* ========================================================================= *
*   End of file:  img_wave_vert.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
yc_demux_0.sa/  1066928953  0     0     0       13109     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Sat Mar 16 02:19:17 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_be16 -- De-interleave a 4:2:2 BIG ENDIAN video stream  *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       09-Oct-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_be16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in BIG ENDIAN byte order       *
*       within each 4-byte word.  This is consistent with reading the       *
*       video stream from a word-oriented BIG ENDIAN device while the       *
*       C6000 device is in a LITTLE ENDIAN configuration.                   *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              |cb0 y1  cr0 y0 |cb2 y3  cr2 y2 |cb4 y5  cr4 y4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in BIG ENDIAN mode, while the CPU is in LITTLE ENDIAN     *
*       mode.  This results in a pixel ordering which is not                *
*       immediately obvious.  This function correctly reorders the          *
*       pixel values so that further processing may proceed in LITTLE       *
*       ENDIAN mode.                                                        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are double-word aligned.                    *
*       The input must be a multiple of 16 luma pixels long.                *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 16 times to allow for         *
*       processing 8 pixels in each datapath.                               *
*                                                                           *
*       Double-word loads and stores maximize memory bandwidth              *
*       utilization.                                                        *
*                                                                           *
*       This code uses _gmpy4() to ease the L/S/D unit bottleneck on        *
*       ANDs.  The _gmpy4(value, 0x00010001) is equivalent to               *
*       value & 0x00FF00FF, as long as the size field of GFPGFR is          *
*       equal to 7.  (The polynomial does not matter.)                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_be16"
        .global _IMG_yc_demux_be16
_IMG_yc_demux_be16 .cproc  A_n, B_yc, A_y, B_cr, A_cb
                  .no_mdep

        .reg  B_yErEyFbE:B_yCrCyDbC
        .reg  B_yArAyBbA:B_y8r8y9b8
        .reg  B_rErC:B_rAr8
        .reg  B_bEbC:B_bAb8
        .reg  B_yFyE:B_yDyC
        .reg  B_yByA:B_y9y8
        .reg  A_y6r6y7b6:A_y4r4y5b4
        .reg  A_y2r2y3b2:A_y0r0y1b0
        .reg  A_r6r4:A_r2r0
        .reg  A_b6b4:A_b2b0
        .reg  A_y7y6:A_y5y4
        .reg  A_y3y2:A_y1y0
        .reg  B_00FF00FF
        .reg  B_y
        .reg  B_cb
        .reg  B_rEbE
        .reg  B_rCbC
        .reg  B_rAbA
        .reg  B_r8b8
        .reg  B_yEyF
        .reg  B_yCyD
        .reg  B_yAyB
        .reg  B_y8y9
        .reg  B_gfpgfr
        .reg  A_i
        .reg  A_00010001
        .reg  A_yc
        .reg  A_cr
        .reg  A_r6b6
        .reg  A_r4b4
        .reg  A_r2b2
        .reg  A_r0b0
        .reg  A_y6y7
        .reg  A_y4y5
        .reg  A_y2y3
        .reg  A_y0y1
        .reg  A_gfpgfr_


        SHRU    .1      A_n,        4,          A_i
        SUB     .1      A_i,        2,          A_i
        MVK     .2      0x00FF,     B_00FF00FF
        PACK2   .2      B_00FF00FF, B_00FF00FF, B_00FF00FF
        SHRU2   .1X     B_00FF00FF, 7,          A_00010001
        ADD     .1X     B_yc,       8,          A_yc
        ADD     .1      A_yc,       8,          A_yc
        ADD     .2X     A_y,        8,          B_y
        ADD     .2      B_y,        8,          B_y
        ADD     .1X     B_cr,       8,          A_cr
        ADD     .2X     A_cb,       8,          B_cb

        ZERO    .1      A_gfpgfr_
        MVKLH   .1      0x0700,     A_gfpgfr_
        MVC     .2      GFPGFR,     B_gfpgfr
        MVC     .2X     A_gfpgfr_,  GFPGFR

        .mptr           A_yc,       yc + 16,    32
        .mptr           B_yc,       yc + 0,     32
        .mptr           B_y,        y  + 16,    32
        .mptr           A_y,        y  + 0,     32
        .mptr           A_cr,       cr + 8,     16
        .mptr           B_cr,       cr + 0,     16
        .mptr           B_cb,       cb + 8,     16
        .mptr           A_cb,       cb + 0,     16
loop:   .trip           2
        ;       ;       ;           ;           ;
        ; Load the packed pixels
        LDDW    .D1T2   *A_yc[1],   B_yErEyFbE:B_yCrCyDbC
        LDDW    .D1T2   *A_yc++[4], B_yArAyBbA:B_y8r8y9b8
        LDDW    .D2T1   *B_yc[1],   A_y6r6y7b6:A_y4r4y5b4
        LDDW    .D2T1   *B_yc++[4], A_y2r2y3b2:A_y0r0y1b0

        ; Do the chromas...
        AND             B_yErEyFbE, B_00FF00FF, B_rEbE
        AND             B_yCrCyDbC, B_00FF00FF, B_rCbC
        AND             B_yArAyBbA, B_00FF00FF, B_rAbA
        AND             B_y8r8y9b8, B_00FF00FF, B_r8b8
        AND             A_y6r6y7b6, B_00FF00FF, A_r6b6
        AND             A_y4r4y5b4, B_00FF00FF, A_r4b4
        AND             A_y2r2y3b2, B_00FF00FF, A_r2b2
        GMPY4           A_y0r0y1b0, A_00010001, A_r0b0

        PACKH2          B_rEbE,     B_rCbC,     B_rErC
        PACKH2          B_rAbA,     B_r8b8,     B_rAr8
        PACKH2          A_r6b6,     A_r4b4,     A_r6r4
        PACKH2          A_r2b2,     A_r0b0,     A_r2r0

        PACK2           B_rEbE,     B_rCbC,     B_bEbC
        PACK2           B_rAbA,     B_r8b8,     B_bAb8
        PACK2           A_r6b6,     A_r4b4,     A_b6b4
        PACK2           A_r2b2,     A_r0b0,     A_b2b0

        ; Do the lumas...
        ANDN            B_yErEyFbE, B_00FF00FF, B_yEyF
        ANDN            B_yCrCyDbC, B_00FF00FF, B_yCyD
        ANDN            B_yArAyBbA, B_00FF00FF, B_yAyB
        ANDN            B_y8r8y9b8, B_00FF00FF, B_y8y9
        ANDN            A_y6r6y7b6, B_00FF00FF, A_y6y7
        ANDN            A_y4r4y5b4, B_00FF00FF, A_y4y5
        ANDN            A_y2r2y3b2, B_00FF00FF, A_y2y3
        ANDN            A_y0r0y1b0, B_00FF00FF, A_y0y1

        ROTL            B_yEyF,     8,          B_yFyE
        ROTL            B_yCyD,     8,          B_yDyC
        ROTL            B_yAyB,     8,          B_yByA
        ROTL            B_y8y9,     8,          B_y9y8
        ROTL            A_y6y7,     8,          A_y7y6
        ROTL            A_y4y5,     8,          A_y5y4
        ROTL            A_y2y3,     8,          A_y3y2
        ROTL            A_y0y1,     8,          A_y1y0

        ; Store it out...
        STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]
        STDW    .D2T2   B_yByA:B_y9y8,          *B_y++[4]
        STDW    .D1T1   A_y7y6:A_y5y4,          *A_y[1]
        STDW    .D1T1   A_y3y2:A_y1y0,          *A_y++[4]

        STDW    .D1T2   B_rErC:B_rAr8,          *A_cr++[2]
        STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr++[2]
        STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb++[2]
        STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb++[2]

        BDEC            loop,       A_i
        MVC     .2      B_gfpgfr,   GFPGFR

        .endproc

* ========================================================================= *
*   End of file:  img_yc_demux_be16.sa                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

yc_demux_1.sa/  1066928953  0     0     0       12956     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Sat Mar 16 03:06:04 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_yc_demux_le16 -- De-interleave a 4:2:2 LITTLE ENDIAN video stream *
*                        into three separate LITTLE ENDIAN 16-bit planes    *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called as follows:              *
*                                                                           *
*       void IMG_yc_demux_le16                                              *
*       (                                                                   *
*           int n,                       // Number of luma pixels    //     *
*           const unsigned char * yc,    // Interleaved luma/chroma  //     *
*           short *restrict y,           // Luma plane (16-bit)      //     *
*           short *restrict cr,          // Cr chroma plane (16-bit) //     *
*           short *restrict cb           // Cb chroma plane (16-bit) //     *
*       );                                                                  *
*                                                                           *
*       The input array 'yc' is expected to be an interleaved 4:2:2         *
*       video stream.  The input is expected in LITTLE ENDIAN byte          *
*       order within each 4-byte word.  This is consistent with reading     *
*       the video stream from a word-oriented LITTLE ENDIAN device          *
*       while the C6000 device is in a LITTLE ENDIAN configuration.         *
*                                                                           *
*       In other words, the expected pixel order is:                        *
*                                                                           *
*                   Word 0           Word 1          Word 2                 *
*              +---------------+---------------+---------------+--          *
*        Byte# | 0   1   2   3 | 4   5   6   7 | 8   9  10  11 |...         *
*              | y0 cr0 y1 cb0 | y2 cr2 y3 cb2 | y4 cr4 y5 cb4 |...         *
*              +---------------+---------------+---------------+--          *
*                                                                           *
*       The output arrays 'y', 'cr', and 'cb' are expected to not           *
*       overlap.  The de-interleaved pixels are written as half-words       *
*       in LITTLE ENDIAN order.                                             *
*                                                                           *
*       Please see the IMGLIB function IMB_yc_demux_be16 for code which     *
*       handles input coming from a BIG ENDIAN device.                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function reads the byte-oriented pixel data, zero-extends      *
*       it, and then writes it to the appropriate result array.  Both       *
*       the luma and chroma values are expected to be unsigned.             *
*                                                                           *
*       The data is expected to be in an order consistent with reading      *
*       byte oriented data from a word-oriented peripheral that is          *
*       operating in LITTLE ENDIAN mode, while the CPU is in LITTLE         *
*       ENDIAN mode.  This function unpacks the byte-oriented data          *
*       so that further processing may proceed in LITTLE ENDIAN mode.       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays are double-word aligned.                    *
*       The input must be a multiple of 16 luma pixels long.                *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop has been unrolled a total of 16 times to allow for         *
*       processing 8 pixels in each datapath.                               *
*                                                                           *
*       Double-word loads and stores maximize memory bandwidth              *
*       utilization.                                                        *
*                                                                           *
*       This code uses _gmpy4() to ease the L/S/D unit bottleneck on        *
*       ANDs.  The _gmpy4(value, 0x00010001) is equivalent to               *
*       value & 0x00FF00FF, as long as the size field of GFPGFR is          *
*       equal to 7.  (The polynomial does not matter.)                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_yc_demux_le16"
        .global _IMG_yc_demux_le16
_IMG_yc_demux_le16 .cproc  A_n, B_yc, A_y, B_cr, A_cb
        .no_mdep

        .reg  B_bEyFrEyE:B_bCyDrCyC
        .reg  B_bAyBrAyA:B_b8y9r8y8
        .reg  A_b6y7r6y6:A_b4y5r4y4
        .reg  A_b2y3r2y2:A_b0y1r0y0
        .reg  B_rErC:B_rAr8, B_bErE, B_rEbE
        .reg  B_bEbC:B_bAb8, B_bCrC, B_rCbC
        .reg  A_r6r4:A_r2r0, B_bArA, B_rAbA
        .reg  A_b6b4:A_b2b0, B_b8r8, B_r8b8
        .reg  B_yFyE:B_yDyC, A_b6r6, A_r6b6
        .reg  B_yByA:B_y9y8, A_b4r4, A_r4b4
        .reg  A_y7y6:A_y5y4, A_b2r2, A_r2b2
        .reg  A_y3y2:A_y1y0, A_b0r0, A_r0b0
        .reg  B_00FF00FF
        .reg  B_y
        .reg  B_cb
        .reg  B_gfpgfr
        .reg  A_i
        .reg  A_00010001
        .reg  A_yc
        .reg  A_cr
        .reg  A_gfpgfr_


        SHRU    .1      A_n,        4,          A_i
        SUB     .1      A_i,        2,          A_i
        MVK     .2      0x00FF,     B_00FF00FF
        PACK2   .2      B_00FF00FF, B_00FF00FF, B_00FF00FF
        SHRU2   .1X     B_00FF00FF, 7,          A_00010001
        ADD     .1X     B_yc,       8,          A_yc
        ADD     .1      A_yc,       8,          A_yc
        ADD     .2X     A_y,        8,          B_y
        ADD     .2      B_y,        8,          B_y
        ADD     .1X     B_cr,       8,          A_cr
        ADD     .2X     A_cb,       8,          B_cb

        ZERO    .1      A_gfpgfr_
        MVKLH   .1      0x0700,     A_gfpgfr_
        MVC     .2      GFPGFR,     B_gfpgfr
        MVC     .2X     A_gfpgfr_,  GFPGFR

        .mptr           A_yc,       yc + 16,    32
        .mptr           B_yc,       yc + 0,     32
        .mptr           B_y,        y  + 16,    32
        .mptr           A_y,        y  + 0,     32
        .mptr           A_cr,       cr + 8,     16
        .mptr           B_cr,       cr + 0,     16
        .mptr           B_cb,       cb + 8,     16
        .mptr           A_cb,       cb + 0,     16
loop:   .trip           2
        ;       ;       ;           ;           ;
        ; Load the packed pixels
        LDDW    .D1T2   *A_yc[1],   B_bEyFrEyE:B_bCyDrCyC
        LDDW    .D1T2   *A_yc++[4], B_bAyBrAyA:B_b8y9r8y8
        LDDW    .D2T1   *B_yc[1],   A_b6y7r6y6:A_b4y5r4y4
        LDDW    .D2T1   *B_yc++[4], A_b2y3r2y2:A_b0y1r0y0

        ; Do the lumas...
        AND             B_bEyFrEyE, B_00FF00FF, B_yFyE
        AND             B_bCyDrCyC, B_00FF00FF, B_yDyC
        AND             B_bAyBrAyA, B_00FF00FF, B_yByA
        AND             B_b8y9r8y8, B_00FF00FF, B_y9y8
        AND             A_b6y7r6y6, B_00FF00FF, A_y7y6
        AND             A_b4y5r4y4, B_00FF00FF, A_y5y4
        AND             A_b2y3r2y2, B_00FF00FF, A_y3y2
        GMPY4           A_b0y1r0y0, A_00010001, A_y1y0

        ; Do the chromas...
        ANDN            B_bEyFrEyE, B_00FF00FF, B_bErE
        ANDN            B_bCyDrCyC, B_00FF00FF, B_bCrC
        ANDN            B_bAyBrAyA, B_00FF00FF, B_bArA
        ANDN            B_b8y9r8y8, B_00FF00FF, B_b8r8
        ANDN            A_b6y7r6y6, B_00FF00FF, A_b6r6
        ANDN            A_b4y5r4y4, B_00FF00FF, A_b4r4
        ANDN            A_b2y3r2y2, B_00FF00FF, A_b2r2
        ANDN            A_b0y1r0y0, B_00FF00FF, A_b0r0

        ROTL            B_bErE,     8,          B_rEbE
        ROTL            B_bCrC,     8,          B_rCbC
        ROTL            B_bArA,     8,          B_rAbA
        ROTL            B_b8r8,     8,          B_r8b8
        ROTL            A_b6r6,     8,          A_r6b6
        ROTL            A_b4r4,     8,          A_r4b4
        ROTL            A_b2r2,     8,          A_r2b2
        ROTL            A_b0r0,     8,          A_r0b0

        PACKH2          B_rEbE,     B_rCbC,     B_rErC
        PACKH2          B_rAbA,     B_r8b8,     B_rAr8
        PACKH2          A_r6b6,     A_r4b4,     A_r6r4
        PACKH2          A_r2b2,     A_r0b0,     A_r2r0

        PACK2           B_rEbE,     B_rCbC,     B_bEbC
        PACK2           B_rAbA,     B_r8b8,     B_bAb8
        PACK2           A_r6b6,     A_r4b4,     A_b6b4
        PACK2           A_r2b2,     A_r0b0,     A_b2b0

        ; Store it out...
        STDW    .D2T2   B_yFyE:B_yDyC,          *B_y[1]
        STDW    .D2T2   B_yByA:B_y9y8,          *B_y++[4]
        STDW    .D1T1   A_y7y6:A_y5y4,          *A_y[1]
        STDW    .D1T1   A_y3y2:A_y1y0,          *A_y++[4]

        STDW    .D1T2   B_rErC:B_rAr8,          *A_cr++[2]
        STDW    .D2T1   A_r6r4:A_r2r0,          *B_cr++[2]
        STDW    .D2T2   B_bEbC:B_bAb8,          *B_cb++[2]
        STDW    .D1T1   A_b6b4:A_b2b0,          *A_cb++[2]

        BDEC            loop,       A_i
        MVC     .2      B_gfpgfr,   GFPGFR

        .endproc

* ========================================================================= *
*   End of file:  img_yc_demux_le16.sa                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
ycbcr422p_.sa/  1066928953  0     0     0       32927     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  IMGLIB  DSP Image/Video Processing Library                              *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.10    Sun Sep 29 03:32:35 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       IMG_ycbcr422p_rgb565 -- Planarized YCbCr 4:2:2/4:2:0 to 16-bit      *
*                               RGB 5:6:5 color space conversion.           *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Sep-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and is called according to this        *
*       C prototype:                                                        *
*                                                                           *
*       void IMG_ycbcr422p_rgb565                                           *
*       (                                                                   *
*         const short         coeff[5],  /* Matrix coefficients.        */  *
*         const unsigned char *y_data,   /* Luminence data  (Y')        */  *
*         const unsigned char *cb_data,  /* Blue color-diff (B'-Y')     */  *
*         const unsigned char *cr_data,  /* Red color-diff  (R'-Y')     */  *
*         unsigned short                                                    *
*                    *restrict rgb_data, /* RGB 5:6:5 packed pixel out. */  *
*         unsigned            num_pixels /* # of luma pixels to process */  *
*       );                                                                  *
*                                                                           *
*       The 'coeff[]' array contains the color-space-conversion matrix      *
*       coefficients.  The 'y_data', 'cb_data' and 'cr_data' pointers       *
*       point to the separate input image planes.  The 'rgb_data' pointer   *
*       points to the output image buffer.  See below for alignment         *
*       constraints on these buffers.                                       *
*                                                                           *
*       The kernel is designed to process arbitrary amounts of 4:2:2        *
*       image data, although 4:2:0 image data may be processed as well.     *
*       For 4:2:2 input data, the 'y_data', 'cb_data' and 'cr_data'         *
*       arrays may hold an arbitrary amount of image data, including        *
*       multiple scan lines of image data.                                  *
*                                                                           *
*       For 4:2:0 input data, only a single scan-line (or portion           *
*       thereof) may be processed at a time.  This is achieved by           *
*       calling the function twice using the same row data for              *
*       'cr_data' and 'cb_data', and providing new row data for             *
*       'y_data'.  This is numerically equivalent to replicating the Cr     *
*       and Cb pixels vertically.                                           *
*                                                                           *
*       The coefficients in the coeff array must be in signed Q13 form.     *
*       These coefficients correspond to the following matrix equation:     *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       The output from this kernel is 16-bit RGB in 5:6:5 format.          *
*       The RGB components are packed into halfwords as shown below.        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Red    |  Green   |   Blue   |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*       This kernel can also return the red, green, and blue values in      *
*       the opposite order if a particular application requires it.         *
*       This is achieved by exchanging the 'cb_data' and 'cr_data'          *
*       arguments when calling the function, and by reversing the order     *
*       of coefficients in coeff[1] through coeff[4].  This essentially     *
*       implements the following matrix multiply:                           *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[4] ]   [ Y' -  16 ]     [ B']         *
*           [ coeff[0] coeff[3] coeff[2] ] * [ Cr - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[1] 0.0000   ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       The reversed RGB ordering output by this mode is as follows:        *
*                                                                           *
*                      15      11 10       5 4        0                     *
*                     +----------+----------+----------+                    *
*                     |   Blue   |  Green   |   Red    |                    *
*                     +----------+----------+----------+                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This kernel performs Y'CbCr to RGB conversion.  From the Color      *
*       FAQ, http://home.inforamp.net/~poynton/ColorFAQ.html :              *
*                                                                           *
*           Various scale factors are applied to (B'-Y') and (R'-Y')        *
*           for different applications.  The Y'PbPr scale factors are       *
*           optimized for component analog video.  The Y'CbCr scaling       *
*           is appropriate for component digital video, JPEG and MPEG.      *
*           Kodak's PhotoYCC(tm) uses scale factors optimized for the       *
*           gamut of film colors.  Y'UV scaling is appropriate as an        *
*           intermediate step in the formation of composite NTSC or PAL     *
*           video signals, but is not appropriate when the components       *
*           are keps separate.  Y'UV nomenclature is now used rather        *
*           loosely, and it sometimes denotes any scaling of (B'-Y')        *
*           and (R'-Y').  Y'IQ coding is obsolete.                          *
*                                                                           *
*       This code can perform various flavors of Y'CbCr to RGB              *
*       conversion as long as the offsets on Y, Cb, and Cr are -16,         *
*       -128, and -128, respectively, and the coefficients match the        *
*       pattern shown.                                                      *
*                                                                           *
*       The kernel implements the following matrix form, which involves 5   *
*       unique coefficients:                                                *
*                                                                           *
*           [ coeff[0] 0.0000   coeff[1] ]   [ Y' -  16 ]     [ R']         *
*           [ coeff[0] coeff[2] coeff[3] ] * [ Cb - 128 ]  =  [ G']         *
*           [ coeff[0] coeff[4] 0.0000   ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*                                                                           *
*       Below are some common coefficient sets, along with the matrix       *
*       equation that they correspond to.   Coefficients are in signed      *
*       Q13 notation, which gives a suitable balance between precision      *
*       and range.                                                          *
*                                                                           *
*       1.  Y'CbCr -> RGB conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  Expected ranges are [16..235] for   *
*           Y' and [16..240] for Cb and Cr.                                 *
*                                                                           *
*           coeff[] = { 0x2000, 0x2BDD, -0x0AC5, -0x1658, 0x3770 };         *
*                                                                           *
*           [ 1.0000    0.0000    1.3707 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.0000   -0.3365   -0.6982 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.0000    1.7324    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       2.  Y'CbCr -> RGB conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  (The matrix       *
*           has been scaled by 255/219.)  Expected ranges are [16..235]     *
*           for Y' and [16..240] for Cb and Cr.                             *
*                                                                           *
*           coeff[] = { 0x2543, 0x3313, -0x0C8A, -0x1A04, 0x408D };         *
*                                                                           *
*           [ 1.1644    0.0000    1.5960 ]   [ Y' -  16 ]     [ R']         *
*           [ 1.1644   -0.3918   -0.8130 ] * [ Cb - 128 ]  =  [ G']         *
*           [ 1.1644    2.0172    0.0000 ]   [ Cr - 128 ]     [ B']         *
*                                                                           *
*       3.  Y'CbCr -> BGR conversion with RGB levels that correspond to     *
*           the 219-level range of Y'.  This is equivalent to #1 above,     *
*           except that the R, G, and B output order in the packed          *
*           pixels is reversed.  Note:  The 'cr_data' and 'cb_data'         *
*           input arguments must be exchanged for this example as           *
*           indicated under USAGE above.                                    *
*                                                                           *
*           coeff[] = { 0x2000, 0x3770, -0x1658, -0x0AC5, 0x2BDD };         *
*                                                                           *
*           [ 1.0000    0.0000    1.7324 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.6982   -0.3365 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.3707    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       4.  Y'CbCr -> BGR conversion with the 219-level range of Y'         *
*           expanded to fill the full RGB dynamic range.  This is           *
*           equivalent to #2 above, except that the R, G, and B output      *
*           order in the packed pixels is reversed.  Note:  The             *
*           'cr_data' and 'cb_data' input arguments must be exchanged       *
*           for this example as indicated under USAGE above.                *
*                                                                           *
*           coeff[] = { 0x2000, 0x408D, -0x1A04, -0x0C8A, 0x3313 };         *
*                                                                           *
*           [ 1.0000    0.0000    2.0172 ]   [ Y' -  16 ]     [ B']         *
*           [ 1.0000   -0.8130   -0.3918 ] * [ Cr - 128 ]  =  [ G']         *
*           [ 1.0000    1.5960    0.0000 ]   [ Cb - 128 ]     [ R']         *
*                                                                           *
*       Other scalings of the color differences (B'-Y') and (R'-Y')         *
*       (sometimes incorrectly referred to as U and V) are supported, as    *
*       long as the color differences are unsigned values centered around   *
*       128 rather than signed values centered around 0, as noted above.    *
*                                                                           *
*       In addition to performing plain color-space conversion, color       *
*       saturation can be adjusted by scaling coeff[1] through coeff[4].    *
*       Similarly, brightness can be adjusted by scaling coeff[0].          *
*       General hue adjustment can not be performed, however, due to the    *
*       two zeros hard-coded in the matrix.                                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       Pixel replication is performed implicitly on chroma data to         *
*       reduce the total number of multiplies required.  The chroma         *
*       portion of the matrix is calculated once for each Cb, Cr pair,      *
*       and the result is added to both Y' samples.                         *
*                                                                           *
*       Matrix Multiplication is performed as a combination of MPY2s and    *
*       DOTP2s.  Saturation to 8bit values is performed using SPACKU4       *
*       which takes in 4 signed 16-bit values and saturates them to         *
*       unsigned 8-bit values.  The output of Matrix Multiplication would   *
*       ideally be in a Q13 format.  This however, cannot be fed directly   *
*       to SPACKU4.                                                         *
*                                                                           *
*       This implies a shift left by 3 bits, which could be pretty          *
*       expensive in terms of the number of shifts to be performed.  Thus,  *
*       to avoid being bottlenecked by so many shifts, the Y, Cr & Cb data  *
*       are shifted left by 3 before multiplication.  This is possible      *
*       because they are 8-bit unsigned data.  Due to this, the output of   *
*       Matrix Multiplication is in a Q16 format, which can be directly     *
*       fed to SPACKU4.                                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of luma samples to be processed needs to be a multiple   *
*       of 8.                                                               *
*       The input Y array needs to be double-word aligned.                  *
*       The input Cr and Cb arrays need to be word aligned                  *
*       The output image must be double-word aligned.                       *
*                                                                           *
*   SOURCE                                                                  *
*       Poynton, Charles et al.  "The Color FAQ,"  1999.                    *
*           http://home.inforamp.net/~poynton/ColorFAQ.html                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_ycbcr422pl_to_rgb565"
        .global _IMG_ycbcr422p_rgb565
_IMG_ycbcr422p_rgb565: .cproc  A_coef, B_y_data, A_cb_data, B_cr_data, A_rgb_ptr, B_num_pix

        .reg B_y_7654:B_y_3210,B_cr6420,A_cb6420,B_cr6420_,A_cb6420_,A_y_data
        .reg B_y_76_:B_y_54_,A_y_32_:A_y_10_,B_y_76,B_y_54,A_y_32,A_y_10
        .reg B_cr64:B_cr20,A_cb64:A_cb20,B_y_7_c0:B_y_6_c0,B_y_5_c0:B_y_4_c0
        .reg A_y_3_c0:A_y_2_c0,A_y_1_c0:A_y_0_c0,B_cr6_c1:B_cr4_c1,B_coef
        .reg B_cr2_c1:B_cr0_c1,A_cb6_c4:A_cb4_c4,A_cb2_c4:A_cb0_c4
        .reg B_cr6cb6,B_cr4cb4,A_cb2cr2,A_cb0cr0,B_cg6,B_cg4,A_cg2,A_cg0
        .reg B_r_7,B_r_6,B_r_5,B_r_4,A_r_3,A_r_2,A_r_1,A_r_0,B_g_7
        .reg B_g_6,B_g_5,B_g_4,A_g_3,A_g_2,A_g_1,A_g_0,B_b_7,B_b_6
        .reg B_b_5,B_b_4,A_b_3,A_b_2,A_b_1,A_b_0,B_r_76,B_r_54,A_r_32
        .reg A_r_10,B_g_76,B_g_54,A_g_32,A_g_10,B_b_76,B_b_54,A_b_32
        .reg A_b_10,B_r_7654,A_r_3210,B_g_7654,A_g_3210,B_b_7654,A_b_3210
        .reg B_r_7654_,B_g_7654_,B_b_7654_,A_r_3210_,A_g_3210_,A_b_3210_
        .reg B_r7_r6:B_r5_r4,A_r3_r2:A_r1_r0,B_g7_g6:B_g5_g4,A_g3_g2:A_g1_g0
        .reg B_b_7654__,A_b_3210__,B_b7_b6:B_b5_b4,A_b3_b2:A_b1_b0
        .reg B_r_b76,B_r_b54,A_r_b32,A_r_b10
        ;.reg B_rgb76,B_rgb54,A_rgb32,A_rgb10
        .reg B_rgb_ptr,B_i,B_c0,B_c1,B_c3c2:B_c1c0,A_c2c3,A_c4
        .reg A_k80,A_k08,B_k16,A_msk6,B_msk5,B_k08,B_k01
        .reg B_rgb76:B_rgb54,A_rgb32:A_rgb10
        .reg A_c0, A_k01

        .no_mdep

        ;; ------------------------------------------------------------ ;;
        ;;  Load our five coefficients.  We do this w/ two LDs, then    ;;
        ;;  use a small set of PACKs to configure the coefficients as   ;;
        ;;  required.                                                   ;;
        ;; ------------------------------------------------------------ ;;

        LDNDW   .D1T2   *A_coef[0], B_c3c2:B_c1c0
        LDH     .D1T1   *A_coef[4], A_c4
        PACK2   .2      B_c1c0,     B_c1c0,     B_c0   ; Packed luma coef
        PACKH2          B_c1c0,     B_c1c0,     B_c1   ; Packed r_cr
        ROTL    .1X     B_c3c2,     16,         A_c2c3 ; Packed g_cb and g_cr
        PACK2           A_c4,       A_c4,       A_c4   ; Packed b_cb and b_cb


        ;; ------------------------------------------------------------ ;;
        ;;  Generate masking and offset constants:                      ;;
        ;;      A_k80   0x80808080  Toggles sign bits on bytes          ;;
        ;;      A_k08   0x08080808  Expands bytes and shifts left 3     ;;
        ;;      A_k16   0x00800080  Q3 Bias to subtract from chroma     ;;
        ;;      B_k01   0x01010101  Expands bytes to halfwords          ;;
        ;;      A_msk6  0xFCFCFCFC  Keeps upper 6 bits of each byte     ;;
        ;;      A_msk5  0xF8F8F8F8  Keeps upper 5 bits of each byte     ;;
        ;; ------------------------------------------------------------ ;;
        MVKL    .1      0x80808080, A_k80              ; lo half
        MVKL    .1      0x08080808, A_k08              ; lo half
        MVKL    .2      0x00800080, B_k16              ; lo half
        MVKL    .2      0x01010101, B_k01              ; lo half
        MVKL    .1      0xFCFCFCFC, A_msk6             ; lo half
        MVKL    .2      0xF8F8F8F8, B_msk5             ; lo half

                        ;           ;           ;
        PACK2   .1      A_k80,      A_k80,      A_k80  ; hi half
        PACK2   .1      A_k08,      A_k08,      A_k08  ; hi half
        PACK2   .2      B_k16,      B_k16,      B_k16  ; hi half
        PACK2   .2      B_k01,      B_k01,      B_k01  ; hi half
        PACK2   .1      A_msk6,     A_msk6,     A_msk6 ; hi half
        PACK2   .2      B_msk5,     B_msk5,     B_msk5 ; hi half

        ;; ------------------------------------------------------------ ;;
        ;;  Partitioning MVs... get things where we want them.          ;;
        ;; ------------------------------------------------------------ ;;
        MV      .2X     A_k08,      B_k08              ; part. mv
        MV      .1X     B_k01,      A_k01              ; part. mv

        MV      .1X     B_y_data,   A_y_data
        ADD     .2X     A_rgb_ptr,  8,          B_rgb_ptr
        MV      .1X     B_c0,       A_c0

        ;; ------------------------------------------------------------ ;;
        ;;  Calculate loop counter.  We initialize it to the value      ;;
        ;;  "(num_pix >> 3) - 2", as we're unrolled 8 times, and we     ;;
        ;;  use BDEC for our loop counter.                              ;;
        ;; ------------------------------------------------------------ ;;
        SHRU            B_num_pix,    3,         B_i
        SUB             B_i,          2,         B_i

loop:   .trip 1
        ;; ------------------------------------------------------------ ;;
        ;;  Load 8 luma, 4 Cr, 4 Cb from the input arrays.              ;;
        ;; ------------------------------------------------------------ ;;
        LDDW    .D1T2   *A_y_data++,            B_y_7654:B_y_3210
        LDW     .D2T2   *B_cr_data++,           B_cr6420
        LDW     .D1T1   *A_cb_data++,           A_cb6420

        ;; ------------------------------------------------------------ ;;
        ;;  Toggle the sign-bits on the chroma to remove +128 bias.     ;;
        ;; ------------------------------------------------------------ ;;
        XOR     .2x     B_cr6420,   A_k80,      B_cr6420_
        XOR     .1      A_cb6420,   A_k80,      A_cb6420_

        ;; ------------------------------------------------------------ ;;
        ;;  Expand the luma and left-shift it by 3.  Subtract 16 bias.  ;;
        ;; ------------------------------------------------------------ ;;
        MPYU4   .2      B_y_7654,   B_k08,      B_y_76_:B_y_54_
        MPYU4   .1x     B_y_3210,   A_k08,      A_y_32_:A_y_10_
        SUB2    .2      B_y_76_,    B_k16,      B_y_76
        SUB2    .2      B_y_54_,    B_k16,      B_y_54
        SUB2    .1      A_y_32_,    B_k16,      A_y_32
        SUB2    .1      A_y_10_,    B_k16,      A_y_10

        ;; ------------------------------------------------------------ ;;
        ;;  Expand the chroma and left-shift it by 3.                   ;;
        ;; ------------------------------------------------------------ ;;
        MPYSU4  .2      B_cr6420_,  B_k08,      B_cr64:B_cr20
        MPYSU4  .1      A_cb6420_,  A_k08,      A_cb64:A_cb20

        ;; ------------------------------------------------------------ ;;
        ;;  Perform the leftmost column of the matrix multiply.         ;;
        ;;  We generate 8 separate products for the 8 output pixels.    ;;
        ;;  These results are 16Q16 values.                             ;;
        ;; ------------------------------------------------------------ ;;
        MPY2    .2      B_y_76,     B_c0,       B_y_7_c0:B_y_6_c0
        MPY2    .2      B_y_54,     B_c0,       B_y_5_c0:B_y_4_c0
        MPY2    .1      A_y_32,     A_c0,       A_y_3_c0:A_y_2_c0
        MPY2    .1      A_y_10,     A_c0,       A_y_1_c0:A_y_0_c0

        ;; ------------------------------------------------------------ ;;
        ;;  Perform the right two columns of the matrix multiply.       ;;
        ;;  We generate 4 pairs of outputs that will be mixed with the  ;;
        ;;  results of the luma calculations.  Recall that each chroma  ;;
        ;;  pair is shared across two luma values.  These are 16Q16.    ;;
        ;; ------------------------------------------------------------ ;;
        MPY2    .2      B_cr64,     B_c1,       B_cr6_c1:B_cr4_c1
        MPY2    .2      B_cr20,     B_c1,       B_cr2_c1:B_cr0_c1

        MPY2    .1      A_cb64,     A_c4,       A_cb6_c4:A_cb4_c4
        MPY2    .1      A_cb20,     A_c4,       A_cb2_c4:A_cb0_c4


        PACKH2  .2X     B_cr64,     A_cb64,     B_cr6cb6
        PACK2   .2X     B_cr64,     A_cb64,     B_cr4cb4
        PACKH2  .1X     A_cb20,     B_cr20,     A_cb2cr2
        PACK2   .1X     A_cb20,     B_cr20,     A_cb0cr0
        DOTP2   .2      B_cr6cb6,   B_c3c2,     B_cg6
        DOTP2   .2      B_cr4cb4,   B_c3c2,     B_cg4
        DOTP2   .1      A_cb2cr2,   A_c2c3,     A_cg2
        DOTP2   .1      A_cb0cr0,   A_c2c3,     A_cg0

        ;; ------------------------------------------------------------ ;;
        ;;  Mix the chroma and luma to generate the 8 RGB pixels as     ;;
        ;;  full 16Q16 pixel values.                                    ;;
        ;; ------------------------------------------------------------ ;;
        ADD     .2      B_y_7_c0,   B_cr6_c1,   B_r_7
        ADD     .2      B_y_6_c0,   B_cr6_c1,   B_r_6
        ADD     .2      B_y_5_c0,   B_cr4_c1,   B_r_5
        ADD     .2      B_y_4_c0,   B_cr4_c1,   B_r_4
        ADD     .1X     A_y_3_c0,   B_cr2_c1,   A_r_3
        ADD     .1X     A_y_2_c0,   B_cr2_c1,   A_r_2
        ADD     .1X     A_y_1_c0,   B_cr0_c1,   A_r_1
        ADD     .1X     A_y_0_c0,   B_cr0_c1,   A_r_0

        ADD     .2      B_y_7_c0,   B_cg6,      B_g_7
        ADD     .2      B_y_6_c0,   B_cg6,      B_g_6
        ADD     .2      B_y_5_c0,   B_cg4,      B_g_5
        ADD     .2      B_y_4_c0,   B_cg4,      B_g_4
        ADD     .1      A_y_3_c0,   A_cg2,      A_g_3
        ADD     .1      A_y_2_c0,   A_cg2,      A_g_2
        ADD     .1      A_y_1_c0,   A_cg0,      A_g_1
        ADD     .1      A_y_0_c0,   A_cg0,      A_g_0

        ADD     .2X     B_y_7_c0,   A_cb6_c4,   B_b_7
        ADD     .2X     B_y_6_c0,   A_cb6_c4,   B_b_6
        ADD     .2X     B_y_5_c0,   A_cb4_c4,   B_b_5
        ADD     .2X     B_y_4_c0,   A_cb4_c4,   B_b_4
        ADD     .1      A_y_3_c0,   A_cb2_c4,   A_b_3
        ADD     .1      A_y_2_c0,   A_cb2_c4,   A_b_2
        ADD     .1      A_y_1_c0,   A_cb0_c4,   A_b_1
        ADD     .1      A_y_0_c0,   A_cb0_c4,   A_b_0


        ;; ------------------------------------------------------------ ;;
        ;;  Keep only the integer portion of the 16Q16 pixel data,      ;;
        ;;  packing two pixels per word.                                ;;
        ;; ------------------------------------------------------------ ;;
        PACKH2  .2      B_r_7,      B_r_6,      B_r_76
        PACKH2  .2      B_r_5,      B_r_4,      B_r_54
        PACKH2  .1      A_r_3,      A_r_2,      A_r_32
        PACKH2  .1      A_r_1,      A_r_0,      A_r_10

        PACKH2  .2      B_g_7,      B_g_6,      B_g_76
        PACKH2  .2      B_g_5,      B_g_4,      B_g_54
        PACKH2  .1      A_g_3,      A_g_2,      A_g_32
        PACKH2  .1      A_g_1,      A_g_0,      A_g_10

        PACKH2  .2      B_b_7,      B_b_6,      B_b_76
        PACKH2  .2      B_b_5,      B_b_4,      B_b_54
        PACKH2  .1      A_b_3,      A_b_2,      A_b_32
        PACKH2  .1      A_b_1,      A_b_0,      A_b_10

        ;; ------------------------------------------------------------ ;;
        ;;  Saturate the signed 16-bit pixels down to unsigned 8-bit,   ;;
        ;;  with four pixels per word.                                  ;;
        ;; ------------------------------------------------------------ ;;
        SPACKU4 .2      B_r_76,     B_r_54,     B_r_7654
        SPACKU4 .1      A_r_32,     A_r_10,     A_r_3210

        SPACKU4 .2      B_g_76,     B_g_54,     B_g_7654
        SPACKU4 .1      A_g_32,     A_g_10,     A_g_3210

        SPACKU4 .2      B_b_76,     B_b_54,     B_b_7654
        SPACKU4 .1      A_b_32,     A_b_10,     A_b_3210

        ;; ------------------------------------------------------------ ;;
        ;;  Now mask away the LSBs to map to the 5:6:5 gamut.           ;;
        ;; ------------------------------------------------------------ ;;
        AND     .2      B_r_7654,   B_msk5,     B_r_7654_
        AND     .2      B_g_7654,   A_msk6,     B_g_7654_
        AND     .2      B_b_7654,   B_msk5,     B_b_7654_

        AND     .1      A_r_3210,   B_msk5,     A_r_3210_
        AND     .1      A_g_3210,   A_msk6,     A_g_3210_
        AND     .1      A_b_3210,   B_msk5,     A_b_3210_

        ;; ------------------------------------------------------------ ;;
        ;;  Unpack back to halfwords, aligning the red, green and blue  ;;
        ;;  fields so that we can merge these together as 16-bit 5:6:5  ;;
        ;;  pixels.  For Red, we need to unpack and shift left 8.  For  ;;
        ;;  Green, unpack and shift left 3.  For Blue, unpack and       ;;
        ;;  shift right 3.                                              ;;
        ;; ------------------------------------------------------------ ;;
        MPYU4   .2      B_r_7654_,  A_k80,      B_r7_r6:B_r5_r4
        MPYU4   .1      A_r_3210_,  A_k80,      A_r3_r2:A_r1_r0

        MPYU4   .2      B_g_7654_,  B_k08,      B_g7_g6:B_g5_g4
        MPYU4   .1      A_g_3210_,  A_k08,      A_g3_g2:A_g1_g0

        ROTL    .2      B_b_7654_,  29,         B_b_7654__
        ROTL    .1      A_b_3210_,  29,         A_b_3210__

        MPYU4   .2      B_b_7654__, B_k01,      B_b7_b6:B_b5_b4
        MPYU4   .1      A_b_3210__, A_k01,      A_b3_b2:A_b1_b0

        ;; ------------------------------------------------------------ ;;
        ;;  Merge the R, G, and B together.  We combine part of R's     ;;
        ;;  left-shift by 8 with the merge below using ADDAH.           ;;
        ;; ------------------------------------------------------------ ;;
        ADDAH   .2      B_b7_b6,    B_r7_r6,    B_r_b76
        ADDAH   .2      B_b5_b4,    B_r5_r4,    B_r_b54
        ADDAH   .1      A_b3_b2,    A_r3_r2,    A_r_b32
        ADDAH   .1      A_b1_b0,    A_r1_r0,    A_r_b10

        ADD     .2      B_r_b76,    B_g7_g6,    B_rgb76
        ADD     .2      B_r_b54,    B_g5_g4,    B_rgb54
        ADD     .1      A_r_b32,    A_g3_g2,    A_rgb32
        ADD     .1      A_r_b10,    A_g1_g0,    A_rgb10

        ;; ------------------------------------------------------------ ;;
        ;;  Store out the 8 RGB pixels.                                 ;;
        ;; ------------------------------------------------------------ ;;
        STDW    .D2T2   B_rgb76:B_rgb54,        *B_rgb_ptr++[2]
        STDW    .D1T1   A_rgb32:A_rgb10,        *A_rgb_ptr++[2]

        BDEC    .2      loop,       B_i

        .return
        .endproc


* ========================================================================= *
*   End of file:  img_ycbcr422p_rgb565.sa                                   *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


