!<arch>
autocor.c/      1066929505  0     0     0       8068      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Fri Nov  1 19:10:28 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*  NAME                                                                   */
/*      DSP_autocor -- Autocorrelation                                     */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      21-Jan-2002                                                        */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void DSP_autocor                                                    */
/*      (                                                                   */
/*          short *restrict r,                                              */
/*          const short *restrict x,                                        */
/*          int          nx,                                                */
/*          int          nr                                                 */
/*      );                                                                  */
/*                                                                          */
/*      r[nr]   : Output array                                              */
/*      x[nr+nx]: Input array. The first nr elements are assumed to be 0.   */
/*      nx      : Length of autocorrelation                                 */
/*      nr      : Number of lags                                            */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine performs an autocorrelation of an input vector         */
/*      x. The length of the autocorrelation is nx samples. Since nr        */
/*      such autocorrelations are performed, input vector x needs to be     */
/*      of length nx + nr. This produces nr output results which are        */
/*      stored in an output array r.                                        */
/*                                                                          */
/*      The following diagram illustrates how the correlations are          */
/*      obtained.                                                           */
/*                                                                          */
/*      Example for nr=8, nx=24:                                            */
/*      0       nr                  nx+nr-1                                 */
/*      |-------|----------------------|  <- x[]                            */
/*      |       |----------------------|  -> r[0]                           */
/*      |      |----------------------|   -> r[1]                           */
/*      |     |----------------------|    -> r[2]                           */
/*      |    |----------------------|     -> r[3]                           */
/*      |   |----------------------|      -> r[4]                           */
/*      |  |----------------------|       -> r[5]                           */
/*      | |----------------------|        -> r[6]                           */
/*                                                                          */
/*      Note that x[0] is never used, but is required for padding to make   */
/*      x[nr] double-word aligned.                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The first nr elements are assumed to be 0.                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_autocor(short *restrict r, const short *restrict x, int nx, int nr)
{
   int i, k;
   int sum;

   #ifndef NOASSUME
   _nassert (nr % 4 == 0);
   #endif

   /*----------------------------------------------------------------------*/
   /* Outer loop that iterates for every output. There are 'nr' output     */
   /* samples to be computed. Hence this loop iterates 'nr' times. 'nr'    */
   /* needs to be a multiple of 4. This information is conveyed to the     */
   /* compiler.                                                            */
   /*----------------------------------------------------------------------*/

   for (i = 0; i < nr; i++)
   {
      sum = 0;

      #ifndef NOASSUME
      _nassert(nx % 8 == 0);
      _nassert((int)(x)%8 == 0);
      _nassert((int)(r)%8 == 8);
      _nassert(nr%2 == 0);
      #pragma MUST_ITERATE(10, ,2);
      #endif

      /*-------------------------------------------------------------------*/
      /*  Compute one autocorrelation. Each autocorrelation has 'nx' terms */
      /*  'nx' is assumed to be a multiple of 8.                           */
      /*-------------------------------------------------------------------*/

      for (k = nr; k < nx + nr; k++)
      {
          sum += x[k] * x[k-i];
      }

      /*-------------------------------------------------------------------*/
      /* Shift out autocorrelation sum taking into account Q15 math.       */
      /*-------------------------------------------------------------------*/

      r[i] = sum  >> 15;
   }
}

/* ======================================================================== */
/*  End of file:  dsp_autocor.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
bexp.c/         1066929505  0     0     0       6260      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Thu Sep 18 15:37:00 2003 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_bexp -- Block exponent of a vector                              */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      18-Sep-2003                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          int DSP_bexp                                                    */
/*          (                                                               */
/*              const int *x,     // Input Data         //                  */
/*              unsigned   nx     // Number of elements //                  */
/*          );                                                              */
/*                                                                          */
/*      The DSP_bexp routine accepts a list of 'num' input points and       */
/*      performs the determination of the block exponent.  It returns       */
/*      the minimum number of "redundant sign bits" observed on the         */
/*      block of data.                                                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The DSP_bexp function, performs a determination of the block        */
/*      exponent of the vector of elements and returns the maximum          */
/*      exponent.  This information can then be used to re-normalize        */
/*      the vector.  This operation is useful when auto-scaling is          */
/*      required as in a FFT.  The DSP_bexp operation returns the minimum   */
/*      norm of the vector.  The minimum norm corresponds to the            */
/*      maximum exponent.                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*      This code is ENDIAN NEUTRAL.                                        */
/*                                                                          */
/*  SOURCE                                                                  */
/*      DSPLIB.                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int DSP_bexp(const int *x, short nx)
{
    int i;
    unsigned int mask, mag;

    mask = 0;

    /* -------------------------------------------------------------------- */
    /*  Merge the absolute values of all the elements together.  The        */
    /*  leftmost bit-change on this mask gives us the magnitude we desire.  */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < nx; i++)
        mask |= x[i] ^ (x[i] >> 31);

    /* -------------------------------------------------------------------- */
    /*  Find the magnitude of the mask.                                     */
    /* -------------------------------------------------------------------- */
    for (mag = 0; (1 << mag) < mask; mag++)
        ;

    return 31 - mag;
}
/* ======================================================================== */
/*  End of file:  dsp_bexp.c                                                */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
blk_eswap0.c/   1066929505  0     0     0       6422      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Tue Sep 18 15:09:56 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_blk_eswap16 -- Endian-swap a block of 16-bit values             */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      12-Aug-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          void DSP_blk_eswap16                                            */
/*          (                                                               */
/*              void *restrict src,     // Source data                  //  */
/*              void *restrict dst,     // Destination array            //  */
/*              int  n_hwords           // Number of half-words to swap //  */
/*          );                                                              */
/*                                                                          */
/*      This function performs an endian-swap on the data in the "src"      */
/*      array, writing the results to "dst".  If NULL is passed in for      */
/*      the destination, then the endian-swap is performed in-place.        */
/*      The "n_hwords" argument gives the total length of the array, in     */
/*      half-words.                                                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The data in the "src" array is endian swapped, meaning that the     */
/*      byte-order of the bytes within each word of the src[] array is      */
/*      reversed.  This is meant to facilitate moving big-endian data       */
/*      to a little-endian system or vice-versa.                            */
/*                                                                          */
/*      When the "dst" pointer is non-NULL, the endian-swap occurs          */
/*      out-of-place, similar to a block move.  When the "dst" pointer      */
/*      is NULL, the endian-swap occurs in-place, allowing the swap to      */
/*      occur without using any additional storage.                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      Input and output arrays do not overlap, except in the very          */
/*      specific case that "dst == NULL" so that the operation occurs       */
/*      in-place.                                                           */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_blk_eswap16
(
    void *restrict src,
    void *restrict dst,
    int  n_hwords
)
{
    int i;
    char *_src, *_dst;

    if (dst)
    {
        _src = (char *)src;
        _dst = (char *)dst;
    } else
    {
        _src = (char *)src;
        _dst = (char *)src;
    }

    for (i = 0; i < n_hwords; i++)
    {
        char t0, t1;
        t0 = _src[i*2 + 1];
        t1 = _src[i*2 + 0];
        _dst[i*2 + 0] = t0;
        _dst[i*2 + 1] = t1;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_blk_eswap16.c                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
blk_eswap1.c/   1066929505  0     0     0       6466      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Wed Sep  5 10:28:26 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_blk_eswap32 -- Endian-swap a block of 32-bit values             */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      12-Aug-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          void DSP_blk_eswap32                                            */
/*          (                                                               */
/*              void *restrict src,     // Source data             //       */
/*              void *restrict dst,     // Destination array       //       */
/*              int  n_words            // Number of words to swap //       */
/*          );                                                              */
/*                                                                          */
/*      This function performs an endian-swap on the data in the "src"      */
/*      array, writing the results to "dst".  If NULL is passed in for      */
/*      the destination, then the endian-swap is performed in-place.        */
/*      The "n_words" argument gives the total length of the array.         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The data in the "src" array is endian swapped, meaning that the     */
/*      byte-order of the bytes within each word of the src[] array is      */
/*      reversed.  This is meant to facilitate moving big-endian data       */
/*      to a little-endian system or vice-versa.                            */
/*                                                                          */
/*      When the "dst" pointer is non-NULL, the endian-swap occurs          */
/*      out-of-place, similar to a block move.  When the "dst" pointer      */
/*      is NULL, the endian-swap occurs in-place, allowing the swap to      */
/*      occur without using any additional storage.                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      Input and output arrays do not overlap, except in the very          */
/*      specific case that "dst == NULL" so that the operation occurs       */
/*      in-place.                                                           */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_blk_eswap32
(
    void *restrict src,
    void *restrict dst,
    int  n_words
)
{
    int i;
    char *_src, *_dst;

    if (dst)
    {
        _src = (char *)src;
        _dst = (char *)dst;
    } else
    {
        _src = (char *)src;
        _dst = (char *)src;
    }

    for (i = 0; i < n_words; i++)
    {
        char t0, t1, t2, t3;
        t0 = _src[i*4 + 3];
        t1 = _src[i*4 + 2];
        t2 = _src[i*4 + 1];
        t3 = _src[i*4 + 0];

        _dst[i*4 + 0] = t0;
        _dst[i*4 + 1] = t1;
        _dst[i*4 + 2] = t2;
        _dst[i*4 + 3] = t3;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_blk_eswap32.c                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
blk_eswap2.c/   1066929505  0     0     0       6696      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Tue Sep 18 15:10:14 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_blk_eswap64 -- Endian-swap a block of 64-bit values             */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      12-Aug-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          void DSP_blk_eswap64                                            */
/*          (                                                               */
/*              double *restrict src, // Source data                    //  */
/*              double *restrict dst, // Destination array              //  */
/*              int    n_dbls         // Number of double-words to swap //  */
/*          );                                                              */
/*                                                                          */
/*      This function performs an endian-swap on the data in the "src"      */
/*      array, writing the results to "dst".  If NULL is passed in for      */
/*      the destination, then the endian-swap is performed in-place.        */
/*      The "n_dbls" argument gives the total length of the array.          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The data in the "src" array is endian swapped, meaning that the     */
/*      byte-order of the bytes within each word of the src[] array is      */
/*      reversed.  This is meant to facilitate moving big-endian data       */
/*      to a little-endian system or vice-versa.                            */
/*                                                                          */
/*      When the "dst" pointer is non-NULL, the endian-swap occurs          */
/*      out-of-place, similar to a block move.  When the "dst" pointer      */
/*      is NULL, the endian-swap occurs in-place, allowing the swap to      */
/*      occur without using any additional storage.                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      Input and output arrays do not overlap, except in the very          */
/*      specific case that "dst == NULL" so that the operation occurs       */
/*      in-place.                                                           */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_blk_eswap64
(
    void *src,
    void *dst,
    int  n_dbls
)
{
    int i;
    char *_src, *_dst;

    if (dst)
    {
        _src = (char *)src;
        _dst = (char *)dst;
    } else
    {
        _src = (char *)src;
        _dst = (char *)src;
    }

    for (i = 0; i < n_dbls; i++)
    {
        char t0, t1, t2, t3, t4, t5, t6, t7;

        t0 = _src[i*8 + 7];
        t1 = _src[i*8 + 6];
        t2 = _src[i*8 + 5];
        t3 = _src[i*8 + 4];
        t4 = _src[i*8 + 3];
        t5 = _src[i*8 + 2];
        t6 = _src[i*8 + 1];
        t7 = _src[i*8 + 0];

        _dst[i*8 + 0] = t0;
        _dst[i*8 + 1] = t1;
        _dst[i*8 + 2] = t2;
        _dst[i*8 + 3] = t3;
        _dst[i*8 + 4] = t4;
        _dst[i*8 + 5] = t5;
        _dst[i*8 + 6] = t6;
        _dst[i*8 + 7] = t7;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_blk_eswap64.c                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
blk_move.c/     1066929505  0     0     0       5620      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.1     Mon Sep  9 09:39:23 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_blk_move -- Move block of memory (overlapping). Endian Neutral  */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      06-Sep-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSP_blk_move(short *x, short *r, int nx);                      */
/*                                                                          */
/*          x  --- block of data to be moved                                */
/*          r  --- destination of block of data                             */
/*          nx --- number of elements in block                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Move nx 16-bit elements from one memory location to another.        */
/*      Source and destination may overlap.                                 */
/*                                                                          */
/*      void DSP_blk_move(short *x, short *r, int nx);                      */
/*      {                                                                   */
/*          int i;                                                          */
/*                                                                          */
/*          if (r < x)                                                      */
/*          {                                                               */
/*              for (i = 0 ; i < nx; i++)                                   */
/*                  r[i] = x[i];                                            */
/*          } else                                                          */
/*          {                                                               */
/*              for (i = nx-1 ; i >= 0; i--)                                */
/*                  r[i] = x[i];                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_blk_move(short   *x, short *r, int nx)
{
    int i;

#endif

    if (r < x)
    {
        for (i = 0; i < nx; i++)
            r[i] = x[i];
    } else
    {
        for (i = nx-1 ; i >= 0; i--)
            r[i] = x[i];
    }
}

/* ======================================================================== */
/*  End of file:  blk_move_c.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
dotp_sqr.c/     1066929505  0     0     0       7779      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Fri Mar 29 20:12:47 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*   TEXAS INSTRUMENTS, INC.                                                */
/*                                                                          */
/*   NAME                                                                   */
/*         DSP_dotp_sqr                                                     */
/*                                                                          */
/*   REVISION DATE                                                          */
/*       29-Mar-2002                                                        */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and can be called as:                   */
/*                                                                          */
/*          int DSP_dotp_sqr                                                */
/*          (                                                               */
/*              int G,            // Sum-of-y-squared initial value //      */
/*              const short  *x,  // First input array.             //      */
/*              const short  *y,  // Second input array.            //      */
/*              int *restrict r,  // Accumulation of x[] * y[].     //      */
/*              int nx            // Length of the input vector.    //      */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine computes the dot product of x[] and y[] arrays,        */
/*      adding it to the value in the location pointed to by 'd'.           */
/*                                                                          */
/*      Additionally, it computes the sum of the squares of the terms       */
/*      in the y[] array, adding it to the argument G.  The final value     */
/*      of G is given as the return value of the function.  This value      */
/*      is used by the VSELP vocoder.                                       */
/*                                                                          */
/*      The following C code is an implementation of the algorithm          */
/*      without restrictions.  Optimized implementations may add            */
/*      restrictions as noted under the heading "ASSUMPTIONS."              */
/*                                                                          */
/*      int DSP_dotp_sqr                                                    */
/*      (                                                                   */
/*          int G,            // Sum-of-y-squared initial value //          */
/*          const short  *x,  // First input array.             //          */
/*          const short  *y,  // Second input array.            //          */
/*          int *restrict r,  // Accumulation of x[] * y[].     //          */
/*          int nx            // Length of the input vector.    //          */
/*      )                                                                   */
/*      {                                                                   */
/*          int i;                                                          */
/*                                                                          */
/*          for (i = 0; i < nx; i++)                                        */
/*          {                                                               */
/*              *r += x[i] * y[i];                                          */
/*              G  += y[i] * y[i];                                          */
/*          }                                                               */
/*                                                                          */
/*          return G;                                                       */
/*      }                                                                   */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This code is ENDIAN NEUTRAL.                                        */
/*                                                                          */
/*                                                                          */
/*  SOURCE                                                                  */
/*      DSPLIB.                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int DSP_dotp_sqr
(
    int G,
    const short  *x,
    const short  *y,
    int *restrict r,
    int nx
)
{
    int i;

    for (i = 0; i < nx; i++)
    {
        *r += x[i] * y[i];
        G  += y[i] * y[i];
    }

    return G;
}

/* ======================================================================== */
/*  End of file:  dsp_dotp_sqr.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

dotprod.c/      1066929505  0     0     0       5006      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Fri Mar 29 15:29:11 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_dotprod                                                         */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      29-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          int DSP_dotprod                                                 */
/*          (                                                               */
/*              const short *m,           // First vector       //          */
/*              const short *n,           // Second vector      //          */
/*              int  count                // Length of vectors  //          */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The "DSP_dotprod" function implements a vector product of two input */
/*      files, returning the result.                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int DSP_dotprod
(
    const short *m,
    const short *n,
    int  count
)
{
    int i;
    int prod, sum = 0;

    #ifndef NOASSUME
    _nassert((int)m % 8 == 0);               /* Double-word aligned         */
    _nassert((int)n % 8 == 0);               /* Double-word aligned         */
    _nassert((int)m % 16 != (int)n % 16);    /* In different banks          */
    #pragma MUST_ITERATE(4,,4);              /* count >= 4, mult of 4       */
    #endif

    for (i = 0; i < count; i++)
    {
        prod = m[i] * n[i];
        sum += prod;
    }

    return sum;
}

/* ======================================================================== */
/*  End of file:  dsp_dotprod.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
fft.c/          1066929505  0     0     0       41222     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.7     Sun Mar 10 01:10:45 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*     DSP_fft                                                              */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      15-Oct-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This code performs a Radix-4 FFT with digit reversal.  The code     */
/*      uses a special ordering of twiddle factors and memory accesses      */
/*      to improve performance in the presence of cache.  It operates       */
/*      largely in-place, but the final digit-reversed output is written    */
/*      out-of-place.                                                       */
/*                                                                          */
/*      This code requires a special sequence of twiddle factors stored     */
/*      in 1Q15 fixed-point format.  The following C code illustrates       */
/*      one way to generate the desired twiddle-factor array:               */
/*                                                                          */
/*      #include <math.h>                                                   */
/*                                                                          */
/*      #ifndef PI                                                          */
/*      # define PI (3.14159265358979323846)                                */
/*      #endif                                                              */
/*                                                                          */
/*      short d2s(double d)                                                 */
/*      {                                                                   */
/*          d = floor(0.5 + d);  // Explicit rounding to integer //         */
/*          if (d >=  32767.0) return  32767;                               */
/*          if (d <= -32768.0) return -32768;                               */
/*          return (short)d;                                                */
/*      }                                                                   */
/*                                                                          */
/*      void gen_twiddle(short *w, int n)                                   */
/*      {                                                                   */
/*          double M = 32767.5;                                             */
/*          int i, j, k;                                                    */
/*                                                                          */
/*          for (j = 1, k = 0; j < n >> 2; j = j << 2)                      */
/*          {                                                               */
/*              for (i = 0; i < n >> 2; i += j << 1)                        */
/*              {                                                           */
/*                  w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       */
/*                  w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       */
/*                  w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       */
/*                  w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       */
/*                  w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       */
/*                  w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       */
/*                  w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       */
/*                  w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       */
/*                  w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       */
/*                  w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  k += 12;                                                */
/*              }                                                           */
/*          }                                                               */
/*          w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   */
/*          w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       */
/*      }                                                                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The size of the FFT, n, must be a power of 4 and greater than       */
/*      or equal to 16 and less than 32768.                                 */
/*                                                                          */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*                                                                          */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices.                         */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The DSP_fft() code shown here performs the bulk of the computation  */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part os the         */
/*      complex multiply is implemented using _dotp2. The imaginary         */
/*      part of the complex multiply is implemented using _dotpn2           */
/*      after the twiddle factors are swizzled within the half word.        */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      */
/*                                                                          */
/*      The actual twiddle factors for the FFT are cosine, - sine. The      */
/*      twiddle factors stored in the table are csine and sine, hence       */
/*      the sign of the "sine" term is comprehended during multipli-        */
/*      cation as shown above.                                              */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

void DSP_fft
(
    const short *restrict w,
    int n,
    short       *restrict x,
    short       *restrict y
)
{
    int stride, i, j, k, t, s, m;

    short  xh0, xh1,  xh20,  xh21;
    short  xl0, xl1,  xl20,  xl21;
    short  xt0, yt0,  xt1,   yt1;
    short  xt2, yt2,  xt3,   yt3;

    /*----------------------------------------------------------------------*/
    /* Inform the compiler that the  input array "x", twiddle factor array  */
    /* "w" and output array "y" are double word aligned.  In addition the   */
    /* number of points to be transformed is assumed to be greater than or  */
    /* equal to 16, and less than 32768.                                    */
    /*----------------------------------------------------------------------*/

    #ifndef NOASSUME
    _nassert((int)x % 8 == 0);
    _nassert((int)y % 8 == 0);
    _nassert((int)w % 8 == 0);
    _nassert(n >= 16);
    _nassert(n <  32768);
    #endif

    /* -------------------------------------------------------------------- */
    /*  Perform initial stages of FFT in place w/out digit reversal.        */
    /* -------------------------------------------------------------------- */

    #ifndef NOASSUME
    #pragma MUST_ITERATE(1,,1);
    #endif

    for (stride = n, t = 0; stride > 4; stride >>= 2)
    {
        /* ---------------------------------------------------------------- */
        /*  Perform each of the butterflies for this particular stride.     */
        /* ---------------------------------------------------------------- */

        s = stride >> 2;

        /*------------------------------------------------------------------*/
        /* stride represents the seperation between the inputs of the radix */
        /* 4 butterfly. The C code breaks the FFT, into two cases, one when */
        /* the stride between the elements is greater than 4, other when    */
        /* the stride is less than 4. Since stride is greater than 16, it   */
        /* can be guranteed that "s" is greater than or equal to 4.         */
        /* In addition it can also be shown that the loop that shares this  */
        /* stride will iterate at least once.  The number of times this     */
        /* loop iterates depends on how many butterflies in this stage      */
        /* share a twiddle factor.                                          */
        /*------------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert(stride >= 16);
        _nassert(s      >=  4);
        #pragma MUST_ITERATE(1,,1);
        #endif

        for (i = 0; i < n; i += stride)
        {

            #ifndef NOASSUME
            _nassert(i % 4 == 0);
            _nassert(s     >= 4);
            #pragma MUST_ITERATE(2,,2);
            #endif

            for (j = 0; j < s; j += 2)
            {
                for (k = 0; k < 2; k++)
                {
                    short           w1c, w1s, w2c, w2s, w3c, w3s;
                    short x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;
                    short y0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i;

                    /* ----------------------------------------------------- */
                    /*  Read the four samples that are the input to this     */
                    /*  particular butterfly.                                */
                    /* ----------------------------------------------------- */

                    x0r = x[2*(i+j+k      ) + 0]; x0i = x[2*(i+j+k      ) + 1];
                    x1r = x[2*(i+j+k +   s) + 0]; x1i = x[2*(i+j+k +   s) + 1];
                    x2r = x[2*(i+j+k + 2*s) + 0]; x2i = x[2*(i+j+k + 2*s) + 1];
                    x3r = x[2*(i+j+k + 3*s) + 0]; x3i = x[2*(i+j+k + 3*s) + 1];

                    /* ----------------------------------------------------- */
                    /*  Read the six twiddle factors that are needed for 3   */
                    /*  of the four outputs. (The first output has no mpys.) */
                    /* ------------------------------------------------------*/

                    w1s = w[t + 2*k + 6*j + 0];    w1c = w[t + 2*k + 6*j + 1];
                    w2s = w[t + 2*k + 6*j + 4];    w2c = w[t + 2*k + 6*j + 5];
                    w3s = w[t + 2*k + 6*j + 8];    w3c = w[t + 2*k + 6*j + 9];

                    /* ----------------------------------------------------- */
                    /*  Calculate the four outputs, remembering that radix4  */
                    /*  FFT accepts 4 inputs and produces 4 outputs. If we   */
                    /*  imagine the inputs as being complex, and look at the */
                    /*  first stage as an example:                           */
                    /*                                                       */
                    /*  Four inputs are x(n) x(n+N/4) x(n+N/2) x(n+3N/4)     */
                    /*  In general the four inputs can be generalized using  */
                    /*  the stride between the elements as follows:          */
                    /*  x(n), x(n + s), x(n + 2*s), x(n + 3*s).              */
                    /*                                                       */
                    /*  These four inputs are used to calculate four outputs */
                    /*  as shown below:                                      */
                    /*                                                       */
                    /* X(4k)  = x(n) + x(n + N/4) + x(n + N/2) + x(n + 3N/4) */
                    /* X(4k+1)= x(n) -jx(n + N/4) - x(n + N/2) +jx(n + 3N/4) */
                    /* X(4k+2)= x(n) - x(n +N/4)  + x(N + N/2) - x(n + 3N/4) */
                    /* X(4k+3)= x(n) +jx(n + N/4) - x(n + N/2) -jx(n + 3N/4) */
                    /*                                                       */
                    /* These four partial results can be re-written to show  */
                    /* the underlying DIF structure similar to radix2 as     */
                    /* follows:                                              */
                    /*                                                       */
                    /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))  */
                    /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4)) */
                    /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))  */
                    /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4)) */
                    /*                                                       */
                    /* which leads to the real and imaginary values as foll: */
                    /*                                                       */
                    /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20        */
                    /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21        */
                    /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21        */
                    /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20        */
                    /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20        */
                    /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21        */
                    /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21        */
                    /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20        */
                    /* ----------------------------------------------------- */

                    xh0  = x0r   +   x2r;
                    xh1  = x0i   +   x2i;
                    xh20 = x1r   +   x3r;
                    xh21 = x1i   +   x3i;

                    xl0  = x0r   -   x2r;
                    xl1  = x0i   -   x2i;
                    xl20 = x1r   -   x3r;
                    xl21 = x1i   -   x3i;

                    xt0  =  xh0  +   xh20;
                    yt0  =  xh1  +   xh21;

                    xt1  =  xl0  +   xl21;
                    yt1  =  xl1  -   xl20;

                    xt2  =  xh0  -   xh20;
                    yt2  =  xh1  -   xh21;

                    xt3  =  xl0  -   xl21;
                    yt3  =  xl1  +   xl20;

                    /*-------------------------------------------------------*/
                    /* Perform twiddle factor multiplies of three terms,top  */
                    /* term does not have any multiplies. Note the twiddle   */
                    /* factors for a normal FFT are C + j (-S). Since the    */
                    /* factors that are stored are C + j S, this is          */
                    /* corrected for in the multiplies.                      */
                    /*                                                       */
                    /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)     */
                    /*-------------------------------------------------------*/

                    y0r = xt0;
                    y0i = yt0;
                    y1r = (xt1 * w1c +  yt1 * w1s) >> 15;
                    y1i = (yt1 * w1c -  xt1 * w1s) >> 15;
                    y2r = (xt2 * w2c +  yt2 * w2s) >> 15;
                    y2i = (yt2 * w2c -  xt2 * w2s) >> 15;
                    y3r = (xt3 * w3c +  yt3 * w3s) >> 15;
                    y3i = (yt3 * w3c -  xt3 * w3s) >> 15;

                    /* ---------------------------------------------------- */
                    /*  Store the final results back to the input array.    */
                    /* ---------------------------------------------------- */

                    x[2*(i+j+k      ) + 0] = y0r; x[2*(i+j+k      ) + 1] = y0i;
                    x[2*(i+j+k +   s) + 0] = y1r; x[2*(i+j+k +   s) + 1] = y1i;
                    x[2*(i+j+k + 2*s) + 0] = y2r; x[2*(i+j+k + 2*s) + 1] = y2i;
                    x[2*(i+j+k + 3*s) + 0] = y3r; x[2*(i+j+k + 3*s) + 1] = y3i;
               }
          }
        }

        /* ---------------------------------------------------------------- */
        /*  Offset to next subtable of twiddle factors. With each iteration */
        /*  of the above block, six twiddle factors get read, s times,      */
        /*  hence the offset into the twiddle factor array is advanved by   */
        /*  this amount.                                                    */
        /* ---------------------------------------------------------------- */

        t += 6 * s;
    }

    /* -------------------------------------------------------------------- */
    /*  Get the magnitude of "n", so we know how many digits to reverse.    */
    /* -------------------------------------------------------------------- */

    for (i = 31, m = 1; (n & (1 << i)) == 0; i--, m++) ;

    /* -------------------------------------------------------------------- */
    /*  Perform final stage with digit reversal.                            */
    /* -------------------------------------------------------------------- */

    s = n >> 2;

    /*----------------------------------------------------------------------*/
    /* One of the nice features, of this last stage are that, no multiplies */
    /* are required. In addition the data always strides by a fixed amount  */
    /* namely 8 elements. Since the data is stored as interleaved pairs, of */
    /* real and imaginary data, the first eight elements contain the data   */
    /* for the first four complex inputs. These are the inputs to the first */
    /* radix4 butterfly.                                                    */
    /*----------------------------------------------------------------------*/

    #ifndef NOASSUME
    #pragma MUST_ITERATE(4,,4);
    #endif
    for (i = 0; i < n; i += 4)
    {
        short x0r, x0i, x1r, x1i, x2r, x2i, x3r, x3i;
        short y0r, y0i, y1r, y1i, y2r, y2i, y3r, y3i;

        /* ---------------------------------------------------------------- */
        /*  Read the four samples that are the input to this butterfly.     */
        /* ---------------------------------------------------------------- */
        x0r = x[2*(i + 0) + 0];     x0i = x[2*(i + 0) + 1];
        x1r = x[2*(i + 1) + 0];     x1i = x[2*(i + 1) + 1];
        x2r = x[2*(i + 2) + 0];     x2i = x[2*(i + 2) + 1];
        x3r = x[2*(i + 3) + 0];     x3i = x[2*(i + 3) + 1];

        /* ---------------------------------------------------------------- */
        /*  Calculate the final FFT result from this butterfly.             */
        /* ---------------------------------------------------------------- */
        y0r  = (x0r + x2r) + (x1r + x3r);
        y0i  = (x0i + x2i) + (x1i + x3i);
        y1r  = (x0r - x2r) + (x1i - x3i);
        y1i  = (x0i - x2i) - (x1r - x3r);
        y2r  = (x0r + x2r) - (x1r + x3r);
        y2i  = (x0i + x2i) - (x1i + x3i);
        y3r  = (x0r - x2r) - (x1i - x3i);
        y3i  = (x0i - x2i) + (x1r - x3r);

        /* ---------------------------------------------------------------- */
        /*  Digit reverse our address to convert the digit-reversed input   */
        /*  into a linearized output order.  This actually results in a     */
        /*  digit-reversed store pattern since we're loading linearly, but  */
        /*  the end result is that the FFT bins are in linear order.        */
        /* ---------------------------------------------------------------- */
        DIG_REV(i, m, j); /* Note:  Result is assigned to 'j' by the macro. */

        /* ---------------------------------------------------------------- */
        /*  Store out the final FFT results.                                */
        /* ---------------------------------------------------------------- */
        y[2*(j +   0) + 0] = y0r;   y[2*(j +   0) + 1] = y0i;
        y[2*(j +   s) + 0] = y1r;   y[2*(j +   s) + 1] = y1i;
        y[2*(j + 2*s) + 0] = y2r;   y[2*(j + 2*s) + 1] = y2i;
        y[2*(j + 3*s) + 0] = y3r;   y[2*(j + 3*s) + 1] = y3i;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fft.c                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
fft16x16r.c/    1066929505  0     0     0       74140     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Sep  6 17:43:08 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ========================================================================= */
/*                                                                           */
/*  TEXAS INSTRUMENTS, INC.                                                  */
/*                                                                           */
/*  NAME                                                                     */
/*        DSP_fft16x16r : 16x16 FFT with rounding and scaling                */
/*                                                                           */
/*                                                                           */
/*  REVISION DATE                                                            */
/*      12-Sep-2000                                                          */
/*                                                                           */
/*  USAGE                                                                    */
/*        This routine is C-callable and can be called as:                   */
/*                                                                           */
/*        void DSP_fft16x16r(                                                */
/*            int N, short * ptr_x, short * ptr_w, short * ptr_y,            */
/*            unsigned char brev[], int n_min, int offset, int n_max);       */
/*                                                                           */
/*        N      = length of fft in complex samples, power of 2 <=16384      */
/*        ptr_x  = pointer to complex data input                             */
/*        ptr_w  = pointer to complex twiddle factor (see below)             */
/*        brev   = pointer to bit reverse table containing 64 entries        */
/*        n_min  = smallest fft butterfly used in computation                */
/*                 used for decomposing fft into subffts, see notes          */
/*        offset = index in complex samples of sub-fft from start of main fft*/
/*        n_max  = size of main fft in complex samples                       */
/*                                                                           */
/*        (See the C compiler reference guide.)                              */
/*                                                                           */
/*  DESCRIPTION                                                              */
/*       The benchmark performs a mixed radix forwards fft using             */
/*       a special sequence of coefficients generated in the following       */
/*       way:                                                                */
/*                                                                           */
/*         -* generate vector of twiddle factors for optimized algorithm *-  */
/*        void tw_gen(short * w, int N)                                      */
/*        {                                                                  */
/*          int j, k;                                                        */
/*          double x_t, y_t, theta1, theta2, theta3;                         */
/*          const double PI = 3.141592654, M = 32767.0;                      */
/*                                       -* M is 16383 for scale by 4 *-     */
/*                                                                           */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                              */
/*          {                                                                */
/*              for (i=0; i < N>>2; i+=j)                                    */
/*              {                                                            */
/*                  theta1 = 2*PI*i/N;                                       */
/*                  x_t = M*cos(theta1);                                     */
/*                  y_t = M*sin(theta1);                                     */
/*                  w[k]   =  (short)x_t;                                    */
/*                  w[k+1] =  (short)y_t;                                    */
/*                                                                           */
/*                  theta2 = 4*PI*i/N;                                       */
/*                  x_t = M*cos(theta2);                                     */
/*                  y_t = M*sin(theta2);                                     */
/*                  w[k+2] =  (short)x_t;                                    */
/*                  w[k+3] =  (short)y_t;                                    */
/*                                                                           */
/*                  theta3 = 6*PI*i/N;                                       */
/*                  x_t = M*cos(theta3);                                     */
/*                  y_t = M*sin(theta3);                                     */
/*                  w[k+4] =  (short)x_t;                                    */
/*                  w[k+5] =  (short)y_t;                                    */
/*                  k+=6;                                                    */
/*              }                                                            */
/*          }                                                                */
/*        }                                                                  */
/*       This redundent set of twiddle factors is size 2*N short samples.    */
/*       As pointed out later dividing these twiddle factors by 2 will give  */
/*       an effective divide by 4 at each stage to guarentee no overflow.    */
/*       The function is accurate to about 68dB of signal to noise ratio     */
/*       to the DFT function below:                                          */
/*                                                                           */
/*        void dft(int n, short x[], short y[])                              */
/*        {                                                                  */
/*           int k,i, index;                                                 */
/*           const double PI = 3.14159654;                                   */
/*           short * p_x;                                                    */
/*           double arg, fx_0, fx_1, fy_0, fy_1, co, si;                     */
/*                                                                           */
/*           for(k = 0; k<n; k++)                                            */
/*           {                                                               */
/*             p_x = x;                                                      */
/*             fy_0 = 0;                                                     */
/*             fy_1 = 0;                                                     */
/*             for(i=0; i<n; i++)                                            */
/*             {                                                             */
/*               fx_0 = (double)p_x[0];                                      */
/*               fx_1 = (double)p_x[1];                                      */
/*               p_x += 2;                                                   */
/*               index = (i*k) % n;                                          */
/*               arg = 2*PI*index/n;                                         */
/*               co = cos(arg);                                              */
/*               si = -sin(arg);                                             */
/*               fy_0 += ((fx_0 * co) - (fx_1 * si));                        */
/*               fy_1 += ((fx_1 * co) + (fx_0 * si));                        */
/*             }                                                             */
/*             y[2*k] = (short)2*fy_0/sqrt(N);                               */
/*             y[2*k+1] = (short)2*fy_1/sqrt(N);                             */
/*           }                                                               */
/*        }                                                                  */
/*       Scaling takes place at each stage except the last one.              */
/*       This is a divide by 2 to prevent overflow. All shifts are rounded to*/
/*       reduce truncation noise power by 3dB.                               */
/*       The function takes the table and input data and calculates the fft  */
/*       producing the frequency domain data in the Y array.                 */
/*       As the fft allows every input point to effect every output point in */
/*       a cache based system such as the c6211, this causes cache thrashing.*/
/*       This is mitigated by allowing the main fft of size N to be divided  */
/*       into several steps, allowing as much data reuse as possible.        */
/*                                                                           */
/*       For example the following function:                                 */
/*                                                                           */
/*       DSP_fft16x16r  (1024, &x_asm[0],&w[0],y_asm,brev,4,  0,1024);       */
/*                                                                           */
/*       is equvalent to:                                                    */
/*                                                                           */
/*       DSP_fft16x16r  (1024,&x_asm[2*0],  &w[0]  ,y_asm,brev,256, 0,1024); */
/*       DSP_fft16x16r  (256, &x_asm[2*0],  &w[2*768],y_asm,brev,4, 0,1024); */
/*       DSP_fft16x16r (256, &x_asm[2*256],&w[2*768],y_asm,brev,4, 256,1024); */
/*       DSP_fft16x16r (256, &x_asm[2*512],&w[2*768],y_asm,brev,4, 512,1024); */
/*       DSP_fft16x16r (256, &x_asm[2*768],&w[2*768],y_asm,brev,4, 768,1024); */
/*                                                                           */
/*       Notice how the 1st fft function is called on the entire 1K data set */
/*       it covers the 1st pass of the fft until the butterfly size is 256.  */
/*       The following 4 ffts do 256 pt ffts 25% of the size. These continue */
/*       down to the end when the buttefly is of size 4. The use an index to */
/*       the main twiddle factor array of 0.75*2*N. This is because the      */
/*       twiddle factor array is composed of successively decimated versions */
/*       of the main array.                                                  */
/*                                                                           */
/*       N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*       decompose the fft the following would be needed :                   */
/*                                                                           */
/*       DSP_fft16x16r   (512, &x_asm[0],&w[0],y_asm,brev,2,  0,512);        */
/*                                                                           */
/*       is equvalent to:                                                    */
/*                                                                           */
/*       DSP_fft16x16r   (512, &x_asm[0],    &w[0],  y_asm,brev,128, 0,512); */
/*       DSP_fft16x16r   (128, &x_asm[2*0],  &w[2*384],y_asm,brev,2, 0,512); */
/*       DSP_fft16x16r (128, &x_asm[2*128],&w[2*384],y_asm,brev,2, 128,512); */
/*       DSP_fft16x16r (128, &x_asm[2*256],&w[2*384],y_asm,brev,2, 256,512); */
/*       DSP_fft16x16r (128, &x_asm[2*384],&w[2*384],y_asm,brev,2, 384,512); */
/*                                                                           */
/*       The twiddle factor array is composed of log4(N) sets of twiddle     */
/*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*       array for each stage of the fft is calculated by summing these      */
/*       indices up appropriately.                                           */
/*       For multiple ffts they can share the same table by calling the small*/
/*       ffts from further down in the twiddle factor array. In the same way */
/*       as the decomposition works for more data reuse.                     */
/*                                                                           */
/*       Thus, the above decomposition can be summarized for a general N ,   */
/*       radix "rad" as follows:                                             */
/*                                                                           */
/*  DSP_fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0, N) */
/*  DSP_fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(N/4)], &w[2*(3*N/4)],brev, y_cn, rad, N/4, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(N/2)], &w[2*(3*N/4)],brev, y_cn, rad, N/2, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) */
/*                                                                           */
/*       As discussed previously, N can be either a power of 4 or 2.  If  N  */
/*       N is a power  of 4, rad = 4, and if N is a power of 2, and not  a   */
/*       power of 4, then rad = 2. "rad" is used to control how many stages  */
/*       of decomposition are performed. It is also used to dtermine whether */
/*       a radix4 or radix2 decomposition should be performed at the last    */
/*       stage. Hence when "rad" is set to "N/4" the first stage of the      */
/*       transform alone is performed and the code exits. To complete the    */
/*       FFT four other calls are required to perform N/4 size FFT's. In     */
/*       fact the ordering of these 4 FFT's amonst themselves does not       */
/*       matter and hence from a cahe perspective it helps to go through     */
/*       the remaining 4 FFT's in exactly the opposite order to the first.   */
/*                                                                           */
/*       This is illustrated as follows:                                     */
/*                                                                           */
/*  DSP_fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(N/2)], &w[2*(3*N/4)],brev, y_cn, rad, N/2, N) */
/*  DSP_fft16x16r(N/4,&x_cn[2*(N/4)], &w[2*(3*N/4)],brev, y_cn, rad, N/4, N) */
/*  DSP_fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0, N) */
/*                                                                           */
/*       In addition this function can be used to minimize call overhead, by */
/*       completing the FFT with one function call invocation as shown below */
/*                                                                           */
/*       DSP_fft16x16r(N, &x_cn[0], &w[0], y_cn, brev, rad, 0, N)            */
/*                                                                           */
/*   ASSUMPTIONS:                                                            */
/*       n must be a power of 2 and n >= 8  n <= 16384 points.               */
/*       Complex time data x and twiddle facotrs w are aligned on double     */
/*       word boundares. Real values are stored in even word positions and   */
/*       imaginary values in odd positions.                                  */
/*                                                                           */
/*       All data is in short precision integer fixed point form. The        */
/*       complex frequency data will be returned in linear order.            */
/*                                                                           */
/*       If Interupts are required the decomposition can be used to allow    */
/*       interupts to occur in between function calls. In this way interupts */
/*       Can occur roughly every 20%  of the time through the function.      */
/*                                                                           */
/*   MEMORY NOTE:                                                            */
/*       Configuration is LITTLE ENDIAN the code will not function if the -me*/
/*       flag is enabled but it can be modified for BIG ENDIAN usage.        */
/*                                                                           */
/*   TECHNIQUES                                                              */
/*       A special sequence of coeffs. used as generated above               */
/*       produces the fft. This collapses the inner 2 loops in the           */
/*       taditional Burrus and Parks implementation Fortran Code.            */
/*                                                                           */
/*       The revised FFT uses a redundant sequence of twiddle factors to     */
/*       allow a linear access through the data. This linear access enables  */
/*       data and instruction level parallelism.                             */
/*       The data produced by the DSP_fft16x16r fft is in normal form, the   */
/*       whole data array is written into a new output buffer.               */
/*                                                                           */
/*       The DSP_fft16x16r butterfly is bit reversed, i.e. the inner 2 points of */
/*       the butterfly are corssed over, this has the effect of making the   */
/*       data come out in bit reversed rather than in radix 4 digit reversed */
/*       order. This simplifies the last pass of the loop. A simple table    */
/*       is used to do the bit reversal out of place.                        */
/*                                                                           */
/*           unsigned char brev[64] = {                                      */
/*                 0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,             */
/*                 0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,             */
/*                 0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,             */
/*                 0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,             */
/*                 0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,             */
/*                 0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,             */
/*                 0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,             */
/*                 0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f              */
/*           };                                                              */
/*                                                                           */
/*        This function no longer uses the lookup table to perform bit       */
/*        reversal. It is performed using the _bitr instruction on C64x      */
/*        architecture. It is performed using a macro BIT_REV instead.       */
/*                                                                           */
/*   NOTES                                                                   */
/*       For more aggressive overflow control the shift in the DC term can be*/
/*       adjusted to 2 and the twiddle factors shifted right by 1. This gives*/
/*       a divide by 4 at each stage. For better accuracy the data can be pre*/
/*       asserted left by so many bits so that as it builds in magnitude the */
/*       divide by 2 prevents too much growth. An optimal point for example  */
/*       with an 8192pt fft with input data precision of 8 bits is to asert  */
/*       the input 4 bits left to make it 12 bits. This gives an SNR of 68dB */
/*       at the output. By trying combinations the optimal can be found.     */
/*       If scaling isnot required it is possible to replace the MPY by SMPY */
/*       this will give a shift left by 1 so a shift right by 16 gives a     */
/*       total 15 bit shift right. The DC term must be adjusted to give a    */
/*       zero shift.                                                         */
/*                                                                           */
/*   C CODE                                                                  */
/*       The following code is the traditional Burrus and Parks implemen-    */
/*       tation, which performs a mixed radix FFT capable of 2^M, 4^M.       */
/*       However it does not support multiple calls. It uses a traditional   */
/*       twiddle factor array wn, generated as follows:                      */
/*                                                                           */
/*       const double M = 32767.0;                                           */
/*       const double PI = 3.141592654;                                      */
/*                                                                           */
/*       for (i=0, k = 0; i < 3*(N>>2); i++)                                 */
/*       {                                                                   */
/*          theta1 = 2*PI*i/N;                                               */
/*          x_t = M*cos(theta1);                                             */
/*          y_t = M*sin(theta1);                                             */
/*          wn[k]   = (short) x_t;                                           */
/*          if (x_t >= M) wn[k  ] = 0x7fff;                                  */
/*          wn[k+1] = (short) y_t;                                           */
/*          if (y_t >= M) wn[k+1] = 0x7fff;                                  */
/*          k+=2;                                                            */
/*       }                                                                   */
/*                                                                           */
/*       The C code that implements the traditional mixed radix FFT is       */
/*       shown below. It has three nested loops, one for the stages,         */
/*       one for the groups of butterflies, one for the passes.              */
/*                                                                           */
/* void DSP_fft16x16r(int n, short x[], short wn[],                          */
/*       unsigned char brev[], short y[], int radix, int offset, int nmax)   */
/* {                                                                         */
/*     int    n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, i, l0;              */
/*     short  co1, co2, co3, si1, si2, si3;                                  */
/*     short  xt0, yt0, xt1, yt1, xt2, yt2;                                  */
/*     short  xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                           */
/*     short * ptr_x0, * y0;                                                 */
/*     unsigned int  j0, j1, k0, k1, k, j;                                   */
/*     short x0, x1, x2, x3, x4, x5, x6, x7;                                 */
/*     short xh0_0, xh1_0, xh0_1, xh1_1;                                     */
/*     short xl0_0, xl1_0, xl0_1, xl1_1;                                     */
/*     short yt3, yt4, yt5, yt6, yt7;                                        */
/*                                                                           */
/*     n2 = n;                                                               */
/*     ie = 1;                                                               */
/*     for (k = n; k > radix; k >>= 2)                                       */
/*     {                                                                     */
/*         n1 = n2;                                                          */
/*         n2 >>= 2;                                                         */
/*         ia1 = 0;                                                          */
/*         for (j = 0; j < n2; j++)                                          */
/*         {                                                                 */
/*             ia2 = ia1 + ia1;                                              */
/*             ia3 = ia2 + ia1;                                              */
/*             co1 = w[2 * ia1    ];                                         */
/*             si1 = w[2 * ia1 + 1];                                         */
/*             co2 = w[2 * ia2    ];                                         */
/*             si2 = w[2 * ia2 + 1];                                         */
/*             co3 = w[2 * ia3    ];                                         */
/*             si3 = w[2 * ia3 + 1];                                         */
/*             ia1 = ia1 + ie;                                               */
/*             for (i0 = j; i0 < n; i0 += n1)                                */
/*             {                                                             */
/*                 i1 = i0 + n2;                                             */
/*                 i2 = i1 + n2;                                             */
/*                 i3 = i2 + n2;                                             */
/*                                                                           */
/*                 xh0  = x[2 * i0    ] + x[2 * i2    ];                     */
/*                 xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];                     */
/*                 xl0  = x[2 * i0    ] - x[2 * i2    ];                     */
/*                 xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];                     */
/*                                                                           */
/*                 xh20 = x[2 * i1    ] + x[2 * i3    ];                     */
/*                 xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];                     */
/*                 xl20 = x[2 * i1    ] - x[2 * i3    ];                     */
/*                 xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];                     */
/*                                                                           */
/*                 x[2 * i0    ] = (xh0 + xh20 + 1)>>1;                      */
/*                 x[2 * i0 + 1] = (xh1 + xh21 + 1)>>1;                      */
/*                                                                           */
/*                 xt0  = xh0 - xh20;                                        */
/*                 yt0  = xh1 - xh21;                                        */
/*                 xt1  = xl0 + xl21;                                        */
/*                 yt2  = xl1 + xl20;                                        */
/*                 xt2  = xl0 - xl21;                                        */
/*                 yt1  = xl1 - xl20;                                        */
/*                                                                           */
/*                 x[2 * i2    ]= (xt1 * co1 + yt1 * si1 + 0x00008000)>> 16; */
/*                 x[2 * i2 + 1]= (yt1 * co1 - xt1 * si1 + 0x00008000)>> 16; */
/*                 x[2 * i1    ]= (xt0 * co2 + yt0 * si2 + 0x00008000)>> 16; */
/*                 x[2 * i1 + 1]= (yt0 * co2 - xt0 * si2 + 0x00008000)>> 16; */
/*                 x[2 * i3    ]= (xt2 * co3 + yt2 * si3 + 0x00008000)>> 16; */
/*                 x[2 * i3 + 1]= (yt2 * co3 - xt2 * si3 + 0x00008000)>> 16; */
/*             }                                                             */
/*         }                                                                 */
/*                                                                           */
/*         ie <<= 2;                                                         */
/*    }                                                                      */
/*                                                                           */
/*    j = 0;                                                                 */
/*    ptr_x0 = x;                                                            */
/*    y0 = y;                                                                */
/*    l0 = _norm(n) - 17;                                                    */
/*                                                                           */
/*    if(radix == 2 || radix  == 4) for (i = 0; i < n; i += 4)               */
/*    {                                                                      */
/*                                                                           */
/*                                                                           */
/*            j0 = (j     ) & 0x3F;                                          */
/*            j1 = (j >> 6) & 0x3F;                                          */
/*            k0 = brev[j0];                                                 */
/*            k1 = brev[j1];                                                 */
/*            k = (k0 << 6) |  k1;                                           */
/*            if (l0 < 0) k = k << -l0;                                      */
/*            else        k = k >> l0;                                       */
/*            j++;                                                           */
/*                                                                           */
/*            x0   = ptr_x0[0];  x1 = ptr_x0[1];                             */
/*            x2   = ptr_x0[2];  x3 = ptr_x0[3];                             */
/*            x4   = ptr_x0[4];  x5 = ptr_x0[5];                             */
/*            x6   = ptr_x0[6];  x7 = ptr_x0[7];                             */
/*            ptr_x0 += 8;                                                   */
/*                                                                           */
/*            xh0_0  = x0 + x4;                                              */
/*            xh1_0  = x1 + x5;                                              */
/*            xh0_1  = x2 + x6;                                              */
/*            xh1_1  = x3 + x7;                                              */
/*                                                                           */
/*            if (radix == 2)                                                */
/*            {                                                              */
/*                xh0_0 = x0;                                                */
/*                xh1_0 = x1;                                                */
/*                xh0_1 = x2;                                                */
/*                xh1_1 = x3;                                                */
/*            }                                                              */
/*                                                                           */
/*            yt0  = xh0_0 + xh0_1;                                          */
/*            yt1  = xh1_0 + xh1_1;                                          */
/*            yt4  = xh0_0 - xh0_1;                                          */
/*            yt5  = xh1_0 - xh1_1;                                          */
/*                                                                           */
/*            xl0_0  = x0 - x4;                                              */
/*            xl1_0  = x1 - x5;                                              */
/*            xl0_1  = x2 - x6;                                              */
/*            xl1_1  = x3 - x7;                                              */
/*                                                                           */
/*            if (radix == 2)                                                */
/*            {                                                              */
/*                  xl0_0 = x4;                                              */
/*                  xl1_0 = x5;                                              */
/*                  xl1_1 = x6;                                              */
/*                  xl0_1 = x7;                                              */
/*            }                                                              */
/*                                                                           */
/*            yt2  = xl0_0 + xl1_1;                                          */
/*            yt3  = xl1_0 - xl0_1;                                          */
/*                                                                           */
/*            yt6  = xl0_0 - xl1_1;                                          */
/*            yt7  = xl1_0 + xl0_1;                                          */
/*                                                                           */
/*            if (radix == 2)                                                */
/*            {                                                              */
/*                 yt7  = xl1_0 - xl0_1;                                     */
/*                 yt3  = xl1_0 + xl0_1;                                     */
/*            }                                                              */
/*                                                                           */
/*            y0[k] = yt0; y0[k+1] = yt1;                                    */
/*            k += n>>1                                                      */
/*            y0[k] = yt2; y0[k+1] = yt3;                                    */
/*            k += n>>1;                                                     */
/*            y0[k] = yt4; y0[k+1] = yt5;                                    */
/*            k += n>>1;                                                     */
/*            y0[k] = yt6; y0[k+1] = yt7;                                    */
/*       }                                                                   */
/*   }                                                                       */
/*                                                                           */
/*       Although code shown above is the simplest equivalent way of writing */
/*       this code, it already carries several optimization ideas. It has    */
/*       a special last stage to avoid multiplication by 1. In addition it   */
/*       was shown by Panos Papamichalis that if the two middle legs of a    */
/*       radix 4 butterfly are reversed, the outputs for a radix4 transform  */
/*       end up in the bit reversed fashion. The code also carries a linear  */
/*       time look up table for bit reversal. This can be used as shown in   */
/*       the code to construct a bit reversed index. The last stage perfo-   */
/*       rms either a radix4 or radix2 as the case may be.                   */
/*                                                                           */
/*       The code shown below performs loop coalescing as it is realized     */
/*       that while the "i" and "j" loop individually iterate for variable   */
/*       number of times, together they always iterate for N/4 times. The    */
/*       natural C code and the code shown below use a modified twiddle      */
/*       factor array to allow for vectorization of the loop. In addition    */
/*       bit-reversal is performed by a macro BIT_REV. This makes the bit-   */
/*       reversal table redundant.                                           */
/*                                                                           */
/*       This is the C equivalent of the assembly code without restrictions: */
/*       Note that the assembly code is hand optimized and restrictions may  */
/*       apply.                                                              */
/*                                                                           */
/*                                                                           */
/*      void DSP_fft16x16r(int n, short ptr_x[], short ptr_w[], short ptr_y[],*/
/*                   unsigned char brev[], int n_min, int offset, int n_max) */
/*      {                                                                    */
/*         int  i, j, k, l1, l2, h2, predj;                                  */
/*         int  tw_offset, stride, fft_jmp;                                  */
/*                                                                           */
/*         short x0, x1, x2, x3,x4,x5,x6,x7;                                 */
/*         short xt0, yt0, xt1, yt1, xt2, yt2, yt3;                          */
/*         short yt4, yt5, yt6, yt7;                                         */
/*         short si1,si2,si3,co1,co2,co3;                                    */
/*         short xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                        */
/*         short x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;        */
/*         short xl0_0, xl1_0, xl0_1, xl1_1;                                 */
/*         short xh0_0, xh1_0, xh0_1, xh1_1;                                 */
/*         short *x,*w;                                                      */
/*         int   k0, k1, j0, j1, l0, radix;                                  */
/*         short * y0, * ptr_x0, * ptr_x2;                                   */
/*                                                                           */
/*         radix = n_min;                                                    */
/*                                                                           */
/*         stride = n; -* n is the number of complex samples *-              */
/*         tw_offset = 0;                                                    */
/*         while (stride > radix)                                            */
/*         {                                                                 */
/*             j = 0;                                                        */
/*             fft_jmp = stride + (stride>>1);                               */
/*             h2 = stride>>1;                                               */
/*             l1 = stride;                                                  */
/*             l2 = stride + (stride>>1);                                    */
/*             x = ptr_x;                                                    */
/*             w = ptr_w + tw_offset;                                        */
/*                                                                           */
/*             for (i = 0; i < n; i += 4)                                    */
/*             {                                                             */
/*                 co1 = w[j];                                               */
/*                 si1 = w[j+1];                                             */
/*                 co2 = w[j+2];                                             */
/*                 si2 = w[j+3];                                             */
/*                 co3 = w[j+4];                                             */
/*                 si3 = w[j+5];                                             */
/*                                                                           */
/*                 x_0    = x[0];                                            */
/*                 x_1    = x[1];                                            */
/*                 x_h2   = x[h2];                                           */
/*                 x_h2p1 = x[h2+1];                                         */
/*                 x_l1   = x[l1];                                           */
/*                 x_l1p1 = x[l1+1];                                         */
/*                 x_l2   = x[l2];                                           */
/*                 x_l2p1 = x[l2+1];                                         */
/*                                                                           */
/*                 xh0  = x_0    + x_l1;                                     */
/*                 xh1  = x_1    + x_l1p1;                                   */
/*                 xl0  = x_0    - x_l1;                                     */
/*                 xl1  = x_1    - x_l1p1;                                   */
/*                                                                           */
/*                 xh20 = x_h2   + x_l2;                                     */
/*                 xh21 = x_h2p1 + x_l2p1;                                   */
/*                 xl20 = x_h2   - x_l2;                                     */
/*                 xl21 = x_h2p1 - x_l2p1;                                   */
/*                                                                           */
/*                 ptr_x0 = x;                                               */
/*                 ptr_x0[0] = ((short) (xh0 + xh20))>>1; can be changed to 2*/
/*                 ptr_x0[1] = ((short) (xh1 + xh21))>>1; can be changed to 2*/
/*                                                                           */
/*                 ptr_x2 = ptr_x0;                                          */
/*                 x += 2;                                                   */
/*                 j += 6;                                                   */
/*                 predj = (j - fft_jmp);                                    */
/*                 if (!predj) x += fft_jmp;                                 */
/*                 if (!predj) j = 0;                                        */
/*                                                                           */
/*                 xt0 = xh0 - xh20;                                         */
/*                 yt0 = xh1 - xh21;                                         */
/*                 xt1 = xl0 + xl21;                                         */
/*                 yt2 = xl1 + xl20;                                         */
/*                 xt2 = xl0 - xl21;                                         */
/*                 yt1 = xl1 - xl20;                                         */
/*                                                                           */
/*                 ptr_x2[l1  ] = (xt1 * co1 + yt1 * si1 + 0x8000)>>16;      */
/*                 ptr_x2[l1+1] = (yt1 * co1 - xt1 * si1 + 0x8000)>>16;      */
/*                 ptr_x2[h2  ] = (xt0 * co2 + yt0 * si2 + 0x8000)>>16;      */
/*                 ptr_x2[h2+1] = (yt0 * co2 - xt0 * si2 + 0x8000)>>16;      */
/*                 ptr_x2[l2  ] = (xt2 * co3 + yt2 * si3 + 0x8000)>>16;      */
/*                 ptr_x2[l2+1] = (yt2 * co3 - xt2 * si3 + 0x8000)>>16;      */
/*             }                                                             */
/*             tw_offset += fft_jmp;                                         */
/*             stride = stride>>2;                                           */
/*         }-* end while *-                                                  */
/*                                                                           */
/*         j = offset>>2;                                                    */
/*                                                                           */
/*         ptr_x0 = ptr_x;                                                   */
/*         y0 = ptr_y;                                                       */
/*         l0 = _norm(nmax) - 17; -* get size of fft *-                      */
/*                                                                           */
/*         if (radix <= 4) for (i = 0; i < n; i += 4)                        */
/*         {                                                                 */
/*                 -* reversal computation *-                                */
/*                                                                           */
/*                 j0 = (j     ) & 0x3F;                                     */
/*                 j1 = (j >> 6) & 0x3F;                                     */
/*                 k0 = brev[j0];                                            */
/*                 k1 = brev[j1];                                            */
/*                 k = (k0 << 6) |  k1;                                      */
/*                 k = k >> l0;                                              */
/*                 j++;        -* multiple of 4 index *-                     */
/*                                                                           */
/*                 x0   = ptr_x0[0];  x1 = ptr_x0[1];                        */
/*                 x2   = ptr_x0[2];  x3 = ptr_x0[3];                        */
/*                 x4   = ptr_x0[4];  x5 = ptr_x0[5];                        */
/*                 x6   = ptr_x0[6];  x7 = ptr_x0[7];                        */
/*                 ptr_x0 += 8;                                              */
/*                                                                           */
/*                 xh0_0  = x0 + x4;                                         */
/*                 xh1_0  = x1 + x5;                                         */
/*                 xh0_1  = x2 + x6;                                         */
/*                 xh1_1  = x3 + x7;                                         */
/*                                                                           */
/*                 if (radix == 2) {                                         */
/*                   xh0_0 = x0;                                             */
/*                   xh1_0 = x1;                                             */
/*                   xh0_1 = x2;                                             */
/*                   xh1_1 = x3;                                             */
/*                 }                                                         */
/*                                                                           */
/*                 yt0  = xh0_0 + xh0_1;                                     */
/*                 yt1  = xh1_0 + xh1_1;                                     */
/*                 yt4  = xh0_0 - xh0_1;                                     */
/*                 yt5  = xh1_0 - xh1_1;                                     */
/*                                                                           */
/*                 xl0_0  = x0 - x4;                                         */
/*                 xl1_0  = x1 - x5;                                         */
/*                 xl0_1  = x2 - x6;                                         */
/*                 xl1_1  = x3 - x7;                                         */
/*                                                                           */
/*                 if (radix == 2) {                                         */
/*                   xl0_0 = x4;                                             */
/*                   xl1_0 = x5;                                             */
/*                   xl1_1 = x6;                                             */
/*                   xl0_1 = x7;                                             */
/*                 }                                                         */
/*                                                                           */
/*                 yt2  = xl0_0 + xl1_1;                                     */
/*                 yt3  = xl1_0 - xl0_1;                                     */
/*                 yt6  = xl0_0 - xl1_1;                                     */
/*                 yt7  = xl1_0 + xl0_1;                                     */
/*                                                                           */
/*                 if (radix == 2) {                                         */
/*                   yt7  = xl1_0 - xl0_1;                                   */
/*                   yt3  = xl1_0 + xl0_1;                                   */
/*                 }                                                         */
/*                                                                           */
/*                 y0[k] = yt0; y0[k+1] = yt1;                               */
/*                 k += n>>1;                                                */
/*                 y0[k] = yt2; y0[k+1] = yt3;                               */
/*                 k += n>>1;                                                */
/*                 y0[k] = yt4; y0[k+1] = yt5;                               */
/*                 k += n>>1;                                                */
/*                 y0[k] = yt6; y0[k+1] = yt7;                               */
/*         }                                                                 */
/*     }                                                                     */
/*                                                                           */
/*  REFERENCES                                                               */
/*  [1] C. S. Burrus and T.W. Parks (1985) "DFT/FFT and Convolution Algos -  */
/*      Theory and Implementation", J. Wiley.                                */
/*  [2] Implementation of Various Precision Fast Fourier Transforms on the   */
/*      TMS320C6400 processor - DJH, ESC 2000                                */
/*  [3] Burrus - Rice University and Papamichalis - TI (1988) - Paper on the */
/*      convertion of radix4 to radix2 digit reversal.                       */
/*                                                                           */
/*===========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*===========================================================================*/

#include <stdio.h>
#include <stdlib.h>

/*---------------------------------------------------------------------------*/
/* Define macro for bit reversal. This macro computes a bit reversed index   */
/* for a given index "i" and returns it in "j". The bit reversed index is    */
/* returned to be of the same size as "i" using the size argument "m".       */
/* For the natural form of C code, this is done by first interchanging every */
/* set of "2 bit" pairs, followed by exchanging nibbles, followed by exchan- */
/* ging bytes, and finally halfwords. To give an example, condider the       */
/* following number:                                                         */
/*                                                                           */
/* N = FEDCBA9876543210, where each digit represents a bit, the following    */
/* steps illustrate the changes as the exchanges are performed:              */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.    */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.       */
/* P = 1032547698BADCFE is the number after every byte is exchanged.         */
/* Q = 0123456789ABCDEF is the bit reversed number.                          */
/* Since only 16 digits were considered this represents the digit reversed   */
/* index. Since the numbers are represented as 32 bits, there is one more    */
/* step typically of exchanging the half words as well.                      */
/*---------------------------------------------------------------------------*/

#define BIT_REV(i, m, j)                                                    \
do {                                                                        \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        _ = ((_ & 0x55555555) <<  1) | ((_ & ~0x55555555) >>  1);           \
        (j) = _ >> (m);                                                     \
} while (0)                                                                 \


void DSP_fft16x16r(
                   int                       n,
                   short *restrict           ptr_x,
                   const short *restrict     ptr_w,
                   unsigned char *restrict   brev,
                   short *restrict           ptr_y,
                   int                       radix,
                   int                       offset,
                   int                       nmax
                  )
{
    short          yt0,         yt1,           yt2;
    short          yt3,         yt4,           yt5;
    short          yt6,         yt7;
    unsigned int   j,           k,             norm;

    int            i,           l0,            l1;
    int            l2,          h2,            fft_jmp;
    int            predj,       tw_offset,     stride;

    short          xt0_0,       yt0_0,         xt1_0;
    short          yt1_0,       xt2_0,         yt2_0;
    short          xt0_1,       yt0_1,         xt1_1;
    short          yt1_1,       xt2_1,         yt2_1;
    short          xh0_0,       xh1_0,         xh20_0;
    short          xh21_0,      xl0_0,         xl1_0;
    short          xl20_0,      xl21_0,        xl20_1;
    short          xh0_1,       xh1_1,         xh20_1;
    short          xh21_1,      xl0_1,         xl1_1;
    short          xl21_1;

    short          x_0,         x_1,           x_2;
    short          x_3,         x_l1_0,        x_l1_1;
    short          x_l1_2,      x_l1_3,        x_l2_0;
    short          x_l2_1,      x_4,           x_5;
    short          x_6,         x_7,           x_l2_2;
    short          x_l2_3,      x_h2_0,        x_h2_1;
    short          x_h2_2,      x_h2_3;

    short          si10,        si20,          si30;
    short          co10,        co20,          co30;
    short          si11,        si21,          si31;
    short          co11,        co21,          co31;

    const short    *w;
    short          *x,           *x2,          *x0;
    short          *y0,          *y1,          *y2;
    short          *ptr_x0,      *y3;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride    =    n;
    tw_offset =    0;
    fft_jmp   =    6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > radix)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         =  0;
        fft_jmp >>=  2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2  = stride>>1;
        l1  = stride;
        l2  = stride + (stride>>1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride >>= 2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount. In addition the following code is unrolled to  */
        /* perform "2" radix4 butterflies in parallel.                    */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        #pragma MUST_ITERATE(1, , 1);
        #endif

        for (i = 0; i < n; i += 8)
        {
            /*------------------------------------------------------------*/
            /* Read the first 12 twiddle factors, six of which are used   */
            /* for one radix 4 butterfly and six of which are used for    */
            /* next one.                                                  */
            /*------------------------------------------------------------*/

            co10 = w[j+1];        si10 = w[j+0];
            co11 = w[j+3];        si11 = w[j+2];
            co20 = w[j+5];        si20 = w[j+4];
            co21 = w[j+7];        si21 = w[j+6];
            co30 = w[j+9];        si30 = w[j+8];
            co31 = w[j+11];       si31 = w[j+10];

            /*------------------------------------------------------------*/
            /* Read in the first complex input for the butterflies.       */
            /* 1st complex input to 1st butterfly: x[0] + jx[1]           */
            /* 1st complex input to 2nd butterfly: x[2] + jx[3]           */
            /*------------------------------------------------------------*/

            x_0 = x[0];           x_1 = x[1];
            x_2 = x[2];           x_3 = x[3];

            /*------------------------------------------------------------*/
            /* Read in the complex inputs for the butterflies. Each of the*/
            /* successive complex inputs of the butterfly are seperated   */
            /* by a fixed amount known as stride. The stride starts out   */
            /* at N/4, and quarters with every stage.                     */
            /*------------------------------------------------------------*/

            x_l1_0 = x[l1  ];       x_l1_1 = x[l1 + 1];
            x_l1_2 = x[l1 + 2];     x_l1_3 = x[l1 + 3];

            x_l2_0 = x[l2  ];       x_l2_1 = x[l2 + 1];
            x_l2_2 = x[l2 + 2];     x_l2_3 = x[l2 + 3];

            x_h2_0 = x[h2  ];       x_h2_1 = x[h2 + 1];
            x_h2_2 = x[h2 + 2];     x_h2_3 = x[h2 + 3];

            /*-----------------------------------------------------------*/
            /* Two butterflies are evaluated in parallel. The following  */
            /* results will be shown for one butterfly only, although    */
            /* both are being evaluated in parallel.                     */
            /*                                                           */
            /* Perform radix2 style DIF butterflies.                     */
            /*-----------------------------------------------------------*/

            xh0_0  = x_0    + x_l1_0;     xh1_0  = x_1    + x_l1_1;
            xh0_1  = x_2    + x_l1_2;     xh1_1  = x_3    + x_l1_3;
            xl0_0  = x_0    - x_l1_0;     xl1_0  = x_1    - x_l1_1;
            xl0_1  = x_2    - x_l1_2;     xl1_1  = x_3    - x_l1_3;

            xh20_0 = x_h2_0 + x_l2_0;     xh21_0 = x_h2_1 + x_l2_1;
            xh20_1 = x_h2_2 + x_l2_2;     xh21_1 = x_h2_3 + x_l2_3;
            xl20_0 = x_h2_0 - x_l2_0;     xl21_0 = x_h2_1 - x_l2_1;
            xl20_1 = x_h2_2 - x_l2_2;     xl21_1 = x_h2_3 - x_l2_3;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 12, to reflect the fact that 12 half words */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 4. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j += 12;
            x += 4;

            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /*                                                          */
            /* Note that in this version of the code voth rounding and  */
            /* scaling are implemented.                                 */
            /* ---------------------------------------------------------*/

            x0[0] = (xh0_0 + xh20_0 + 1) >> 1;
            x0[1] = (xh1_0 + xh21_0 + 1) >> 1;
            x0[2] = (xh0_1 + xh20_1 + 1) >> 1;
            x0[3] = (xh1_1 + xh21_1 + 1) >> 1;

            xt0_0 = xh0_0 - xh20_0;  yt0_0 = xh1_0 - xh21_0;
            xt0_1 = xh0_1 - xh20_1;  yt0_1 = xh1_1 - xh21_1;

            xt1_0 = xl0_0 + xl21_0;  yt2_0 = xl1_0 + xl20_0;
            xt2_0 = xl0_0 - xl21_0;  yt1_0 = xl1_0 - xl20_0;

            xt1_1 = xl0_1 + xl21_1;  yt2_1 = xl1_1 + xl20_1;
            xt2_1 = xl0_1 - xl21_1;  yt1_1 = xl1_1 - xl20_1;

            /*---------------------------------------------------------*/
            /* Notice that in this version of the code the two middle  */
            /* legs are swapped as indicated by the stores to x[l1]..  */
            /* x[l1 + 3] which preceede the stores to x[h2]..x[h2 + 3] */
            /* This reversal guarantees that a radix4 DIF butterfly    */
            /* produces results in digit reversed order. Note that in  */
            /* addition to the rounding, the shift is performed by 16, */
            /* as opposed to 15, to give scaling.                      */
            /*---------------------------------------------------------*/

            x2[l1  ] = (si10 * yt1_0 + co10 * xt1_0 + 0x8000) >> 16;
            x2[l1+1] = (co10 * yt1_0 - si10 * xt1_0 + 0x8000) >> 16;

            x2[l1+2] = (si11 * yt1_1 + co11 * xt1_1 + 0x8000) >> 16;
            x2[l1+3] = (co11 * yt1_1 - si11 * xt1_1 + 0x8000) >> 16;

            x2[h2  ] = (si20 * yt0_0 + co20 * xt0_0 + 0x8000) >> 16;
            x2[h2+1] = (co20 * yt0_0 - si20 * xt0_0 + 0x8000) >> 16;

            x2[h2+2] = (si21 * yt0_1 + co21 * xt0_1 + 0x8000) >> 16;
            x2[h2+3] = (co21 * yt0_1 - si21 * xt0_1 + 0x8000) >> 16;

            x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0 + 0x8000) >> 16;
            x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0 + 0x8000) >> 16;

            x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1 + 0x8000) >> 16;
            x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1 + 0x8000) >> 16;
        }
    }

    /*----------------------------------------------------------------*/
    /* The following condition allows the fft to become a multiple    */
    /* call FFT as it exits as soon as stride, between two legs       */
    /* becomes greater than the radix.                                */
    /*----------------------------------------------------------------*/

    if (radix > 4) return;

    /*-----------------------------------------------------------------*/
    /* Use index at offset/4 for bit reversal. Set up input , output   */
    /* pointers to store away the result. The last stage perfoms 1     */
    /* radix4 butterfly or 4 radix2 burtterflies per iteration.        */
    /*-----------------------------------------------------------------*/

    j = offset >> 2;
    ptr_x0 = ptr_x;

    y0 = ptr_y;
    y1 = y0 + (nmax >> 1);
    y2 = y1 + (nmax >> 1);
    y3 = y2 + (nmax >> 1);

    /*-----------------------------------------------------------------*/
    /* Use the following loop to determine norm as determined by C6x   */
    /*-----------------------------------------------------------------*/

    for (i = 31, norm = 1; (nmax & (1 << i)) == 0; i--, norm++) ;
    norm -= 2;
    l0 = norm + 3;

    #ifndef NOASSUME
    _nassert((int)(n)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < n; i += 4)
    {
            /*--------------------------------------------------------*/
            /* The following macro performs bit reversal of index "j" */
            /* of size "l0" bits into index "k". This forms the index */
            /* with respect to pointers y0, y1, y2, y3 into which  4  */
            /* consecutive inputs map into.                           */
            /*--------------------------------------------------------*/

            BIT_REV(j, l0, k);
            j +=  1;

            x_0   = ptr_x0[0];  x_1 = ptr_x0[1];
            x_2   = ptr_x0[2];  x_3 = ptr_x0[3];
            x_4   = ptr_x0[4];  x_5 = ptr_x0[5];
            x_6   = ptr_x0[6];  x_7 = ptr_x0[7];
            ptr_x0 += 8;

            /*--------------------------------------------------------*/
            /* Read in the input data, from the first eight locations.*/
            /* These results are transformed as radix 4               */
            /*--------------------------------------------------------*/

            xl0_0  = x_0 - x_4; xl1_0  = x_1 - x_5;
            xl0_1  = x_2 - x_6; xl1_1  = x_3 - x_7;

            if (radix == 2)
            {
                /*----------------------------------------------------*/
                /* These results are appropriately changed if radix   */
                /* is 2, so that when the next set of radix 4 steps   */
                /* performed then the results are same as radix 2.    */
                /*----------------------------------------------------*/

                xl0_0   =   x_4;     xl1_0   =   x_5;
                xl1_1   =   x_6;     xl0_1   =   -x_7;
            }

            /*--------------------------------------------------------*/
            /* Perform nest step of radix4 for lower leg. This will   */
            /* result in the correct results radix4 or radix2         */
            /*--------------------------------------------------------*/

            yt2  = xl0_0 + xl1_1; yt7  = xl1_0 + xl0_1;
            yt6  = xl0_0 - xl1_1; yt3  = xl1_0 - xl0_1;

            if (radix == 2)
            {
               /*-----------------------------------------------------*/
               /* Zero out the contributions of x4..x7 for the high   */
               /* leg if the radix is 2, rememebering that the cont-  */
               /* ributions are restricted within four points.        */
               /*-----------------------------------------------------*/

               x_4 = x_5 = x_6 = x_7 = 0;
            }

            /*---------------------------------------------------------*/
            /* Perform radix4 decomposition as a series of radix2 DIF  */
            /* compositions. This yields yt1:yt0 and yt5:yt4           */
            /*---------------------------------------------------------*/

            xh0_0  = x_0   +  x_4;     xh1_0  = x_1 + x_5;
            xh0_1  = x_2   +  x_6;     xh1_1  = x_3 + x_7;
            yt0    = xh0_0 +  xh0_1;   yt1  = xh1_0 + xh1_1;
            yt4    = xh0_0 -  xh0_1;   yt5  = xh1_0 - xh1_1;

            /*---------------------------------------------------------*/
            /*  Store out the results of the radix4 butterfly as 4 o/p */
            /* or the result of 2 radix2 butterflies.                  */
            /*---------------------------------------------------------*/

            y0[k  ] = yt0;             y0[k+1] = yt1;
            y1[k  ] = yt2;             y1[k+1] = yt3;
            y2[k  ] = yt4;             y2[k+1] = yt5;
            y3[k  ] = yt6;             y3[k+1] = yt7;
    }
}

/*===========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*===========================================================================*/
fft16x16t.c/    1066929505  0     0     0       48782     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.1     Fri Apr 27 21:09:50 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*     fft: Mixed radix FFT for 2^M and 4^M, 16x16 with truncation          */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      27-Dec-1999                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/* void DSP_fft16x16t(const short * ptr_w, int  npoints, short * ptr_x,     */
/*                   short * ptr_y)                                         */
/*                                                                          */
/*  where:                                                                  */
/*  ptr_w: pointer to an array of twiddle factors generated as explained    */
/*  below.                                                                  */
/*  npoints: Number of points for the FFT transform, can be a multiple of   */
/*  2 or 4.                                                                 */
/*  ptr_x: Pointer to input data to be transformed.                         */
/*  ptr_y: Pointer that contains the final FFT results in normal order.     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This code performs a Radix-4 FFT with digit reversal.  The code     */
/*      uses a special ordering of twiddle factors and memory accesses      */
/*      to improve performance in the presence of cache.  It operates       */
/*      largely in-place, but the final digit-reversed output is written    */
/*      out-of-place.                                                       */
/*                                                                          */
/*      This code requires a special sequence of twiddle factors stored     */
/*      in 1Q15 fixed-point format.  The following C code illustrates       */
/*      one way to generate the desired twiddle-factor array:               */
/*                                                                          */
/*      #include <math.h>                                                   */
/*                                                                          */
/*      #ifndef PI                                                          */
/*      # define PI (3.14159265358979323846)                                */
/*      #endif                                                              */
/*                                                                          */
/*      short d2s(double d)                                                 */
/*      {                                                                   */
/*          d = floor(0.5 + d);  // Explicit rounding to integer //         */
/*          if (d >=  32767.0) return  32767;                               */
/*          if (d <= -32768.0) return -32768;                               */
/*          return (short)d;                                                */
/*      }                                                                   */
/*                                                                          */
/*      void gen_twiddle(short *w, int n)                                   */
/*      {                                                                   */
/*          double M = 32767.5;                                             */
/*          int i, j, k;                                                    */
/*                                                                          */
/*          for (j = 1, k = 0; j < n >> 2; j = j << 2)                      */
/*          {                                                               */
/*              for (i = 0; i < n >> 2; i += j << 1)                        */
/*              {                                                           */
/*                  w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       */
/*                  w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       */
/*                  w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       */
/*                  w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       */
/*                  w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       */
/*                  w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       */
/*                  w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       */
/*                  w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       */
/*                  w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       */
/*                  w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       */
/*                                                                          */
/*                  k += 12;                                                */
/*              }                                                           */
/*          }                                                               */
/*          w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   */
/*          w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       */
/*      }                                                                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The size of the FFT, n, must be a power of 4 or 2 and greater than  */
/*      or equal to 16 and less than 32768.                                 */
/*                                                                          */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*                                                                          */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices.                         */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order. In addition if the number  */
/*      of points to be transformed is a power of 2, the final stage        */
/*      applies a radix2 pass instead of a radix 4. In any case the         */
/*      outputs are returned in normal order.                               */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part os the         */
/*      complex multiply is implemented using _dotp2. The imaginary         */
/*      part of the complex multiply is implemented using _dotpn2           */
/*      after the twiddle factors are swizzled within the half word.        */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      */
/*                                                                          */
/*      The actual twiddle factors for the FFT are cosine, - sine. The      */
/*      twiddle factors stored in the table are csine and sine, hence       */
/*      the sign of the "sine" term is comprehended during multipli-        */
/*      cation as shown above.                                              */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

/*==========================================================================*/
/* DSP_fft16x16t  - bevavioural code/ natural c                             */
/*==========================================================================*/

void DSP_fft16x16t(const short *restrict ptr_w, int npoints, short * ptr_x,
                  short * ptr_y)
{
    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    short xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    short xt0_1, yt0_1, xt1_1, yt1_1, xt2_1, yt2_1;
    short xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    short xh0_1, xh1_1, xh20_1, xh21_1, xl0_1, xl1_1, xl20_1, xl21_1;
    short x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l1_2, x_l1_3, x_l2_0, x_l2_1;
    short xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    short x_4, x_5, x_6, x_7, x_l2_2, x_l2_3, x_h2_0, x_h2_1, x_h2_2, x_h2_3;
    short x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    short si10, si20, si30, co10, co20, co30;
    short si11, si21, si31, co11, co21, co31;
    short * x, * x2, * x0;
    short * y0, * y1, * y2, *y3;
    short n00, n10, n20, n30, n01, n11, n21, n31;
    short n02, n12, n22, n32, n03, n13, n23, n33;
    short y0r, y0i, y4r, y4i;
    int   n0, j0;
    int   radix,  m;
    int   norm;

    const short *w;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     =   m & 1 ? 2 :  4;
    norm      =   m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride     =   npoints;
    tw_offset  =   0;
    fft_jmp    =   6 * stride;

     #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > radix)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         = 0;
        fft_jmp >>= 2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride>>1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;
        stride >>=   2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount. In addition the following code is unrolled to  */
        /* perform "2" radix4 butterflies in parallel.                    */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        #pragma MUST_ITERATE(1, , 1);
        #endif

        for (i = 0; i < npoints; i += 8)
        {
            /*------------------------------------------------------------*/
            /* Read the first 12 twiddle factors, six of which are used   */
            /* for one radix 4 butterfly and six of which are used for    */
            /* next one.                                                  */
            /*------------------------------------------------------------*/

            co10 = w[j+1];    si10 = w[j+0];
            co11 = w[j+3];    si11 = w[j+2];
            co20 = w[j+5];    si20 = w[j+4];
            co21 = w[j+7];    si21 = w[j+6];
            co30 = w[j+9];    si30 = w[j+8];
            co31 = w[j+11];   si31 = w[j+10];

            /*------------------------------------------------------------*/
            /* Read in the first complex input for the butterflies.       */
            /* 1st complex input to 1st butterfly: x[0] + jx[1]           */
            /* 1st complex input to 2nd butterfly: x[2] + jx[3]           */
            /*------------------------------------------------------------*/

            x_0 = x[0];       x_1 = x[1];
            x_2 = x[2];       x_3 = x[3];

            /*------------------------------------------------------------*/
            /* Read in the complex inputs for the butterflies. Each of the*/
            /* successive complex inputs of the butterfly are seperated   */
            /* by a fixed amount known as stride. The stride starts out   */
            /* at N/4, and quarters with every stage.                     */
            /*------------------------------------------------------------*/

            x_l1_0 = x[l1  ]; x_l1_1 = x[l1+1];
            x_l1_2 = x[l1+2]; x_l1_3 = x[l1+3];

            x_l2_0 = x[l2  ]; x_l2_1 = x[l2+1];
            x_l2_2 = x[l2+2]; x_l2_3 = x[l2+3];

            x_h2_0 = x[h2  ]; x_h2_1 = x[h2+1];
            x_h2_2 = x[h2+2]; x_h2_3 = x[h2+3];

            /*-----------------------------------------------------------*/
            /* Two butterflies are evaluated in parallel. The following  */
            /* results will be shown for one butterfly only, although    */
            /* both are being evaluated in parallel.                     */
            /*                                                           */
            /* Perform radix2 style DIF butterflies.                     */
            /*-----------------------------------------------------------*/

            xh0_0  = x_0    + x_l1_0;     xh1_0  = x_1    + x_l1_1;
            xh0_1  = x_2    + x_l1_2;     xh1_1  = x_3    + x_l1_3;
            xl0_0  = x_0    - x_l1_0;     xl1_0  = x_1    - x_l1_1;
            xl0_1  = x_2    - x_l1_2;     xl1_1  = x_3    - x_l1_3;

            xh20_0 = x_h2_0 + x_l2_0;     xh21_0 = x_h2_1 + x_l2_1;
            xh20_1 = x_h2_2 + x_l2_2;     xh21_1 = x_h2_3 + x_l2_3;
            xl20_0 = x_h2_0 - x_l2_0;     xl21_0 = x_h2_1 - x_l2_1;
            xl20_1 = x_h2_2 - x_l2_2;     xl21_1 = x_h2_3 - x_l2_3;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 12, to reflect the fact that 12 half words */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 4. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j += 12;
            x += 4;

            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* ---------------------------------------------------------*/

            y0r   = xh0_0 + xh20_0; y0i   = xh1_0 + xh21_0;
            y4r   = xh0_1 + xh20_1; y4i   = xh1_1 + xh21_1;

            xt0_0 = xh0_0 - xh20_0;  yt0_0 = xh1_0 - xh21_0;
            xt0_1 = xh0_1 - xh20_1;  yt0_1 = xh1_1 - xh21_1;

            xt1_0 = xl0_0 + xl21_0;  yt2_0 = xl1_0 + xl20_0;
            xt2_0 = xl0_0 - xl21_0;  yt1_0 = xl1_0 - xl20_0;
            xt1_1 = xl0_1 + xl21_1;  yt2_1 = xl1_1 + xl20_1;
            xt2_1 = xl0_1 - xl21_1;  yt1_1 = xl1_1 - xl20_1;

            /*---------------------------------------------------------*/
            /* Store out first output, of the four outputs of a radix4 */
            /* butterfly. Since two such radix4 butterflies are per-   */
            /* formed in parallel, there are 2 such 1st outputs.       */
            /*---------------------------------------------------------*/

            x2[0] = y0r;             x2[1] = y0i;
            x2[2] = y4r;             x2[3] = y4i;

            /*---------------------------------------------------------*/
            /* Perform twiddle factor multiplies of three terms,top    */
            /* term does not have any multiplies. Note the twiddle     */
            /* factors for a normal FFT are C + j (-S). Since the      */
            /* factors that are stored are C + j S, this is            */
            /* corrected for in the multiplies.                        */
            /*                                                         */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)       */
            /* Perform the multiplies using 16 by 32 multiply macro    */
            /* defined. This treats the twiddle factor as 16 bits      */
            /* and incoming data as 32 bits.                           */
            /*---------------------------------------------------------*/

            x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0) >> 15;
            x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0) >> 15;

            x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1) >> 15;
            x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1) >> 15;

            x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0) >> 15;
            x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0) >> 15;

            x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1) >> 15;
            x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1) >> 15;

            x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0) >> 15;
            x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0) >> 15;

            x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1) >> 15;
            x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1) >> 15;
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints >> 1);

    if (radix == 2)
    {
      /*----------------------------------------------------------------*/
      /* The pointers are set at the following locations which are half */
      /* the offsets of a radix4 FFT.                                   */
      /*----------------------------------------------------------------*/

      y1 = y0 + (int) (npoints >> 2);
      y3 = y2 + (int) (npoints >> 2);
      l1 = norm + 1;
      j0 = 8;
      n0 = npoints>>1;
    }
    else
    {
      y1 = y0 + (int) (npoints >> 1);
      y3 = y2 + (int) (npoints >> 1);
      l1 = norm + 2;
      j0 = 4;
      n0 = npoints >> 2;
    }

    /*--------------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4    */
    /* or a radix 2 style decomposition. It writes out at different       */
    /* locations though. It checks if either half the points, or a        */
    /* quarter of the complex points have been exhausted to jump to       */
    /* pervent double reversal.                                           */
    /*--------------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {

        /*----------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to "j"  */
        /* is either by 4, or 8.                                          */
        /*----------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*----------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations. These  */
        /* are transformed either as a radix4 or as a radix 2.            */
        /*----------------------------------------------------------------*/

        x_0 = x0[0];             x_1 = x0[1];
        x_2 = x0[2];             x_3 = x0[3];
        x_4 = x0[4];             x_5 = x0[5];
        x_6 = x0[6];             x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4;       xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4;       xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6;       xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6;       xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n10 = xl0_0 + xl1_1; n11 = xl1_0 - xl0_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n30 = xl0_0 - xl1_1; n31 = xl1_0 + xl0_1;

        if (radix == 2)
        {
             /*-------------------------------------------------------------*/
             /* Perform radix2 style decomposition.                         */
             /*-------------------------------------------------------------*/
             n00 = x_0 + x_2;     n01 = x_1 + x_3;
             n20 = x_0 - x_2;     n21 = x_1 - x_3;
             n10 = x_4 + x_6;     n11 = x_5 + x_7;
             n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        y0[2*h2] = n00;           y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;           y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;           y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;           y3[2*h2 + 1] = n31;

        /*----------------------------------------------------------------*/
        /* Read in ht enext eight inputs, and perform radix4 or radix2    */
        /* decomposition.                                                 */
        /*----------------------------------------------------------------*/

        x_8 = x2[0];              x_9 = x2[1];
        x_a = x2[2];              x_b = x2[3];
        x_c = x2[4];              x_d = x2[5];
        x_e = x2[6];              x_f = x2[7];
        x2 += 8;

        xh0_2 = x_8 + x_c;        xh1_2  = x_9 + x_d;
        xl0_2 = x_8 - x_c;        xl1_2  = x_9 - x_d;
        xh0_3 = x_a + x_e;        xh1_3 = x_b + x_f;
        xl0_3 = x_a - x_e;        xl1_3 = x_b - x_f;

        n02 = xh0_2 + xh0_3;      n03 = xh1_2 + xh1_3;
        n12 = xl0_2 + xl1_3;      n13 = xl1_2 - xl0_3;
        n22 = xh0_2 - xh0_3;      n23 = xh1_2 - xh1_3;
        n32 = xl0_2 - xl1_3;      n33 = xl1_2 + xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;        n03 = x_9 + x_b;
          n22 = x_8 - x_a;        n23 = x_9 - x_b;
          n12 = x_c + x_e;        n13 = x_d + x_f;
          n32 = x_c - x_e;        n33 = x_d - x_f;
        }

        /*-----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4]  */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]   */
        /*-----------------------------------------------------------------*/

        y0[2*h2+2] = n02;         y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;         y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;         y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;         y3[2*h2+3] = n33;

        /*-----------------------------------------------------------------*/
        /* Increment "j" by "j0". If j equals n0, then increment both "x0" */
        /* and "x2" so that double inversion is avoided.                   */
        /*-----------------------------------------------------------------*/

        j += j0;

        if (j == n0)
        {
           j  += n0;
           x0 += (int) npoints>>1;
           x2 += (int) npoints>>1;
        }
    }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/
fft16x32.c/     1066929505  0     0     0       48905     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Sep  6 17:51:06 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/*==========================================================================*/
/*     TEXAS INSTRUMENTS, INC.                                              */
/*                                                                          */
/*     NAME                                                                 */
/*           DSP_fft16x32                                                   */
/*                                                                          */
/*     USAGE                                                                */
/*           This routine is C-callable and can be called as:               */
/*                                                                          */
/*          void DSP_fft16x32(const short * ptr_w, int  npoints,            */
/*                           int   * ptr_x, int  * ptr_y ) ;                */
/*                                                                          */
/*            ptr_w   =  input twiddle factors                              */
/*            npoints =  number of points                                   */
/*            ptr_x   =  transformed data reversed                          */
/*            ptr_y   =  linear transformed data                            */
/*                                                                          */
/*           (See the C compiler reference guide.)                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The following code performs a mixed radix FFT for "npoints" which   */
/*      is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  */
/*      transform and performs either a radix2 or radix4 transform on the   */
/*      last stage depending on "npoints". If "npoints" is a multiple of 4, */
/*      then this last stage is also a radix4 transform, otherwise it is a  */
/*      radix2 transform. This program is available as a C compilable file  */
/*      to automatically generate the twiddle factors "twiddle_split.c"     */
/*                                                                          */
/*        int i, j, k, n = N;                                               */
/*        double theta1, theta2, theta3, x_t, y_t;                          */
/*        const double M = 32768.0, PI = 3.141592654;                       */
/*                                                                          */
/*        for (j=1, k=0; j < n>>2; j = j<<2)                                */
/*        {                                                                 */
/*            for (i=0; i < n>>2; i += j<<1)                                */
/*            {                                                             */
/*                theta1 = 2*PI*i/n;                                        */
/*                x_t = M*cos(theta1);                                      */
/*                y_t = M*sin(theta1);                                      */
/*                w[k+1] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+1] = 0x7fff;                            */
/*                w[k+0] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+0] = 0x7fff;                            */
/*                                                                          */
/*                theta1 = 2*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta1);                                      */
/*                y_t = M*sin(theta1);                                      */
/*                w[k+7] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+3] = 0x7fff;                            */
/*                w[k+6] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+2] = 0x7fff;                            */
/*                                                                          */
/*                theta2 = 4*PI*i/n;                                        */
/*                x_t = M*cos(theta2);                                      */
/*                y_t = M*sin(theta2);                                      */
/*                w[k+3] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+5] = 0x7fff;                            */
/*                w[k+2] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+4] = 0x7fff;                            */
/*                                                                          */
/*                theta2 = 4*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta2);                                      */
/*                y_t = M*sin(theta2);                                      */
/*                w[k+9] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+7] = 0x7fff;                            */
/*                w[k+8] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+6] = 0x7fff;                            */
/*                                                                          */
/*                theta3 = 6*PI*i/n;                                        */
/*                x_t = M*cos(theta3);                                      */
/*                y_t = M*sin(theta3);                                      */
/*                w[k+5] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+9] = 0x7fff;                            */
/*                w[k+4] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+8] = 0x7fff;                            */
/*                                                                          */
/*                theta3 = 6*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta3);                                      */
/*                y_t = M*sin(theta3);                                      */
/*                w[k+11] = (short) x_t;                                    */
/*                if (x_t >= M) w[k+11] = 0x7fff;                           */
/*                w[k+10] = (short) y_t;                                    */
/*                if (y_t >= M) w[k+10] = 0x7fff;                           */
/*                                                                          */
/*                k += 12;                                                  */
/*            }                                                             */
/*        }                                                                 */
/*        w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          */
/*        w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      This code works for  both "npoints" a multiple of 2 or 4.           */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*                                                                          */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices.                         */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part of the         */
/*      multiply and the imaginary part of the multiply are performed       */
/*      as 16x32 multiplies using MPYLIR and MPYHIR                         */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      */
/*                                                                          */
/*      The actual twiddle factors for the FFT are cosine, - sine. The      */
/*      twiddle factors stored in the table are csine and sine, hence       */
/*      the sign of the "sine" term is comprehended during multipli-        */
/*      cation as shown above.                                              */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include <stdio.h>
#include <stdlib.h>

/* ======================================================================== */
/*  Perform a signed 16-bit by signed 32-bit multiply, rounding and         */
/*  shifting away the lower 15 bits.                                        */
/* ======================================================================== */

#define MPY16X32R(x,y) \
    (((int)((short)(x) * (unsigned short)(y) + 0x4000) >> 15) + \
     ((int)((short)(x) * (short)((y) >> 16)) << 1))

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

/*==========================================================================*/
/* DSP_fft16x32  - bevavioural code/ natural c                              */
/*==========================================================================*/

void DSP_fft16x32(const short * ptr_w, int npoints, int * ptr_x, int * ptr_y)
{
    int i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    int xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    int xt0_1, yt0_1, xt1_1, yt1_1, xt2_1, yt2_1;
    int xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    int xh0_1, xh1_1, xh20_1, xh21_1, xl0_1, xl1_1, xl20_1, xl21_1;
    int x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l1_2, x_l1_3, x_l2_0, x_l2_1;
    int xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    int x_4, x_5, x_6, x_7, x_l2_2, x_l2_3, x_h2_0, x_h2_1, x_h2_2, x_h2_3;
    int x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    short si10, si20, si30, co10, co20, co30;
    short si11, si21, si31, co11, co21, co31;
    const short *w;
    int *x, *x2, *x0;
    int * y0, * y1, * y2, *y3;
    int n00, n10, n20, n30, n01, n11, n21, n31;
    int n02, n12, n22, n32, n03, n13, n23, n33;
    int n0, j0;
    int radix, m;
    int y0r, y0i,  y4r, y4i;
    int norm;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     = m & 1 ? 2 :  4;
    norm      = m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride     =   npoints;
    tw_offset  =   0;
    fft_jmp    =   6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > 4)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         = 0;
        fft_jmp >>= 2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride >> 1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride  >>= 2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount. In addition the following code is unrolled to  */
        /* perform "2" radix4 butterflies in parallel.                    */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        #pragma MUST_ITERATE(1, , 1);
        #endif

        for (i = 0; i < (npoints >> 3); i ++)
        {

            /*------------------------------------------------------------*/
            /* Read the first 12 twiddle factors, six of which are used   */
            /* for one radix 4 butterfly and six of which are used for    */
            /* next one.                                                  */
            /*------------------------------------------------------------*/

            co10 = w[j+1];    si10 = w[j+0];
            co20 = w[j+3];    si20 = w[j+2];
            co30 = w[j+5];    si30 = w[j+4];
            co11 = w[j+7];    si11 = w[j+6];
            co21 = w[j+9];    si21 = w[j+8];
            co31 = w[j+11];   si31 = w[j+10];

            /*------------------------------------------------------------*/
            /* Read in the first complex input for the butterflies.       */
            /* 1st complex input to 1st butterfly: x[0] + jx[1]           */
            /* 1st complex input to 2nd butterfly: x[2] + jx[3]           */
            /*------------------------------------------------------------*/

            x_0 = x[0];       x_1 = x[1];
            x_2 = x[2];       x_3 = x[3];

            /*------------------------------------------------------------*/
            /* Read in the complex inputs for the butterflies. Each of the*/
            /* successive complex inputs of the butterfly are seperated   */
            /* by a fixed amount known as stride. The stride starts out   */
            /* at N/4, and quarters with every stage.                     */
            /*------------------------------------------------------------*/

            x_l1_0 = x[l1  ]; x_l1_1 = x[l1+1];
            x_l1_2 = x[l1+2]; x_l1_3 = x[l1+3];

            x_l2_0 = x[l2  ]; x_l2_1 = x[l2+1];
            x_l2_2 = x[l2+2]; x_l2_3 = x[l2+3];

            x_h2_0 = x[h2  ]; x_h2_1 = x[h2+1];
            x_h2_2 = x[h2+2]; x_h2_3 = x[h2+3];

            /*-----------------------------------------------------------*/
            /* Two butterflies are evaluated in parallel. The following  */
            /* results will be shown for one butterfly only, although    */
            /* both are being evaluated in parallel.                     */
            /*                                                           */
            /* Perform radix2 style DIF butterflies.                     */
            /*-----------------------------------------------------------*/

            xh0_0  = x_0    + x_l1_0;        xh1_0  = x_1    + x_l1_1;
            xh0_1  = x_2    + x_l1_2;        xh1_1  = x_3    + x_l1_3;

            xl0_0  = x_0    - x_l1_0;        xl1_0  = x_1    - x_l1_1;
            xl0_1  = x_2    - x_l1_2;        xl1_1  = x_3    - x_l1_3;

            xh20_0 = x_h2_0 + x_l2_0;        xh21_0 = x_h2_1 + x_l2_1;
            xh20_1 = x_h2_2 + x_l2_2;        xh21_1 = x_h2_3 + x_l2_3;

            xl20_0 = x_h2_0 - x_l2_0;        xl21_0 = x_h2_1 - x_l2_1;
            xl20_1 = x_h2_2 - x_l2_2;        xl21_1 = x_h2_3 - x_l2_3;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 12, to reflect the fact that 12 half words */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 4. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j += 12;
            x += 4;

            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* ---------------------------------------------------------*/

            y0r   = xh0_0 + xh20_0; y0i   = xh1_0 + xh21_0;
            y4r   = xh0_1 + xh20_1; y4i   = xh1_1 + xh21_1;

            xt0_0 = xh0_0 - xh20_0;  yt0_0 = xh1_0 - xh21_0;
            xt0_1 = xh0_1 - xh20_1;  yt0_1 = xh1_1 - xh21_1;

            xt1_0 = xl0_0 + xl21_0;  yt2_0 = xl1_0 + xl20_0;
            xt2_0 = xl0_0 - xl21_0;  yt1_0 = xl1_0 - xl20_0;

            xt1_1 = xl0_1 + xl21_1;  yt2_1 = xl1_1 + xl20_1;
            xt2_1 = xl0_1 - xl21_1;  yt1_1 = xl1_1 - xl20_1;

            x2[0] = y0r;             x2[1] = y0i;
            x2[2] = y4r;             x2[3] = y4i;

            /*---------------------------------------------------------*/
            /* Perform twiddle factor multiplies of three terms,top    */
            /* term does not have any multiplies. Note the twiddle     */
            /* factors for a normal FFT are C + j (-S). Since the      */
            /* factors that are stored are C + j S, this is            */
            /* corrected for in the multiplies.                        */
            /*                                                         */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)       */
            /* Perform the multiplies using 16 by 32 multiply macro    */
            /* defined. This treats the twiddle factor as 16 bits      */
            /* and incoming data as 32 bits.                           */
            /*---------------------------------------------------------*/

            x2[h2  ] = MPY16X32R(si10 , yt1_0) + MPY16X32R(co10 , xt1_0);
            x2[h2+1] = MPY16X32R(co10 , yt1_0) - MPY16X32R(si10 , xt1_0);

            x2[h2+2] = MPY16X32R(si11 , yt1_1) + MPY16X32R(co11 , xt1_1);
            x2[h2+3] = MPY16X32R(co11 , yt1_1) - MPY16X32R(si11 , xt1_1);

            x2[l1  ] = MPY16X32R(si20 , yt0_0) + MPY16X32R(co20 , xt0_0);
            x2[l1+1] = MPY16X32R(co20 , yt0_0) - MPY16X32R(si20 , xt0_0);

            x2[l1+2] = MPY16X32R(si21 , yt0_1) + MPY16X32R(co21 , xt0_1);
            x2[l1+3] = MPY16X32R(co21 , yt0_1) - MPY16X32R(si21 , xt0_1);

            x2[l2  ] = MPY16X32R(si30 , yt2_0) + MPY16X32R(co30 , xt2_0);
            x2[l2+1] = MPY16X32R(co30 , yt2_0) - MPY16X32R(si30 , xt2_0);

            x2[l2+2] = MPY16X32R(si31 , yt2_1) + MPY16X32R(co31 , xt2_1);
            x2[l2+3] = MPY16X32R(co31 , yt2_1) - MPY16X32R(si31 , xt2_1);
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints >> 1);

    if (radix == 2)
    {
        /*----------------------------------------------------------------*/
        /* The pointers are set at the following locations which are half */
        /* the offsets of a radix4 FFT.                                   */
        /*----------------------------------------------------------------*/

        y1 = y0 + (int) (npoints >> 2);
        y3 = y2 + (int) (npoints >> 2);
        l1 = norm + 1;
        j0 = 8;
        n0 = npoints >> 1;
    }
    else
    {
        y1 = y0 + (int) (npoints >> 1);
        y3 = y2 + (int) (npoints >> 1);
        l1 = norm + 2;
        j0 = 4;
        n0 = npoints >> 2;
    }

    /*--------------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4    */
    /* or a radix 2 style decomposition. It writes out at different       */
    /* locations though. It checks if either half the points, or a        */
    /* quarter of the complex points have been exhausted to jump to       */
    /* pervent double reversal.                                           */
    /*--------------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {
        /*----------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to "j"  */
        /* is either by 4, or 8.                                          */
        /*----------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*----------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations. These  */
        /* are transformed either as a radix4 or as a radix 2.            */
        /*----------------------------------------------------------------*/

        x_0 = x0[0]; x_1 = x0[1];
        x_2 = x0[2]; x_3 = x0[3];
        x_4 = x0[4]; x_5 = x0[5];
        x_6 = x0[6]; x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4; xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4; xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6; xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6; xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n10 = xl0_0 + xl1_1; n11 = xl1_0 - xl0_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n30 = xl0_0 - xl1_1; n31 = xl1_0 + xl0_1;

        if (radix == 2)
        {
           /*-------------------------------------------------------------*/
           /* Perform radix2 style decomposition.                         */
           /*-------------------------------------------------------------*/

           n00 = x_0 + x_2;     n01 = x_1 + x_3;
           n20 = x_0 - x_2;     n21 = x_1 - x_3;
           n10 = x_4 + x_6;     n11 = x_5 + x_7;
           n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        y0[2*h2] = n00;   y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;   y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;   y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;   y3[2*h2 + 1] = n31;

        /*----------------------------------------------------------------*/
        /* Read in ht enext eight inputs, and perform radix4 or radix2    */
        /* decomposition.                                                 */
        /*----------------------------------------------------------------*/

        x_8 = x2[0]; x_9 = x2[1];
        x_a = x2[2]; x_b = x2[3];
        x_c = x2[4]; x_d = x2[5];
        x_e = x2[6]; x_f = x2[7];
        x2 += 8;

        xh0_2 = x_8 + x_c; xh1_2  = x_9 + x_d;
        xl0_2 = x_8 - x_c; xl1_2  = x_9 - x_d;
        xh0_3 = x_a + x_e; xh1_3 = x_b + x_f;
        xl0_3 = x_a - x_e; xl1_3 = x_b - x_f;

        n02 = xh0_2 + xh0_3; n03 = xh1_2 + xh1_3;
        n12 = xl0_2 + xl1_3; n13 = xl1_2 - xl0_3;
        n22 = xh0_2 - xh0_3; n23 = xh1_2 - xh1_3;
        n32 = xl0_2 - xl1_3; n33 = xl1_2 + xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;     n03 = x_9 + x_b;
          n22 = x_8 - x_a;     n23 = x_9 - x_b;
          n12 = x_c + x_e;     n13 = x_d + x_f;
          n32 = x_c - x_e;     n33 = x_d - x_f;
        }

        /*-----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4]  */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]   */
        /*-----------------------------------------------------------------*/

        y0[2*h2+2] = n02;   y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;   y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;   y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;   y3[2*h2+3] = n33;

        j += j0;
        if (j == n0)
        {
          j  += n0;
          x0 += (int) npoints >> 1;
          x2 += (int) npoints >> 1;
        }
      }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/

fft32x32.c/     1066929505  0     0     0       48343     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Thu Sep  6 17:54:56 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/*==========================================================================*/
/*     TEXAS INSTRUMENTS, INC.                                              */
/*                                                                          */
/*     NAME                                                                 */
/*           DSP_fft32x32: Double Precision FFT                             */
/*                                                                          */
/*     USAGE                                                                */
/*           This routine is C-callable and can be called as:               */
/*                                                                          */
/*          void DSP_fft32x32(const int  * ptr_w, int  npoints,             */
/*                           int   * ptr_x, int  * ptr_y ) ;                */
/*                                                                          */
/*            ptr_w   =  input twiddle factors                              */
/*            npoints =  number of points                                   */
/*            ptr_x   =  transformed data reversed                          */
/*            ptr_y   =  linear transformed data                            */
/*                                                                          */
/*           (See the C compiler reference guide.)                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The following code performs a mixed radix FFT for "npoints" which   */
/*      is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  */
/*      transform and performs either a radix2 or radix4 transform on the   */
/*      last stage depending on "npoints". If "npoints" is a multiple of 4, */
/*      then this last stage is also a radix4 transform, otherwise it is a  */
/*      radix2 transform. This program is available as a C compilable file  */
/*      to automatically generate the twiddle factors "twiddle_split.c"     */
/*                                                                          */
/*      Generate special vector of twiddle factors                          */
/*                                                                          */
/*      for (j=1, k=0; j < npoints>>2; j = j <<2 )                          */
/*      {                                                                   */
/*          for (i=0; i < npoints>>2; i += j)                               */
/*          {                                                               */
/*              theta1 = 2*PI*i/npoints;                                    */
/*              x_t = M*cos(theta1);                                        */
/*              y_t = M*sin(theta1);                                        */
/*              ptr_w[k+1] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      */
/*              ptr_w[k+0] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      */
/*                                                                          */
/*              theta2 = 4*PI*i/npoints;                                    */
/*              x_t = M*cos(theta2);                                        */
/*              y_t = M*sin(theta2);                                        */
/*              ptr_w[k+3] = (int) x_t;                                     */
/*                                                                          */
/*              if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      */
/*              ptr_w[k+2] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      */
/*                                                                          */
/*              theta3 = 6*PI*i/npoints;                                    */
/*              x_t = M*cos(theta3);                                        */
/*              y_t = M*sin(theta3);                                        */
/*              ptr_w[k+5] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      */
/*              ptr_w[k+4] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      */
/*              k += 6;                                                     */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      This code works for  both "npoints" a multiple of 2 or 4.           */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices. The input, twiddle      */
/*      factors are in 32 bit precision. The 32 by 32 multiplies are        */
/*      done with a 1.5 bit loss in accuracy. This comes about because      */
/*      the contribution of the low sixteen bits to the 32 bit result       */
/*      is not computed. In addition the contribution of the low * high     */
/*      term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      */
/*      after rounding. To illustrate real part of complex multiply of:     */
/*      (X + jY) ( C + jS) =                                                */
/*                                                                          */
/*      MPYHIRC(si10 , yt1_0)  + MPYHIRC(co10 , xt1_0) +                    */
/*                       (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      */
/*                                              + 0x8000)  >> 16) << 1)     */
/*      where the functions MPYHIRC, MPYLUHS are as follows:                */
/*                                                                          */
/*  #define MPYHIRC(x,y) \                                                  */
/*  (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    */
/*   + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               */
/*                                                                          */
/*  #define MPYLUHS(x,y)   \                                                */
/*      ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      In the folllowing code since all data elements are 32 bits, add2    */
/*      sub2 are replaced with normal 32 bit add's and subtracts.           */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part of the         */
/*      multiply and the imaginary part of the multiply are performed       */
/*      as 16x32 multiplies using MPYLIR and MPYHIR                         */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      */
/*                                                                          */
/*      The actual twiddle factors for the FFT are cosine, - sine. The      */
/*      twiddle factors stored in the table are csine and sine, hence       */
/*      the sign of the "sine" term is comprehended during multipli-        */
/*      cation as shown above.                                              */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

#define MPYHIRC(x,y) \
(((int)((short)(x >> 16) * (unsigned short)(y & 0x0000FFFF) + 0x4000) >> 15)+ \
     ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))

#define MPYLUHS(x,y)   \
    ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )

void DSP_fft32x32(int * ptr_w, int npoints, int * ptr_x, int * ptr_y)
{
    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    int   xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    int   xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    int   xh0_1, xh1_1, xl0_1, xl1_1;
    int   x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l2_0, x_l2_1;
    int   xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    int   x_4, x_5, x_6, x_7, x_h2_0, x_h2_1;
    int   x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    int   si10, si20, si30, co10, co20, co30;
    int   *w;
    int   *x, *x2, *x0;
    int   *y0, *y1, *y2, *y3;
    int   n00, n10, n20, n30, n01, n11, n21, n31;
    int   n02, n12, n22, n32, n03, n13, n23, n33;
    int   n0, j0;
    int   radix;
    int   norm;
    int   m;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     = m & 1 ? 2 :  4;
    norm      = m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride    =   npoints;
    tw_offset =   0;
    fft_jmp   =   6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > radix)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         =  0;
        fft_jmp >>=  2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride >> 1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride >>=  2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount.                                                */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        _nassert(npoints >= 16);
        #pragma MUST_ITERATE(4, , 1);
        #endif

        for (i = 0; i < npoints; i += 4)
        {
            /*------------------------------------------------------------*/
            /*  Read the first three twiddle factor values. This loop co- */
            /*  mputes one radix 4 butterfly at a time.                   */
            /*------------------------------------------------------------*/

            co10 = w[j+1];            si10 = w[j+0];
            co20 = w[j+3];            si20 = w[j+2];
            co30 = w[j+5];            si30 = w[j+4];

            /*-----------------------------------------------------------*/
            /* Read in the data elements for the four inputs of radix4   */
            /* butterfly.                                                */
            /*-----------------------------------------------------------*/

            x_0    = x[0];            x_1    = x[1];
            x_l1_0 = x[l1  ];         x_l1_1 = x[l1+1];
            x_l2_0 = x[l2  ];         x_l2_1 = x[l2+1];
            x_h2_0 = x[h2  ];         x_h2_1 = x[h2+1];

            /*-----------------------------------------------------------*/
            /* Perform radix2 style DIF butterflies, for initial radix4  */
            /*-----------------------------------------------------------*/

            xh0_0    =   x_0        +       x_l1_0;
            xh1_0    =   x_1        +       x_l1_1;
            xl0_0    =   x_0        -       x_l1_0;
            xl1_0    =   x_1        -       x_l1_1;
            xh20_0   =   x_h2_0     +       x_l2_0;
            xh21_0   =   x_h2_1     +       x_l2_1;
            xl20_0   =   x_h2_0     -       x_l2_0;
            xl21_0   =   x_h2_1     -       x_l2_1;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 6, to reflect the fact that 6 half words   */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 2. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j    += 6;
            x    += 2;
            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* ---------------------------------------------------------*/

            x0[0] = xh0_0 + xh20_0;       x0[1] = xh1_0 + xh21_0;
            xt0_0 = xh0_0 - xh20_0;       yt0_0 = xh1_0 - xh21_0;
            xt1_0 = xl0_0 + xl21_0;       yt2_0 = xl1_0 + xl20_0;
            xt2_0 = xl0_0 - xl21_0;       yt1_0 = xl1_0 - xl20_0;

            /*-----------------------------------------------------------*/
            /* The following multiplies are close to a true 32 by 32     */
            /* multiply instruction.                                     */
            /* Perform twiddle factor multiplies of three terms,top      */
            /* term does not have any multiplies. Note the twiddle       */
            /* factors for a normal FFT are C + j (-S). Since the        */
            /* factors that are stored are C + j S, this is              */
            /* corrected for in the multiplies.                          */
            /*                                                           */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)         */
            /* There is a loss of 1.5 bits of accuracy. This arises be-  */
            /* cause the result of the low sixteen by sixteen bits is    */
            /* not computed and the multiply of the low by high is       */
            /* shifted by 16, and results in a loss of 1 bit.            */
            /* Multiplies are performed for all the three legs of the    */
            /* radix4 butterfly are performed. In addition note that     */
            /* themiddle two legs are swapped. This is based on work     */
            /* done by Panos Papamichalis, on obtaining bit reversed     */
            /* order from a radix 4 butterfly. This allows the last      */
            /* stage to be performed either as a radix4 or a radix2      */
            /* pass for this stage.                                      */
            /*-----------------------------------------------------------*/

            x2[h2  ] = MPYHIRC(si10 , yt1_0)  + MPYHIRC(co10 , xt1_0) +
                       (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)
                                              + 0x8000)  >> 16)    << 1);

            x2[h2+1] = MPYHIRC(co10 , yt1_0)   - MPYHIRC(si10 , xt1_0)  +
                       (((MPYLUHS(co10, yt1_0) - MPYLUHS(si10, xt1_0)
                                               + 0x8000)  >> 16)  << 1);

            x2[l1  ] = MPYHIRC(si20 , yt0_0)   + MPYHIRC(co20 , xt0_0) +
                       (((MPYLUHS(si20, yt0_0) + MPYLUHS(co20, xt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l1+1] = MPYHIRC(co20 , yt0_0)   - MPYHIRC(si20 , xt0_0) +
                       (((MPYLUHS(co20, yt0_0) - MPYLUHS(si20,  xt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2  ] = MPYHIRC(si30 , yt2_0)   + MPYHIRC(co30 , xt2_0) +
                       (((MPYLUHS(si30, yt2_0) + MPYLUHS(co30,  xt2_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2+1] = MPYHIRC(co30 , yt2_0)   - MPYHIRC(si30 , xt2_0) +
                       (((MPYLUHS(co30,yt2_0)  - MPYLUHS(si30,  xt2_0)
                                               + 0x8000) >> 16)   << 1);
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints>>1);

    if (radix == 2)
    {
        /*------------------------------------------------------------*/
        /* The pointers are set at the following locations which are  */
        /* half the offsets of a radix4 FFT.                          */
        /*------------------------------------------------------------*/

        y1  = y0 + (int) (npoints >> 2);
        y3  = y2 + (int) (npoints >> 2);
        l1  = norm + 1;
        j0  = 8;
        n0  = npoints >> 1;
    }
    else
    {
        y1  = y0 + (int) (npoints >> 1);
        y3  = y2 + (int) (npoints >> 1);
        l1  = norm + 2;
        j0  = 4;
        n0  = npoints >> 2;
    }

    /*-----------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4 */
    /* or a radix 2 style decomposition. It writes out at different    */
    /* locations though. It checks if either half the points, or a     */
    /* quarter of the complex points have been exhausted to jump to    */
    /* pervent double reversal.                                        */
    /*-----------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {
        /*-------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to   */
        /* "j" is either by 4, or 8.                                   */
        /*-------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*-------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations.     */
        /* These are transformed either as a radix4 or as a radix 2.   */
        /*-------------------------------------------------------------*/

        x_0 = x0[0];         x_1 = x0[1];
        x_2 = x0[2];         x_3 = x0[3];
        x_4 = x0[4];         x_5 = x0[5];
        x_6 = x0[6];         x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4; xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4; xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6; xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6; xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n10 = xl0_0 + xl1_1; n11 = xl1_0 - xl0_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n30 = xl0_0 - xl1_1; n31 = xl1_0 + xl0_1;

        if (radix == 2)
        {
             /*--------------------------------------------------------*/
             /* Perform radix2 style decomposition.                    */
             /*--------------------------------------------------------*/

             n00 = x_0 + x_2;     n01 = x_1 + x_3;
             n20 = x_0 - x_2;     n21 = x_1 - x_3;
             n10 = x_4 + x_6;     n11 = x_5 + x_7;
             n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        /*-------------------------------------------------------------*/
        /*  Store out the four outputs of 1 radix4 butterfly or 2      */
        /*  radix2 butterflies.                                        */
        /*-------------------------------------------------------------*/

        y0[2*h2] = n00;            y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;            y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;            y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;            y3[2*h2 + 1] = n31;

        /*-------------------------------------------------------------*/
        /* Read in the next set of inputs from pointer "x2". These will*/
        /* produce outputs that are contiguous to the previous outputs.*/
        /*-------------------------------------------------------------*/

        x_8 = x2[0];               x_9 = x2[1];
        x_a = x2[2];               x_b = x2[3];
        x_c = x2[4];               x_d = x2[5];
        x_e = x2[6];               x_f = x2[7];
        x2 += 8;

        /*-------------------------------------------------------------*/
        /* Perform radix4 style decompositions and overwrite results   */
        /* if it is dtermined that the radix to be used is radix 2.    */
        /*-------------------------------------------------------------*/

        xh0_2 = x_8 + x_c;         xh1_2  =  x_9    +  x_d;
        xl0_2 = x_8 - x_c;         xl1_2  =  x_9    -  x_d;
        xh0_3 = x_a + x_e;         xh1_3  =  x_b    +  x_f;
        xl0_3 = x_a - x_e;         xl1_3  =  x_b    -  x_f;

        n02 = xh0_2 + xh0_3;       n03    =  xh1_2  +  xh1_3;
        n12 = xl0_2 + xl1_3;       n13    =  xl1_2  -  xl0_3;
        n22 = xh0_2 - xh0_3;       n23    =  xh1_2  -  xh1_3;
        n32 = xl0_2 - xl1_3;       n33    =  xl1_2  +  xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;         n03 = x_9   +   x_b;
          n22 = x_8 - x_a;         n23 = x_9   -   x_b;
          n12 = x_c + x_e;         n13 = x_d   +   x_f;
          n32 = x_c - x_e;         n33 = x_d   -   x_f;
        }

        /*----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4] */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]  */
        /*----------------------------------------------------------------*/

        y0[2*h2+2] = n02;          y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;          y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;          y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;          y3[2*h2+3] = n33;

        /*---------------------------------------------------------------*/
        /* Increment j by "j0", if j is equal to n0, increment j by n0,  */
        /* that double reversal is avoided.                              */
        /*---------------------------------------------------------------*/

        j += j0;

        if (j == n0)
        {
            j  += n0;
            x0 += (int) npoints >> 1;
            x2 += (int) npoints >> 1;
        }
   }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/

fft32x32s.c/    1066929505  0     0     0       48370     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Sep  6 18:01:28 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/*==========================================================================*/
/*     TEXAS INSTRUMENTS, INC.                                              */
/*                                                                          */
/*     NAME                                                                 */
/*           fft32x32: Double Precision FFT, with scaling                   */
/*                                                                          */
/*     USAGE                                                                */
/*           This routine is C-callable and can be called as:               */
/*                                                                          */
/*          void fft32x32_cn(const int  * ptr_w, int  npoints,              */
/*                           int   * ptr_x, int  * ptr_y ) ;                */
/*                                                                          */
/*            ptr_w   =  input twiddle factors                              */
/*            npoints =  number of points                                   */
/*            ptr_x   =  transformed data reversed                          */
/*            ptr_y   =  linear transformed data                            */
/*                                                                          */
/*           (See the C compiler reference guide.)                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The following code performs a mixed radix FFT for "npoints" which   */
/*      is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  */
/*      transform and performs either a radix2 or radix4 transform on the   */
/*      last stage depending on "npoints". If "npoints" is a multiple of 4, */
/*      then this last stage is also a radix4 transform, otherwise it is a  */
/*      radix2 transform. This program is available as a C compilable file  */
/*      to automatically generate the twiddle factors "twiddle_split.c"     */
/*                                                                          */
/*      Generate special vector of twiddle factors                          */
/*                                                                          */
/*      for (j=1, k=0; j < npoints>>2; j = j <<2 )                          */
/*      {                                                                   */
/*          for (i=0; i < npoints>>2; i += j)                               */
/*          {                                                               */
/*              theta1 = 2*PI*i/npoints;                                    */
/*              x_t = M*cos(theta1);                                        */
/*              y_t = M*sin(theta1);                                        */
/*              ptr_w[k+1] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      */
/*              ptr_w[k+0] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      */
/*                                                                          */
/*              theta2 = 4*PI*i/npoints;                                    */
/*              x_t = M*cos(theta2);                                        */
/*              y_t = M*sin(theta2);                                        */
/*              ptr_w[k+3] = (int) x_t;                                     */
/*                                                                          */
/*              if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      */
/*              ptr_w[k+2] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      */
/*                                                                          */
/*              theta3 = 6*PI*i/npoints;                                    */
/*              x_t = M*cos(theta3);                                        */
/*              y_t = M*sin(theta3);                                        */
/*              ptr_w[k+5] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      */
/*              ptr_w[k+4] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      */
/*              k += 6;                                                     */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      This code works for  both "npoints" a multiple of 2 or 4.           */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices. The input, twiddle      */
/*      factors are in 32 bit precision. The 32 by 32 multiplies are        */
/*      done with a 1.5 bit loss in accuracy. This comes about because      */
/*      the contribution of the low sixteen bits to the 32 bit result       */
/*      is not computed. In addition the contribution of the low * high     */
/*      term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      */
/*      after rounding. To illustrate real part of complex multiply of:     */
/*      (X + jY) ( C + jS) =                                                */
/*                                                                          */
/*      MPYHIRC(si10 , yt1_0)  + MPYHIRC(co10 , xt1_0) +                    */
/*                       (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      */
/*                                              + 0x8000)  >> 16) << 1)     */
/*      where the functions MPYHIRC, MPYLUHS are as follows:                */
/*                                                                          */
/*  #define MPYHIRC(x,y) \                                                  */
/*  (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    */
/*   + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               */
/*                                                                          */
/*  #define MPYLUHS(x,y)   \                                                */
/*      ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      In the folllowing code since all data elements are 32 bits, add2    */
/*      sub2 are replaced with normal 32 bit add's and subtracts.           */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part of the         */
/*      multiply and the imaginary part of the multiply are performed       */
/*      as 16x32 multiplies using MPYLIR and MPYHIR                         */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      */
/*                                                                          */
/*      The actual twiddle factors for the FFT are cosine, - sine. The      */
/*      twiddle factors stored in the table are csine and sine, hence       */
/*      the sign of the "sine" term is comprehended during multipli-        */
/*      cation as shown above.                                              */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

#define MPYHIRC(x,y) \
(((int)((short)(x >> 16) * (unsigned short)(y & 0x0000FFFF) + 0x4000) >> 15)+ \
     ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))

#define MPYLUHS(x,y)   \
    ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )

void DSP_fft32x32s(int * ptr_w, int npoints, int * ptr_x, int * ptr_y)
{
    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    int   xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    int   xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    int   xh0_1, xh1_1, xl0_1, xl1_1;
    int   x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l2_0, x_l2_1;
    int   xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    int   x_4, x_5, x_6, x_7, x_h2_0, x_h2_1;
    int   x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    int   si10, si20, si30, co10, co20, co30;
    int   *w;
    int   *x, *x2, *x0;
    int   *y0, *y1, *y2, *y3;
    int   n00, n10, n20, n30, n01, n11, n21, n31;
    int   n02, n12, n22, n32, n03, n13, n23, n33;
    int   n0, j0;
    int   radix;
    int   norm;
    int   m;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     = m & 1 ? 2 :  4;
    norm      = m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride    =   npoints;
    tw_offset =   0;
    fft_jmp   =   6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > radix)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         =  0;
        fft_jmp >>=  2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride >> 1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride >>=  2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount.                                                */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        _nassert(npoints >= 16);
        #pragma MUST_ITERATE(4, , 1);
        #endif

        for (i = 0; i < npoints; i += 4)
        {
            /*------------------------------------------------------------*/
            /*  Read the first three twiddle factor values. This loop co- */
            /*  mputes one radix 4 butterfly at a time.                   */
            /*------------------------------------------------------------*/

            co10 = w[j+1];            si10 = w[j+0];
            co20 = w[j+3];            si20 = w[j+2];
            co30 = w[j+5];            si30 = w[j+4];

            /*-----------------------------------------------------------*/
            /* Read in the data elements for the four inputs of radix4   */
            /* butterfly.                                                */
            /*-----------------------------------------------------------*/

            x_0    = x[0];            x_1    = x[1];
            x_l1_0 = x[l1  ];         x_l1_1 = x[l1+1];
            x_l2_0 = x[l2  ];         x_l2_1 = x[l2+1];
            x_h2_0 = x[h2  ];         x_h2_1 = x[h2+1];

            /*-----------------------------------------------------------*/
            /* Perform radix2 style DIF butterflies, for initial radix4  */
            /*-----------------------------------------------------------*/

            xh0_0    =   x_0        +       x_l1_0;
            xh1_0    =   x_1        +       x_l1_1;
            xl0_0    =   x_0        -       x_l1_0;
            xl1_0    =   x_1        -       x_l1_1;
            xh20_0   =   x_h2_0     +       x_l2_0;
            xh21_0   =   x_h2_1     +       x_l2_1;
            xl20_0   =   x_h2_0     -       x_l2_0;
            xl21_0   =   x_h2_1     -       x_l2_1;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 6, to reflect the fact that 6 half words   */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 2. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j    += 6;
            x    += 2;
            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* ---------------------------------------------------------*/

            x0[0] = (xh0_0 + xh20_0) >> 1;
            x0[1] = (xh1_0 + xh21_0) >> 1;

            xt0_0 = xh0_0 - xh20_0;        yt0_0 = xh1_0 - xh21_0;
            xt1_0 = xl0_0 + xl21_0;        yt2_0 = xl1_0 + xl20_0;
            xt2_0 = xl0_0 - xl21_0;        yt1_0 = xl1_0 - xl20_0;

            /*-----------------------------------------------------------*/
            /* The following multiplies are close to a true 32 by 32     */
            /* multiply instruction.                                     */
            /* Perform twiddle factor multiplies of three terms,top      */
            /* term does not have any multiplies. Note the twiddle       */
            /* factors for a normal FFT are C + j (-S). Since the        */
            /* factors that are stored are C + j S, this is              */
            /* corrected for in the multiplies.                          */
            /*                                                           */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)         */
            /* There is a loss of 1.5 bits of accuracy. This arises be-  */
            /* cause the result of the low sixteen by sixteen bits is    */
            /* not computed and the multiply of the low by high is       */
            /* shifted by 16, and results in a loss of 1 bit.            */
            /* Multiplies are performed for all the three legs of the    */
            /* radix4 butterfly are performed. In addition note that     */
            /* themiddle two legs are swapped. This is based on work     */
            /* done by Panos Papamichalis, on obtaining bit reversed     */
            /* order from a radix 4 butterfly. This allows the last      */
            /* stage to be performed either as a radix4 or a radix2      */
            /* pass for this stage.                                      */
            /*-----------------------------------------------------------*/

            x2[h2  ] = MPYHIRC(si10 , yt1_0)  + MPYHIRC(co10 , xt1_0) +
                       (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)
                                              + 0x8000)  >> 16)    << 1);

            x2[h2+1] = MPYHIRC(co10 , yt1_0)   - MPYHIRC(si10 , xt1_0)  +
                       (((MPYLUHS(co10, yt1_0) - MPYLUHS(si10, xt1_0)
                                               + 0x8000)  >> 16)  << 1);

            x2[l1  ] = MPYHIRC(si20 , yt0_0)   + MPYHIRC(co20 , xt0_0) +
                       (((MPYLUHS(si20, yt0_0) + MPYLUHS(co20, xt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l1+1] = MPYHIRC(co20 , yt0_0)   - MPYHIRC(si20 , xt0_0) +
                       (((MPYLUHS(co20, yt0_0) - MPYLUHS(si20,  xt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2  ] = MPYHIRC(si30 , yt2_0)   + MPYHIRC(co30 , xt2_0) +
                       (((MPYLUHS(si30, yt2_0) + MPYLUHS(co30,  xt2_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2+1] = MPYHIRC(co30 , yt2_0)   - MPYHIRC(si30 , xt2_0) +
                       (((MPYLUHS(co30,yt2_0)  - MPYLUHS(si30,  xt2_0)
                                               + 0x8000) >> 16)   << 1);
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints>>1);

    if (radix == 2)
    {
        /*------------------------------------------------------------*/
        /* The pointers are set at the following locations which are  */
        /* half the offsets of a radix4 FFT.                          */
        /*------------------------------------------------------------*/

        y1  = y0 + (int) (npoints >> 2);
        y3  = y2 + (int) (npoints >> 2);
        l1  = norm + 1;
        j0  = 8;
        n0  = npoints >> 1;
    }
    else
    {
        y1  = y0 + (int) (npoints >> 1);
        y3  = y2 + (int) (npoints >> 1);
        l1  = norm + 2;
        j0  = 4;
        n0  = npoints >> 2;
    }

    /*-----------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4 */
    /* or a radix 2 style decomposition. It writes out at different    */
    /* locations though. It checks if either half the points, or a     */
    /* quarter of the complex points have been exhausted to jump to    */
    /* pervent double reversal.                                        */
    /*-----------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {
        /*-------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to   */
        /* "j" is either by 4, or 8.                                   */
        /*-------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*-------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations.     */
        /* These are transformed either as a radix4 or as a radix 2.   */
        /*-------------------------------------------------------------*/

        x_0 = x0[0];         x_1 = x0[1];
        x_2 = x0[2];         x_3 = x0[3];
        x_4 = x0[4];         x_5 = x0[5];
        x_6 = x0[6];         x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4; xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4; xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6; xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6; xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n10 = xl0_0 + xl1_1; n11 = xl1_0 - xl0_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n30 = xl0_0 - xl1_1; n31 = xl1_0 + xl0_1;

        if (radix == 2)
        {
             /*--------------------------------------------------------*/
             /* Perform radix2 style decomposition.                    */
             /*--------------------------------------------------------*/

             n00 = x_0 + x_2;     n01 = x_1 + x_3;
             n20 = x_0 - x_2;     n21 = x_1 - x_3;
             n10 = x_4 + x_6;     n11 = x_5 + x_7;
             n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        /*-------------------------------------------------------------*/
        /*  Store out the four outputs of 1 radix4 butterfly or 2      */
        /*  radix2 butterflies.                                        */
        /*-------------------------------------------------------------*/

        y0[2*h2] = n00;            y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;            y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;            y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;            y3[2*h2 + 1] = n31;

        /*-------------------------------------------------------------*/
        /* Read in the next set of inputs from pointer "x2". These will*/
        /* produce outputs that are contiguous to the previous outputs.*/
        /*-------------------------------------------------------------*/

        x_8 = x2[0];               x_9 = x2[1];
        x_a = x2[2];               x_b = x2[3];
        x_c = x2[4];               x_d = x2[5];
        x_e = x2[6];               x_f = x2[7];
        x2 += 8;

        /*-------------------------------------------------------------*/
        /* Perform radix4 style decompositions and overwrite results   */
        /* if it is dtermined that the radix to be used is radix 2.    */
        /*-------------------------------------------------------------*/

        xh0_2 = x_8 + x_c;         xh1_2  =  x_9    +  x_d;
        xl0_2 = x_8 - x_c;         xl1_2  =  x_9    -  x_d;
        xh0_3 = x_a + x_e;         xh1_3  =  x_b    +  x_f;
        xl0_3 = x_a - x_e;         xl1_3  =  x_b    -  x_f;

        n02 = xh0_2 + xh0_3;       n03    =  xh1_2  +  xh1_3;
        n12 = xl0_2 + xl1_3;       n13    =  xl1_2  -  xl0_3;
        n22 = xh0_2 - xh0_3;       n23    =  xh1_2  -  xh1_3;
        n32 = xl0_2 - xl1_3;       n33    =  xl1_2  +  xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;         n03 = x_9   +   x_b;
          n22 = x_8 - x_a;         n23 = x_9   -   x_b;
          n12 = x_c + x_e;         n13 = x_d   +   x_f;
          n32 = x_c - x_e;         n33 = x_d   -   x_f;
        }

        /*----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4] */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]  */
        /*----------------------------------------------------------------*/

        y0[2*h2+2] = n02;          y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;          y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;          y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;          y3[2*h2+3] = n33;

        /*---------------------------------------------------------------*/
        /* Increment j by "j0", if j is equal to n0, increment j by n0,  */
        /* that double reversal is avoided.                              */
        /*---------------------------------------------------------------*/

        j += j0;

        if (j == n0)
        {
            j  += n0;
            x0 += (int) npoints >> 1;
            x2 += (int) npoints >> 1;
        }
   }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/
fir_cplx.c/     1066929506  0     0     0       5777      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Thu Jan 10 19:02:53 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*  NAME                                                                   */
/*      DSP_fir_cplx -- Natural C code for Complex Filter.                 */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      31-Oct-2000                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void DSP_fir_cplx                                                  */
/*      (                                                                  */
/*          const short *restrict x,                                       */
/*          const short *restrict h,                                       */
/*          short       *restrict r,                                       */
/*          short                 nh,                                      */
/*          short                 nr                                       */
/*     )                                                                   */
/*                                                                         */
/*     x[2*(nr+nh-1)] : Complex input data. x must point to x[2*(nh-1)].   */
/*     h[2*nh]        : Complex coefficients (in normal order).            */
/*     r[2*nr]        : Complex output data.                               */
/*     nh             : Number of complex coefficients.                    */
/*     nr             : Number of complex output samples.                  */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      This complex FIR computes nr complex output samples using nh       */
/*      complex coefficients. It operates on 16-bit data with a 32-bit     */
/*      accumulate. Each array consists of an even and odd term with even  */
/*      terms representing the real part of the element and the odd terms  */
/*      the imaginary part. The pointer to input array x must point to the */
/*      (nh)th complex sample, i.e. element 2*(nh-1), upon entry to the    */
/*      function. The coefficients are expected in normal order.           */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void DSP_fir_cplx
(
    const short *restrict x,
    const short *restrict h,
    short       *restrict r,
    short nh,
    short nr
)
{
    int i,    j;
    int imag, real;


    for (i = 0; i < 2*nr; i += 2)
    {
        imag = 0;
        real = 0;
        for (j = 0; j < 2*nh; j += 2)
        {
            real += h[j+0] * x[i-j+0] - h[j+1] * x[i-j+1];
            imag += h[j+1] * x[i-j+0] + h[j+0] * x[i-j+1];
        }
        r[i  ] = (real >> 15);
        r[i+1] = (imag >> 15);
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fir_cplx.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

fir_gen.c/      1066929506  0     0     0       5671      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Thu Oct  3 11:36:14 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      DSP_fir_gen: FIR Filter                                            */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      28-Jun-2000                                                        */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSP_fir_gen                                                    */
/*      (                                                                   */
/*          const short *restrict x,  // Input ('nr + nh - 1' samples) //   */
/*          const short *restrict h,  // Filter coefficients (nh taps) //   */
/*          short       *restrict r,  // Output array ('nr' samples)   //   */
/*          int                   nh, // Length of filter (nh >= 5)    //   */
/*          int                   nr  // Length of output (nr >= 1)    //   */
/*      );                                                                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Computes a real FIR filter (direct-form) using coefficients         */
/*      stored in vector h. The real data input is stored in vector x.      */
/*      The filter output result is stored in vector r. This FIR            */
/*      assumes the number of filter coefficients is greater than or        */
/*      equal to 5. It operates on 16-bit data with a 32-bit                */
/*      accumulate. This routine has no memory hits regardless of where     */
/*      x, h, and r arrays are located in memory. The filter is nr          */
/*      output samples and nh coefficients. The assembly routine            */
/*      performs 4 output samples at a time.                                */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_fir_gen
(
    const short *restrict x,  /* Input array [nr+nh-1 elements] */
    const short *restrict h,  /* Coeff array [nh elements]      */
    short       *restrict r,  /* Output array [nr elements]     */
    int nh,                   /* Number of coefficients.        */
    int nr                    /* Number of output samples.      */
)
{
    int i, j, sum;

    for (j = 0; j < nr; j++)
    {
        sum = 0;
        for (i = 0; i < nh; i++)
            sum += x[i + j] * h[i];
        r[j] = sum >> 15;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fir_gen.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

fir_r4.c/       1066929506  0     0     0       5761      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Wed Oct  4 17:44:01 2000 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_fir_r4: FIR Filter (radix 4)                                    */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      04-Oct-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSP_fir_r4                                                     */
/*      (                                                                   */
/*          const short *restrict x,  // Input array [nr+nh-1 elements] //  */
/*          const short *restrict h,  // Coeff array [nh elements]      //  */
/*          short       *restrict r,  // Output array [nr elements]     //  */
/*          int nh,                   // Number of coefficients.        //  */
/*          int nr                    // Number of output samples.      //  */
/*      )                                                                   */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Computes a real FIR filter (direct-form) using coefficients         */
/*      stored in vector h.  The real data input is stored in vector x.     */
/*      The filter output result is stored in vector r.  Input data and     */
/*      filter taps are 16-bit, with intermediate values kept at 32-bit     */
/*      precision.  Filter taps are expected in Q15 format.                 */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      n/a                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_fir_r4
(
    const short *restrict x,  /* Input array [nr+nh-1 elements] */
    const short *restrict h,  /* Coeff array [nh elements]      */
    short       *restrict r,  /* Output array [nr elements]     */
    int nh,                   /* Number of coefficients.        */
    int nr                    /* Number of output samples.      */
)
{
    int i, j, sum;

    for (j = 0; j < nr; j++)
    {
        sum = 0;

        for (i = 0; i < nh; i++)
            sum += x[i + j] * h[i];
        r[j] = sum >> 15;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fir_r4.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

fir_r8.c/       1066929506  0     0     0       7870      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Thu Mar  8 18:26:11 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_fir_r8: FIR Filter (radix 8)                                    */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      04-Oct-2000                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSP_fir_r8                                                     */
/*      (                                                                   */
/*          const short *restrict x,  // Input array [nr+nh-1 elements] //  */
/*          const short *restrict h,  // Coeff array [nh elements]      //  */
/*          short       *restrict r,  // Output array [nr elements]     //  */
/*          short nh,                 // Number of coefficients.        //  */
/*          short nr                  // Number of output samples.      //  */
/*      )                                                                   */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Computes a real FIR filter (direct-form) using coefficients         */
/*      stored in vector h.  The real data input is stored in vector x.     */
/*      The filter output result is stored in vector r.  Input data and     */
/*      filter taps are 16-bit, with intermediate values kept at 32-bit     */
/*      precision.  Filter taps are expected in Q15 format.                 */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      n/a                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*      n/a                                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_fir_r8
(
    const short *restrict x,  /* Input array [nr+nh-1 elements] */
    const short *restrict h,  /* Coeff array [nh elements]      */
    short       *restrict r,  /* Output array [nr elements]     */
    short nh,                 /* Number of coefficients.        */
    short nr                  /* Number of output samples.      */
)
{
    int i, j, sum;

     /*-------------------------------------------------------------------*/
     /* The following assumptions are made if NOASSUME is not defined     */
     /* It is assumed that the number of output samples >= 2. It is also  */
     /* assumed that the number of output samples to be computed is a     */
     /* multiple of 2. In addition it is assumed, that the number of      */
     /* filter taps is >= 4, and a multiple of 4.                         */
     /*-------------------------------------------------------------------*/

     #ifndef NOASSUME
    _nassert(nr >= 2);
    _nassert(nr % 2 == 0);
    _nassert(nh >= 4);
    _nassert(nh % 4 == 0);
    #pragma MUST_ITERATE(4,,4);
    #endif

    for (j = 0; j < nr; j++)
    {

        /*----------------------------------------------------------------*/
        /* Initizlize accumulator for FIR sum to be zero.                 */
        /*----------------------------------------------------------------*/

        sum = 0;

        /*----------------------------------------------------------------*/
        /* The following assumptions are made if noassume is defined.     */
        /* It is assumed that the input, filter and output pointers       */
        /* are dword aligned. In addition it is assumed that the #        */
        /* of filter taps is at least 8, or a multiple of 8.              */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)x % 8 == 0);
        _nassert((int)h % 8 == 0);
        _nassert((int)r % 8 == 0);
        #pragma MUST_ITERATE(8,,8);
        #endif

        /*---------------------------------------------------------------*/
        /* Compute FIR as sum of products.                               */
        /*---------------------------------------------------------------*/

        for (i = 0; i < nh; i++)
        {
            sum += x[i + j] * h[i];
        }

        /*---------------------------------------------------------------*/
        /* Shift out FIR sum and store out.                              */
        /*---------------------------------------------------------------*/

        r[j] = sum >> 15;
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fir_r8.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
fir_sym.c/      1066929506  0     0     0       7167      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Tue Mar 12 01:06:04 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_fir_sym -- Symmetric FIR                                        */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      11-Mar-2002                                                         */
/*                                                                          */
/*                                                                          */
/*  USAGE                                                                   */
/*      This function is C callable, and may be called as follows:          */
/*                                                                          */
/*      void DSP_fir_sym                                                    */
/*      (                                                                   */
/*          const short * x,      // Input samples                   //     */
/*          const short * h ,     // Filter taps                     //     */
/*          short * restrict r,   // Output samples                  //     */
/*          int nh,               // Number of symmetric filter taps //     */
/*          int nr,               // Number of output samples        //     */
/*          int s                 // Final output shift.             //     */
/*      );                                                                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This function applies a symmetric filter to the input samples.      */
/*      The filter tap array h[] provides 'nh + 1' total filter taps.       */
/*      The filter tap at h[nh] forms the center point of the filter.       */
/*      The taps at h[nh - 1] through h[0] form a symmetric filter          */
/*      about this central tap.  The effective filter length is thus        */
/*      2*nh + 1 taps.                                                      */
/*                                                                          */
/*      The filter is performed on 16-bit data with 16-bit coefficients,    */
/*      accumulating intermediate results to 40-bit precision.  The         */
/*      accumulator is rounded and truncated according to the value         */
/*      provided in 's'.  This allows a variety of Q-points to be used.     */
/*                                                                          */
/*      Note that samples are added together before multiplication, and     */
/*      so overflow *may* result for large-scale values, despite the        */
/*      40-bit accumulation.                                                */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_fir_sym
(
    const short * x,      /* Input samples                   */
    const short * h ,     /* Filter taps                     */
    short * restrict r,   /* Output samples                  */
    int nh,               /* Number of symmetric filter taps */
    int nr,               /* Number of output samples        */
    int s                 /* Final output shift.             */
)
{
    int  i, j;
    long y0, round = (long) 1 << (s - 1);

    #ifndef  NOASSUME
    _nassert((int)(x)%8 == 0);
    _nassert((int)(h)%8 == 0);
    _nassert(nh >= 8);
    _nassert((int)(nh)%8 == 0);
    #endif

    /* -------------------------------------------------------------------- */
    /*  The outer loop iterates once for each output sample.                */
    /* -------------------------------------------------------------------- */
#pragma UNROLL(2);
    for (j = 0; j < nr; j++)
    {
        y0 = round;

        /* ---------------------------------------------------------------- */
        /*  The inner loop calculates the filter for an individual sample.  */
        /* ---------------------------------------------------------------- */
#pragma UNROLL(4);
        for (i = 0; i < nh; i++)
            y0 += ((short) (x[j + i] + x[j + 2 * nh - i])) * h[i];

        y0 += x[j + nh] * h[nh];

        r[j] = (int) (y0 >> s);
    }
}

/* ======================================================================== */
/*  End of file:  dsp_fir_sym.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

firlms2.c/      1066929506  0     0     0       8078      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Wed Mar 13 23:55:50 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  NAME                                                                    */
/*      DSP_firlms2 -- Least Mean Square Adaptive Filter                    */
/*                 Natural C Implementation                                 */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      13-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*          long DSP_firlms2                                                */
/*          (                                                               */
/*              short       *restrict h,  // Filter Coefficients            */
/*              const short *restrict x,  // Input Data                     */
/*              short                 b,  // Error from previous FIR        */
/*              int                   nh, // Number of Coefficients         */
/*          )                                                               */
/*                                                                          */
/*      The DSP_firlms2 routine accepts a list of 'nh' input data and 'nh'  */
/*      adaptive filter coefficients and updates the coefficients by        */
/*      adding weighted error times the inputs to the original              */
/*      coefficients. This assumes single sample input followed by the      */
/*      last nh-1 inputs and nh coefficients.                               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The algorithm is simple and is implemented as follows:              */
/*                                                                          */
/*          long DSP_firlms2                                                */
/*          (                                                               */
/*              short       *restrict h,  // Filter Coefficients            */
/*              const short *restrict x,  // Input Data                     */
/*              short                 b,  // Error from previous FIR        */
/*              int                   nh, // Number of Coefficients         */
/*          )                                                               */
/*                                                                          */
/*          {                                                               */
/*              int  i;                                                     */
/*              long r=0;                                                   */
/*                                                                          */
/*              for(i = 0; i < nh; i++)                                     */
/*              {                                                           */
/*                * Update the filter coefficients *                        */
/*                                                                          */
/*                  h[i] += (x[i] * b) >> 15;                               */
/*                                                                          */
/*                * Calculate the filter output    *                        */
/*                                                                          */
/*                  r    += x[i + 1] * h[i];                                */
/*              }                                                           */
/*              return r;                                                   */
/*          }                                                               */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      - Assumes 16-bit input data, error and filter coefficients.         */
/*      - nh > = 4 and is a multiple of 4                                   */
/*                                                                          */
/*  SOURCE                                                                  */
/*                                                                          */
/*      DSPLIB                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

long DSP_firlms2
(
    short *restrict h,         // h[nh] = Coefficient Array
    const short *restrict x,   // x[nh] = Input Array
    short b,                   // b = Error from Previous FIR
    int nh                     // nh = Number of Coefficients
)

{

    int       i;
    long  r = 0; // r is output of the filter

    for (i = 0; i < nh; i++)
    {
        h[i] += (x[i] * b) >> 15;
        r    += x[i+1] * h[i];
    }

    return r;
}

/* ======================================================================== */
/*  End of file:  dsp_firlms2.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
fltoq15.c/      1066929506  0     0     0       6393      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Mon Jan 21 21:11:30 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*    TEXAS INSTRUMENTS, INC.                                              */
/*                                                                         */
/*    NAME                                                                 */
/*          DSP_fltoq15                                                    */
/*S                                                                        */
/*                                                                         */
/*    REVISION DATE                                                        */
/*        27-Jul-2001                                                      */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void DSP_fltoq15(float x[], short r[], short nx)                   */
/*                                                                         */
/*      x[nx] : Pointer to values of type float                            */
/*      r[nx] : Contains Q15 values from x[nx]                             */
/*      nx    : Number of elements in arrays                               */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      Convert the IEEE floating point numbers stored in vector x[] into  */
/*      Q.15 format numbers stored in vector r[]. Results are truncated    */
/*      towards zero. Values that exceed the size limit will be saturated  */
/*      to 0x7fff if value is positive and 0x8000 if value is negative.    */
/*      All values too small to be correctly represented will be truncated */
/*      to 0.                                                              */
/*                                                                         */
/*      The 16-bit Q.15 format is defined as follows:                      */
/*                                                                         */
/*          1 11111                                                        */
/*          5 432109876543210                                              */
/*          S.XXXXXXXXXXXXXXX                                              */
/*                                                                         */
/*          range: 1.000000000000000 = -1.0               <-> -32768       */
/*                 0.111111111111111 =  0.999969482421875 <->  32767       */
/*                                                                         */
/*      IEEE floating point format is defined as follows:                  */
/*                                                                         */
/*          31 30....23  22.....0                                          */
/*           S EXPONENT  MANTISSA                                          */
/*                                                                         */
/*      The value is obtained as: (-1)^S * 1.MANTISSA * 2^(EXPONENT-127)   */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

#include <math.h>

void DSP_fltoq15(float x[], short r[], short nx)
{
    int i, a;

    for(i = 0; i < nx; i++)
    {
        /* results in saturated integer if overflow */
        a = 32768 * x[i];

        /* saturate to 16-bit */
        if (a>32767)  a =  32767;
        if (a<-32768) a = -32768;

        r[i] = (short) a;
    }
}

/* ======================================================================= */
/*   End of file:  dsp_fltoq15.c                                           */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

ifft16x32.c/    1066929506  0     0     0       49380     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Thu Sep  6 18:05:14 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/*==========================================================================*/
/*     TEXAS INSTRUMENTS, INC.                                              */
/*                                                                          */
/*     NAME                                                                 */
/*           DSP_ifft16x32                                                  */
/*                                                                          */
/*     USAGE                                                                */
/*           This routine is C-callable and can be called as:               */
/*                                                                          */
/*          void DSP_ifft16x32(const short * ptr_w, int  npoints,           */
/*                           int   * ptr_x, int  * ptr_y ) ;                */
/*                                                                          */
/*            ptr_w   =  input twiddle factors                              */
/*            npoints =  number of points                                   */
/*            ptr_x   =  transformed data reversed                          */
/*            ptr_y   =  linear transformed data                            */
/*                                                                          */
/*           (See the C compiler reference guide.)                          */
/*                                                                          */
/*      In reality one can re-use fft16x32 to perform IFFT, by first        */
/*      conjugating the input, performing the FFT, conjugating again.       */
/*      This allows fft16x32 to perform the IFFT as well. However if        */
/*      the double conjugation needs to be avoided then this routine        */
/*      uses the same twiddle factors as the FFT and performs an IFFT.      */
/*      The change in the sign of the twiddle factors is adjusted for       */
/*      software. Hence this routine uses the same twiddle factors as       */
/*      the FFT routine.                                                    */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The following code performs a mixed radix IFFT for "npoints" which  */
/*      is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  */
/*      transform and performs either a radix2 or radix4 transform on the   */
/*      last stage depending on "npoints". If "npoints" is a multiple of 4, */
/*      then this last stage is also a radix4 transform, otherwise it is a  */
/*      radix2 transform. This program is available as a C compilable file  */
/*      to automatically generate the twiddle factors "twiddle_split.c"     */
/*                                                                          */
/*        int i, j, k, n = N;                                               */
/*        double theta1, theta2, theta3, x_t, y_t;                          */
/*        const double M = 32768.0, PI = 3.141592654;                       */
/*                                                                          */
/*        for (j=1, k=0; j < n>>2; j = j<<2)                                */
/*        {                                                                 */
/*            for (i=0; i < n>>2; i += j<<1)                                */
/*            {                                                             */
/*                theta1 = 2*PI*i/n;                                        */
/*                x_t = M*cos(theta1);                                      */
/*                y_t = M*sin(theta1);                                      */
/*                w[k+1] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+1] = 0x7fff;                            */
/*                w[k+0] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+0] = 0x7fff;                            */
/*                                                                          */
/*                theta1 = 2*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta1);                                      */
/*                y_t = M*sin(theta1);                                      */
/*                w[k+7] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+3] = 0x7fff;                            */
/*                w[k+6] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+2] = 0x7fff;                            */
/*                                                                          */
/*                theta2 = 4*PI*i/n;                                        */
/*                x_t = M*cos(theta2);                                      */
/*                y_t = M*sin(theta2);                                      */
/*                w[k+3] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+5] = 0x7fff;                            */
/*                w[k+2] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+4] = 0x7fff;                            */
/*                                                                          */
/*                theta2 = 4*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta2);                                      */
/*                y_t = M*sin(theta2);                                      */
/*                w[k+9] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+7] = 0x7fff;                            */
/*                w[k+8] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+6] = 0x7fff;                            */
/*                                                                          */
/*                theta3 = 6*PI*i/n;                                        */
/*                x_t = M*cos(theta3);                                      */
/*                y_t = M*sin(theta3);                                      */
/*                w[k+5] = (short) x_t;                                     */
/*                if (x_t >= M) w[k+9] = 0x7fff;                            */
/*                w[k+4] = (short) y_t;                                     */
/*                if (y_t >= M) w[k+8] = 0x7fff;                            */
/*                                                                          */
/*                theta3 = 6*PI*(i+j)/n;                                    */
/*                x_t = M*cos(theta3);                                      */
/*                y_t = M*sin(theta3);                                      */
/*                w[k+11] = (short) x_t;                                    */
/*                if (x_t >= M) w[k+11] = 0x7fff;                           */
/*                w[k+10] = (short) y_t;                                    */
/*                if (y_t >= M) w[k+10] = 0x7fff;                           */
/*                                                                          */
/*                k += 12;                                                  */
/*            }                                                             */
/*        }                                                                 */
/*        w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          */
/*        w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      This code works for  both "npoints" a multiple of 2 or 4.           */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*                                                                          */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices.                         */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF IFFT. It accepts the inputs in normal order and   */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part of the         */
/*      multiply and the imaginary part of the multiply are performed       */
/*      as 16x32 multiplies using MPYLIR and MPYHIR                         */
/*                                                                          */
/*      (X + jY) ( C + j S) = (XC - YS) + j (YC + XS).                      */
/*                                                                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

#include <stdio.h>
#include <stdlib.h>

/* ======================================================================== */
/*  Perform a signed 16-bit by signed 32-bit multiply, rounding and         */
/*  shifting away the lower 15 bits.                                        */
/* ======================================================================== */

#define MPY16X32R(x,y) \
    (((int)((short)(x) * (unsigned short)(y) + 0x4000) >> 15) + \
     ((int)((short)(x) * (short)((y) >> 16)) << 1))

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

/*==========================================================================*/
/* DSP_ifft16x32  - bevavioural code/ natural c                             */
/*==========================================================================*/

void DSP_ifft16x32(const short * ptr_w, int npoints, int * ptr_x, int * ptr_y)
{
    int i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    int xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    int xt0_1, yt0_1, xt1_1, yt1_1, xt2_1, yt2_1;
    int xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    int xh0_1, xh1_1, xh20_1, xh21_1, xl0_1, xl1_1, xl20_1, xl21_1;
    int x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l1_2, x_l1_3, x_l2_0, x_l2_1;
    int xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    int x_4, x_5, x_6, x_7, x_l2_2, x_l2_3, x_h2_0, x_h2_1, x_h2_2, x_h2_3;
    int x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    short si10, si20, si30, co10, co20, co30;
    short si11, si21, si31, co11, co21, co31;
    const short *w;
    int *x, *x2, *x0;
    int * y0, * y1, * y2, *y3;
    int n00, n10, n20, n30, n01, n11, n21, n31;
    int n02, n12, n22, n32, n03, n13, n23, n33;
    int n0, j0;
    int radix, m;
    int y0r, y0i,  y4r, y4i;
    int norm;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     = m & 1 ? 2 :  4;
    norm      = m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride     =   npoints;
    tw_offset  =   0;
    fft_jmp    =   6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > 4)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         = 0;
        fft_jmp >>= 2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride >> 1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride  >>= 2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount. In addition the following code is unrolled to  */
        /* perform "2" radix4 butterflies in parallel.                    */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        #pragma MUST_ITERATE(1, , 1);
        #endif

        for (i = 0; i < (npoints >> 3); i ++)
        {

            /*------------------------------------------------------------*/
            /* Read the first 12 twiddle factors, six of which are used   */
            /* for one radix 4 butterfly and six of which are used for    */
            /* next one.                                                  */
            /*------------------------------------------------------------*/

            co10 = w[j+1];    si10 = w[j+0];
            co20 = w[j+3];    si20 = w[j+2];
            co30 = w[j+5];    si30 = w[j+4];
            co11 = w[j+7];    si11 = w[j+6];
            co21 = w[j+9];    si21 = w[j+8];
            co31 = w[j+11];   si31 = w[j+10];

            /*------------------------------------------------------------*/
            /* Read in the first complex input for the butterflies.       */
            /* 1st complex input to 1st butterfly: x[0] + jx[1]           */
            /* 1st complex input to 2nd butterfly: x[2] + jx[3]           */
            /*------------------------------------------------------------*/

            x_0 = x[0];       x_1 = x[1];
            x_2 = x[2];       x_3 = x[3];

            /*------------------------------------------------------------*/
            /* Read in the complex inputs for the butterflies. Each of the*/
            /* successive complex inputs of the butterfly are seperated   */
            /* by a fixed amount known as stride. The stride starts out   */
            /* at N/4, and quarters with every stage.                     */
            /*------------------------------------------------------------*/

            x_l1_0 = x[l1  ]; x_l1_1 = x[l1+1];
            x_l1_2 = x[l1+2]; x_l1_3 = x[l1+3];

            x_l2_0 = x[l2  ]; x_l2_1 = x[l2+1];
            x_l2_2 = x[l2+2]; x_l2_3 = x[l2+3];

            x_h2_0 = x[h2  ]; x_h2_1 = x[h2+1];
            x_h2_2 = x[h2+2]; x_h2_3 = x[h2+3];

            /*-----------------------------------------------------------*/
            /* Two butterflies are evaluated in parallel. The following  */
            /* results will be shown for one butterfly only, although    */
            /* both are being evaluated in parallel.                     */
            /*                                                           */
            /* Perform radix2 style DIF butterflies.                     */
            /*-----------------------------------------------------------*/

            xh0_0  = x_0    + x_l1_0;        xh1_0  = x_1    + x_l1_1;
            xh0_1  = x_2    + x_l1_2;        xh1_1  = x_3    + x_l1_3;

            xl0_0  = x_0    - x_l1_0;        xl1_0  = x_1    - x_l1_1;
            xl0_1  = x_2    - x_l1_2;        xl1_1  = x_3    - x_l1_3;

            xh20_0 = x_h2_0 + x_l2_0;        xh21_0 = x_h2_1 + x_l2_1;
            xh20_1 = x_h2_2 + x_l2_2;        xh21_1 = x_h2_3 + x_l2_3;

            xl20_0 = x_h2_0 - x_l2_0;        xl21_0 = x_h2_1 - x_l2_1;
            xl20_1 = x_h2_2 - x_l2_2;        xl21_1 = x_h2_3 - x_l2_3;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 12, to reflect the fact that 12 half words */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 4. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j += 12;
            x += 4;

            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y1i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y3i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* ---------------------------------------------------------*/

            y0r   = xh0_0 + xh20_0; y0i   = xh1_0 + xh21_0;
            y4r   = xh0_1 + xh20_1; y4i   = xh1_1 + xh21_1;

            xt0_0 = xh0_0 - xh20_0; yt0_0 = xh1_0 - xh21_0;
            xt0_1 = xh0_1 - xh20_1; yt0_1 = xh1_1 - xh21_1;

            xt2_0 = xl0_0 + xl21_0; yt2_0 = xl1_0 - xl20_0;
            xt1_0 = xl0_0 - xl21_0; yt1_0 = xl1_0 + xl20_0;

            xt2_1 = xl0_1 + xl21_1; yt2_1 = xl1_1 - xl20_1;
            xt1_1 = xl0_1 - xl21_1; yt1_1 = xl1_1 + xl20_1;

            x2[0] = y0r;             x2[1] = y0i;
            x2[2] = y4r;             x2[3] = y4i;

            /*---------------------------------------------------------*/
            /* Perform twiddle factor multiplies of three terms,top    */
            /* term does not have any multiplies. Note the twiddle     */
            /* factors for a normal FFT are C + j (-S). Since the      */
            /* factors that are stored are C + j S, this is            */
            /* corrected for in the multiplies.                        */
            /*                                                         */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)       */
            /* Perform the multiplies using 16 by 32 multiply macro    */
            /* defined. This treats the twiddle factor as 16 bits      */
            /* and incoming data as 32 bits.                           */
            /*---------------------------------------------------------*/

            x2[h2  ] = MPY16X32R(co10 , xt1_0) - MPY16X32R(si10 , yt1_0);
            x2[h2+1] = MPY16X32R(co10 , yt1_0) + MPY16X32R(si10 , xt1_0);

            x2[h2+2] = MPY16X32R(co11 , xt1_1) - MPY16X32R(si11 , yt1_1);
            x2[h2+3] = MPY16X32R(co11 , yt1_1) + MPY16X32R(si11 , xt1_1);

            x2[l1  ] = MPY16X32R(co20 , xt0_0) - MPY16X32R(si20 , yt0_0);
            x2[l1+1] = MPY16X32R(co20 , yt0_0) + MPY16X32R(si20 , xt0_0);

            x2[l1+2] = MPY16X32R(co21 , xt0_1) - MPY16X32R(si21 , yt0_1);
            x2[l1+3] = MPY16X32R(co21 , yt0_1) + MPY16X32R(si21 , xt0_1);

            x2[l2  ] = MPY16X32R(co30 , xt2_0) - MPY16X32R(si30 , yt2_0);
            x2[l2+1] = MPY16X32R(co30 , yt2_0) + MPY16X32R(si30 , xt2_0);

            x2[l2+2] = MPY16X32R(co31 , xt2_1) - MPY16X32R(si31 , yt2_1);
            x2[l2+3] = MPY16X32R(co31 , yt2_1) + MPY16X32R(si31 , xt2_1);
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints >> 1);

    if (radix == 2)
    {
        /*----------------------------------------------------------------*/
        /* The pointers are set at the following locations which are half */
        /* the offsets of a radix4 FFT.                                   */
        /*----------------------------------------------------------------*/

        y1 = y0 + (int) (npoints >> 2);
        y3 = y2 + (int) (npoints >> 2);
        l1 = norm + 1;
        j0 = 8;
        n0 = npoints >> 1;
    }
    else
    {
        y1 = y0 + (int) (npoints >> 1);
        y3 = y2 + (int) (npoints >> 1);
        l1 = norm + 2;
        j0 = 4;
        n0 = npoints >> 2;
    }

    /*--------------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4    */
    /* or a radix 2 style decomposition. It writes out at different       */
    /* locations though. It checks if either half the points, or a        */
    /* quarter of the complex points have been exhausted to jump to       */
    /* pervent double reversal.                                           */
    /*--------------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {
        /*----------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to "j"  */
        /* is either by 4, or 8.                                          */
        /*----------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*----------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations. These  */
        /* are transformed either as a radix4 or as a radix 2.            */
        /*----------------------------------------------------------------*/

        x_0 = x0[0]; x_1 = x0[1];
        x_2 = x0[2]; x_3 = x0[3];
        x_4 = x0[4]; x_5 = x0[5];
        x_6 = x0[6]; x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4; xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4; xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6; xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6; xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n10 = xl0_0 - xl1_1; n11 = xl1_0 + xl0_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n30 = xl0_0 + xl1_1; n31 = xl1_0 - xl0_1;

        if (radix == 2)
        {
           /*-------------------------------------------------------------*/
           /* Perform radix2 style decomposition.                         */
           /*-------------------------------------------------------------*/

           n00 = x_0 + x_2;     n01 = x_1 + x_3;
           n20 = x_0 - x_2;     n21 = x_1 - x_3;
           n10 = x_4 + x_6;     n11 = x_5 + x_7;
           n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        y0[2*h2] = n00;   y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;   y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;   y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;   y3[2*h2 + 1] = n31;

        /*----------------------------------------------------------------*/
        /* Read in ht enext eight inputs, and perform radix4 or radix2    */
        /* decomposition.                                                 */
        /*----------------------------------------------------------------*/

        x_8 = x2[0]; x_9 = x2[1];
        x_a = x2[2]; x_b = x2[3];
        x_c = x2[4]; x_d = x2[5];
        x_e = x2[6]; x_f = x2[7];
        x2 += 8;

        xh0_2 = x_8 + x_c; xh1_2  = x_9 + x_d;
        xl0_2 = x_8 - x_c; xl1_2  = x_9 - x_d;
        xh0_3 = x_a + x_e; xh1_3 = x_b + x_f;
        xl0_3 = x_a - x_e; xl1_3 = x_b - x_f;

        n02 = xh0_2 + xh0_3; n03 = xh1_2 + xh1_3;
        n12 = xl0_2 - xl1_3; n13 = xl1_2 + xl0_3;
        n22 = xh0_2 - xh0_3; n23 = xh1_2 - xh1_3;
        n32 = xl0_2 + xl1_3; n33 = xl1_2 - xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;     n03 = x_9 + x_b;
          n22 = x_8 - x_a;     n23 = x_9 - x_b;
          n12 = x_c + x_e;     n13 = x_d + x_f;
          n32 = x_c - x_e;     n33 = x_d - x_f;
        }

        /*-----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4]  */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]   */
        /*-----------------------------------------------------------------*/

        y0[2*h2+2] = n02;   y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;   y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;   y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;   y3[2*h2+3] = n33;

        j += j0;
        if (j == n0)
        {
          j  += n0;
          x0 += (int) npoints >> 1;
          x2 += (int) npoints >> 1;
        }
      }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/
ifft32x32.c/    1066929506  0     0     0       48585     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Sep  6 18:04:20 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/*==========================================================================*/
/*     TEXAS INSTRUMENTS, INC.                                              */
/*                                                                          */
/*     NAME                                                                 */
/*           DSP_ifft32x32: Double Precision IFFT                           */
/*                                                                          */
/*     USAGE                                                                */
/*           This routine is C-callable and can be called as:               */
/*                                                                          */
/*          void DSP_ifft32x32(const int  * ptr_w, int  npoints,            */
/*                           int   * ptr_x, int  * ptr_y ) ;                */
/*                                                                          */
/*            ptr_w   =  input twiddle factors                              */
/*            npoints =  number of points                                   */
/*            ptr_x   =  transformed data reversed                          */
/*            ptr_y   =  linear transformed data                            */
/*                                                                          */
/*           (See the C compiler reference guide.)                          */
/*                                                                          */
/*      In reality one can re-use fft32x32 to perform IFFT, by first        */
/*      conjugating the input, performing the FFT, conjugating again.       */
/*      This allows fft32x32 to perform the IFFT as well. However if        */
/*      the double conjugation needs to be avoided then this routine        */
/*      uses the same twiddle factors as the FFT and performs an IFFT.      */
/*      The change in the sign of the twiddle factors is adjusted for       */
/*      software. Hence this routine uses the same twiddle factors as       */
/*      the FFT routine.                                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The following code performs a mixed radix IFFT for "npoints" which  */
/*      is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  */
/*      transform and performs either a radix2 or radix4 transform on the   */
/*      last stage depending on "npoints". If "npoints" is a multiple of 4, */
/*      then this last stage is also a radix4 transform, otherwise it is a  */
/*      radix2 transform. This program is available as a C compilable file  */
/*      to automatically generate the twiddle factors "twiddle_split.c"     */
/*                                                                          */
/*      Generate special vector of twiddle factors                          */
/*                                                                          */
/*      for (j=1, k=0; j < npoints>>2; j = j <<2 )                          */
/*      {                                                                   */
/*          for (i=0; i < npoints>>2; i += j)                               */
/*          {                                                               */
/*              theta1 = 2*PI*i/npoints;                                    */
/*              x_t = M*cos(theta1);                                        */
/*              y_t = M*sin(theta1);                                        */
/*              ptr_w[k+1] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      */
/*              ptr_w[k+0] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      */
/*                                                                          */
/*              theta2 = 4*PI*i/npoints;                                    */
/*              x_t = M*cos(theta2);                                        */
/*              y_t = M*sin(theta2);                                        */
/*              ptr_w[k+3] = (int) x_t;                                     */
/*                                                                          */
/*              if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      */
/*              ptr_w[k+2] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      */
/*                                                                          */
/*              theta3 = 6*PI*i/npoints;                                    */
/*              x_t = M*cos(theta3);                                        */
/*              y_t = M*sin(theta3);                                        */
/*              ptr_w[k+5] = (int) x_t;                                     */
/*              if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      */
/*              ptr_w[k+4] = (int) y_t;                                     */
/*              if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      */
/*              k += 6;                                                     */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      This code works for  both "npoints" a multiple of 2 or 4.           */
/*      The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         */
/*      double-word boundary for the "optimized" implementations.           */
/*      The input and output data are complex, with the real/imaginary      */
/*      components stored in adjacent locations in the array.  The real     */
/*      components are stored at even array indices, and the imaginary      */
/*      components are stored at odd array indices. The input, twiddle      */
/*      factors are in 32 bit precision. The 32 by 32 multiplies are        */
/*      done with a 1.5 bit loss in accuracy. This comes about because      */
/*      the contribution of the low sixteen bits to the 32 bit result       */
/*      is not computed. In addition the contribution of the low * high     */
/*      term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      */
/*      after rounding. To illustrate real part of complex multiply of:     */
/*      (X + jY) ( C + jS) =                                                */
/*                                                                          */
/*      MPYHIRC(co10 , xt1_0)  - MPYHIRC(co10 , xt1_0) +                    */
/*                       (((MPYLUHS(co10,xt1_0) - MPYLUHS(co10, xt1_0)      */
/*                                              + 0x8000)  >> 16) << 1)     */
/*      where the functions MPYHIRC, MPYLUHS are as follows:                */
/*                                                                          */
/*  #define MPYHIRC(x,y) \                                                  */
/*  (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    */
/*   + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               */
/*                                                                          */
/*  #define MPYLUHS(x,y)   \                                                */
/*      ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*      The following C code represents an implementation of the Cooley     */
/*      Tukey radix 4 DIF IFFT. It accepts the inputs in normal order and   */
/*      produces the outputs in digit reversed order. The natural C code    */
/*      shown in this file on the other hand, accepts the inputs in nor-    */
/*      mal order and produces the outputs in normal order.                 */
/*                                                                          */
/*      Several transformations have been applied to the original Cooley    */
/*      Tukey code to produce the natural C code description shown here.    */
/*      In order to understand these it would first be educational to       */
/*      understand some of the issues involved in the conventional Cooley   */
/*      Tukey FFT code.                                                     */
/*                                                                          */
/*      void radix4(int n, short x[], short wn[])                           */
/*      {                                                                   */
/*          int    n1,  n2,  ie,   ia1,  ia2, ia3;                          */
/*          int    i0,  i1,  i2,    i3,    i, j,     k;                     */
/*          short  co1, co2, co3,  si1,  si2, si3;                          */
/*          short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          */
/*          short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                */
/*                                                                          */
/*          n2 = n;                                                         */
/*          ie = 1;                                                         */
/*          for (k = n; k > 1; k >>= 2)                                     */
/*          {                                                               */
/*              n1 = n2;                                                    */
/*              n2 >>= 2;                                                   */
/*              ia1 = 0;                                                    */
/*                                                                          */
/*              for (j = 0; j < n2; j++)                                    */
/*              {                                                           */
/*                   ia2 = ia1 + ia1;                                       */
/*                   ia3 = ia2 + ia1;                                       */
/*                                                                          */
/*                   co1 = wn[2 * ia1    ];                                 */
/*                   si1 = wn[2 * ia1 + 1];                                 */
/*                   co2 = wn[2 * ia2    ];                                 */
/*                   si2 = wn[2 * ia2 + 1];                                 */
/*                   co3 = wn[2 * ia3    ];                                 */
/*                   si3 = wn[2 * ia3 + 1];                                 */
/*                   ia1 = ia1 + ie;                                        */
/*                                                                          */
/*                   for (i0 = j; i0< n; i0 += n1)                          */
/*                   {                                                      */
/*                       i1 = i0 + n2;                                      */
/*                       i2 = i1 + n2;                                      */
/*                       i3 = i2 + n2;                                      */
/*                                                                          */
/*                                                                          */
/*                       xh0  = x[2 * i0    ] + x[2 * i2    ];              */
/*                       xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                                                                          */
/*                       xh20 = x[2 * i1    ] + x[2 * i3    ];              */
/*                       xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       x[2 * i0    ] = xh0 + xh20;                        */
/*                       x[2 * i0 + 1] = xh1 + xh21;                        */
/*                                                                          */
/*                       xt0  = xh0 - xh20;                                 */
/*                       yt0  = xh1 - xh21;                                 */
/*                       xt1  = xl0 - xl21;                                 */
/*                       yt2  = xl1 - xl20;                                 */
/*                       xt2  = xl0 + xl21;                                 */
/*                       yt1  = xl1 + xl20;                                 */
/*                                                                          */
/*                       x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     */
/*                       x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     */
/*                       x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     */
/*                       x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     */
/*                       x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     */
/*                       x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     */
/*                   }                                                      */
/*             }                                                            */
/*                                                                          */
/*             ie <<= 2;                                                    */
/*         }                                                                */
/*     }                                                                    */
/*                                                                          */
/*      The conventional Cooley Tukey FFT, is written using three loops.    */
/*      The outermost loop "k" cycles through the stages. There are log     */
/*      N to the base 4 stages in all. The loop "j" cycles through the      */
/*      groups of butterflies with different twiddle factors, loop "i"      */
/*      reuses the twiddle factors for the different butterflies within     */
/*      a stage. It is interesting to note the following:                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*      Stage#     #Groups     # Butterflies with common     #Groups*Bflys  */
/*                               twiddle factors                            */
/*--------------------------------------------------------------------------*/
/*       1         N/4          1                            N/4            */
/*       2         N/16         4                            N/4            */
/*       ..                                                                 */
/*       logN      1            N/4                          N/4            */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*      The following statements can be made based on above observations:   */
/*                                                                          */
/*      a) Inner loop "i0" iterates a veriable number of times. In          */
/*      particular the number of iterations quadruples every time from      */
/*      1..N/4. Hence software pipelining a loop that iterates a vraiable   */
/*      number of times is not profitable.                                  */
/*                                                                          */
/*      b) Outer loop "j" iterates a variable number of times as well.      */
/*      However the number of iterations is quartered every time from       */
/*      N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    */
/*      to each other.                                                      */
/*                                                                          */
/*      c) If the two loops "i" and "j" are colaesced together then they    */
/*      will iterate for a fixed number of times namely N/4. This allows    */
/*      us to combine the "i" and "j" loops into 1 loop. Optimized impl-    */
/*      ementations will make use of this fact.                             */
/*                                                                          */
/*      In addition the Cooley Tukey FFT accesses three twiddle factors     */
/*      per iteration of the inner loop, as the butterflies that re-use     */
/*      twiddle factors are lumped together. This leads to accessing the    */
/*      twiddle factor array at three points each sepearted by "ie". Note   */
/*      that "ie" is initially 1, and is quadrupled with every iteration.   */
/*      Therfore these three twiddle factors are not even contiguous in     */
/*      the array.                                                          */
/*                                                                          */
/*      In order to vectorize the FFT, it is desirable to access twiddle    */
/*      factor array using double word wide loads and fetch the twiddle     */
/*      factors needed. In order to do this a modified twiddle factor       */
/*      array is created, in which the factors WN/4, WN/2, W3N/4 are        */
/*      arranged to be contiguous. This eliminates the seperation between   */
/*      twiddle factors within a butterfly. However this implies that as    */
/*      the loop is traversed from one stage to another, that we maintain   */
/*      a redundant version of the twiddle factor array. Hence the size     */
/*      of the twiddle factor array increases as compared to the normal     */
/*      Cooley Tukey FFT.  The modified twiddle factor array is of size     */
/*      "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    */
/*      where N is the number of complex points to be transformed. The      */
/*      routine that generates the modified twiddle factor array was        */
/*      presented earlier. With the above transformation of the FFT,        */
/*      both the input data and the twiddle factor array can be accessed    */
/*      using double-word wide loads to enable packed data processing.      */
/*                                                                          */
/*      The final stage is optimised to remove the multiplication as        */
/*      w0 = 1.  This stage also performs digit reversal on the data,       */
/*      so the final output is in natural order.                            */
/*                                                                          */
/*      The fft() code shown here performs the bulk of the computation      */
/*      in place. However, because digit-reversal cannot be performed       */
/*      in-place, the final result is written to a separate array, y[].     */
/*                                                                          */
/*      There is one slight break in the flow of packed processing that     */
/*      needs to be comprehended. The real part of the complex number is    */
/*      in the lower half, and the imaginary part is in the upper half.     */
/*      The flow breaks in case of "xl0" and "xl1" because in this case     */
/*      the real part needs to be combined with the imaginary part because  */
/*      of the multiplication by "j". This requires a packed quantity like  */
/*      "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   */
/*       using add2's and sub2's. Hence the natural version of C code       */
/*      shown below is transformed using packed data processing as shown:   */
/*                                                                          */
/*                       xl0  = x[2 * i0    ] - x[2 * i2    ];              */
/*                       xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              */
/*                       xl20 = x[2 * i1    ] - x[2 * i3    ];              */
/*                       xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              */
/*                                                                          */
/*                       xt1  = xl0 + xl21;                                 */
/*                       yt2  = xl1 + xl20;                                 */
/*                       xt2  = xl0 - xl21;                                 */
/*                       yt1  = xl1 - xl20;                                 */
/*                                                                          */
/*                       xl1_xl0   = _sub2(x21_x20, x21_x20)                */
/*                       xl21_xl20 = _sub2(x32_x22, x23_x22)                */
/*                       xl20_xl21 = _rotl(xl21_xl20, 16)                   */
/*                                                                          */
/*                       yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              */
/*                       yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              */
/*                                                                          */
/*      Also notice that xt1, yt1 endup on seperate words, these need to    */
/*      be packed together to take advantage of the packed twiddle fact     */
/*      ors that have been loaded. In order for this to be achieved they    */
/*      are re-aligned as follows:                                          */
/*                                                                          */
/*      yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                */
/*      yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                */
/*                                                                          */
/*      In the folllowing code since all data elements are 32 bits, add2    */
/*      sub2 are replaced with normal 32 bit add's and subtracts.           */
/*      The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     */
/*      to be used for the complex multiplies. The real part of the         */
/*      multiply and the imaginary part of the multiply are performed       */
/*      as 16x32 multiplies using MPYLIR and MPYHIR                         */
/*                                                                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      The optimized implementations are written for LITTLE ENDIAN.        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

/*--------------------------------------------------------------------------*/
/* The following macro is used to obtain a digit reversed index, of a given */
/* number i, into j where the number of bits in "i" is "m". For the natural */
/* form of C code, this is done by first interchanging every set of "2 bit" */
/* pairs, followed by exchanging nibbles, followed by exchanging bytes, and */
/* finally halfwords. To give an example, condider the following number:    */
/*                                                                          */
/* N = FEDCBA9876543210, where each digit represents a bit, the following   */
/* steps illustrate the changes as the exchanges are performed:             */
/* M = DCFE98BA54761032 is the number after every "2 bits" are exchanged.   */
/* O = 98BADCFE10325476 is the number after every nibble is exchanged.      */
/* P = 1032547698BADCFE is the number after every byte is exchanged.        */
/* Since only 16 digits were considered this represents the digit reversed  */
/* index. Since the numbers are represented as 32 bits, there is one more   */
/* step typically of exchanging the half words as well.                     */
/*--------------------------------------------------------------------------*/

#if 0
# define DIG_REV(i, m, j) ((j) = (_shfl(_rotl(_bitr(_deal(i)), 16)) >> (m)))
#else
# define DIG_REV(i, m, j)                                                   \
    do {                                                                    \
        unsigned _ = (i);                                                   \
        _ = ((_ & 0x33333333) <<  2) | ((_ & ~0x33333333) >>  2);           \
        _ = ((_ & 0x0F0F0F0F) <<  4) | ((_ & ~0x0F0F0F0F) >>  4);           \
        _ = ((_ & 0x00FF00FF) <<  8) | ((_ & ~0x00FF00FF) >>  8);           \
        _ = ((_ & 0x0000FFFF) << 16) | ((_ & ~0x0000FFFF) >> 16);           \
        (j) = _ >> (m);                                                     \
    } while (0)
#endif

#define MPYHIRC(x,y) \
(((int)((short)(x >> 16) * (unsigned short)(y & 0x0000FFFF) + 0x4000) >> 15)+ \
     ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))

#define MPYLUHS(x,y)   \
    ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )

void DSP_ifft32x32(int * ptr_w, int npoints, int * ptr_x, int * ptr_y)
{
    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;
    int   xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
    int   xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    int   xh0_1, xh1_1, xl0_1, xl1_1;
    int   x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l2_0, x_l2_1;
    int   xh0_2, xh1_2, xl0_2, xl1_2, xh0_3, xh1_3, xl0_3, xl1_3;
    int   x_4, x_5, x_6, x_7, x_h2_0, x_h2_1;
    int   x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
    int   si10, si20, si30, co10, co20, co30;
    int   *w;
    int   *x, *x2, *x0;
    int   *y0, *y1, *y2, *y3;
    int   n00, n10, n20, n30, n01, n11, n21, n31;
    int   n02, n12, n22, n32, n03, n13, n23, n33;
    int   n0, j0;
    int   radix;
    int   norm;
    int   m;

    /*---------------------------------------------------------------------*/
    /* Determine the magnitude od the number of points to be transformed.  */
    /* Check whether we can use a radix4 decomposition or a mixed radix    */
    /* transformation, by determining modulo 2.                            */
    /*---------------------------------------------------------------------*/

    for (i = 31, m = 1; (npoints & (1 << i)) == 0; i--, m++) ;
    radix     = m & 1 ? 2 :  4;
    norm      = m - 2;

    /*----------------------------------------------------------------------*/
    /* The stride is quartered with every iteration of the outer loop. It   */
    /* denotes the seperation between any two adjacent inputs to the butter */
    /* -fly. This should start out at N/4, hence stride is initially set to */
    /* N. For every stride, 6*stride twiddle factors are accessed. The      */
    /* "tw_offset" is the offset within the current twiddle factor sub-     */
    /* table. This is set to zero, at the start of the code and is used to  */
    /* obtain the appropriate sub-table twiddle pointer by offseting it     */
    /* with the base pointer "ptr_w".                                       */
    /*----------------------------------------------------------------------*/

    stride    =   npoints;
    tw_offset =   0;
    fft_jmp   =   6 * stride;

    #ifndef NOASSUME
    _nassert(stride > 4);
    #pragma MUST_ITERATE(1,,1);
    #endif

    while (stride > radix)
    {
        /*-----------------------------------------------------------------*/
        /* At the start of every iteration of the outer loop, "j" is set   */
        /* to zero, as "w" is pointing to the correct location within the  */
        /* twiddle factor array. For every iteration of the inner loop     */
        /* 6 * stride twiddle factors are accessed. For eg,                */
        /*                                                                 */
        /* #Iteration of outer loop  # twiddle factors    #times cycled    */
        /*  1                          6 N/4               1               */
        /*  2                          6 N/16              4               */
        /*  ...                                                            */
        /*-----------------------------------------------------------------*/

        j         =  0;
        fft_jmp >>=  2;

        /*-----------------------------------------------------------------*/
        /* Set up offsets to access "N/4", "N/2", "3N/4" complex point or  */
        /* "N/2", "N", "3N/2" half word                                    */
        /*-----------------------------------------------------------------*/

        h2 = stride >> 1;
        l1 = stride;
        l2 = stride + (stride >> 1);

        /*-----------------------------------------------------------------*/
        /*  Reset "x" to point to the start of the input data array.       */
        /* "tw_offset" starts off at 0, and increments by "6 * stride"     */
        /*  The stride quarters with every iteration of the outer loop     */
        /*-----------------------------------------------------------------*/

        x = ptr_x;
        w = ptr_w + tw_offset;
        tw_offset += fft_jmp;

        stride >>=  2;

        /*----------------------------------------------------------------*/
        /* The following loop iterates through the different butterflies, */
        /* within a given stage. Recall that there are logN to base 4     */
        /* stages. Certain butterflies share the twiddle factors. These   */
        /* are grouped together. On the very first stage there are no     */
        /* butterflies that share the twiddle factor, all N/4 butter-     */
        /* flies have different factors. On the next stage two sets of    */
        /* N/8 butterflies share the same twiddle factor. Hence after     */
        /* half the butterflies are performed, j the index into the       */
        /* factor array resets to 0, and the twiddle factors are reused.  */
        /* When this happens, the data pointer 'x' is incremented by the  */
        /* fft_jmp amount.                                                */
        /*----------------------------------------------------------------*/

        #ifndef NOASSUME
        _nassert((int)(w)%8 == 0);
        _nassert((int)(x)%8 == 0);
        _nassert(h2 %8 == 0);
        _nassert(l1 %8 == 0);
        _nassert(l2 %8 == 0);
        _nassert(npoints >= 16);
        #pragma MUST_ITERATE(4, , 1);
        #endif

        for (i = 0; i < npoints; i += 4)
        {
            /*------------------------------------------------------------*/
            /*  Read the first three twiddle factor values. This loop co- */
            /*  mputes one radix 4 butterfly at a time.                   */
            /*------------------------------------------------------------*/

            co10 = w[j+1];            si10 = w[j+0];
            co20 = w[j+3];            si20 = w[j+2];
            co30 = w[j+5];            si30 = w[j+4];

            /*-----------------------------------------------------------*/
            /* Read in the data elements for the four inputs of radix4   */
            /* butterfly.                                                */
            /*-----------------------------------------------------------*/

            x_0    = x[0];            x_1    = x[1];
            x_l1_0 = x[l1  ];         x_l1_1 = x[l1+1];
            x_l2_0 = x[l2  ];         x_l2_1 = x[l2+1];
            x_h2_0 = x[h2  ];         x_h2_1 = x[h2+1];

            /*-----------------------------------------------------------*/
            /* Perform radix2 style DIF butterflies, for initial radix4  */
            /*-----------------------------------------------------------*/

            xh0_0    =   x_0        +       x_l1_0;
            xh1_0    =   x_1        +       x_l1_1;
            xl0_0    =   x_0        -       x_l1_0;
            xl1_0    =   x_1        -       x_l1_1;
            xh20_0   =   x_h2_0     +       x_l2_0;
            xh21_0   =   x_h2_1     +       x_l2_1;
            xl20_0   =   x_h2_0     -       x_l2_0;
            xl21_0   =   x_h2_1     -       x_l2_1;

            /*-----------------------------------------------------------*/
            /* Derive output pointers using the input pointer "x"        */
            /*-----------------------------------------------------------*/

            x0 = x;
            x2 = x0;

            /*-----------------------------------------------------------*/
            /* When the twiddle factors are not to be re-used, j is      */
            /* incremented by 6, to reflect the fact that 6 half words   */
            /* are consumed in every iteration. The input data pointer   */
            /* increments by 2. Note that within a stage, the stride     */
            /* does not change and hence the offsets for the other three */
            /* legs, 0, h2, l1, l2.                                      */
            /*-----------------------------------------------------------*/

            j    += 6;
            x    += 2;
            predj = (j - fft_jmp);
            if (!predj) x += fft_jmp;
            if (!predj) j = 0;

            /*----------------------------------------------------------*/
            /* These four partial results can be re-written to show     */
            /* the underlying DIF structure similar to radix2 as        */
            /* follows:                                                 */
            /*                                                          */
            /* X(4k)  = (x(n)+x(n + N/2)) + (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+1)= (x(n)-x(n + N/2)) -j(x(n+N/4) - x(n + 3N/4))    */
            /* x(4k+2)= (x(n)+x(n + N/2)) - (x(n+N/4)+ x(n + 3N/4))     */
            /* X(4k+3)= (x(n)-x(n + N/2)) +j(x(n+N/4) - x(n + 3N/4))    */
            /*                                                          */
            /* which leads to the real and imaginary values as foll:    */
            /*                                                          */
            /* y0r = x0r + x2r +  x1r +  x3r    =  xh0 + xh20           */
            /* y0i = x0i + x2i +  x1i +  x3i    =  xh1 + xh21           */
            /* y1r = x0r - x2r + (x1i -  x3i)   =  xl0 + xl21           */
            /* y1i = x0i - x2i - (x1r -  x3r)   =  xl1 - xl20           */
            /* y2r = x0r + x2r - (x1r +  x3r)   =  xh0 - xh20           */
            /* y2i = x0i + x2i - (x1i +  x3i    =  xh1 - xh21           */
            /* y3r = x0r - x2r - (x1i -  x3i)   =  xl0 - xl21           */
            /* y3i = x0i - x2i + (x1r -  x3r)   =  xl1 + xl20           */
            /* ---------------------------------------------------------*/

            x0[0] = xh0_0 + xh20_0;       x0[1] = xh1_0 + xh21_0;
            xt0_0 = xh0_0 - xh20_0;       yt0_0 = xh1_0 - xh21_0;
            xt1_0 = xl0_0 - xl21_0;       yt2_0 = xl1_0 - xl20_0;
            xt2_0 = xl0_0 + xl21_0;       yt1_0 = xl1_0 + xl20_0;

            /*-----------------------------------------------------------*/
            /* The following multiplies are close to a true 32 by 32     */
            /* multiply instruction.                                     */
            /* Perform twiddle factor multiplies of three terms,top      */
            /* term does not have any multiplies. Note the twiddle       */
            /* factors for a normal FFT are C + j (-S). Since the        */
            /* factors that are stored are C + j S, this is              */
            /* corrected for in the multiplies.                          */
            /*                                                           */
            /* Y1 = (xt1 + jyt1) (c + js) = (xc + ys) + (yc -xs)         */
            /* There is a loss of 1.5 bits of accuracy. This arises be-  */
            /* cause the result of the low sixteen by sixteen bits is    */
            /* not computed and the multiply of the low by high is       */
            /* shifted by 16, and results in a loss of 1 bit.            */
            /* Multiplies are performed for all the three legs of the    */
            /* radix4 butterfly are performed. In addition note that     */
            /* themiddle two legs are swapped. This is based on work     */
            /* done by Panos Papamichalis, on obtaining bit reversed     */
            /* order from a radix 4 butterfly. This allows the last      */
            /* stage to be performed either as a radix4 or a radix2      */
            /* pass for this stage.                                      */
            /*-----------------------------------------------------------*/

            x2[h2  ] = MPYHIRC(co10 ,  xt1_0)  - MPYHIRC(si10, yt1_0) +
                       (((MPYLUHS(co10,xt1_0)  - MPYLUHS(si10, yt1_0)
                                               + 0x8000)  >> 16)    << 1);

            x2[h2+1] = MPYHIRC(co10 , yt1_0)   + MPYHIRC(si10 , xt1_0)  +
                       (((MPYLUHS(co10, yt1_0) + MPYLUHS(si10, xt1_0)
                                               + 0x8000)  >> 16)  << 1);

            x2[l1  ] = MPYHIRC(co20 ,  xt0_0)  - MPYHIRC(si20, yt0_0) +
                       (((MPYLUHS(co20,xt0_0)  - MPYLUHS(si20, yt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l1+1] = MPYHIRC(co20 , yt0_0)   + MPYHIRC(si20 , xt0_0) +
                       (((MPYLUHS(co20, yt0_0) + MPYLUHS(si20,  xt0_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2  ] = MPYHIRC(co30 , xt2_0)   - MPYHIRC(si30 , yt2_0) +
                       (((MPYLUHS(co30, xt2_0) - MPYLUHS(si30,  yt2_0)
                                               + 0x8000) >> 16)   << 1);

            x2[l2+1] = MPYHIRC(co30 , yt2_0)   + MPYHIRC(si30 , xt2_0) +
                       (((MPYLUHS(co30,yt2_0)  + MPYLUHS(si30,  xt2_0)
                                               + 0x8000) >> 16)   << 1);
        }
    }

    /*-----------------------------------------------------------------*/
    /* The following code performs either a standard radix4 pass or a  */
    /* radix2 pass. Two pointers are used to access the input data.    */
    /* The input data is read "N/4" complex samples apart or "N/2"     */
    /* words apart using pointers "x0" and "x2". This produces out-    */
    /* puts that are 0, N/4, N/2, 3N/4 for a radix4 FFT, and 0, N/8    */
    /* N/2, 3N/8 for radix 2.                                          */
    /*-----------------------------------------------------------------*/

    y0 = ptr_y;
    y2 = ptr_y + (int) npoints;
    x0 = ptr_x;
    x2 = ptr_x + (int) (npoints>>1);

    if (radix == 2)
    {
        /*------------------------------------------------------------*/
        /* The pointers are set at the following locations which are  */
        /* half the offsets of a radix4 FFT.                          */
        /*------------------------------------------------------------*/

        y1  = y0 + (int) (npoints >> 2);
        y3  = y2 + (int) (npoints >> 2);
        l1  = norm + 1;
        j0  = 8;
        n0  = npoints >> 1;
    }
    else
    {
        y1  = y0 + (int) (npoints >> 1);
        y3  = y2 + (int) (npoints >> 1);
        l1  = norm + 2;
        j0  = 4;
        n0  = npoints >> 2;
    }

    /*-----------------------------------------------------------------*/
    /* The following code reads data indentically for either a radix 4 */
    /* or a radix 2 style decomposition. It writes out at different    */
    /* locations though. It checks if either half the points, or a     */
    /* quarter of the complex points have been exhausted to jump to    */
    /* pervent double reversal.                                        */
    /*-----------------------------------------------------------------*/

    j = 0;

    #ifndef NOASSUME
    _nassert((int)(n0)%4  == 0);
    _nassert((int)(x0)%8 == 0);
    _nassert((int)(x2)%8 == 0);
    _nassert((int)(y0)%8 == 0);
    #pragma MUST_ITERATE(2,,2);
    #endif

    for (i = 0; i < npoints; i += 8)
    {
        /*-------------------------------------------------------------*/
        /* Digit reverse the index starting from 0. The increment to   */
        /* "j" is either by 4, or 8.                                   */
        /*-------------------------------------------------------------*/

        DIG_REV(j, l1, h2);

        /*-------------------------------------------------------------*/
        /* Read in the input data, from the first eight locations.     */
        /* These are transformed either as a radix4 or as a radix 2.   */
        /*-------------------------------------------------------------*/

        x_0 = x0[0];         x_1 = x0[1];
        x_2 = x0[2];         x_3 = x0[3];
        x_4 = x0[4];         x_5 = x0[5];
        x_6 = x0[6];         x_7 = x0[7];
        x0 += 8;

        xh0_0 = x_0 + x_4; xh1_0 = x_1 + x_5;
        xl0_0 = x_0 - x_4; xl1_0 = x_1 - x_5;
        xh0_1 = x_2 + x_6; xh1_1 = x_3 + x_7;
        xl0_1 = x_2 - x_6; xl1_1 = x_3 - x_7;

        n00 = xh0_0 + xh0_1; n01 = xh1_0 + xh1_1;
        n20 = xh0_0 - xh0_1; n21 = xh1_0 - xh1_1;
        n10 = xl0_0 - xl1_1; n11 = xl1_0 + xl0_1;
        n30 = xl0_0 + xl1_1; n31 = xl1_0 - xl0_1;

        if (radix == 2)
        {
             /*--------------------------------------------------------*/
             /* Perform radix2 style decomposition.                    */
             /*--------------------------------------------------------*/

             n00 = x_0 + x_2;     n01 = x_1 + x_3;
             n20 = x_0 - x_2;     n21 = x_1 - x_3;
             n10 = x_4 + x_6;     n11 = x_5 + x_7;
             n30 = x_4 - x_6;     n31 = x_5 - x_7;
        }

        /*-------------------------------------------------------------*/
        /*  Store out the four outputs of 1 radix4 butterfly or 2      */
        /*  radix2 butterflies.                                        */
        /*-------------------------------------------------------------*/

        y0[2*h2] = n00;            y0[2*h2 + 1] = n01;
        y1[2*h2] = n10;            y1[2*h2 + 1] = n11;
        y2[2*h2] = n20;            y2[2*h2 + 1] = n21;
        y3[2*h2] = n30;            y3[2*h2 + 1] = n31;

        /*-------------------------------------------------------------*/
        /* Read in the next set of inputs from pointer "x2". These will*/
        /* produce outputs that are contiguous to the previous outputs.*/
        /*-------------------------------------------------------------*/

        x_8 = x2[0];               x_9 = x2[1];
        x_a = x2[2];               x_b = x2[3];
        x_c = x2[4];               x_d = x2[5];
        x_e = x2[6];               x_f = x2[7];
        x2 += 8;

        /*-------------------------------------------------------------*/
        /* Perform radix4 style decompositions and overwrite results   */
        /* if it is dtermined that the radix to be used is radix 2.    */
        /*-------------------------------------------------------------*/

        xh0_2 = x_8 + x_c;         xh1_2  =  x_9    +  x_d;
        xl0_2 = x_8 - x_c;         xl1_2  =  x_9    -  x_d;
        xh0_3 = x_a + x_e;         xh1_3  =  x_b    +  x_f;
        xl0_3 = x_a - x_e;         xl1_3  =  x_b    -  x_f;

        n02 = xh0_2 + xh0_3;       n03    =  xh1_2  +  xh1_3;
        n12 = xl0_2 - xl1_3;       n13    =  xl1_2  +  xl0_3;
        n22 = xh0_2 - xh0_3;       n23    =  xh1_2  -  xh1_3;
        n32 = xl0_2 + xl1_3;       n33    =  xl1_2  -  xl0_3;

        if (radix == 2)
        {
          n02 = x_8 + x_a;         n03 = x_9   +   x_b;
          n22 = x_8 - x_a;         n23 = x_9   -   x_b;
          n12 = x_c + x_e;         n13 = x_d   +   x_f;
          n32 = x_c - x_e;         n33 = x_d   -   x_f;
        }

        /*----------------------------------------------------------------*/
        /* Points that are read from succesive locations map to y, y[N/4] */
        /* y[N/2], y[3N/4] in a radix4 scheme, y, y[N/8], y[N/2],y[5N/8]  */
        /*----------------------------------------------------------------*/

        y0[2*h2+2] = n02;          y0[2*h2+3] = n03;
        y1[2*h2+2] = n12;          y1[2*h2+3] = n13;
        y2[2*h2+2] = n22;          y2[2*h2+3] = n23;
        y3[2*h2+2] = n32;          y3[2*h2+3] = n33;

        /*---------------------------------------------------------------*/
        /* Increment j by "j0", if j is equal to n0, increment j by n0,  */
        /* that double reversal is avoided.                              */
        /*---------------------------------------------------------------*/

        j += j0;

        if (j == n0)
        {
            j  += n0;
            x0 += (int) npoints >> 1;
            x2 += (int) npoints >> 1;
        }
   }
}

/*==========================================================================*/
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/*==========================================================================*/

iirlat.c/       1066929506  0     0     0       6467      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Wed Apr 17 16:07:13 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_iirlat                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      14-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C Callable and can be called as:                    */
/*                                                                          */
/*      void DSP_iirlat                                                     */
/*      (                                                                   */
/*          short       *x,                                                 */
/*          int          nx,                                                */
/*          const short *restrict k,                                        */
/*          int          nk,                                                */
/*          int         *restrict b,                                        */
/*          short       *r                                                  */
/*      );                                                                  */
/*                                                                          */
/*      x[nx]   : Input vector (16-bit)                                     */
/*      nx      : Length of input vector.                                   */
/*      k[nk]   : Reflection coefficients in Q.15 format                    */
/*      nk      : Number of reflection coefficients/lattice stages          */
/*      b[nk+1] : Delay line elements from previous call. Should be         */
/*                initialized to all zeros prior to the first call.         */
/*      r[nx]   : Output vector (16-bit)                                    */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine implements a real all-pole IIR filter in lattice       */
/*      structure (AR lattice). The filter consists of nk lattice stages.   */
/*      Each stage requires one reflection coefficient k and one delay      */
/*      element b. The routine takes an input vector x[] and returns the    */
/*      filter output in r[]. Prior to the first call of the routine the    */
/*      delay elements in b[] should be set to zero. The input data may     */
/*      have to be pre-scaled to avoid overflow or achieve better SNR. The  */
/*      reflections coefficients lie in the range -1.0 < k < 1.0. The       */
/*      order of the coefficients is such that k[nk-1] corresponds to the   */
/*      first lattice stage after the input and k[0] corresponds to the     */
/*      last stage.                                                         */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_iirlat
(
    short       *x,
    int         nx,
    const short *restrict k,
    int         nk,
    int         *restrict b,
    short       *r
)
{
    int rt;     /* output       */
    int i, j;   /* loop counter */

    for (j=0; j<nx; j++)
    {
        rt = x[j] << 15;

        for (i = nk - 1; i >= 0; i--)
        {
            rt       = rt   - (short)(b[i] >> 15) * k[i];
            b[i + 1] = b[i] + (short)(rt   >> 15) * k[i];
        }

        b[0] = rt;

        r[j] = rt >> 15;
    }
}
/* ======================================================================= */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

iir.c/          1066929506  0     0     0       6121      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Tue Jun 24 17:03:36 2003 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      iir -- Infinite Impulse Response Filter/ ARMA filter                */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      29-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable and can be called as:                    */
/*                                                                          */
/*      void DSP_iir                                                        */
/*      (                                                                   */
/*          short *restrict r1,                                             */
/*          const short *x,                                                 */
/*          short *restrict r2,                                             */
/*          const short *h2,                                                */
/*          const short *h1,                                                */
/*          int nr                                                          */
/*      )                                                                   */
/*                                                                          */
/*      r1[nr+4] : Output array (used).                                     */
/*      x[nr+4]  : Input array.                                             */
/*      r2[nr]   : Output array (stored).                                   */
/*      h1[5]    : 4 Autoregressive filter coefficients (h1[0] is not used) */
/*      h2[5]    : 5 Moving-average filter coefficients.                    */
/*      nr       : Number of output samples. Must be >= 8.                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The IIR performs an auto-regressive moving-average (ARMA) filter    */
/*      with 4 auto-regressive filter coefficients and 5 moving-average     */
/*      filter coefficients for nr output samples. The output vector is     */
/*      stored in two locations.  This routine is used as a high pass       */
/*      filter in the VSELP vocoder.                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_iir
(
    short *restrict r1,      /* Output array (used)      */
    const short     *x,      /* Input array              */
    short *restrict r2,      /* Output array (stored)    */
    const short     *h2,     /* Filter Coeffs. AR part   */
    const short     *h1,     /* Filter Coeffs. FIR part  */
    int             nr       /* Number of output samples */
)
{
    int i, j;
    int sum;

    for ( i = 0; i < nr; i++)
    {
        sum = h2[0] * x[4 + i];

        for ( j = 1; j <= 4; j++)
             sum += h2[j] * x[4 + i - j] - h1[j] * r1[4 + i - j];

        r1[4 + i] = (sum >> 15);
        r2[i]     = r1[4 + i];
    }
}

/* ======================================================================== */
/*  End of file:  dsp_iir.c                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

mat_mul.c/      1066929506  0     0     0       7499      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.1     Mon Feb 11 15:32:05 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_mat_mul -- Matrix Multiply                                      */
/*                                                                          */
/*   REVISION DATE                                                          */
/*       13-Jan-2002                                                        */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSP_mat_mul                                                */
/*          (                                                               */
/*              const short *restrict x, int r1, int c1,                    */
/*              const short *restrict y,         int c2,                    */
/*              short       *restrict r,                                    */
/*              int                   qs                                    */
/*          );                                                              */
/*                                                                          */
/*      x  == Pointer to r1 by c1 input matrix.                             */
/*      y  == Pointer to c1 by c2 input matrix.                             */
/*      r  == Pointer to r1 by c2 output matrix.                            */
/*                                                                          */
/*      r1 == Number of rows in x.                                          */
/*      c1 == Number of columns in x.  Also number of rows in y.            */
/*      c2 == Number of columns in y.                                       */
/*                                                                          */
/*      qs == Final right-shift to apply to the result.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This function computes the expression "r = x * y" for the           */
/*      matrices x and y.  The columnar dimension of x must match           */
/*      the row dimension of y.  The resulting matrix has the same          */
/*      number of rows as x and the same number of columns as y.            */
/*                                                                          */
/*      The values stored in the matrices are assumed to be fixed-point     */
/*      or integer values.  All intermediate sums are retained to 32-bit    */
/*      precision, and no overflow checking is performed.  The results      */
/*      are right-shifted by a user-specified amount, and then truncated    */
/*      to 16 bits.                                                         */
/*                                                                          */
/*      This code is suitable for dense matrices.  No optimizations are     */
/*      made for sparse matrices.                                           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That   */
/*      is, in-place processing is not allowed.                             */
/*                                                                          */
/*      The input matrices have minimum dimensions of at least 1 row and    */
/*      1 column, and no more than 32767 rows or 32767 columns.             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_mat_mul
(
    const short *restrict x, int r1, int c1,
    const short *restrict y,         int c2,
    short       *restrict r,
    int                   qs
)
{
    int i, j, k;
    int sum;

    /* -------------------------------------------------------------------- */
    /*  Multiply each row in x by each column in y.  The product of row m   */
    /*  in x and column n in y is placed in position (m,n) in the result.   */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < r1; i++)
        for (j = 0; j < c2; j++)
        {
            sum = 0;
            for (k = 0; k < c1; k++)
                sum += x[k + i*c1] * y[j + k*c2];

            r[j + i*c2] = sum >> qs;
        }
}
/* ======================================================================== */
/*  End of file:  dsp_mat_mul.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

mat_trans.c/    1066929506  0     0     0       5573      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Mon Feb 18 00:54:30 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*    TEXAS INSTRUMENTS, INC.                                              */
/*                                                                         */
/*    NAME                                                                 */
/*          DSP_mat_trans                                                  */
/*                                                                         */
/*    REVISION DATE                                                        */
/*        13-May-2001                                                      */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      void DSP_mat_trans                                                 */
/*      (                                                                  */
/*          const short *restrict x,    // Input matrix            //      */
/*          short rows,                 // Height of input matrix  //      */
/*          short columns,              // Width of input matrix   //      */
/*          short *restrict r           // Output matrix           //      */
/*      );                                                                 */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      The program transposes a matrix of 16-bit values and user-         */
/*      determined dimensions. The result of a matrix transpose is a       */
/*      matrix with the number of rows = number of columns of input matrix */
/*      and number of columns = number of rows of input matrix The value   */
/*      of an elements of the output matrix is equal to the value of the   */
/*      element from the input matrix with switched coordinates (rows,     */
/*      columns).                                                          */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

void DSP_mat_trans
(
    const short *restrict x,
    short rows,
    short columns,
    short *restrict r
)
{
    int i, j;

    #ifdef NOASSUME
    _nassert(columns %4 == 0);
    _nassert(rows % 4 == 0);
    _nassert((int)(x)%8 == 0);
    _nassert((int)(r)%8 == 0);
    _nassert(columns >= 8);
    _nassert(rows >= 8);
    #endif

    /* ------------------------------------------------------------------- */
    /*  Write each column of 'x' to a row of 'r'.                          */
    /* ------------------------------------------------------------------- */
    for (i = 0; i < columns; i++)
        for (j = 0; j < rows; j++)
            r[(i * rows) + j] = x[i + (columns * j)];

}

/* ======================================================================= */
/*  End of file:  dsp_mat_trans.c                                          */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

maxidx.c/       1066929506  0     0     0       8074      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Sun Sep 29 03:32:25 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_maxidx                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      13-Aug-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          int DSP_maxidx                                                  */
/*          (                                                               */
/*              const short *Input,      // Input array     //              */
/*              short        nInputs     // Length of input //              */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The "DSP_maxidx" routine finds the largest element in an array,     */
/*      returning the index to that element within the array.               */
/*                                                                          */
/*      The input array is treated as 16 separate "columns" that are        */
/*      interleaved throughout the array.  If values in different columns   */
/*      are equal to the maximum value, then the element in the leftmost    */
/*      column is returned.  If two values within a column are equal to     */
/*      the maximum, then the one with the lower index is returned.         */
/*      Column takes precedence over index within the column.               */
/*                                                                          */
/*      The function returns the index of the maximum value.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input must be at least 48 elements long, and be a multiple      */
/*      of 16 elements long.                                                */
/*                                                                          */
/*      The code requires at least 48 bytes of stack, to make room for a    */
/*      32-byte temporary working buffer.                                   */
/*                                                                          */
/*      The optimized implementations assume that the Input array is        */
/*      double-word aligned, and are optimized for LITTLE ENDIAN.           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int  DSP_maxidx
(
    const short *Input,
    int          nInputs
)
{
    int    i, j;
    int    maxLocation, maxIndex;
    short  maxValue;
    short  Max[16];

    #ifndef NOASSUME
    _nassert((int) nInputs      >= 32);
    _nassert((int) nInputs % 16 == 0);
    _nassert((int) Input   % 8  == 0);
    #endif

    /* -------------------------------------------------------------------- */
    /*  Initialize our "max" values from the input array.                   */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < 16; i++)
        Max[i] = Input[i];

    /* -------------------------------------------------------------------- */
    /*  Find the maximums for each of 16 "columns" of the input.            */
    /* -------------------------------------------------------------------- */

    #ifndef NOASSUME
    #pragma MUST_ITERATE(2,,1);
    #endif
    for (i = 16; i < nInputs; i += 16)
        for (j = 0; j < 16; j++)
            if (Input[i + j] > Max[j]) Max[j] = Input[i + j];

    /* -------------------------------------------------------------------- */
    /*  Find the leftmost "column" with the largest value.                  */
    /* -------------------------------------------------------------------- */
    maxValue = Max[0];
    maxIndex = 0;
    for (i = 0; i < 16; i++)
        if (Max[i] > maxValue)
        {
            maxValue = Max[i];
            maxIndex = i;
        }

    /* -------------------------------------------------------------------- */
    /*  Find the earliest value in the selected column with the max value.  */
    /* -------------------------------------------------------------------- */
    maxLocation = maxIndex;

    #ifndef NOASSUME
    #pragma MUST_ITERATE(2,,1);
    #endif
    for (i = nInputs - 16 + maxIndex; i >= 0; i -= 16)
        if (Input[i] == maxValue) maxLocation = i;

    /* -------------------------------------------------------------------- */
    /*  Return the the location                                             */
    /* -------------------------------------------------------------------- */

    return maxLocation;
}

/* ======================================================================== */
/*  End of file:  dsp_maxidx.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
maxval.c/       1066929506  0     0     0       4756      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Mon Jan 21 15:38:00 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_maxval                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      18-Sep-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*         short DSP_maxval(const short *x, int nx);                        */
/*                                                                          */
/*         x  = address to array of values                                  */
/*         nx = number of values in array                                   */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine finds the maximum value of a vector and returns        */
/*      the value.                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

short DSP_maxval(const short *x, int nx)
{
    int i;
    short max = -32768;

    /* -------------------------------------------------------------------- */
    /*  Determine the maximum, value in the given vector and return it.     */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < nx; i++)
        if (x[i] > max)
            max = x[i];

    return max;

}

/* ======================================================================== */
/*  End of file:  dsp_maxval.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
minerror.c/     1066929506  0     0     0       5785      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Mon Mar 11 23:40:47 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================= */
/*                                                                         */
/*  TEXAS INSTRUMENTS, INC.                                                */
/*                                                                         */
/*  NAME                                                                   */
/*      DSP_minerror --  Minimum Energy Error Search                       */
/*S                                                                        */
/*                                                                         */
/*  REVISION DATE                                                          */
/*      11-Feb-2002                                                        */
/*                                                                         */
/*  USAGE                                                                  */
/*      This routine is C-callable and can be called as:                   */
/*                                                                         */
/*      int DSP_minerror                                                   */
/*      (                                                                  */
/*          const short *restrict GSP0_TABLE,                              */
/*          const short *restrict errCoefs,                                */
/*          int         *restrict max_index                                */
/*      );                                                                 */
/*                                                                         */
/*      GSP0_TABLE[256*9] :  Pointer to GSP0 terms array.                  */
/*                           Must be double-word aligned.                  */
/*      errCoefs[9]       :  Array of error coefficients.                  */
/*      max_index         :  Index to GSP0_TABLE[max_index], the first     */
/*                           element of the 9-element vector that resulted */
/*                           in the maximum dot product.                   */
/*      return int        :  Maximum dot product result.                   */
/*                                                                         */
/*  DESCRIPTION                                                            */
/*      Performs a dot product on 256 pairs of 9 element vectors and       */
/*      searches for the pair of vectors which produces the maximum dot    */
/*      product result. This is a large part of the VSELP vocoder codebook */
/*      search.                                                            */
/*                                                                         */
/*                                                                         */
/* ----------------------------------------------------------------------- */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================= */

#define GSP0_TERMS 9
#define GSP0_NUM 256

int DSP_minerror
(
        const short *restrict GSP0_TABLE,
        const short *restrict errCoefs,
        int *max_index
)
{
    int val, maxVal = -50;
    int i, j;

    for (i = 0; i < GSP0_NUM; i++)
    {
        for (val = 0, j = 0; j < GSP0_TERMS; j++)
           val += GSP0_TABLE[i*GSP0_TERMS+j] * errCoefs[j];

        if (val > maxVal)
        {
           maxVal = val;
           *max_index = i*GSP0_TERMS;
        }
    }

    return (maxVal);
}

/* ========================================================================== */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ========================================================================== */

minval.c/       1066929506  0     0     0       4755      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.5     Mon Jan 21 16:47:44 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_minval                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      18-Sep-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*         short DSP_minval(const short *x, int nx);                        */
/*                                                                          */
/*         x  = address to array of values                                  */
/*         nx = number of values in array                                   */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine finds the minimum value of a vector and returns        */
/*      the value.                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

short DSP_minval(const short *x, int nx)
{
    int i;
    short min = 32767;

    /* -------------------------------------------------------------------- */
    /*  Determine the minimum, value in the given vector and return it.     */
    /* -------------------------------------------------------------------- */
    for (i = 0; i < nx; i++)
        if (x[i] < min)
            min = x[i];

    return min;

}

/* ======================================================================== */
/*  End of file:  dsp_minval.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

mul32.c/        1066929506  0     0     0       7820      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Fri Mar 29 19:26:26 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_mul32                                                           */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      14-May-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSP_mul32                                                  */
/*          (                                                               */
/*              const int    *x,   // Input array of length nx  //          */
/*              const int    *y,   // Input array of length nx  //          */
/*              int *restrict r,   // Output array of length nx //          */
/*              int           nx   // Number of elements.       //          */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine performs a 32-bit by 32-bit multiply, returning the    */
/*      upper 32 bits of the 64-bit result.  This is equivalent to a        */
/*      Q31 x Q31 multiply, yielding a Q30 result.                          */
/*                                                                          */
/*      The 32 x 32 multiply is constructed from 16 x 16 multiplies.        */
/*      For efficiency reasons, the 'lo * lo' term of the 32 x 32           */
/*      multiply is omitted, as it has minimal impact on the final          */
/*      result.  This is due to the fact that the 'lo * lo' term            */
/*      primarily affects the lower 32 bits of the result, and these        */
/*      are not returned.  Due to this omission, the results of this        */
/*      function differ from the exact results of a 32 x 32 multiply by     */
/*      at most 1.                                                          */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This function is ENDIAN NEUTRAL.                                    */
/*                                                                          */
/*  NOTES                                                                   */
/*      The 32x32 multiply is an approximation, as described above.         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_mul32
(
    const int    *x,
    const int    *y,
    int *restrict r,
    int           nx
)
{
    int i;

    for (i = 0; i < nx; i++)
    {
        short           a_hi, b_hi;
        unsigned short  a_lo, b_lo;
        int             hihi, lohi, hilo, hllh;

        /* ---------------------------------------------------------------- */
        /*  A full 32x32 multiply can be constructed from four 16x16        */
        /*  multiplies.  If you divide the two 32-bit multipliers into hi   */
        /*  and lo halves, then the 32x32 product is constructed from the   */
        /*  sum of 'hi * hi', 'hi * lo', 'lo * hi', and 'lo * lo', each     */
        /*  shifted appropriately.  The 'hi' terms are signed terms, and    */
        /*  the 'lo' terms are unsigned.                                    */
        /* ---------------------------------------------------------------- */
        a_hi = (short)(x[i] >> 16);
        b_hi = (short)(y[i] >> 16);
        a_lo = (unsigned short)x[i];
        b_lo = (unsigned short)y[i];

        /* ---------------------------------------------------------------- */
        /*  For our result alignment, the 'hi * hi' term requires no shift. */
        /* ---------------------------------------------------------------- */
        hihi = a_hi * b_hi;

        /* ---------------------------------------------------------------- */
        /*  The 'lo * hi' and the 'hi * lo' terms will both be shifted      */
        /*  right by 16.  Therefore, we will compute them, then add them    */
        /*  together.  Note that this sum can be 33 bits long, and we need  */
        /*  the upper 17 bits of that 33-bit sum.  Hence, we use longs.     */
        /* ---------------------------------------------------------------- */
        hilo = a_hi * b_lo;
        lohi = a_lo * b_hi;
        hllh = (hilo + (long)lohi) >> 16;

        /* ---------------------------------------------------------------- */
        /*  Merge the middle and upper sums to form the final result.       */
        /* ---------------------------------------------------------------- */
        r[i] = hihi + hllh;
    }
}
/* ======================================================================== */
/*  End of file:  dsp_mul32.c                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
neg32.c/        1066929506  0     0     0       5565      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.4     Mon Dec 10 20:54:20 2001 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_neg32                                                           */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      10-Dec-2001                                                         */
/*                                                                          */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and may be called using the following   */
/*      C function prototype:                                               */
/*                                                                          */
/*          void DSP_neg32                                                  */
/*          (                                                               */
/*              int   *x,      // Input data array     //                   */
/*              int   *r,      // Output data array    //                   */
/*              short nx       // Number of elements.  //                   */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This routine negates an array of 32-bit integers, and stores        */
/*      the result either in a new array, or back to the same array.        */
/*                                                                          */
/*  MEMORY NOTE                                                             */
/*      This kernel is ENDIAN NEUTRAL.                                      */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      The input must be at least 8 elements long, and a multiple of 4.    */
/*                                                                          */
/*      The input and output arrays must not overlap, except in the         */
/*      special case where the input and output pointers are exactly        */
/*      equal.                                                              */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_neg32(int *x, int *r, short nx)
{
    int i;

    for (i = 0; i < nx; i++)
          r[i] = -x[i];
}

/* ======================================================================== */
/*   End of file:  dsp_neg32.c                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

q15tofl.c/      1066929506  0     0     0       5747      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.3     Mon Mar 11 20:57:07 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*                                                                          */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_q15tofl -- Q.15 to IEEE float conversion                        */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      17-Jul-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSP_q15tofl (short *x, float *r, int nx)                   */
/*                                                                          */
/*          x[nx]  ---  Pointer to Q15 input vector of size nx              */
/*          r[nx]  ---  Pointer to floating-point output data vector        */
/*                      of size nx containing the floating-point equivalent */
/*                      of vector input                                     */
/*          nx     ---  length of input and output data vectors             */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      Converts the Q15 stored in vector input to IEEE floating point      */
/*      numbers stored in vector output.                                    */
/*                                                                          */
/*      void DSP_q15tofl (short *x, float *r, int nx)                       */
/*      {                                                                   */
/*       int i;                                                             */
/*                                                                          */
/*       for (i=0;i<nx;i++)                                                 */
/*            r[i]=(float)x[i]/0x8000;                                      */
/*      }                                                                   */
/*                                                                          */
/*      The above C code is a general implementation without                */
/*      restrictions.  The assembly code may have some restrictions, as     */
/*      noted below.                                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_q15tofl(const short *restrict x, float *r, int nx )
{
    int i;

    for (i=0;i<nx;i++)
        r[i]=(float)x[i]/32768;
}

/* ======================================================================== */
/*  End of file:  dsp_q15tofl.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

recip16.c/      1066929506  0     0     0       5992      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Thu Sep 18 16:14:28 2003 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_recip16                                                         */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      20-Jul-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx);   */
/*                                                                          */
/*      x[nx]     = Pointer to input vector of size nx                      */
/*      rfrac[nx] = Pointer to output vector of size nx to                  */
/*                  contain the fractional part of the reciprocal           */
/*      rexp[nx]  = Pointer to output vector of size nx to                  */
/*                  contain the exponent part of the reciprocal             */
/*      nx        = Number of elements in input vector                      */
/*                                                                          */
/*      (See the C compiler reference guide.)                               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      This program performs a reciprocal on a vector of Q15 numbers.      */
/*      The result is stored in two parts: a Q15 part and an exponent       */
/*      (power of two) of the fraction.                                     */
/*      First, the input is loaded, then its absolute value is taken,       */
/*      then it is normalized, then divided using a loop of conditional     */
/*      subtracts, and finally it is negated if the original input was      */
/*      negative.                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx)
{
   int i,j,a,b;
   short neg, normal;

   for(i = nx; i > 0; i--)
   {
       a = *(x++);
       if(a < 0)             /* take absolute value */
       {
           a = -a;
           neg = 1;
       }
       else
           neg = 0;

       normal = _norm(a);              /* normalize */
       a = a << normal;

       *(rexp++) = normal - 15;   /* store exponent */
       b = 0x80000000;              /* dividend = 1 */

       for(j = 15; j > 0; j--)
           b = _subc(b,a);                /* divide */

       b = b & 0x7FFF;           /* clear remainder */

       if(neg) b = -b;       /* if negative, negate */

       *(rfrac++) = b;            /* store fraction */
   }
}
/* ======================================================================== */
/*  End of file:  dsp_recip16.c                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
vecsumsq.c/     1066929506  0     0     0       4950      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.2     Fri Mar 29 20:52:28 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_vecsumsq                                                        */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      15-May-2001                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*          int DSP_vecsumsq                                                */
/*          (                                                               */
/*              const short *x,    // Pointer to vector  //                 */
/*              int          nx    // Length of vector.  //                 */
/*          );                                                              */
/*                                                                          */
/*      This routine returns the sum of squares as its return value.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The "DSP_vecsumsq" function returns the sum of squares of the       */
/*      elements contained in vector "x".                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*      This code is ENDIAN NEUTRAL                                         */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

int DSP_vecsumsq
(
    const short *x,
    int  count
)
{
    int i;
    int prod, sum = 0;

    for (i = 0; i < count; i++)
    {
        prod = x[i] * x[i];
        sum += prod;
    }

    return sum;
}

/* ======================================================================== */
/*  End of file:  dsp_vecsumsq.c                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
w_vec.c/        1066929506  0     0     0       5593      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  DSPLIB  DSP Signal Processing Library                                   */
/*                                                                          */
/*      Release:        Revision 1.04b                                      */
/*      CVS Revision:   1.6     Fri Mar 29 21:05:02 2002 (UTC)              */
/*      Snapshot date:  23-Oct-2003                                         */
/*                                                                          */
/*  This library contains proprietary intellectual property of Texas        */
/*  Instruments, Inc.  The library and its source code are protected by     */
/*  various copyrights, and portions may also be protected by patents or    */
/*  other legal protections.                                                */
/*                                                                          */
/*  This software is licensed for use with Texas Instruments TMS320         */
/*  family DSPs.  This license was provided to you prior to installing      */
/*  the software.  You may review this license by consulting the file       */
/*  TI_license.PDF which accompanies the files in this library.             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */


/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSP_w_vec: Weighted vector sum                                      */
/*                                                                          */
/*                                                                          */
/*  REVISION DATE                                                           */
/*      29-Mar-2002                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSP_w_vec                                                  */
/*          (                                                               */
/*              const short *x,     // Vector being weighted  //            */
/*              const short *y,     // Non-weighted vector    //            */
/*              short m,            // weighting factor       //            */
/*              short *restrict r,  // Result vector          //            */
/*              int nr              // Number of samples.     //            */
/*          );                                                              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*      The benchmark performs a weighted vector sum.  The elements         */
/*      of the x[] vector are weighted according to the Q15 value 'm',      */
/*      and then added to the corresponding elements of the y[] vector.     */
/*      The results are written to the r[] vector.                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      m is not -32768.                                                    */
/*  SOURCE                                                                  */
/*      DSPLIB.                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

void DSP_w_vec
(
    const short *x,     /* Vector being weighted  */
    const short *y,     /* Non-weighted vector    */
    short m,            /* weighting factor       */
    short *restrict r,  /* Result vector          */
    int nr              /* Number of samples.     */
)
{
    int i;

    for (i = 0; i < nr; i++)
        r[i] = ((m * x[i]) >> 15) + y[i];
}

/* ======================================================================== */
/*  End of file:  dsp_w_vec.c                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

