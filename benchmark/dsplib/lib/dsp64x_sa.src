!<arch>
autocor.sa/     1066929505  0     0     0       14437     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Fri Nov  1 19:10:30 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_autocor -- Autocorrelation                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSP_autocor                                                    *
*       (                                                                   *
*           short *restrict r,                                              *
*           const short *restrict x,                                        *
*           int          nx,                                                *
*           int          nr                                                 *
*       );                                                                  *
*                                                                           *
*       r[nr]   : Output array                                              *
*       x[nr+nx]: Input array. The first nr elements are assumed to be 0.   *
*                 Must be double-word aligned.                              *
*       nx      : Length of autocorrelation                                 *
*                 Must be a multiple of 8.                                  *
*       nr      : Number of lags                                            *
*                 Must be a multiple of 4.                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs an autocorrelation of an input vector         *
*       x. The length of the autocorrelation is nx samples. Since nr        *
*       such autocorrelations are performed, input vector x needs to be     *
*       of length nx + nr. This produces nr output results which are        *
*       stored in an output array r.                                        *
*                                                                           *
*       The following diagram illustrates how the correlations are          *
*       obtained.                                                           *
*                                                                           *
*       Example for nr=8, nx=24:                                            *
*       0       nr                  nx+nr-1                                 *
*       |-------|----------------------|  <- x[]                            *
*       |       |----------------------|  -> r[0]                           *
*       |      |----------------------|   -> r[1]                           *
*       |     |----------------------|    -> r[2]                           *
*       |    |----------------------|     -> r[3]                           *
*       |   |----------------------|      -> r[4]                           *
*       |  |----------------------|       -> r[5]                           *
*       | |----------------------|        -> r[6]                           *
*                                                                           *
*       Note that x[0] is never used, but is required for padding to make   *
*       x[nr] double-word aligned.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*       Loop coalescing is implemented and both loops are colesced          *
*       together. Separate copies of inner loop counter are made to         *
*       de-couple input loads and output stores. Double word wide loads     *
*       are used on the input data array.                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The first nr elements are assumed to be 0.                          *
*       nx is a multiple of 8                                               *
*       nr is a multiple of 4                                               *
*       x[] is double-word aligned                                          *
*       No alignment restrictions on r[]                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_autocor"
        .global _DSP_autocor
_DSP_autocor:   .cproc  A_r,  B_x,  A_nx,  B_nr

               .reg    B_nr_4,            A_nx_8,            A_i
               .reg    A_ik_rst,          B_lk_rst,          B_yptr_rst
               .reg    A_xptr,            A_ofs,             B_yptr
               .reg    A_ik,              B_lk,              A_rptr
               .reg    B_rptr

               ; Variables within loop

               .reg    A_sum_2:A_sum_0
               .reg    B_sum_3:B_sum_1
               .reg    B_xptr,            A_x3x2:A_x1x0,     B_x7x6:B_x5x4
               .reg    A_z0z1:A_z2z3,     A_y3y2:A_y1y0,     B_y7y6:B_y5y4
               .reg    A_z1z2,            A_y0z0,            A_y2y1
               .reg    B_y4y3,            B_y6y5,            A_prod0
               .reg    A_prod1,           B_prod2,           B_prod3
               .reg    A_prod4,           A_prod5,           B_prod6
               .reg    B_prod7,           A_prod8,           A_prod9
               .reg    B_prodA,           B_prodB,           A_prodC
               .reg    A_prodD,           B_prodE,           B_prodF
               .reg    A_s0,              B_s0,              A_t0
               .reg    B_t0,              A_u0,              B_u0
               .reg    A_v0,              B_v0,              A_temp0
               .reg    B_temp1,           A_temp2,           B_temp3
               .reg    A_sum0s,           B_sum1s,           A_sum2s
               .reg    B_sum3s,           A_xptr_rst

               .no_mdep

               SHRU.2      B_nr,              2,                 B_nr_4
               SHRU.1      A_nx,              3,                 A_nx_8
               MPY.1x      A_nx_8,            B_nr_4,            A_i

               MV.1        A_nx_8,             A_ik_rst
               MV.2x       A_nx_8,             B_lk_rst

               ADDAH.2     B_x,                B_nr,              B_yptr_rst
               MV.1x       B_yptr_rst,         A_xptr_rst


               ZERO.1      A_ik
               MV.2        B_lk_rst,           B_lk

               MV.1        A_r,                A_rptr
               ADD.2x      A_rptr,             2,                 B_rptr
               SUB.1       A_i,                2,                 A_i

               ZERO.1      A_sum_2:A_sum_0
               ZERO.2      B_sum_3:B_sum_1

               .mptr       A_xptr,             x+0,               16
               .mptr       B_xptr,             x+8,               16
               .mptr       B_yptr,             x+0,               16
               .mptr       A_rptr,             r+0,               8
               .mptr       B_rptr,             r+2,               8

LOOP:          .trip       4

[!A_ik]        MV.1        A_xptr_rst,          A_xptr
[!A_ik]        MV.2        B_yptr_rst,          B_yptr
[!A_ik]        SUB.2       B_yptr_rst,          8,                B_yptr_rst
[!A_ik]        MV.1        A_ik_rst,            A_ik
[ A_ik]        SUB.1       A_ik,                1,                A_ik


               ADD.2x      A_xptr,             8,                B_xptr

               LDDW.D1T1   *A_xptr++[2],       A_x3x2:A_x1x0
               LDDW.D2T2   *B_xptr++[2],       B_x7x6:B_x5x4

               LDDW.D2T1   *-B_yptr[1],        A_z0z1:A_z2z3
               LDDW.D2T1   *B_yptr++,          A_y3y2:A_y1y0
               LDDW.D2T2   *B_yptr++,          B_y7y6:B_y5y4

               PACKLH2.1   A_z0z1,             A_z2z3,           A_z1z2
               PACKLH2.1   A_y1y0,             A_z0z1,           A_y0z0
               PACKLH2.1   A_y3y2,             A_y1y0,           A_y2y1
               PACKLH2.2   B_y5y4,             A_y3y2,           B_y4y3
               PACKLH2.2   B_y7y6,             B_y5y4,           B_y6y5

               DOTP2.1     A_x1x0,             A_y1y0,           A_prod0
               DOTP2.1     A_x3x2,             A_y3y2,           A_prod1
               DOTP2.2     B_x5x4,             B_y5y4,           B_prod2
               DOTP2.2     B_x7x6,             B_y7y6,           B_prod3

               DOTP2.1     A_x1x0,             A_y0z0,           A_prod4
               DOTP2.1     A_x3x2,             A_y2y1,           A_prod5
               DOTP2.2     B_x5x4,             B_y4y3,           B_prod6
               DOTP2.2     B_x7x6,             B_y6y5,           B_prod7

               DOTP2.1     A_x1x0,             A_z0z1,           A_prod8
               DOTP2.1     A_x3x2,             A_y1y0,           A_prod9
               DOTP2.2     B_x5x4,             A_y3y2,           B_prodA
               DOTP2.2     B_x7x6,             B_y5y4,           B_prodB

               DOTP2.1     A_x1x0,             A_z1z2,           A_prodC
               DOTP2.1     A_x3x2,             A_y0z0,           A_prodD
               DOTP2.2     B_x5x4,             A_y2y1,           B_prodE
               DOTP2.2     B_x7x6,             B_y4y3,           B_prodF

               ADD.1       A_prod0,            A_prod1,          A_s0
               ADD.2       B_prod2,            B_prod3,          B_s0
               ADD.1       A_prod4,            A_prod5,          A_t0
               ADD.2       B_prod6,            B_prod7,          B_t0

               ADD.1       A_prod8,            A_prod9,          A_u0
               ADD.2       B_prodA,            B_prodB,          B_u0
               ADD.1       A_prodC,            A_prodD,          A_v0
               ADD.2       B_prodE,            B_prodF,          B_v0

               ADD.1       A_s0,               B_s0,             A_temp0
               ADD.2x      B_t0,               A_t0,             B_temp1
               ADD.1x      A_u0,               B_u0,             A_temp2
               ADD.2x      B_v0,               A_v0,             B_temp3

               ADD.1       A_sum_0,            A_temp0,          A_sum_0
               ADD.2       B_sum_1,            B_temp1,          B_sum_1
               ADD.1       A_sum_2,            A_temp2,          A_sum_2
               ADD.2       B_sum_3,            B_temp3,          B_sum_3

               SHR.1       A_sum_0,            15,               A_sum0s
               SHR.2       B_sum_1,            15,               B_sum1s
               SHR.1       A_sum_2,            15,               A_sum2s
               SHR.2       B_sum_3,            15,               B_sum3s

[B_lk]         SUB.2       B_lk,               1,                B_lk
[!B_lk]        STH.D1T1    A_sum0s,            *A_rptr++[2]
[!B_lk]        STH.D2T2    B_sum1s,            *B_rptr++[2]
[!B_lk]        STH.D1T1    A_sum2s,            *A_rptr++[2]
[!B_lk]        STH.D2T2    B_sum3s,            *B_rptr++[2]
[!B_lk]        ZERO.1      A_sum_2:A_sum_0
[!B_lk]        ZERO.2      B_sum_3:B_sum_1
[!B_lk]        MV.2        B_lk_rst,          B_lk

               BDEC.1      LOOP,              A_i

               .return
               .endproc

bexp.sa/        1066929505  0     0     0       10685     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.7     Fri Mar 29 20:21:21 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_bexp -- Block exponent of a vector                              *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           int DSP_bexp                                                    *
*           (                                                               *
*               const int *x,     /* Input Data         */                  *
*               unsigned   nx     /* Number of elements */                  *
*           );                                                              *
*                                                                           *
*       The DSP_bexp routine accepts a list of 'num' input points and       *
*       performs the determination of the block exponent.  It returns       *
*       the minimum number of "redundant sign bits" observed on the         *
*       block of data.                                                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The DSP_bexp function, performs a determination of the block        *
*       exponent of the vector of elements and returns the maximum          *
*       exponent.  This information can then be used to re-normalize        *
*       the vector.  This operation is useful when auto-scaling is          *
*       required as in a FFT.  The DSP_bexp operation returns the minimum   *
*       norm of the vector.  The minimum norm corresponds to the            *
*       maximum exponent.                                                   *
*                                                                           *
*   C CODE                                                                  *
*       The following is a general C code description of the algorithm      *
*       without restrictions.  This implementation may have restrictions    *
*       as noted under 'ASSUMPTIONS' below.                                 *
*                                                                           *
*       int DSP_bexp(const int *x, short nx)                                *
*       {                                                                   *
*           int i;                                                          *
*           int mask, mag;                                                  *
*                                                                           *
*           mask = 0;                                                       *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Merge the absolute values of all the elements       */      *
*           /*  together.  The leftmost bit-change on this mask     */      *
*           /*  gives us the magnitude we desire.                   */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < nx; i++)                                        *
*               mask |= x[i] ^ (x[i] >> 31);                                *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Find the magnitude of the mask.                     */      *
*           /* ---------------------------------------------------- */      *
*           for (mag = 0; (1 << mag) < mask; mag++)                         *
*               ;                                                           *
*                                                                           *
*           return 31 - mag;                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 8.                                                            *
*       nx % 8 == 0.                                                        *
*                                                                           *
*       The array 'x' is double-word aligned.                               *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_bexp"
        .global _DSP_bexp
_DSP_bexp    .cproc  A_x,    B_nx
            .no_mdep

            .reg    B_i, A_mag, B_x
            .reg    A_m, B_m, A_ms
            .reg    A_x7:A_x6, B_x5:B_x4
            .reg    A_a7,A_a6, B_a5,B_a4
            .reg    A_b7,A_b6, B_b5,B_b4
            .reg    A_x3:A_x2, B_x1:B_x0
            .reg    A_a3,A_a2, B_a1,B_a0
            .reg    A_b3,A_b2, B_b1,B_b0
            .reg    A_k31, B_k31

            MVK     .1      31,     A_k31
            MVK     .2      31,     B_k31
            SHRU    .2      B_nx,   3,      B_i
            SUB     .2      B_i,    2,      B_i
            ZERO            A_m
            ZERO            B_m
            ADD     .2X     A_x,    8,      B_x

            .mptr           A_x,    x + 0,  32
            .mptr           B_x,    x + 8,  32

loop:       .trip           2
            LDDW    .D2T1   *B_x  [2],      A_x7:A_x6
            LDDW    .D1T2   *A_x  [2],      B_x5:B_x4
            LDDW    .D2T1   *B_x++[4],      A_x3:A_x2
            LDDW    .D1T2   *A_x++[4],      B_x1:B_x0

            SSHVR   .1      A_x7,   A_k31,  A_a7
            SSHVR   .1      A_x6,   A_k31,  A_a6
            SSHVR   .2      B_x5,   B_k31,  B_a5
            SSHVR   .2      B_x4,   B_k31,  B_a4
            SSHVR   .1      A_x3,   A_k31,  A_a3
            SSHVR   .1      A_x2,   A_k31,  A_a2
            SSHVR   .2      B_x1,   B_k31,  B_a1
            SSHVR   .2      B_x0,   B_k31,  B_a0

            XOR     .1      A_x7,   A_a7,   A_b7
            XOR     .1      A_x6,   A_a6,   A_b6
            XOR     .2      B_x5,   B_a5,   B_b5
            XOR     .2      B_x4,   B_a4,   B_b4
            XOR     .1      A_x3,   A_a3,   A_b3
            XOR     .1      A_x2,   A_a2,   A_b2
            XOR     .2      B_x1,   B_a1,   B_b1
            XOR     .2      B_x0,   B_a0,   B_b0

            OR      .1      A_b7,   A_m,    A_m
            OR      .1      A_b6,   A_m,    A_m
            OR      .2      B_b5,   B_m,    B_m
            OR      .2      B_b4,   B_m,    B_m
            OR      .1      A_b3,   A_m,    A_m
            OR      .1      A_b2,   A_m,    A_m
            OR      .2      B_b1,   B_m,    B_m
            OR      .2      B_b0,   B_m,    B_m

            BDEC    .2      loop,   B_i

            OR      .1X     A_m,    B_m,    A_m
            NORM    .1      A_m,    A_mag

            .return         A_mag
            .endproc

* ========================================================================= *
*   End of file:  dsp_bexp.sa                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_eswap0.sa/  1066929505  0     0     0       7310      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Sun Aug 12 18:49:52 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap16 -- Endian-swap a block of 16-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap16                                            *
*           (                                                               *
*               void *restrict src,     /* Source data                 */   *
*               void *restrict dst,     /* Destination array           */   *
*               int  n_hwords           /* Number of halfwords to swap */   *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_hwords" argument gives the total length of the array, in     *
*       half-words.                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 8 half-words must be processed.          *
*                                                                           *
*   NOTES                                                                   *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_blk_eswap16"
        .global _DSP_blk_eswap16
_DSP_blk_eswap16 .cproc A_src, B_dst, A_n_words
        .no_mdep
        .reg B_x3:B_x2, A_x1:A_x0
        .reg B_y3:B_y2, A_y1:A_y0
        .reg A_i, B_src, A_dst

        SHR             A_n_words,  3,          A_i
        SUB             A_i,        2,          A_i
 [!B_dst]MV     .2X     A_src,      B_dst
        ADD     .2X     A_src,      8,          B_src
        ADD     .1X     B_dst,      8,          A_dst

        .mptr           A_src,      src,        16
        .mptr           B_src,      src + 8,    16
        .mptr           A_dst,      dst,        16
        .mptr           B_dst,      dst + 8,    16
loop:   .trip           1
        LDDW    .D1T2   *A_src++[2],            B_x3:B_x2
        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0
        SWAP4   .2      B_x3,       B_y3
        SWAP4   .2      B_x2,       B_y2
        SWAP4   .1      A_x1,       A_y1
        SWAP4   .1      A_x0,       A_y0
        STDW    .D2T2   B_y3:B_y2,  *B_dst++[2]
        STDW    .D1T1   A_y1:A_y0,  *A_dst++[2]
        BDEC            loop,       A_i

        .return
        .endproc
* ========================================================================= *
*   End of file:  dsp_blk_eswap16.sa                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_eswap1.sa/  1066929505  0     0     0       7482      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Aug 12 18:34:50 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap32 -- Endian-swap a block of 32-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap32                                            *
*           (                                                               *
*               void *restrict src,     /* Source data             */       *
*               void *restrict dst,     /* Destination array       */       *
*               int  n_words            /* Number of words to swap */       *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_words" argument gives the total length of the array.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 4 words must be processed.               *
*                                                                           *
*   NOTES                                                                   *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_blk_eswap32"
        .global _DSP_blk_eswap32
_DSP_blk_eswap32 .cproc A_src, B_dst, A_n_words
        .no_mdep
        .reg B_x3:B_x2, A_x1:A_x0
        .reg B_y3,B_y2, A_y1,A_y0
        .reg B_z3:B_z2, A_z1:A_z0
        .reg A_i, B_src, A_dst

        SHR             A_n_words,  2,          A_i
        SUB             A_i,        2,          A_i
 [!B_dst]MV     .2X     A_src,      B_dst
        ADD     .2X     A_src,      8,          B_src
        ADD     .1X     B_dst,      8,          A_dst

        .mptr           A_src,      src,        16
        .mptr           B_src,      src + 8,    16
        .mptr           A_dst,      dst,        16
        .mptr           B_dst,      dst + 8,    16
loop:   .trip           1
        LDDW    .D1T2   *A_src++[2],            B_x3:B_x2
        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0
        SWAP4   .2      B_x3,       B_y3
        SWAP4   .2      B_x2,       B_y2
        SWAP4   .1      A_x1,       A_y1
        SWAP4   .1      A_x0,       A_y0
        ROTL    .2      B_y3,       16,         B_z3
        ROTL    .2      B_y2,       16,         B_z2
        ROTL    .1      A_y1,       16,         A_z1
        ROTL    .1      A_y0,       16,         A_z0
        STDW    .D2T2   B_z3:B_z2,  *B_dst++[2]
        STDW    .D1T1   A_z1:A_z0,  *A_dst++[2]
        BDEC            loop,       A_i

        .return
        .endproc
* ========================================================================= *
*   End of file:  dsp_blk_eswap32.sa                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_eswap2.sa/  1066929505  0     0     0       7482      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Sun Aug 12 18:45:28 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap64 -- Endian-swap a block of 64-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap64                                            *
*           (                                                               *
*               void *restrict src, /* Source data                    */    *
*               void *restrict dst, /* Destination array              */    *
*               int  n_dbls         /* Number of double-words to swap */    *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_words" argument gives the total length of the array.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 2 double-words must be processed.        *
*                                                                           *
*   NOTES                                                                   *
*       n/a                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_blk_eswap64"
        .global _DSP_blk_eswap64
_DSP_blk_eswap64 .cproc A_src, B_dst, A_n_words
        .no_mdep
        .reg B_x3:B_x2, A_x1:A_x0
        .reg B_y3,B_y2, A_y1,A_y0
        .reg B_z2:B_z3, A_z0:A_z1
        .reg A_i, B_src, A_dst

        SHR             A_n_words,  1,          A_i
        SUB             A_i,        2,          A_i
 [!B_dst]MV     .2X     A_src,      B_dst
        ADD     .2X     A_src,      8,          B_src
        ADD     .1X     B_dst,      8,          A_dst

        .mptr           A_src,      src,        16
        .mptr           B_src,      src + 8,    16
        .mptr           A_dst,      dst,        16
        .mptr           B_dst,      dst + 8,    16
loop:   .trip           1
        LDDW    .D1T2   *A_src++[2],            B_x3:B_x2
        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0
        SWAP4   .2      B_x3,       B_y3
        SWAP4   .2      B_x2,       B_y2
        SWAP4   .1      A_x1,       A_y1
        SWAP4   .1      A_x0,       A_y0
        ROTL    .2      B_y3,       16,         B_z3
        ROTL    .2      B_y2,       16,         B_z2
        ROTL    .1      A_y1,       16,         A_z1
        ROTL    .1      A_y0,       16,         A_z0
        STDW    .D2T2   B_z2:B_z3,  *B_dst++[2]
        STDW    .D1T1   A_z0:A_z1,  *A_dst++[2]
        BDEC            loop,       A_i

        .return
        .endproc
* ========================================================================= *
*   End of file:  dsp_blk_eswap64.sa                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_move.sa/    1066929505  0     0     0       7543      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Tue Oct 14 20:05:25 2003 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_move -- Move block of memory (overlapping). Endian Neutral  *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Sep-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_blk_move(short *x, short *r, int nx);                      *
*                                                                           *
*           x  --- block of data to be moved                                *
*           r  --- destination of block of data                             *
*           nx --- number of elements in block                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       Move nx 16-bit elements from one memory location to another.        *
*       Source and destination may overlap.                                 *
*                                                                           *
*       void DSP_blk_move(short *x, short *r, int nx);                      *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           if (r < x)                                                      *
*           {                                                               *
*               for (i = 0 ; i < nx; i++)                                   *
*                   r[i] = x[i];                                            *
*           } else                                                          *
*           {                                                               *
*               for (i = nx-1 ; i >= 0; i--)                                *
*                   r[i] = x[i];                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx greater than or equal to 32                                      *
*       nx a multiple of 8                                                  *
*                                                                           *
*   TECHNIQUES                                                              *
*       Twin input and output pointers are used.                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_blk_move_ov"
        .global _DSP_blk_move
_DSP_blk_move: .cproc A_x,   B_r,   A_nx 

            .no_mdep
            .reg    A_in32:A_in10,  B_in76:B_in54,        A_count
            .reg    B_x,            A_r
            .reg    A_rev,          A_fix,      B_fix
            .reg    A_inc,          B_inc

            SHR.1       A_nx,       3,          A_count  ;count = nx/8
            SUB.1       A_count,    2,          A_count  ;count -= 2
            SHL.1       A_nx,       1,          A_fix
            SUB.2X      A_fix,      16,         B_fix
            SUB.1       A_fix,      16,         A_fix
            MVK.1       2,          A_inc
            MVK.2       2,          B_inc
            CMPGTU      B_r,        A_x,        A_rev
  [A_rev]   MVK.1       -2,         A_inc
  [A_rev]   MVK.2       -2,         B_inc
  [A_rev]   ADD         A_x,        A_fix,      A_x
  [A_rev]   ADD         B_r,        B_fix,      B_r

            ADD.2x      A_x,        8,          B_x      ;Twin inp.ptr
            ADD.1x      B_r,        8,          A_r      ;Twin out.ptr
            ;           ;           ;           ;
            .mptr       A_x, x+0,   16
            .mptr       B_x, x+8,   16
            .mptr       B_r, r+0,   16
            .mptr       A_r, r+8,   16
LOOP:
            LDDW.D1T1   *A_x++[A_inc],          A_in32:A_in10
            LDDW.D2T2   *B_x++[B_inc],          B_in76:B_in54
            STDW.D2T1   A_in32:A_in10,          *B_r++[B_inc]
            STDW.D1T2   B_in76:B_in54,          *A_r++[A_inc]
            BDEC.1      LOOP,       A_count

            .endproc

* ========================================================================= *
*   End of file:  blk_move_p.sa                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

dotp_sqr.sa/    1066929505  0     0     0       9080      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Fri Mar 29 20:12:48 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*    TEXAS INSTRUMENTS, INC.                                                *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotp_sqr                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and can be called as:                   *
*                                                                           *
*           int DSP_dotp_sqr                                                *
*           (                                                               *
*               int G,            /* Sum-of-y-squared initial value */      *
*               const short  *x,  /* First input array.             */      *
*               const short  *y,  /* Second input array.            */      *
*               int *restrict r,  /* Accumulation of x[] * y[].     */      *
*               int nx            /* Length of the input vector.    */      *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine computes the dot product of x[] and y[] arrays,        *
*       adding it to the value in the location pointed to by 'd'.           *
*                                                                           *
*       Additionally, it computes the sum of the squares of the terms       *
*       in the y[] array, adding it to the argument G.  The final value     *
*       of G is given as the return value of the function.  This value      *
*       is used by the VSELP vocoder.                                       *
*                                                                           *
*       The following C code is an implementation of the algorithm          *
*       without restrictions.  Optimized implementations may add            *
*       restrictions as noted under the heading "ASSUMPTIONS."              *
*                                                                           *
*       int DSP_dotp_sqr                                                    *
*       (                                                                   *
*           int G,            /* Sum-of-y-squared initial value */          *
*           const short  *x,  /* First input array.             */          *
*           const short  *y,  /* Second input array.            */          *
*           int *restrict r,  /* Accumulation of x[] * y[].     */          *
*           int nx            /* Length of the input vector.    */          *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               *r += x[i] * y[i];                                          *
*               G  += y[i] * y[i];                                          *
*           }                                                               *
*                                                                           *
*           return G;                                                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 12, nx % 4 == 0.                                              *
*                                                                           *
*   TECHNIQUES                                                              *
*       Unrolled 4 times to maximize multiplier utilization.                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_dotp_sqr"
        .global _DSP_dotp_sqr
_DSP_dotp_sqr: .cproc  A_g, B_x, A_y, B_d, A_nx 

        .no_mdep
        .reg    B_sum,  A_i
        .reg    B_x32:B_x10, A_y32:A_y10, B_p32, B_p10, A_s32, A_s10
                ;       ;           ;           ;           ;
        LDW     .D2T2   *B_d,       B_sum
        SHR             A_nx,       2,          A_i
        SUB             A_i,        2,          A_i

loop:   .trip           3
        LDNDW   .D2T2   *B_x++[1],  B_x32:B_x10
        LDNDW   .D1T1   *A_y++[1],  A_y32:A_y10
        DOTP2   .2X     B_x32,      A_y32,      B_p32
        DOTP2   .2X     B_x10,      A_y10,      B_p10
        ADD             B_p32,      B_sum,      B_sum
        ADD             B_p10,      B_sum,      B_sum

        DOTP2   .1      A_y32,      A_y32,      A_s32
        DOTP2   .1      A_y10,      A_y10,      A_s10
        ADD             A_s32,      A_g,        A_g
        ADD             A_s10,      A_g,        A_g

        BDEC            loop,       A_i

        STW             B_sum,      *B_d

        .return         A_g

        .endproc

* ========================================================================= *
*   End of file:  dsp_dotp_sqr.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
dotprod.sa/     1066929505  0     0     0       8012      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Fri Mar 29 15:29:12 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotprod                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       int DSP_dotprod                                                     *
*       (                                                                   *
*           const short *m,       /* Pointer to first vector  */            *
*           const short *n,       /* Pointer to second vector */            *
*           int          count    /* Length of vectors.       */            *
*       );                                                                  *
*                                                                           *
*       This routine returns the dot product as its return value.           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The "DSP_dotprod" function implements a dot product of two input    *
*       vectors, returning the scalar result.  Each element of the          *
*       first array is multiplied with the corresponding element of the     *
*       second array, and the products are summed.  The sum is returned.    *
*                                                                           *
*       int DSP_dotprod                                                     *
*       (                                                                   *
*           const short *m,       /* Pointer to first vector  */            *
*           const short *n,       /* Pointer to second vector */            *
*           int          count    /* Length of vectors.       */            *
*       )                                                                   *
*       {                                                                   *
*           int i, sum = 0;                                                 *
*                                                                           *
*           for (i = 0; i < count; i++)                                     *
*               sum += m[i] * n[i];                                         *
*                                                                           *
*           return sum;                                                     *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has some restrictions, as          *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 4 times to enable full memory and multiplier   *
*       bandwidth to be utilized.                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input length is a multiple of 4 and greater than 0.             *
*                                                                           *
*       The input data and coeeficients are stored on double word           *
*       aligned boundaries.                                                 *
*                                                                           *
* ========================================================================= *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_dotprod"
        .global _DSP_dotprod
_DSP_dotprod: .cproc     A_m, B_n, A_count
             .no_mdep
             .reg   A_reg1:A_reg0, B_reg1:B_reg0
             .reg   A_prod, B_prod, A_sum, B_sum, A_i

             ZERO        A_sum
             ZERO        B_sum
             SHRU        A_count, 2,      A_i
             SUB         A_i,     2,      A_i

             .mptr       A_m,     x + 0,  8
             .mptr       B_n,     x + 8,  8
loop:        .trip  8

             LDDW  .1    *A_m++,  A_reg1:A_reg0
             LDDW  .2    *B_n++,  B_reg1:B_reg0
             DOTP2       A_reg1,  B_reg1, A_prod
             DOTP2       B_reg0,  A_reg0, B_prod
             ADD         A_sum,   A_prod, A_sum
             ADD         B_sum,   B_prod, B_sum
             BDEC        loop,    A_i

             ADD         A_sum,   B_sum,  A_sum

             .return  A_sum
             .endproc

* ========================================================================= *
*   End of file:  dsp_dotprod.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fft.sa/         1066929505  0     0     0       72247     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Thu Aug 30 14:33:52 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fft                                                             *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fft(const short *w, int nsamp, short *x, short *y);        *
*                                                                           *
*       nsamp = length of DSP_fft in complex samples                        *
*       x     = pointer to complex data input, time domain                  *
*       w     = pointer to complex twiddle factors                          *
*       y     = pointer to complex data output, frequency domain            *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs a Radix-4 FFT with digit reversal.  The code     *
*       uses a special ordering of twiddle factors and memory accesses      *
*       to improve performance in the presence of cache.  It operates       *
*       largely in-place, but the final digit-reversed output is written    *
*       out-of-place.                                                       *
*                                                                           *
*       This code requires a special sequence of twiddle factors stored     *
*       in Q.15 fixed-point format.  The following C code illustrates       *
*       one way to generate the desired twiddle-factor array:               *
*                                                                           *
*       #include <math.h>                                                   *
*                                                                           *
*       #ifndef PI                                                          *
*       # define PI (3.14159265358979323846)                                *
*       #endif                                                              *
*                                                                           *
*       short d2s(double d)                                                 *
*       {                                                                   *
*           d = floor(0.5 + d);  /* Explicit rounding to integer */         *
*           if (d >=  32767.0) return  32767;                               *
*           if (d <= -32768.0) return -32768;                               *
*           return (short)d;                                                *
*       }                                                                   *
*                                                                           *
*       void gen_twiddle(short *w, int n)                                   *
*       {                                                                   *
*           double M = 32767.5;                                             *
*           int i, j, k;                                                    *
*                                                                           *
*           for (j = 1, k = 0; j < n >> 2; j = j << 2)                      *
*           {                                                               *
*               for (i = 0; i < n >> 2; i += j << 1)                        *
*               {                                                           *
*                   w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       *
*                   w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       *
*                   w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       *
*                   w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       *
*                   w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       *
*                   w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       *
*                   w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       *
*                   w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       *
*                   w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       *
*                   w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       *
*                                                                           *
*                   k += 12;                                                *
*               }                                                           *
*           }                                                               *
*           w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   *
*           w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       n must be a power of 4 and n >= 16 & n < 32768.                     *
*       FFT data x are aligned on a double word boundary, in real/imag      *
*       pairs, FFT twiddle factors w are also aligned on a double word      *
*       boundary in real/imaginary pairs.                                   *
*                                                                           *
*       Input FFT coeffs. are in signed Q.15 format.                        *
*       The memory Configuration is LITTLE ENDIAN.                          *
*       The complex data will be returned in natural order.                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflict stalls occur in this code.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       A special sequence of coefficients. are used (as generated above)   *
*       to produce the DSP_fft. This collapses the inner 2 loops in the     *
*       taditional Burrus and Parks implementation Fortran Code.            *
*                                                                           *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in         *
*       normal order and produces the outputs in normal order.              *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
* ------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
* ------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The DSP_fft() code shown here performs the bulk of the computation  *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using _dotpn2           *
*       after the twiddle factors are swizzled within the half word.        *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without restrictions: *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
* void DSP_fft(short *ptr_w, int n, short *ptr_x, short *ptr_y)             *
* {                                                                         *
*    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;             *
*    short xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;                        *
*    short xt0_1, yt0_1, xt1_1, yt1_1, xt2_1, yt2_1;                        *
*    short xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;      *
*    short xh0_1, xh1_1, xh20_1, xh21_1, xl0_1, xl1_1, xl20_1, xl21_1;      *
*    short x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l1_2, x_l1_3, x_l2_0:      *
*    short x_10, x_11, x_12, x_13, x_14, x_15, x_16, x_17, x_l2_1, x_h2_3;  *
*    short x_4, x_5, x_6, x_7, x_l2_2, x_l2_3, x_h2_0, x_h2_1, x_h2_2;      *
*    short si10, si20, si30, co10, co20, co30;                              *
*    short si11, si21, si31, co11, co21, co31;                              *
*    short * x, *w, * x2, * x0;                                             *
*    short * y0, * y1, * y2, *y3;                                           *
*                                                                           *
*    stride = n; -* n is the number of complex samples *-                   *
*    tw_offset = 0;                                                         *
*    while (stride > 4)  /* for all strides > 4 */                          *
*    {                                                                      *
*        j = 0;                                                             *
*        fft_jmp = stride + (stride>>1);                                    *
*        h2 = stride>>1;                          /* n/4 */                 *
*        l1 = stride;                             /* n/2 */                 *
*        l2 = stride + (stride>>1);               /* 3n/4 */                *
*        x = ptr_x;                                                         *
*        w = ptr_w + tw_offset;                                             *
*        tw_offset += fft_jmp;                                              *
*        stride = stride>>2;                                                *
*                                                                           *
*        for (i = 0; i < n>>1; i += 4)                                      *
*        {                                                                  *
*            co10 = w[j+1];    si10 = w[j+0];   /* W  */                    *
*            co11 = w[j+3];    si11 = w[j+2];                               *
*            co20 = w[j+5];    si20 = w[j+4];   /* W^2 */                   *
*            co21 = w[j+7];    si21 = w[j+6];                               *
*            co30 = w[j+9];    si30 = w[j+8];   /* W^3 */                   *
*            co31 = w[j+11];   si31 = w[j+10];                              *
*                                                                           *
*            x_0 = x[0];       x_1 = x[1];         /* perform 2 parallel */ *
*            x_2 = x[2];       x_3 = x[3];         /* radix4 butterflies */ *
*                                                                           *
*            x_l1_0 = x[l1  ]; x_l1_1 = x[l1+1];                            *
*            x_l1_2 = x[l1+2]; x_l1_3 = x[l1+3];                            *
*                                                                           *
*            x_l2_0 = x[l2  ]; x_l2_1 = x[l2+1];                            *
*            x_l2_2 = x[l2+2]; x_l2_3 = x[l2+3];                            *
*                                                                           *
*            x_h2_0 = x[h2  ]; x_h2_1 = x[h2+1];                            *
*            x_h2_2 = x[h2+2]; x_h2_3 = x[h2+3];                            *
*                                                                           *
*            xh0_0  = x_0    + x_l1_0; xh1_0  = x_1    + x_l1_1;            *
*            xh0_1  = x_2    + x_l1_2; xh1_1  = x_3    + x_l1_3;            *
*                                                                           *
*            xl0_0  = x_0    - x_l1_0; xl1_0  = x_1    - x_l1_1;            *
*            xl0_1  = x_2    - x_l1_2; xl1_1  = x_3    - x_l1_3;            *
*                                                                           *
*            xh20_0 = x_h2_0 + x_l2_0; xh21_0 = x_h2_1 + x_l2_1;            *
*            xh20_1 = x_h2_2 + x_l2_2; xh21_1 = x_h2_3 + x_l2_3;            *
*                                                                           *
*            xl20_0 = x_h2_0 - x_l2_0; xl21_0 = x_h2_1 - x_l2_1;            *
*            xl20_1 = x_h2_2 - x_l2_2; xl21_1 = x_h2_3 - x_l2_3;            *
*                                                                           *
*            x0 = x;                                                        *
*            x2 = x0;                 /* copy pointers for output*/         *
*                                                                           *
*            j += 12;                                                       *
*            x += 4;                                                        *
*            predj = (j - fft_jmp);   /* check if reached end of */         *
*            if (!predj) x += fft_jmp;/* current twiddle factor section */  *
*            if (!predj) j = 0;                                             *
*                                                                           *
*            x0[0] = xh0_0 + xh20_0; x0[1] = xh1_0 + xh21_0;                *
*            x0[2] = xh0_1 + xh20_1; x0[3] = xh1_1 + xh21_1;                *
*                                                                           *
*            xt0_0 = xh0_0 - xh20_0;  yt0_0 = xh1_0 - xh21_0;               *
*            xt0_1 = xh0_1 - xh20_1;  yt0_1 = xh1_1 - xh21_1;               *
*                                                                           *
*            xt1_0 = xl0_0 + xl21_0;  yt2_0 = xl1_0 + xl20_0;               *
*            xt2_0 = xl0_0 - xl21_0;  yt1_0 = xl1_0 - xl20_0;               *
*            xt1_1 = xl0_1 + xl21_1;  yt2_1 = xl1_1 + xl20_1;               *
*            xt2_1 = xl0_1 - xl21_1;  yt1_1 = xl1_1 - xl20_1;               *
*                                                                           *
*            x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0) >> 15;                *
*            x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0) >> 15;                *
*                                                                           *
*            x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1) >> 15;                *
*            x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1) >> 15;                *
*                                                                           *
*            x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0) >> 15;                *
*            x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0) >> 15;                *
*                                                                           *
*            x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1) >> 15;                *
*            x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1) >> 15;                *
*                                                                           *
*            x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0) >> 15;                *
*            x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0) >> 15;                *
*                                                                           *
*            x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1) >> 15;                *
*            x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1) >> 15;                *
*        }                                                                  *
*    }-* end while *-                                                       *
*                                                                           *
*    y0 = ptr_y;                                                            *
*    y1 = y0 + (int)(n>>1);                                                 *
*    y2 = y1 + (int)(n>>1);                                                 *
*    y3 = y2 + (int)(n>>1);                                                 *
*    x0 = ptr_x;                                                            *
*    x2 = ptr_x + (int)(n>>1);                                              *
*    l1 = _norm(n) + 2;                                                     *
*    j = 0;                                                                 *
*    for (i = 0; i < n; i += 8)                                             *
*    {                                                                      *
*        h2 = _deal(j);                                                     *
*        h2 = _bitr(h2);                                                    *
*        h2 = _rotl(h2, 16);                                                *
*        h2 = _shfl(h2);                                                    *
*        h2 >>= l1;                                                         *
*                                                                           *
*        x_0 = x0[0]; x_1 = x0[1];                                          *
*        x_2 = x0[2]; x_3 = x0[3];                                          *
*        x_4 = x0[4]; x_5 = x0[5];                                          *
*        x_6 = x0[6]; x_7 = x0[7];                                          *
*        x0 += 8;                                                           *
*                                                                           *
*        xh0_0  = x_0 + x_4; xh1_0  = x_1 + x_5;                            *
*        xl0_0  = x_0 - x_4; xl1_0  = x_1 - x_5;                            *
*        xh20_0 = x_2 + x_6; xh21_0 = x_3 + x_7;                            *
*        xl20_0 = x_2 - x_6; xl21_0 = x_3 - x_7;                            *
*                                                                           *
*        xt0_0 = xh0_0 - xh20_0;                                            *
*        yt0_0 = xh1_0 - xh21_0;                                            *
*        xt1_0 = xl0_0 + xl21_0;                                            *
*        yt2_0 = xl1_0 + xl20_0;                                            *
*        xt2_0 = xl0_0 - xl21_0;                                            *
*        yt1_0 = xl1_0 - xl20_0;                                            *
*                                                                           *
*        y0[2*h2  ] = xh0_0 + xh20_0;                                       *
*        y0[2*h2+1] = xh1_0 + xh21_0;                                       *
*        y1[2*h2  ] = xt1_0;                                                *
*        y1[2*h2+1] = yt1_0;                                                *
*        y2[2*h2  ] = xt0_0;                                                *
*        y2[2*h2+1] = yt0_0;                                                *
*        y3[2*h2  ] = xt2_0;                                                *
*        y3[2*h2+1] = yt2_0;                                                *
*                                                                           *
*        x_10 = x2[0]; x_11 = x2[1];                                        *
*        x_12 = x2[2]; x_13 = x2[3];                                        *
*        x_14 = x2[4]; x_15 = x2[5];                                        *
*        x_16 = x2[6]; x_17 = x2[7];                                        *
*        x2 += 8;                                                           *
*                                                                           *
*        xh0_1  = x_10 + x_14; xh1_1  = x_11 + x_15;                        *
*        xl0_1  = x_10 - x_14; xl1_1  = x_11 - x_15;                        *
*        xh20_1 = x_12 + x_16; xh21_1 = x_13 + x_17;                        *
*        xl20_1 = x_12 - x_16; xl21_1 = x_13 - x_17;                        *
*                                                                           *
*        xt0_1 = xh0_1 - xh20_1;                                            *
*        yt0_1 = xh1_1 - xh21_1;                                            *
*        xt1_1 = xl0_1 + xl21_1;                                            *
*        yt2_1 = xl1_1 + xl20_1;                                            *
*        xt2_1 = xl0_1 - xl21_1;                                            *
*        yt1_1 = xl1_1 - xl20_1;                                            *
*                                                                           *
*        y0[2*h2+2] = xh0_1 + xh20_1;                                       *
*        y0[2*h2+3] = xh1_1 + xh21_1;                                       *
*        y1[2*h2+2] = xt1_1;                                                *
*        y1[2*h2+3] = yt1_1;                                                *
*        y2[2*h2+2] = xt0_1;                                                *
*        y2[2*h2+3] = yt0_1;                                                *
*        y3[2*h2+2] = xt2_1;                                                *
*        y3[2*h2+3] = yt2_1;                                                *
*                                                                           *
*        j += 4;                                                            *
*        if (j == n>>2)                                                     *
*        {                                                                  *
*          j  += n>>2;                                                      *
*          x0 += (int) n>>1;                                                *
*          x2 += (int) n>>1;                                                *
*        }                                                                  *
*      }                                                                    *
*  }                                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .sect ".text:_fft"
        .global _DSP_fft
_DSP_fft:     .cproc   A_ptr_w, B_n, A_ptr_x, B_ptr_y
             .no_mdep
*============================================================================*
        .reg    A_j,      B_w0,       A_w0,     A_w1
        .reg    B_w2,     B_x,        B_j,      A_i
        .reg    B_h2

        .reg    B_l1,     B_l2,       A_h2,     A_l1
        .reg    A_l2

        .reg    A_co11_si11:A_co10_si10
        .reg    B_co21_si21:B_co20_si20
        .reg    B_co31_si31:B_co30_si30

        .reg    B_xl1_3_xl1_2:B_xl1_1_xl1_0
        .reg    A_xh2_3_xh2_2:A_xh2_1_xh2_0
        .reg    B_xl2_3_xl2_2:B_xl2_1_xl2_0

        .reg    B_xh0_0_xh0_0,        B_xh1_0_xh0_0
        .reg    A_xl1_0_xl0_0,        B_xh1_1_xh0_1
        .reg    A_xl1_1_xl0_1,        A_xl0_0_xl1_0
        .reg    B_xh21_0_xh20_0,      B_xh21_1_xh20_1
        .reg    A_xl21_0_xl20_0,      A_xl21_1_xl20_1

        .reg    A_x1,       B_x1,      A_x_,   A_x__
        .reg    A_fft_jmp,  B_fft_jmp
        .reg    A_ifj, B_ifi
        .reg    A_x_3_x_2:A_x_1_x_0
        .reg    B_x_3_x_2:B_x_1_x_0

        .reg    A_xl20_0_xl21_0,     A_xl20_1_xl21_1
        .reg    A_yt2_0_xt1_0,       A_yt1_0_xt2_0
        .reg    A_yt2_1_xt1_1,       A_yt1_1_xt2_1
        .reg    A_xt1_0_yt1_0,       A_xt2_0_yt2_0
        .reg    A_xt1_1_yt1_1,       A_xt2_1_yt2_1
        .reg    B_xt0_0_yt0_0,       B_xt0_1_yt0_1
        .reg    A_yt1_0_xt1_0,       A_yt1_1_xt1_1
        .reg    A_yt2_0_xt2_0,       A_yt2_1_xt2_1
        .reg    A_xh1_0_xh0_0,       A_xh21_0_xh20_0
        .reg    A_xt1_0_yt2_0,       A_xt2_0_yt1_0
        .reg    A_x_h2_0,            A_x_h2_1
        .reg    A_x_h2_2,            A_x_h2_3
        .reg    B_x_l1_1,            B_x_l1_0
        .reg    B_x_l1_2,            B_x_l1_3
        .reg    B_x_l2_0,            B_x_l2_1
        .reg    B_x_l2_2,            B_x_l2_3

        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0

        .reg    A_tw_offset,         B_stride
        .reg    B_stride_1,          B_while
        .reg    B_c10,               A_x0
        .reg    A_xo2,               B_xo3
        .reg    B_x7x6:B_x5x4,       B_x3x2:B_x1x0
        .reg    A_x7x6:A_x5x4,       A_x3x2:A_x1x0
        .reg    B_y9y8:B_y1y0
        .reg    A_yfye:A_y7y6,       A_ybya:A_y3y2

        .reg    B_yt0_1_xt0_1:B_yt0_0_xt0_0

        .reg    B_fft_jmp_1,         B_xl21_1_xl20_1
        .reg    A_xbxa:A_x9x8,       B_xfxe:B_xdxc
        .reg    A_yt0_0_xt0_0,       A_xt2_1_yt1_1
        .reg    B_xl1_1_xl0_1,       A_xl0_1_xl1_1
        .reg    A_xt1_1_yt2_1
        .reg    A_n,                 B_x0
        .reg    A_n_2,               B_nm2
        .reg    B_y0,                B_y1
        .reg    B_y2,                B_y3
        .reg    B_h0,                B_h1
        .reg    B_h3,                B_h4
*============================================================================*

        ;----------------------------------------------------------;
        ; Initially set stride = n. The "tw_offset" is set to zero ;
        ; and is the offset that is added to the twiddle factor    ;
        ; pointer "ptr_w" for the current iteration. At the start  ;
        ; of the program "tw_offset" is 0.                         ;
        ;----------------------------------------------------------;

        MV.2       B_n,             B_stride                      ;  n
        ZERO.1     A_tw_offset                                    ;  0


LOOP_WHILE:                                                       ; while

        ;---------------------------------------------------------;
        ; "j" is an index into the twiddle factor array. At the   ;
        ; start of every iteration of the outer loop, it is re    ;
        ; set to zero.                                            ;
        ;---------------------------------------------------------;

        ZERO.1     A_j                                            ; j = 0
        ZERO.2     B_j                                            ; j = 0

        ;---------------------------------------------------------;
        ; For every iteration of the inner loop, 6 * stride,      ;
        ; twiddle factors are loaded, where half of them are      ;
        ; cosines and the other half are sines. Since the data    ;
        ; is being accessed as double words. The fft_jmp is       ;
        ; set to fft_jmp/8                                        ;
        ;---------------------------------------------------------;

        SHL.2      B_stride,        1,              B_stride_1    ; 2 *stride
        ADD.2      B_stride,        B_stride_1,     B_fft_jmp     ; 3 * stride
        SHRU.2     B_fft_jmp,       3,              A_fft_jmp     ; stride/8

        ;---------------------------------------------------------;
        ; Input data offsets are set for double words             ;
        ; h2: loads &x[N/2] where x is a short array, hence its   ;
        ; double word offset is N/8. Similar argument holds for   ;
        ; l1 and l2.                                              ;
        ;---------------------------------------------------------;

        SHRU.2     B_stride,        3,              B_h2          ; x[N/2]
        SHRU.2     B_stride,        2,              B_l1          ; x[N]
        ADD.2      B_l1,            B_h2,           B_l2          ; x[3N/2]

        MV.1x      B_l1,            A_l1                          ; copy
        MV.1x      B_h2,            A_h2                          ; copy
        MV.1x      B_l2,            A_l2                          ; copy

        MV.2x      A_ptr_x,         B_x                           ; x = ptr_x
        ADDAH.1    A_ptr_w,         A_tw_offset,    A_w0          ; +tw_offset

        MV.2x      A_w0,            B_w0                          ; Twin ptrs
        ADD.1      A_w0,            8,              A_w1          ; to twiddle
        ADD.2x     A_w1,            8,              B_w2          ; factor array

        SHRU.2     B_fft_jmp,       1,              B_fft_jmp_1   ;
        ADD.1x     A_tw_offset,     B_fft_jmp_1,    A_tw_offset   ;+= fft_jmp

        ;---------------------------------------------------------;
        ; The stride is quartered with every iteration of the     ;
        ; outer loop until stride = 4.                            ;
        ;---------------------------------------------------------;

        SHRU.2     B_stride,        2,              B_stride      ;stride >> 2

        SUB.1      A_fft_jmp,       3,              A_fft_jmp     ;

        ;---------------------------------------------------------;
        ; The following loop iterates for N/8 iterations. Since   ;
        ; BDEC is used 2 needs to be subtracted from the loop     ;
        ; counter A_i.                                            ;
        ;---------------------------------------------------------;

        SHRU.1x    B_n,             3,              A_i           ; n >> 3
        SUB.1      A_i,             2,              A_i           ; i -= 2

        ;---------------------------------------------------------;
        ; Since the stride amount across iterations is variable,  ;
        ; it is tough to put an exact stride. However for this    ;
        ; loop stride is guranteed to be greater than or equal    ;
        ; to 16 complex samples, 32 half words. Since this str-   ;
        ; ide is wider than the bank width, of all the banks,     ;
        ; stride is specified as zero.                            ;
        ;---------------------------------------------------------;


        .mptr      B_w0,   x+0,     0
        .mptr      A_w1,   x+2,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_,   x+0,     0

LOOP_Y: .trip  3
        ;---------------------------------------------------------;
        ; Load three twiddle factors for the first radix4 butter- ;
        ; fly, and the next three twiddle factors for the second  ;
        ; radix4 butterfly.                                       ;
        ; si10=w[0]   co10=w[1]    si11=w[2]   co11=w[3]          ;
        ; si20=w[4]   co20=w[5]    si21=w[6]   co21=w[7]          ;
        ; si30=w[8]   co30=w[9]    si31=w[a]   co31=w[b]          ;
        ;---------------------------------------------------------;



        LDDW.D2T1  *B_w0[B_j],       A_co11_si11:A_co10_si10
        LDDW.D1T2  *A_w1[A_j],       B_co21_si21:B_co20_si20
        LDDW.D2T2  *B_w2[B_j],       B_co31_si31:B_co30_si30

        ;---------------------------------------------------------;
        ; Load the complex input data for the first radix4 bfly.  ;
        ; x[0]    x[1]    x[2]    x[3]                            ;
        ; x[h2+0] x[h2+1] x[h2+2] x[h2+3]                         ;
        ; x[l1+0] x[l1+1] x[l1+2] x[l1+3]                         ;
        ; x[l2+0] x[l2+1] x[l2+2] x[l2+3]                         ;
        ; These loads cannot parallelize as they could have bank  ;
        ; conflicts.                                              ;
        ;---------------------------------------------------------;

        LDDW.D2T1  *B_x[0],          A_x_3_x_2:A_x_1_x_0
        LDDW.D2T1  *B_x[B_h2],       A_xh2_3_xh2_2:A_xh2_1_xh2_0
        LDDW.D2T2  *B_x[B_l1],       B_xl1_3_xl1_2:B_xl1_1_xl1_0
        LDDW.D2T2  *B_x[B_l2],       B_xl2_3_xl2_2:B_xl2_1_xl2_0

        ;--------------------------------------------------------;
        ; Perform radix2 style DIF equations on input data       ;
        ; The subscript "h" refers to high and "l" refers to low ;
        ; xh0_0  =  x[0] + x[l1]    xh1_0  =  x[1] + x[l1+1]     ;
        ; xh0_1  =  x[2] + x[l1+2]  xh1_1  =  x[3] + x[l1+3]     ;
        ; xl0_0  =  x[0] - x[l1]    xl1_0  =  x[1] - x[l1+1]     ;
        ; xl0_1  =  x[2] - x[l1+2]  xl1_1  =  x[3] - x[l1+3]     ;
        ;--------------------------------------------------------;

        ADD2.2x    B_xl1_1_xl1_0,    A_x_1_x_0,      B_xh1_0_xh0_0
        ADD2.2x    B_xl1_3_xl1_2,    A_x_3_x_2,      B_xh1_1_xh0_1

        SUB2.1x    A_x_1_x_0,        B_xl1_1_xl1_0,  A_xl1_0_xl0_0
        SUB2.1x    A_x_3_x_2,        B_xl1_3_xl1_2,  A_xl1_1_xl0_1

        ;--------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]   xh21_0 = x[h2+1] + x[l2+1];
        ; xh20_1 = x[h2+2] + x[l2+2]   xh21_1 = x[h2+3]+x[l2+3]  ;
        ;--------------------------------------------------------;

        ADD2.2x    B_xl2_1_xl2_0,    A_xh2_1_xh2_0,  B_xh21_0_xh20_0
        ADD2.2x    B_xl2_3_xl2_2,    A_xh2_3_xh2_2,  B_xh21_1_xh20_1

        ;--------------------------------------------------------;
        ; xl20_0 = x[h2  ] - x[l2  ];  xl21_0 = x[h2+1] - x[l2+1];
        ; xl20_1 = x[h2+2] - x[l2+2];  xl21_1 = x[h2+3] - x[l2+3];
        ;--------------------------------------------------------;

        SUB2.1x    A_xh2_1_xh2_0,    B_xl2_1_xl2_0,  A_xl21_0_xl20_0
        SUB2.1x    A_xh2_3_xh2_2,    B_xl2_3_xl2_2,  A_xl21_1_xl20_1

        ;---------------------------------------------------------;
        ; Make copies of the input pointer so that stores take    ;
        ; place. Use the delayed move instruction to avoid live   ;
        ; too longs.                                              ;
        ;---------------------------------------------------------;

        MVD.1x     B_x,              A_x_
        MVD.1      A_x_,             A_x__

        ;---------------------------------------------------------;
        ; Check if the current twiddle factor sub-table has been  ;
        ; exhausted. If so reest twiddle factor index to zero,    ;
        ; and increment the data pointer by the "fft_jmp" so      ;
        ; that the data elements that re-use the twiddle factor   ;
        ; may be loaded.                                          ;
        ;                                                         ;
        ; if (!(j - fft_jmp))                                     ;
        ; {                                                       ;
        ;     j += 12 shorts;                                     ;
        ;     x += fft_jmp;                                       ;
        ;     j = 0;                                              ;
        ; }                                                       ;
        ;     x += 4(shorts)                                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; Since the twiddle factor array is loaded in as doubles  ;
        ; the increment by 12 shorts is done as an add by 3, as   ;
        ; the load double word scales this offset by 4.           ;
        ;---------------------------------------------------------;

        SUB.1      A_fft_jmp,        A_j,               A_ifj
        ADD.1      A_j,              3,                 A_j
        ADD.2      B_j,              3,                 B_j

        ;----------------------------------------------------------;
        ; If j equals fft_jmp, then the data pointer is incr-      ;
        ; emented by this amount, so that twiddle factors can be   ;
        ; re-used.                                                 ;
        ;----------------------------------------------------------;

[!A_ifj]ADD.2      B_x,              B_fft_jmp,         B_x
[!A_ifj]ZERO.2     B_j
[!A_ifj]ZERO.1     A_j

        ;----------------------------------------------------------;
        ; The input pointer needs to be incremented by 4 shorts or ;
        ; 8 bytes.                                                 ;
        ;----------------------------------------------------------;

        ADD.2      B_x,              8,                 B_x


        ;----------------------------------------------------------;
        ; Compute first set of outputs:                            ;
        ;                                                          ;
        ;  x0[0]= xh0_0 + xh20_0     x0[1] = xh1_0 + xh21_0        ;
        ;----------------------------------------------------------;

        ADD2.2    B_xh21_0_xh20_0, B_xh1_0_xh0_0, B_x_1_x_0

        ;----------------------------------------------------------;
        ; Compute first output for second butterfly:               ;
        ;                                                          ;
        ; x0[2] = xh0_1 + xh20_1   x0[3] = xh1_1 + xh21_1          ;
        ;----------------------------------------------------------;

        ADD2.2    B_xh21_1_xh20_1, B_xh1_1_xh0_1, B_x_3_x_2

        ;----------------------------------------------------------;
        ; perform the store as a double word                       ;
        ; x[0], x[1], x[2], x[3] = (^)                             ;
        ;----------------------------------------------------------;

        STDW.D1T2 B_x_3_x_2:B_x_1_x_0, *A_x_[0]

        ;----------------------------------------------------------;
        ; xt0_0 = xh0_0 - xh20_0  yt0_0 = xh1_0 - xh21_0           ;
        ; xt0_1 = xh0_1 - xh20_1  yt0_1 = xh1_1 - xh21_1           ;
        ;----------------------------------------------------------;

        SUB2.2     B_xh1_0_xh0_0,   B_xh21_0_xh20_0,   B_yt0_0_xt0_0
        SUB2.2     B_xh1_1_xh0_1,   B_xh21_1_xh20_1,   B_yt0_1_xt0_1

        ;----------------------------------------------------------;
        ; Perform a halfword swizzle so that xl0 can be combined   ;
        ; with xl21, xl1 can be combined with xl20. This is a      ;
        ; reult of the multiplication by the j term                ;
        ;----------------------------------------------------------;

        PACKLH2.1  A_xl21_0_xl20_0, A_xl21_0_xl20_0, A_xl20_0_xl21_0
        PACKLH2.1  A_xl21_1_xl20_1, A_xl21_1_xl20_1, A_xl20_1_xl21_1

        ;----------------------------------------------------------;
        ; xt1_0 = xl0_0 + xl21_0   yt2_0 = xl1_0 + xl20_0          ;
        ; xt1_1 = xl0_1 + xl21_1   yt2_1 = xl1_1 + xl20_1          ;
        ; xt2_0 = xl0_0 - xl21_0   yt1_0 = xl1_0 - xl20_0          ;
        ; xt2_1 = xl0_1 - xl21_1   yt1_1 = xl1_1 - xl20_1          ;
        ;----------------------------------------------------------;

        ADD2.1     A_xl1_0_xl0_0,  A_xl20_0_xl21_0,  A_yt2_0_xt1_0
        ADD2.1     A_xl1_1_xl0_1,  A_xl20_1_xl21_1,  A_yt2_1_xt1_1
        SUB2.1     A_xl1_0_xl0_0,  A_xl20_0_xl21_0,  A_yt1_0_xt2_0
        SUB2.1     A_xl1_1_xl0_1,  A_xl20_1_xl21_1,  A_yt1_1_xt2_1

        ;----------------------------------------------------------;
        ; Since yt2 and xt1 get packed together, we need to do     ;
        ; a few more packs to get terms yt1,xt1 packed together    ;
        ; This operation is akin to taking a 2x2 transpose.        ;
        ; This allows us to get packed xy's for  the three other   ;
        ; inputs of the butterfly.                                 ;
        ;----------------------------------------------------------;

        PACKLH2.1  A_yt2_0_xt1_0,  A_yt1_0_xt2_0,    A_xt1_0_yt1_0
        PACKLH2.1  A_yt2_1_xt1_1,  A_yt1_1_xt2_1,    A_xt1_1_yt1_1
        PACKLH2.1  A_yt1_0_xt2_0,  A_yt2_0_xt1_0,    A_xt2_0_yt2_0
        PACKLH2.1  A_yt1_1_xt2_1,  A_yt2_1_xt1_1,    A_xt2_1_yt2_1

        ;----------------------------------------------------------;
        ; In addition either the data terms or the twiddle factor  ;
        ; needs to be rotated by 16, to make use of dotp2 and      ;
        ; dotpn2 using the same twiddle factor to realize real     ;
        ; and imaginary multiplies.                                ;
        ;----------------------------------------------------------;

        ROTL.2     B_yt0_0_xt0_0,  16,               B_xt0_0_yt0_0
        ROTL.2     B_yt0_1_xt0_1,  16,               B_xt0_1_yt0_1
        ROTL.1     A_xt1_0_yt1_0,  16,               A_yt1_0_xt1_0
        ROTL.1     A_xt1_1_yt1_1,  16,               A_yt1_1_xt1_1
        ROTL.1     A_xt2_0_yt2_0,  16,               A_yt2_0_xt2_0
        ROTL.1     A_xt2_1_yt2_1,  16,               A_yt2_1_xt2_1

        ;---------------------------------------------------------;
        ; x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0) >> 15          ;
        ; x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0) >> 15          ;
        ; x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1) >> 15          ;
        ; x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1) >> 15          ;
        ;---------------------------------------------------------;

        DOTP2.1    A_xt1_0_yt1_0,  A_co10_si10,      A_x_h2_0
        DOTPN2.1   A_yt1_0_xt1_0,  A_co10_si10,      A_x_h2_1
        DOTP2.1    A_xt1_1_yt1_1,  A_co11_si11,      A_x_h2_2
        DOTPN2.1   A_yt1_1_xt1_1,  A_co11_si11,      A_x_h2_3

        ;---------------------------------------------------------;
        ; x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0) >> 15          ;
        ; x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0) >> 15          ;
        ; x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1) >> 15          ;
        ; x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1) >> 15          ;
        ;---------------------------------------------------------;

        DOTP2.2    B_xt0_0_yt0_0,   B_co20_si20,     B_x_l1_0
        DOTPN2.2   B_yt0_0_xt0_0,   B_co20_si20,     B_x_l1_1
        DOTP2.2    B_xt0_1_yt0_1,   B_co21_si21,     B_x_l1_2
        DOTPN2.2   B_yt0_1_xt0_1,   B_co21_si21,     B_x_l1_3

        ;---------------------------------------------------------;
        ; x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0) >> 15          ;
        ; x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0) >> 15          ;
        ; x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1) >> 15          ;
        ; x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1) >> 15          ;
        ;---------------------------------------------------------;

        DOTP2.2    B_co30_si30,     A_xt2_0_yt2_0,   B_x_l2_0
        DOTPN2.2   B_co30_si30,     A_yt2_0_xt2_0,   B_x_l2_1
        DOTP2.2    B_co31_si31,     A_xt2_1_yt2_1,   B_x_l2_2
        DOTPN2.2   B_co31_si31,     A_yt2_1_xt2_1,   B_x_l2_3

        ;---------------------------------------------------------;
        ; Shift right by 15, or shift left by 1, retaining value  ;
        ; in upper 16 bits. Combine two such results using the    ;
        ; PACKH2 instructions                                     ;
        ;---------------------------------------------------------;

        ADD.1      A_x_h2_0,        A_x_h2_0,        A_x_h2_0
        ADD.1      A_x_h2_1,        A_x_h2_1,        A_x_h2_1
        ADD.1      A_x_h2_2,        A_x_h2_2,        A_x_h2_2
        ADD.1      A_x_h2_3,        A_x_h2_3,        A_x_h2_3

        ADD.2      B_x_l1_0,        B_x_l1_0,        B_x_l1_0
        ADD.2      B_x_l1_1,        B_x_l1_1,        B_x_l1_1
        ADD.2      B_x_l1_2,        B_x_l1_2,        B_x_l1_2
        ADD.2      B_x_l1_3,        B_x_l1_3,        B_x_l1_3

        ADD.2      B_x_l2_0,        B_x_l2_0,        B_x_l2_0
        ADD.2      B_x_l2_1,        B_x_l2_1,        B_x_l2_1
        ADD.2      B_x_l2_2,        B_x_l2_2,        B_x_l2_2
        ADD.2      B_x_l2_3,        B_x_l2_3,        B_x_l2_3

        ;---------------------------------------------------------;
        ; Combine the results using packh2 abd store to the three ;
        ; legs of the butterfly. Since two butterflies were comp- ;
        ; uted in parallel, one store double word stores the real ;
        ; and imaginary parts of that particular leg for both the ;
        ; butterflies in parallel.                                ;
        ;---------------------------------------------------------;

        PACKH2.1   A_x_h2_1,        A_x_h2_0,        A_xh2_1_0
        PACKH2.1   A_x_h2_3,        A_x_h2_2,        A_xh2_3_2
        STDW.D1T1  A_xh2_3_2:A_xh2_1_0,              *A_x__[A_h2]

        PACKH2.2   B_x_l1_1,        B_x_l1_0,        B_xl1_1_0
        PACKH2.2   B_x_l1_3,        B_x_l1_2,        B_xl1_3_2
        STDW.D1T2  B_xl1_3_2:B_xl1_1_0,              *A_x__[A_l1]

        PACKH2.2   B_x_l2_1,        B_x_l2_0,        B_xl2_1_0
        PACKH2.2   B_x_l2_3,        B_x_l2_2,        B_xl2_3_2
        STDW.D1T2  B_xl2_3_2:B_xl2_1_0,              *A_x__[A_l2]

        ;---------------------------------------------------------;
        ; Decrement and branch on loop variable A_i.              ;
        ;---------------------------------------------------------;

        BDEC.1     LOOP_Y,          A_i

        ;---------------------------------------------------------;
        ; Continue to use this loop as long as stride > 4.        ;
        ;---------------------------------------------------------;

        CMPLTU.2  4,                B_stride,       B_while

[B_while]B.2      LOOP_WHILE

        ;---------------------------------------------------------;
        ; The following loop makes use of the fact that twiddle   ;
        ; factors in the last stage of the radix 4 are W0 = 1     ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; Use twin pointers to access input data array. The twin  ;
        ; pointers are "A_x0", "B_x0", these are offset by 1      ;
        ; double word.                                            ;
        ;---------------------------------------------------------;

        MV.1       A_ptr_x,        A_x0
        ADD.2x     A_ptr_x,        8,                B_x0

        ;---------------------------------------------------------;
        ; Also create pointer to work on data that is x[n/4]      ;
        ; Create twin pointers.                                   ;
        ;---------------------------------------------------------;

        MV.1x      B_n,            A_n
        ADD.1      A_ptr_x,        A_n,              A_x1         ;
        ADD.2x     A_x1,           8,                B_x1         ;

        ;---------------------------------------------------------;
        ; This constant is used to prepare checking for j = n/4   ;
        ; Since most units are being used, the negative is prep-  ;
        ; ared for checking. nm2 = 4 - n/4                        ;
        ;---------------------------------------------------------;

        SHRU.1x    B_n,            2,                A_n_2        ;
        SUB.2x     4,              A_n_2,            B_nm2        ; 4 - n/4

        ;---------------------------------------------------------;
        ; Prepare output pointers to point to the four regions.   ;
        ; Since the input data is N/4 complex points away or N/2  ;
        ; halfwords away, it is in reality N bytes away. Hence    ;
        ; the pointers are prepared by using this fact, rather    ;
        ; than using ADDAH, as ADD's schedule on more units than  ;
        ; ADDAH                                                   ;
        ;---------------------------------------------------------;

        MV.2       B_ptr_y,        B_y0                           ;
        ADD.2      B_y0,           B_n,              B_y1         ;
        ADD.2      B_y1,           B_n,              B_y2         ;
        ADD.2      B_y2,           B_n,              B_y3         ;

        ;---------------------------------------------------------;
        ; Determine the number of digits in n before bit reversal ;
        ;---------------------------------------------------------;

        NORM.2     B_n,            B_l1                           ;
        ADD.2      B_l1,           3,                B_l1         ;

        ;---------------------------------------------------------;
        ; Loop trip counter is N/8. 2 is deducted from the loop   ;
        ; trip count as BDEC is being used.                       ;
        ;---------------------------------------------------------;

        SHRU.2     B_n,            3,                B_j          ;
        SUB.2      B_j,            2,                B_j          ;

        ;---------------------------------------------------------;
        ;  The first index to start reversing is from 0           ;
        ;---------------------------------------------------------;

        ZERO.1     A_i

        .mptr      A_x0,   A_x + 0, 16
        .mptr      B_x0,   A_x + 1, 16
        .mptr      A_x1,   A_x + 0, 16
        .mptr      B_x1,   A_x + 1, 16
        ;.mptr      B_y0,   A_x + 0, 0
        ;.mptr      B_y1,   A_x + 0, 0
        ;.mptr      B_y2,   A_x + 0, 0
        ;.mptr      B_y3,   A_x + 0, 0

LOOP_Z: .trip      2

        ;---------------------------------------------------------;
        ; Use DEAL, BITR,  ROTL, SHFL, Shift right to prepare     ;
        ; the digit reversed index. The index will be used to     ;
        ; store the outputs back into the "y" array               ;
        ;---------------------------------------------------------;

        DEAL.2x    A_i,            B_h0
        BITR.2     B_h0,           B_h1
        ROTL.2     B_h1,           16,               B_h2
        SHFL.2     B_h2,           B_h3
        SHRU.2     B_h3,           B_l1,             B_h4

        ;---------------------------------------------------------;
        ; Load the input data from the start of the array, Also   ;
        ; load data that is N/4 complex points away.              ;
        ;---------------------------------------------------------;

        LDDW.D1T1  *A_x0++[2],     A_x3x2:A_x1x0
        LDDW.D2T2  *B_x0++[2],     B_x7x6:B_x5x4

        LDDW.D1T1  *A_x1++[2],     A_xbxa:A_x9x8
        LDDW.D2T2  *B_x1++[2],     B_xfxe:B_xdxc

        ;---------------------------------------------------------;
        ; Perform radix2 style ADD's and SUB'son the data         ;
        ;---------------------------------------------------------;

        ADD2.2x    B_x5x4,         A_x1x0,         B_xh1_0_xh0_0
        ADD2.2     B_x7x6,         A_x3x2,         B_xh21_0_xh20_0
        SUB2.1x    A_x1x0,         B_x5x4,         A_xl1_0_xl0_0
        SUB2.1x    A_x3x2,         B_x7x6,         A_xl21_0_xl20_0

        ROTL.1     A_xl1_0_xl0_0,  16,             A_xl0_0_xl1_0

        ;---------------------------------------------------------;
        ; Perform add's and sub's on rotated data, Once again     ;
        ; pack the results using PACKLH2                          ;
        ;---------------------------------------------------------;

        ADD2.2     B_xh1_0_xh0_0,  B_xh21_0_xh20_0,     B_y1y0
        SUB2.2     B_xh1_0_xh0_0,  B_xh21_0_xh20_0,     B_yt0_0_xt0_0
        ADD2.1     A_xl0_0_xl1_0,  A_xl21_0_xl20_0,     A_xt1_0_yt2_0
        SUB2.1     A_xl0_0_xl1_0,  A_xl21_0_xl20_0,     A_xt2_0_yt1_0

        PACKLH2.1  A_xt1_0_yt2_0,  A_xt2_0_yt1_0,       A_y7y6
        PACKLH2.1  A_xt2_0_yt1_0,  A_xt1_0_yt2_0,       A_y3y2

        ADD2.2x    B_xdxc,         A_x9x8,              B_xh1_1_xh0_1
        SUB2.1x    A_x9x8,         B_xdxc,              A_xl1_1_xl0_1

        ADD2.2x    A_xbxa,         B_xfxe,              B_xh21_1_xh20_1
        SUB2.1x    A_xbxa,         B_xfxe,              A_xl21_1_xl20_1

        ROTL.1     A_xl1_1_xl0_1,  16,                  A_xl0_1_xl1_1

        ADD2.2     B_xh1_1_xh0_1,  B_xh21_1_xh20_1,     B_y9y8
        SUB2.2     B_xh1_1_xh0_1,  B_xh21_1_xh20_1,     B_yt0_1_xt0_1

        ADD2.1     A_xl0_1_xl1_1,  A_xl21_1_xl20_1,     A_xt1_1_yt2_1
        SUB2.1     A_xl0_1_xl1_1,  A_xl21_1_xl20_1,     A_xt2_1_yt1_1

        ;----------------------------------------------------------;
        ; In this case shift right by 15 is not required because   ;
        ; of there are no multiplies.                              ;
        ;----------------------------------------------------------;

        PACKLH2.1  A_xt1_1_yt2_1,     A_xt2_1_yt1_1,       A_yfye
        PACKLH2.1  A_xt2_1_yt1_1,     A_xt1_1_yt2_1,       A_ybya

        ;----------------------------------------------------------;
        ; Perform stores to pointers that are offset N/4 complex   ;
        ; points.                                                  ;
        ;----------------------------------------------------------;

        STDW.D2T2  B_y9y8:B_y1y0,               *B_y0[B_h4]

        STDW.D2T1  A_ybya:A_y3y2,               *B_y1[B_h4]

        STDW.D2T2  B_yt0_1_xt0_1:B_yt0_0_xt0_0, *B_y2[B_h4]

        STDW.D2T1  A_yfye:A_y7y6,               *B_y3[B_h4]

        ;----------------------------------------------------------;
        ; If j == N/4 then jump over N/4 complex points            ;
        ; j += 4, j += n >> 2 Increment pointers on input side     ;
        ;----------------------------------------------------------;

        AVG2.1x    A_i,              B_nm2,           B_ifi
        ADD.1      A_i,              4,               A_i
[!B_ifi]ADD.1      A_i,              A_n_2,           A_i
[!B_ifi]ADD.1      A_x0,             A_n,             A_x0
[!B_ifi]ADD.2      B_x0,             B_n,             B_x0
[!B_ifi]ADD.1      A_x1,             A_n,             A_x1
[!B_ifi]ADD.2      B_x1,             B_n,             B_x1

        ;---------------------------------------------------------;
        ; Decrement loop variable j and branch.                   ;
        ;---------------------------------------------------------;

        BDEC.2     LOOP_Z,           B_j

        .return
        .endproc

* ========================================================================= *
*   End of file:  dsp_fft.sa                                                *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fft16x16r.sa/   1066929505  0     0     0       87625     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Thu Sep  6 17:43:09 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================== *
*                                                                            *
*   TEXAS INSTRUMENTS, INC.                                                  *
*                                                                            *
*   NAME                                                                     *
*         DSP_fft16x16r : 16x16 FFT with rounding and scaling                *
*                                                                            *
*                                                                            *
*   REVISION DATE                                                            *
*       12-Sep-2000                                                          *
*                                                                            *
*   USAGE                                                                    *
*         This routine is C-callable and can be called as:                   *
*                                                                            *
*         void DSP_fft16x16r                                                 *
*         (                                                                  *
*             int                       n,                                   *
*             short *restrict           ptr_x,                               *
*             const short *restrict     ptr_w,                               *
*             unsigned char *restrict   brev,                                *
*             short *restrict           ptr_y,                               *
*             int                       radix,                               *
*             int                       offset,                              *
*             int                       nmax                                 *
*         )                                                                  *
*                                                                            *
*         N      = length of fft in complex samples, power of 2 <=16384      *
*         ptr_x  = pointer to complex data input                             *
*         ptr_w  = pointer to complex twiddle factor (see below)             *
*         brev   = pointer to bit reverse table containing 64 entries        *
*         n_min  = smallest fft butterfly used in computation                *
*                  used for decomposing fft into subffts, see notes          *
*         offset = index in complex samples of sub-fft from start of main ff *
*         n_max  = size of main fft in complex samples                       *
*                                                                            *
*         (See the C compiler reference guide.)                              *
*                                                                            *
*   DESCRIPTION                                                              *
*        The benchmark performs a mixed radix forwards fft using             *
*        a special sequence of coefficients generated in the following       *
*        way:                                                                *
*                                                                            *
*          -* generate vector of twiddle factors for optimized algorithm *-  *
*         void tw_gen(short * w, int N)                                      *
*         {                                                                  *
*           int j, k;                                                        *
*           double x_t, y_t, theta1, theta2, theta3;                         *
*           const double PI = 3.141592654, M = 32767.0;                      *
*                                        -* M is 16383 for scale by 4 *-     *
*                                                                            *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                              *
*           {                                                                *
*               for (i=0; i < N>>2; i+=j)                                    *
*               {                                                            *
*                   theta1 = 2*PI*i/N;                                       *
*                   x_t = M*cos(theta1);                                     *
*                   y_t = M*sin(theta1);                                     *
*                   w[k]   =  (short)x_t;                                    *
*                   w[k+1] =  (short)y_t;                                    *
*                                                                            *
*                   theta2 = 4*PI*i/N;                                       *
*                   x_t = M*cos(theta2);                                     *
*                   y_t = M*sin(theta2);                                     *
*                   w[k+2] =  (short)x_t;                                    *
*                   w[k+3] =  (short)y_t;                                    *
*                                                                            *
*                   theta3 = 6*PI*i/N;                                       *
*                   x_t = M*cos(theta3);                                     *
*                   y_t = M*sin(theta3);                                     *
*                   w[k+4] =  (short)x_t;                                    *
*                   w[k+5] =  (short)y_t;                                    *
*                   k+=6;                                                    *
*               }                                                            *
*           }                                                                *
*         }                                                                  *
*        This redundent set of twiddle factors is size 2*N short samples.    *
*        As pointed out later dividing these twiddle factors by 2 will give  *
*        an effective divide by 4 at each stage to guarentee no overflow.    *
*        The function is accurate to about 68dB of signal to noise ratio     *
*        to the DFT function below:                                          *
*                                                                            *
*         void dft(int n, short x[], short y[])                              *
*         {                                                                  *
*            int k,i, index;                                                 *
*            const double PI = 3.14159654;                                   *
*            short * p_x;                                                    *
*            double arg, fx_0, fx_1, fy_0, fy_1, co, si;                     *
*                                                                            *
*            for(k = 0; k<n; k++)                                            *
*            {                                                               *
*              p_x = x;                                                      *
*              fy_0 = 0;                                                     *
*              fy_1 = 0;                                                     *
*              for(i=0; i<n; i++)                                            *
*              {                                                             *
*                fx_0 = (double)p_x[0];                                      *
*                fx_1 = (double)p_x[1];                                      *
*                p_x += 2;                                                   *
*                index = (i*k) % n;                                          *
*                arg = 2*PI*index/n;                                         *
*                co = cos(arg);                                              *
*                si = -sin(arg);                                             *
*                fy_0 += ((fx_0 * co) - (fx_1 * si));                        *
*                fy_1 += ((fx_1 * co) + (fx_0 * si));                        *
*              }                                                             *
*              y[2*k] = (short)2*fy_0/sqrt(N);                               *
*              y[2*k+1] = (short)2*fy_1/sqrt(N);                             *
*            }                                                               *
*         }                                                                  *
*        Scaling takes place at each stage except the last one.              *
*        This is a divide by 2 to prevent overflow. All shifts are rounded t *
*        reduce truncation noise power by 3dB.                               *
*        The function takes the table and input data and calculates the fft  *
*        producing the frequency domain data in the Y array.                 *
*        As the fft allows every input point to effect every output point in *
*        a cache based system such as the c6211, this causes cache thrashing *
*        This is mitigated by allowing the main fft of size N to be divided  *
*        into several steps, allowing as much data reuse as possible.        *
*                                                                            *
*        For example the following function:                                 *
*                                                                            *
*        DSP_fft16x16r  (1024, &x_asm[0],&w[0],y_asm,brev,4,  0,1024);       *
*                                                                            *
*        is equvalent to:                                                    *
*                                                                            *
*        DSP_fft16x16r  (1024,&x_asm[2*0],  &w[0]  ,y_asm,brev,256, 0,1024); *
*        DSP_fft16x16r  (256, &x_asm[2*0],  &w[2*768],y_asm,brev,4, 0,1024); *
*        DSP_fft16x16r (256, &x_asm[2*256],&w[2*768],y_asm,brev,4, 256,1024); *
*        DSP_fft16x16r (256, &x_asm[2*512],&w[2*768],y_asm,brev,4, 512,1024); *
*        DSP_fft16x16r (256, &x_asm[2*768],&w[2*768],y_asm,brev,4, 768,1024); *
*                                                                            *
*        Notice how the 1st fft function is called on the entire 1K data set *
*        it covers the 1st pass of the fft until the butterfly size is 256.  *
*        The following 4 ffts do 256 pt ffts 25% of the size. These continue *
*        down to the end when the buttefly is of size 4. The use an index to *
*        the main twiddle factor array of 0.75*2*N. This is because the      *
*        twiddle factor array is composed of successively decimated versions *
*        of the main array.                                                  *
*                                                                            *
*        N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*        decompose the fft the following would be needed :                   *
*                                                                            *
*        DSP_fft16x16r   (512, &x_asm[0],&w[0],y_asm,brev,2,  0,512);        *
*                                                                            *
*        is equvalent to:                                                    *
*                                                                            *
*        DSP_fft16x16r   (512, &x_asm[0],    &w[0],  y_asm,brev,128, 0,512); *
*        DSP_fft16x16r   (128, &x_asm[2*0],  &w[2*384],y_asm,brev,2, 0,512); *
*        DSP_fft16x16r (128, &x_asm[2*128],&w[2*384],y_asm,brev,2, 128,512); *
*        DSP_fft16x16r (128, &x_asm[2*256],&w[2*384],y_asm,brev,2, 256,512); *
*        DSP_fft16x16r (128, &x_asm[2*384],&w[2*384],y_asm,brev,2, 384,512); *
*                                                                            *
*        The twiddle factor array is composed of log4(N) sets of twiddle     *
*        factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*        array for each stage of the fft is calculated by summing these      *
*        indices up appropriately.                                           *
*        For multiple ffts they can share the same table by calling the smal *
*        ffts from further down in the twiddle factor array. In the same way *
*        as the decomposition works for more data reuse.                     *
*                                                                            *
*        Thus, the above decomposition can be summarized for a general N ,   *
*        radix "rad" as follows:                                             *
*                                                                            *
*   DSP_fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0, N) *
*   DSP_fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(N/4)], &w[2*(3*N/4)],brev, y_cn, rad, N/4, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(N/2)], &w[2*(3*N/4)],brev, y_cn, rad, N/2, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) *
*                                                                            *
*        As discussed previously, N can be either a power of 4 or 2.  If  N  *
*        N is a power  of 4, rad = 4, and if N is a power of 2, and not  a   *
*        power of 4, then rad = 2. "rad" is used to control how many stages  *
*        of decomposition are performed. It is also used to dtermine whether *
*        a radix4 or radix2 decomposition should be performed at the last    *
*        stage. Hence when "rad" is set to "N/4" the first stage of the      *
*        transform alone is performed and the code exits. To complete the    *
*        FFT four other calls are required to perform N/4 size FFT's. In     *
*        fact the ordering of these 4 FFT's amonst themselves does not       *
*        matter and hence from a cahe perspective it helps to go through     *
*        the remaining 4 FFT's in exactly the opposite order to the first.   *
*                                                                            *
*        This is illustrated as follows:                                     *
*                                                                            *
*   DSP_fft16x16r(N,  &x_cn[0],         &w[0],        brev, y_cn, N/4, 0, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(N/2)], &w[2*(3*N/4)],brev, y_cn, rad, N/2, N) *
*   DSP_fft16x16r(N/4,&x_cn[2*(N/4)], &w[2*(3*N/4)],brev, y_cn, rad, N/4, N) *
*   DSP_fft16x16r(N/4,&x_cn[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0, N) *
*                                                                            *
*        In addition this function can be used to minimize call overhead, by *
*        completing the FFT with one function call invocation as shown below *
*                                                                            *
*        DSP_fft16x16r(N, &x_cn[0], &w[0], y_cn, brev, rad, 0, N)            *
*                                                                            *
*    ASSUMPTIONS:                                                            *
*        n must be a power of 2 and n >= 8  n <= 16384 points.               *
*        Complex time data x and twiddle facotrs w are aligned on double     *
*        word boundares. Real values are stored in even word positions and   *
*        imaginary values in odd positions.                                  *
*                                                                            *
*        All data is in short precision integer fixed point form. The        *
*        complex frequency data will be returned in linear order.            *
*                                                                            *
*        If Interupts are required the decomposition can be used to allow    *
*        interupts to occur in between function calls. In this way interupts *
*        Can occur roughly every 20%  of the time through the function.      *
*                                                                            *
*    MEMORY NOTE:                                                            *
*        Configuration is LITTLE ENDIAN the code will not function if the -m *
*        flag is enabled but it can be modified for BIG ENDIAN usage.        *
*                                                                            *
*    TECHNIQUES                                                              *
*        A special sequence of coeffs. used as generated above               *
*        produces the fft. This collapses the inner 2 loops in the           *
*        taditional Burrus and Parks implementation Fortran Code.            *
*                                                                            *
*        The revised FFT uses a redundant sequence of twiddle factors to     *
*        allow a linear access through the data. This linear access enables  *
*        data and instruction level parallelism.                             *
*        The data produced by the DSP_fft16x16r fft is in normal form, the   *
*        whole data array is written into a new output buffer.               *
*                                                                            *
*        The DSP_fft16x16r butterfly is bit reversed, i.e. the inner 2 points of *
*        the butterfly are corssed over, this has the effect of making the   *
*        data come out in bit reversed rather than in radix 4 digit reversed *
*        order. This simplifies the last pass of the loop. A simple table    *
*        is used to do the bit reversal out of place.                        *
*                                                                            *
*            unsigned char brev[64] = {                                      *
*                  0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,             *
*                  0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,             *
*                  0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,             *
*                  0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,             *
*                  0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,             *
*                  0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,             *
*                  0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,             *
*                  0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f              *
*            };                                                              *
*                                                                            *
*         This function no longer uses the lookup table to perform bit       *
*         reversal. It is performed using the _bitr instruction on C64x      *
*         architecture. It is performed using a macro BIT_REV instead.       *
*                                                                            *
*    NOTES                                                                   *
*        For more aggressive overflow control the shift in the DC term can b *
*        adjusted to 2 and the twiddle factors shifted right by 1. This give *
*        a divide by 4 at each stage. For better accuracy the data can be pr *
*        asserted left by so many bits so that as it builds in magnitude the *
*        divide by 2 prevents too much growth. An optimal point for example  *
*        with an 8192pt fft with input data precision of 8 bits is to asert  *
*        the input 4 bits left to make it 12 bits. This gives an SNR of 68dB *
*        at the output. By trying combinations the optimal can be found.     *
*        If scaling isnot required it is possible to replace the MPY by SMPY *
*        this will give a shift left by 1 so a shift right by 16 gives a     *
*        total 15 bit shift right. The DC term must be adjusted to give a    *
*        zero shift.                                                         *
*                                                                            *
*    C CODE                                                                  *
*        The following code is the traditional Burrus and Parks implemen-    *
*        tation, which performs a mixed radix FFT capable of 2^M, 4^M.       *
*        However it does not support multiple calls. It uses a traditional   *
*        twiddle factor array wn, generated as follows:                      *
*                                                                            *
*        const double M = 32767.0;                                           *
*        const double PI = 3.141592654;                                      *
*                                                                            *
*        for (i=0, k = 0; i < 3*(N>>2); i++)                                 *
*        {                                                                   *
*           theta1 = 2*PI*i/N;                                               *
*           x_t = M*cos(theta1);                                             *
*           y_t = M*sin(theta1);                                             *
*           wn[k]   = (short) x_t;                                           *
*           if (x_t >= M) wn[k  ] = 0x7fff;                                  *
*           wn[k+1] = (short) y_t;                                           *
*           if (y_t >= M) wn[k+1] = 0x7fff;                                  *
*           k+=2;                                                            *
*        }                                                                   *
*                                                                            *
*        The C code that implements the traditional mixed radix FFT is       *
*        shown below. It has three nested loops, one for the stages,         *
*        one for the groups of butterflies, one for the passes.              *
*                                                                            *
*  void DSP_fft16x16r(int n, short x[], short wn[],                          *
*        unsigned char brev[], short y[], int radix, int offset, int nmax)   *
*  {                                                                         *
*      int    n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, i, l0;              *
*      short  co1, co2, co3, si1, si2, si3;                                  *
*      short  xt0, yt0, xt1, yt1, xt2, yt2;                                  *
*      short  xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                           *
*      short * ptr_x0, * y0;                                                 *
*      unsigned int  j0, j1, k0, k1, k, j;                                   *
*      short x0, x1, x2, x3, x4, x5, x6, x7;                                 *
*      short xh0_0, xh1_0, xh0_1, xh1_1;                                     *
*      short xl0_0, xl1_0, xl0_1, xl1_1;                                     *
*      short yt3, yt4, yt5, yt6, yt7;                                        *
*                                                                            *
*      n2 = n;                                                               *
*      ie = 1;                                                               *
*      for (k = n; k > radix; k >>= 2)                                       *
*      {                                                                     *
*          n1 = n2;                                                          *
*          n2 >>= 2;                                                         *
*          ia1 = 0;                                                          *
*          for (j = 0; j < n2; j++)                                          *
*          {                                                                 *
*              ia2 = ia1 + ia1;                                              *
*              ia3 = ia2 + ia1;                                              *
*              co1 = w[2 * ia1    ];                                         *
*              si1 = w[2 * ia1 + 1];                                         *
*              co2 = w[2 * ia2    ];                                         *
*              si2 = w[2 * ia2 + 1];                                         *
*              co3 = w[2 * ia3    ];                                         *
*              si3 = w[2 * ia3 + 1];                                         *
*              ia1 = ia1 + ie;                                               *
*              for (i0 = j; i0 < n; i0 += n1)                                *
*              {                                                             *
*                  i1 = i0 + n2;                                             *
*                  i2 = i1 + n2;                                             *
*                  i3 = i2 + n2;                                             *
*                                                                            *
*                  xh0  = x[2 * i0    ] + x[2 * i2    ];                     *
*                  xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];                     *
*                  xl0  = x[2 * i0    ] - x[2 * i2    ];                     *
*                  xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];                     *
*                                                                            *
*                  xh20 = x[2 * i1    ] + x[2 * i3    ];                     *
*                  xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];                     *
*                  xl20 = x[2 * i1    ] - x[2 * i3    ];                     *
*                  xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];                     *
*                                                                            *
*                  x[2 * i0    ] = (xh0 + xh20 + 1)>>1;                      *
*                  x[2 * i0 + 1] = (xh1 + xh21 + 1)>>1;                      *
*                                                                            *
*                  xt0  = xh0 - xh20;                                        *
*                  yt0  = xh1 - xh21;                                        *
*                  xt1  = xl0 + xl21;                                        *
*                  yt2  = xl1 + xl20;                                        *
*                  xt2  = xl0 - xl21;                                        *
*                  yt1  = xl1 - xl20;                                        *
*                                                                            *
*                  x[2 * i2    ]= (xt1 * co1 + yt1 * si1 + 0x00008000)>> 16; *
*                  x[2 * i2 + 1]= (yt1 * co1 - xt1 * si1 + 0x00008000)>> 16; *
*                  x[2 * i1    ]= (xt0 * co2 + yt0 * si2 + 0x00008000)>> 16; *
*                  x[2 * i1 + 1]= (yt0 * co2 - xt0 * si2 + 0x00008000)>> 16; *
*                  x[2 * i3    ]= (xt2 * co3 + yt2 * si3 + 0x00008000)>> 16; *
*                  x[2 * i3 + 1]= (yt2 * co3 - xt2 * si3 + 0x00008000)>> 16; *
*              }                                                             *
*          }                                                                 *
*                                                                            *
*          ie <<= 2;                                                         *
*     }                                                                      *
*                                                                            *
*     j = 0;                                                                 *
*     ptr_x0 = x;                                                            *
*     y0 = y;                                                                *
*     l0 = _norm(n) - 17;                                                    *
*                                                                            *
*     if(radix == 2 || radix  == 4) for (i = 0; i < n; i += 4)               *
*     {                                                                      *
*                                                                            *
*                                                                            *
*             j0 = (j     ) & 0x3F;                                          *
*             j1 = (j >> 6) & 0x3F;                                          *
*             k0 = brev[j0];                                                 *
*             k1 = brev[j1];                                                 *
*             k = (k0 << 6) |  k1;                                           *
*             if (l0 < 0) k = k << -l0;                                      *
*             else        k = k >> l0;                                       *
*             j++;                                                           *
*                                                                            *
*             x0   = ptr_x0[0];  x1 = ptr_x0[1];                             *
*             x2   = ptr_x0[2];  x3 = ptr_x0[3];                             *
*             x4   = ptr_x0[4];  x5 = ptr_x0[5];                             *
*             x6   = ptr_x0[6];  x7 = ptr_x0[7];                             *
*             ptr_x0 += 8;                                                   *
*                                                                            *
*             xh0_0  = x0 + x4;                                              *
*             xh1_0  = x1 + x5;                                              *
*             xh0_1  = x2 + x6;                                              *
*             xh1_1  = x3 + x7;                                              *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                 xh0_0 = x0;                                                *
*                 xh1_0 = x1;                                                *
*                 xh0_1 = x2;                                                *
*                 xh1_1 = x3;                                                *
*             }                                                              *
*                                                                            *
*             yt0  = xh0_0 + xh0_1;                                          *
*             yt1  = xh1_0 + xh1_1;                                          *
*             yt4  = xh0_0 - xh0_1;                                          *
*             yt5  = xh1_0 - xh1_1;                                          *
*                                                                            *
*             xl0_0  = x0 - x4;                                              *
*             xl1_0  = x1 - x5;                                              *
*             xl0_1  = x2 - x6;                                              *
*             xl1_1  = x3 - x7;                                              *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                   xl0_0 = x4;                                              *
*                   xl1_0 = x5;                                              *
*                   xl1_1 = x6;                                              *
*                   xl0_1 = x7;                                              *
*             }                                                              *
*                                                                            *
*             yt2  = xl0_0 + xl1_1;                                          *
*             yt3  = xl1_0 - xl0_1;                                          *
*                                                                            *
*             yt6  = xl0_0 - xl1_1;                                          *
*             yt7  = xl1_0 + xl0_1;                                          *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                  yt7  = xl1_0 - xl0_1;                                     *
*                  yt3  = xl1_0 + xl0_1;                                     *
*             }                                                              *
*                                                                            *
*             y0[k] = yt0; y0[k+1] = yt1;                                    *
*             k += n>>1                                                      *
*             y0[k] = yt2; y0[k+1] = yt3;                                    *
*             k += n>>1;                                                     *
*             y0[k] = yt4; y0[k+1] = yt5;                                    *
*             k += n>>1;                                                     *
*             y0[k] = yt6; y0[k+1] = yt7;                                    *
*        }                                                                   *
*    }                                                                       *
*                                                                            *
*        Although code shown above is the simplest equivalent way of writing *
*        this code, it already carries several optimization ideas. It has    *
*        a special last stage to avoid multiplication by 1. In addition it   *
*        was shown by Panos Papamichalis that if the two middle legs of a    *
*        radix 4 butterfly are reversed, the outputs for a radix4 transform  *
*        end up in the bit reversed fashion. The code also carries a linear  *
*        time look up table for bit reversal. This can be used as shown in   *
*        the code to construct a bit reversed index. The last stage perfo-   *
*        rms either a radix4 or radix2 as the case may be.                   *
*                                                                            *
*        The code shown below performs loop coalescing as it is realized     *
*        that while the "i" and "j" loop individually iterate for variable   *
*        number of times, together they always iterate for N/4 times. The    *
*        natural C code and the code shown below use a modified twiddle      *
*        factor array to allow for vectorization of the loop. In addition    *
*        bit-reversal is performed by a macro BIT_REV. This makes the bit-   *
*        reversal table redundant.                                           *
*                                                                            *
*        This is the C equivalent of the assembly code without restrictions: *
*        Note that the assembly code is hand optimized and restrictions may  *
*        apply.                                                              *
*                                                                            *
*                                                                            *
*       void DSP_fft16x16r(int n, short ptr_x[], short ptr_w[], short ptr_y[] *
*                    unsigned char brev[], int n_min, int offset, int n_max) *
*       {                                                                    *
*          int  i, j, k, l1, l2, h2, predj;                                  *
*          int  tw_offset, stride, fft_jmp;                                  *
*                                                                            *
*          short x0, x1, x2, x3,x4,x5,x6,x7;                                 *
*          short xt0, yt0, xt1, yt1, xt2, yt2, yt3;                          *
*          short yt4, yt5, yt6, yt7;                                         *
*          short si1,si2,si3,co1,co2,co3;                                    *
*          short xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                        *
*          short x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;        *
*          short xl0_0, xl1_0, xl0_1, xl1_1;                                 *
*          short xh0_0, xh1_0, xh0_1, xh1_1;                                 *
*          short *x,*w;                                                      *
*          int   k0, k1, j0, j1, l0, radix;                                  *
*          short * y0, * ptr_x0, * ptr_x2;                                   *
*                                                                            *
*          radix = n_min;                                                    *
*                                                                            *
*          stride = n; -* n is the number of complex samples *-              *
*          tw_offset = 0;                                                    *
*          while (stride > radix)                                            *
*          {                                                                 *
*              j = 0;                                                        *
*              fft_jmp = stride + (stride>>1);                               *
*              h2 = stride>>1;                                               *
*              l1 = stride;                                                  *
*              l2 = stride + (stride>>1);                                    *
*              x = ptr_x;                                                    *
*              w = ptr_w + tw_offset;                                        *
*                                                                            *
*              for (i = 0; i < n; i += 4)                                    *
*              {                                                             *
*                  co1 = w[j];                                               *
*                  si1 = w[j+1];                                             *
*                  co2 = w[j+2];                                             *
*                  si2 = w[j+3];                                             *
*                  co3 = w[j+4];                                             *
*                  si3 = w[j+5];                                             *
*                                                                            *
*                  x_0    = x[0];                                            *
*                  x_1    = x[1];                                            *
*                  x_h2   = x[h2];                                           *
*                  x_h2p1 = x[h2+1];                                         *
*                  x_l1   = x[l1];                                           *
*                  x_l1p1 = x[l1+1];                                         *
*                  x_l2   = x[l2];                                           *
*                  x_l2p1 = x[l2+1];                                         *
*                                                                            *
*                  xh0  = x_0    + x_l1;                                     *
*                  xh1  = x_1    + x_l1p1;                                   *
*                  xl0  = x_0    - x_l1;                                     *
*                  xl1  = x_1    - x_l1p1;                                   *
*                                                                            *
*                  xh20 = x_h2   + x_l2;                                     *
*                  xh21 = x_h2p1 + x_l2p1;                                   *
*                  xl20 = x_h2   - x_l2;                                     *
*                  xl21 = x_h2p1 - x_l2p1;                                   *
*                                                                            *
*                  ptr_x0 = x;                                               *
*                  ptr_x0[0] = ((short) (xh0 + xh20))>>1; can be changed to  *
*                  ptr_x0[1] = ((short) (xh1 + xh21))>>1; can be changed to  *
*                                                                            *
*                  ptr_x2 = ptr_x0;                                          *
*                  x += 2;                                                   *
*                  j += 6;                                                   *
*                  predj = (j - fft_jmp);                                    *
*                  if (!predj) x += fft_jmp;                                 *
*                  if (!predj) j = 0;                                        *
*                                                                            *
*                  xt0 = xh0 - xh20;                                         *
*                  yt0 = xh1 - xh21;                                         *
*                  xt1 = xl0 + xl21;                                         *
*                  yt2 = xl1 + xl20;                                         *
*                  xt2 = xl0 - xl21;                                         *
*                  yt1 = xl1 - xl20;                                         *
*                                                                            *
*                  ptr_x2[l1  ] = (xt1 * co1 + yt1 * si1 + 0x8000)>>16;      *
*                  ptr_x2[l1+1] = (yt1 * co1 - xt1 * si1 + 0x8000)>>16;      *
*                  ptr_x2[h2  ] = (xt0 * co2 + yt0 * si2 + 0x8000)>>16;      *
*                  ptr_x2[h2+1] = (yt0 * co2 - xt0 * si2 + 0x8000)>>16;      *
*                  ptr_x2[l2  ] = (xt2 * co3 + yt2 * si3 + 0x8000)>>16;      *
*                  ptr_x2[l2+1] = (yt2 * co3 - xt2 * si3 + 0x8000)>>16;      *
*              }                                                             *
*              tw_offset += fft_jmp;                                         *
*              stride = stride>>2;                                           *
*          }-* end while *-                                                  *
*                                                                            *
*          j = offset>>2;                                                    *
*                                                                            *
*          ptr_x0 = ptr_x;                                                   *
*          y0 = ptr_y;                                                       *
*          l0 = _norm(nmax) - 17; -* get size of fft *-                      *
*                                                                            *
*          if (radix <= 4) for (i = 0; i < n; i += 4)                        *
*          {                                                                 *
*                  -* reversal computation *-                                *
*                                                                            *
*                  j0 = (j     ) & 0x3F;                                     *
*                  j1 = (j >> 6) & 0x3F;                                     *
*                  k0 = brev[j0];                                            *
*                  k1 = brev[j1];                                            *
*                  k = (k0 << 6) |  k1;                                      *
*                  k = k >> l0;                                              *
*                  j++;        -* multiple of 4 index *-                     *
*                                                                            *
*                  x0   = ptr_x0[0];  x1 = ptr_x0[1];                        *
*                  x2   = ptr_x0[2];  x3 = ptr_x0[3];                        *
*                  x4   = ptr_x0[4];  x5 = ptr_x0[5];                        *
*                  x6   = ptr_x0[6];  x7 = ptr_x0[7];                        *
*                  ptr_x0 += 8;                                              *
*                                                                            *
*                  xh0_0  = x0 + x4;                                         *
*                  xh1_0  = x1 + x5;                                         *
*                  xh0_1  = x2 + x6;                                         *
*                  xh1_1  = x3 + x7;                                         *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    xh0_0 = x0;                                             *
*                    xh1_0 = x1;                                             *
*                    xh0_1 = x2;                                             *
*                    xh1_1 = x3;                                             *
*                  }                                                         *
*                                                                            *
*                  yt0  = xh0_0 + xh0_1;                                     *
*                  yt1  = xh1_0 + xh1_1;                                     *
*                  yt4  = xh0_0 - xh0_1;                                     *
*                  yt5  = xh1_0 - xh1_1;                                     *
*                                                                            *
*                  xl0_0  = x0 - x4;                                         *
*                  xl1_0  = x1 - x5;                                         *
*                  xl0_1  = x2 - x6;                                         *
*                  xl1_1  = x3 - x7;                                         *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    xl0_0 = x4;                                             *
*                    xl1_0 = x5;                                             *
*                    xl1_1 = x6;                                             *
*                    xl0_1 = x7;                                             *
*                  }                                                         *
*                                                                            *
*                  yt2  = xl0_0 + xl1_1;                                     *
*                  yt3  = xl1_0 - xl0_1;                                     *
*                  yt6  = xl0_0 - xl1_1;                                     *
*                  yt7  = xl1_0 + xl0_1;                                     *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    yt7  = xl1_0 - xl0_1;                                   *
*                    yt3  = xl1_0 + xl0_1;                                   *
*                  }                                                         *
*                                                                            *
*                  y0[k] = yt0; y0[k+1] = yt1;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt2; y0[k+1] = yt3;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt4; y0[k+1] = yt5;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt6; y0[k+1] = yt7;                               *
*          }                                                                 *
*      }                                                                     *
*                                                                            *
*   REFERENCES                                                               *
*   [1] C. S. Burrus and T.W. Parks (1985) "DFT/FFT and Convolution Algos -  *
*       Theory and Implementation", J. Wiley.                                *
*   [2] Implementation of Various Precision Fast Fourier Transforms on the   *
*       TMS320C6400 processor - DJH, ESC 2000                                *
*   [3] Burrus - Rice University and Papamichalis - TI (1988) - Paper on the *
*       convertion of radix4 to radix2 digit reversal.                       *
*                                                                            *
*   SPECIAL NOTES                                                            *
*   1. Complex multiplies are performed using _dotp2 and _dotpn2. _dotpn2    *
*   requires the data to be swizzled about the halfword, so that an extra    *
*   negate can be avoided.                                                   *
*   2. The intermediate adds and subtracts are performed using _add2's,      *
*   _sub2's.                                                                 *
*   3. Data is loaded in using the intrinsic _amemd8 as a double word, and   *
*   the low and high halves are accessed using _lo and _hi intrinsic.        *
*   4. Middle two legs of radix4 butterfly are swapped to get intermediate   *
*   outputs in bit reversed order. Final output in the output array "y" is   *
*   in normal order.                                                         *
*=========================================================================== *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=========================================================================== *

        .sect ".text:_fft16x16r"
        .global _DSP_fft16x16r
_DSP_fft16x16r: .cproc A_n, B_ptr_x, A_ptr_w, B_brev, A_ptr_y, B_radix, A_offset, B_nmax
            .no_mdep
*============================================================================*
        .reg    A_j, B_j,  B_w0, A_w0, A_w1, B_w2, B_x, B_h2
        .reg    B_l1, B_l2, A_h2, A_l1, A_l2
        .reg    A_co11_si11:A_co10_si10
        .reg    B_co21_si21:B_co20_si20
        .reg    B_co31_si31:B_co30_si30
        .reg    B_xl1_3_xl1_2:B_xl1_1_xl1_0
        .reg    A_xh2_3_xh2_2:A_xh2_1_xh2_0
        .reg    B_xl2_3_xl2_2:B_xl2_1_xl2_0
        .reg    B_xh0_0_xh0_0, B_xh1_0_xh0_0
        .reg    A_xl1_0_xl0_0, B_xh1_1_xh0_1
        .reg    A_xl1_1_xl0_1, A_xl0_0_xl1_0
        .reg    B_xh21_0_xh20_0, B_xh21_1_xh20_1
        .reg    A_xl21_0_xl20_0, A_xl21_1_xl20_1
        .reg    A_x1,B_x1, A_x_, A_x__
        .reg    A_fft_jmp
        .reg    A_ifj, B_ifj
        .reg    B_fft_jmp
        .reg    A_x_3_x_2:A_x_1_x_0
        .reg    B_x_3_x_2:B_x_1_x_0
        .reg    A_xl20_0_xl21_0, A_xl20_1_xl21_1
        .reg    A_yt2_0_xt1_0, A_yt1_0_xt2_0
        .reg    A_yt2_1_xt1_1, A_yt1_1_xt2_1
        .reg    A_xt1_0_yt1_0, A_xt2_0_yt2_0
        .reg    A_xt1_1_yt1_1, A_xt2_1_yt2_1
        .reg    B_xt0_0_yt0_0, B_xt0_1_yt0_1
        .reg    A_yt1_0_xt1_0, A_yt1_1_xt1_1
        .reg    A_yt2_0_xt2_0, A_yt2_1_xt2_1
        .reg    A_xh1_0_xh0_0, A_xh21_0_xh20_0
        .reg    A_xt1_0_yt2_0, A_xt2_0_yt1_0
        .reg    A_x_h2_0, A_x_h2_1, A_x_h2_2, A_x_h2_3, B_x_l1_1, B_x_l1_0
        .reg    B_x_l1_2, B_x_l1_3, B_x_l2_0, B_x_l2_1, B_x_l2_2, B_x_l2_3
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride,B_stride_1, B_while
        .reg    B_c10, A_x0, A_xo2, B_xo3
        .reg    A_tbta, A_t3t2
        .reg    B_x7x6:B_x5x4, B_x3x2:B_x1x0
        .reg    A_x7x6:A_x5x4, A_x3x2:A_x1x0
        .reg    B_y9y8:B_y1y0, B_ydyc:B_y5y4
        .reg    A_yfye:A_y7y6, A_ybya:A_y3y2
        .reg    B_yt0_1_xt0_1:B_yt0_0_xt0_0
        .reg    B_fft_jmp_1, B_xl21_1_xl20_1
        .reg    A_xbxa:A_x9x8, B_xfxe:B_xdxc
        .reg    A_yt0_0_xt0_0, A_xt2_1_yt1_1
        .reg    B_xl1_1_xl0_1, A_xl0_1_xl1_1, A_xt1_1_yt2_1
        .reg    B_n, B_x0, B_n_2, B_nm2
        .reg    B_y0, B_y1, B_y2, B_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_i, A_r2, B_j0
        .reg    A_rnd, B_rnd
        .reg    B_xh1_2_xh0_2, A_xl1_2_xl0_2, A_xl1_3_xl0_3, B_xl1_3_xl0_3
        .reg    B_xh1_3_xh0_3, A_xl0_2_xl1_2, B_zero, A_zero
        .reg    A_mx7mx6, B_mxfmxe, A_yt7_yt2, A_yt3_yt6
        .reg    A_yte_ytb, A_yta_ytf, B_early
*============================================================================*

        ;----------------------------------------------------------;
        ; Initially set stride = n. The "tw_offset" is set to zero ;
        ; and is the offset that is added to the twiddle factor    ;
        ; pointer "ptr_w" for the current iteration. At the start  ;
        ; of the program "tw_offset" is 0.                         ;
        ;----------------------------------------------------------;

        MV.2x      A_n,                   B_stride
        ZERO.1     A_tw_offset

LOOP_WHILE:

        ;---------------------------------------------------------;
        ; "j" is an index into the twiddle factor array. At the   ;
        ; start of every iteration of the outer loop, it is re    ;
        ; set to zero.                                            ;
        ;---------------------------------------------------------;

        ZERO.1     A_j
        ZERO.2     B_j

        ;---------------------------------------------------------;
        ; For every iteration of the inner loop, 6 * stride,      ;
        ; twiddle factors are loaded, where half of them are      ;
        ; cosines and the other half are sines. Since the data    ;
        ; is being accessed as double words. The fft_jmp is       ;
        ; set to fft_jmp/8                                        ;
        ;---------------------------------------------------------;

        SHL.2      B_stride,              1,                   B_stride_1
        ADD.2      B_stride,              B_stride_1,          B_fft_jmp
        SHRU.1x    B_fft_jmp,             3,                   A_fft_jmp

        ;---------------------------------------------------------;
        ; Input data offsets are set for double words             ;
        ; h2: loads &x[N/2] where x is a short array, hence its   ;
        ; double word offset is N/8. Similar argument holds for   ;
        ; l1 and l2.                                              ;
        ;---------------------------------------------------------;


        SHRU.2     B_stride,              3,                   B_h2
        SHRU.2     B_stride,              2,                   B_l1
        ADD.2      B_l1,                  B_h2,                B_l2

        ;---------------------------------------------------------;
        ; Make partitioning copies of the indexes into oppsoite   ;
        ; data paths.                                             ;
        ;---------------------------------------------------------;

        MV.1x      B_l1,                  A_l1
        MV.1x      B_h2,                  A_h2
        MV.1x      B_l2,                  A_l2

        ;---------------------------------------------------------;
        ; Reset data pointer, derive twin twiddle factors.        ;
        ; Add twiddle offset to ptr_w to derive new twiddle       ;
        ; factor pointer.                                         ;
        ;---------------------------------------------------------;

        MV.2       B_ptr_x,               B_x
        ADDAH.1    A_ptr_w,               A_tw_offset,         A_w0
        MV.2x      A_w0,                  B_w0

        ADD.1      A_w0,                  8,                   A_w1
        ADD.2x     A_w1,                  8,                   B_w2

        SHRU.2     B_fft_jmp,             1,                   B_fft_jmp_1
        ADD.1x     A_tw_offset,           B_fft_jmp_1,         A_tw_offset

        ;---------------------------------------------------------;
        ; The stride is quartered with every iteration of the     ;
        ; outer loop until stride = 4.                            ;
        ;---------------------------------------------------------;

        SHRU.2     B_stride,              2,                   B_stride

        ;---------------------------------------------------------;
        ; The following loop iterates for N/8 iterations. Since   ;
        ; BDEC is used 2 needs to be subtracted from the loop     ;
        ; counter A_i.                                            ;
        ;---------------------------------------------------------;

        SHRU.1     A_n,                   3,                   A_i
        SUB.1      A_i,                   2,                   A_i
        SUB.1      A_fft_jmp,             3,                   A_fft_jmp

        ;---------------------------------------------------------;
        ; Initialize round for scaling, as shift is done by 16,   ;
        ; to 0x8000 and not 0x4000.                               ;
        ;---------------------------------------------------------;

        MVKL.1     0x8000,                A_rnd
        MVKLH.1    0x0000,                A_rnd
        MV.2x      A_rnd,                 B_rnd


        ;---------------------------------------------------------;
        ; Since the stride amount across iterations is variable,  ;
        ; it is tough to put an exact stride. However for this    ;
        ; loop stride is guranteed to be greater than or equal    ;
        ; to 16 complex samples, 32 half words. Since this str-   ;
        ; ide is wider than the bank width, of all the banks,     ;
        ; stride is specified as zero.                            ;
        ;---------------------------------------------------------;


        .mptr      B_w0,   x+0,     0
        .mptr      A_w1,   x+2,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_,   x+0,     0

LOOP_Y: .trip      3

        ;---------------------------------------------------------;
        ; Load three twiddle factors for the first radix4 butter- ;
        ; fly, and the next three twiddle factors for the second  ;
        ; radix4 butterfly.                                       ;
        ; si10=w[0]   co10=w[1]    si11=w[2]   co11=w[3]          ;
        ; si20=w[4]   co20=w[5]    si21=w[6]   co21=w[7]          ;
        ; si30=w[8]   co30=w[9]    si31=w[a]   co31=w[b]          ;
        ;---------------------------------------------------------;

        LDDW.D2T1  *B_w0[B_j],            A_co11_si11:A_co10_si10
        LDDW.D1T2  *A_w1[A_j],            B_co21_si21:B_co20_si20
        LDDW.D2T2  *B_w2[B_j],            B_co31_si31:B_co30_si30

        ;---------------------------------------------------------;
        ; Load the complex input data for the first radix4 bfly.  ;
        ; x[0]    x[1]    x[2]    x[3]                            ;
        ; x[h2+0] x[h2+1] x[h2+2] x[h2+3]                         ;
        ; x[l1+0] x[l1+1] x[l1+2] x[l1+3]                         ;
        ; x[l2+0] x[l2+1] x[l2+2] x[l2+3]                         ;
        ; These loads cannot parallelize as they could have bank  ;
        ; conflicts.                                              ;
        ;---------------------------------------------------------;

        LDDW.D2T1  *B_x[0],               A_x_3_x_2:A_x_1_x_0
        LDDW.D2T1  *B_x[B_h2],            A_xh2_3_xh2_2:A_xh2_1_xh2_0
        LDDW.D2T2  *B_x[B_l1],            B_xl1_3_xl1_2:B_xl1_1_xl1_0
        LDDW.D2T2  *B_x[B_l2],            B_xl2_3_xl2_2:B_xl2_1_xl2_0

        ;--------------------------------------------------------;
        ; Perform radix2 style DIF equations on input data       ;
        ; The subscript "h" refers to high and "l" refers to low ;
        ; xh0_0  =  x[0] + x[l1]    xh1_0  =  x[1] + x[l1+1]     ;
        ; xh0_1  =  x[2] + x[l1+2]  xh1_1  =  x[3] + x[l1+3]     ;
        ; xl0_0  =  x[0] - x[l1]    xl1_0  =  x[1] - x[l1+1]     ;
        ; xl0_1  =  x[2] - x[l1+2]  xl1_1  =  x[3] - x[l1+3]     ;
        ;--------------------------------------------------------;

        ADD2.2     B_xl1_1_xl1_0,         A_x_1_x_0,          B_xh1_0_xh0_0
        ADD2.2     B_xl1_3_xl1_2,         A_x_3_x_2,          B_xh1_1_xh0_1
        SUB2.1x    A_x_1_x_0,             B_xl1_1_xl1_0,      A_xl1_0_xl0_0
        SUB2.1x    A_x_3_x_2,             B_xl1_3_xl1_2,      A_xl1_1_xl0_1

        ;--------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]   xh21_0 = x[h2+1] + x[l2+1];
        ; xh20_1 = x[h2+2] + x[l2+2]   xh21_1 = x[h2+3]+x[l2+3]  ;
        ;--------------------------------------------------------;

        ADD2.2x    B_xl2_1_xl2_0,         A_xh2_1_xh2_0,      B_xh21_0_xh20_0
        ADD2.2x    B_xl2_3_xl2_2,         A_xh2_3_xh2_2,      B_xh21_1_xh20_1

        ;--------------------------------------------------------;
        ; xl20_0 = x[h2  ] - x[l2  ];  xl21_0 = x[h2+1] - x[l2+1];
        ; xl20_1 = x[h2+2] - x[l2+2];  xl21_1 = x[h2+3] - x[l2+3];
        ;--------------------------------------------------------;

        SUB2.1x    A_xh2_1_xh2_0,         B_xl2_1_xl2_0,      A_xl21_0_xl20_0
        SUB2.1x    A_xh2_3_xh2_2,         B_xl2_3_xl2_2,      A_xl21_1_xl20_1

        ;---------------------------------------------------------;
        ; Make copies of the input pointer so that stores take    ;
        ; place. Use the delayed move instruction to avoid live   ;
        ; too longs.                                              ;
        ;---------------------------------------------------------;

        MVD.1x     B_x,                   A_x_
        MVD.1      A_x_,                  A_x__

        ;---------------------------------------------------------;
        ; Check if the current twiddle factor sub-table has been  ;
        ; exhausted. If so reest twiddle factor index to zero,    ;
        ; and increment the data pointer by the "fft_jmp" so      ;
        ; that the data elements that re-use the twiddle factor   ;
        ; may be loaded.                                          ;
        ;                                                         ;
        ; if (!(j - fft_jmp))                                     ;
        ; {                                                       ;
        ;     j += 12 shorts;                                     ;
        ;     x += fft_jmp;                                       ;
        ;     j = 0;                                              ;
        ; }                                                       ;
        ;     x += 4(shorts)                                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; Since the twiddle factor array is loaded in as doubles  ;
        ; the increment by 12 shorts is done as an add by 3, as   ;
        ; the load double word scales this offset by 4.           ;
        ;---------------------------------------------------------;

        SUB.1      A_fft_jmp,             A_j,                A_ifj
        ADD.1      A_j,                   3,                  A_j
        ADD.2      B_j,                   3,                  B_j

        ;----------------------------------------------------------;
        ; If j equals fft_jmp, then the data pointer is incr-      ;
        ; emented by this amount, so that twiddle factors can be   ;
        ; re-used.                                                 ;
        ;----------------------------------------------------------;

[!A_ifj]ADD.2      B_x,                   B_fft_jmp,          B_x
[!A_ifj]ZERO.2     B_j
[!A_ifj]ZERO.1     A_j
        ADD.2      B_x,                   8,                  B_x

        ;----------------------------------------------------------;
        ; Compute first set of outputs:                            ;
        ;                                                          ;
        ;  x0[0]= xh0_0 + xh20_0 + 1 >> 1                          ;
        ;  x0[1]= xh1_0 + xh21_0 + 1 >> 1                          ;
        ;----------------------------------------------------------;

        AVG2.2     B_xh21_0_xh20_0,       B_xh1_0_xh0_0,      B_x_1_x_0
        AVG2.2     B_xh21_1_xh20_1,       B_xh1_1_xh0_1,      B_x_3_x_2


        ;----------------------------------------------------------;
        ; xt0_0 = xh0_0 - xh20_0  yt0_0 = xh1_0 - xh21_0           ;
        ; xt0_1 = xh0_1 - xh20_1  yt0_1 = xh1_1 - xh21_1           ;
        ;----------------------------------------------------------;

        SUB2.2     B_xh1_0_xh0_0,         B_xh21_0_xh20_0,    B_yt0_0_xt0_0
        SUB2.2     B_xh1_1_xh0_1,         B_xh21_1_xh20_1,    B_yt0_1_xt0_1

        ;----------------------------------------------------------;
        ; Perform a halfword swizzle so that xl0 can be combined   ;
        ; with xl21, xl1 can be combined with xl20. This is a      ;
        ; reult of the multiplication by the j term                ;
        ;----------------------------------------------------------;

        PACKLH2.1  A_xl21_0_xl20_0,       A_xl21_0_xl20_0,    A_xl20_0_xl21_0
        PACKLH2.1  A_xl21_1_xl20_1,       A_xl21_1_xl20_1,    A_xl20_1_xl21_1

        ;----------------------------------------------------------;
        ; xt1_0 = xl0_0 + xl21_0   yt2_0 = xl1_0 + xl20_0          ;
        ; xt1_1 = xl0_1 + xl21_1   yt2_1 = xl1_1 + xl20_1          ;
        ; xt2_0 = xl0_0 - xl21_0   yt1_0 = xl1_0 - xl20_0          ;
        ; xt2_1 = xl0_1 - xl21_1   yt1_1 = xl1_1 - xl20_1          ;
        ;----------------------------------------------------------;

        ADD2.1     A_xl1_0_xl0_0,         A_xl20_0_xl21_0,    A_yt2_0_xt1_0
        ADD2.1     A_xl1_1_xl0_1,         A_xl20_1_xl21_1,    A_yt2_1_xt1_1
        SUB2.1     A_xl1_0_xl0_0,         A_xl20_0_xl21_0,    A_yt1_0_xt2_0
        SUB2.1     A_xl1_1_xl0_1,         A_xl20_1_xl21_1,    A_yt1_1_xt2_1

        ;----------------------------------------------------------;
        ; Since yt2 and xt1 get packed together, we need to do     ;
        ; a few more packs to get terms yt1,xt1 packed together    ;
        ; This operation is akin to taking a 2x2 transpose.        ;
        ; This allows us to get packed xy's for  the three other   ;
        ; inputs of the butterfly.                                 ;
        ;----------------------------------------------------------;

        PACKLH2.1  A_yt2_0_xt1_0,         A_yt1_0_xt2_0,      A_xt1_0_yt1_0
        PACKLH2.1  A_yt2_1_xt1_1,         A_yt1_1_xt2_1,      A_xt1_1_yt1_1
        PACKLH2.1  A_yt1_0_xt2_0,         A_yt2_0_xt1_0,      A_xt2_0_yt2_0
        PACKLH2.1  A_yt1_1_xt2_1,         A_yt2_1_xt1_1,      A_xt2_1_yt2_1

        ;----------------------------------------------------------;
        ; In addition either the data terms or the twiddle factor  ;
        ; needs to be rotated by 16, to make use of dotp2 and      ;
        ; dotpn2 using the same twiddle factor to realize real     ;
        ; and imaginary multiplies.                                ;
        ;----------------------------------------------------------;

        PACKLH2.2  B_yt0_0_xt0_0,         B_yt0_0_xt0_0,      B_xt0_0_yt0_0
        PACKLH2.2  B_yt0_1_xt0_1,         B_yt0_1_xt0_1,      B_xt0_1_yt0_1
        ROTL.1     A_xt1_0_yt1_0,         16,                 A_yt1_0_xt1_0
        ROTL.1     A_xt1_1_yt1_1,         16,                 A_yt1_1_xt1_1
        ROTL.1     A_xt2_0_yt2_0,         16,                 A_yt2_0_xt2_0
        ROTL.1     A_xt2_1_yt2_1,         16,                 A_yt2_1_xt2_1

        ;---------------------------------------------------------;
        ; Notice that in this version of the code the two middle  ;
        ; legs are swapped as indicated by the stores to x[l1]..  ;
        ; x[l1 + 3] which preceede the stores to x[h2]..x[h2 + 3] ;
        ; This reversal guarantees that a radix4 DIF butterfly    ;
        ; produces results in digit reversed order. Note that in  ;
        ; addition to the rounding, the shift is performed by 16, ;
        ; as opposed to 15, to give scaling.                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; The following code is implemented on C64x using _dotp2  ;
        ; and _dotpn2. Notice that for the imaginary part, the    ;
        ; data has to be swizzled to get correct results with     ;
        ; _dotpn2, if an extyra negate is to be avoided.          ;
        ;                                                         ;
        ; x2[l1  ] = (si10 * yt1_0 + co10 * xt1_0 + 0x8000) >> 16 ;
        ; x2[l1+1] = (co10 * yt1_0 - si10 * xt1_0 + 0x8000) >> 16 ;
        ; x2[l1+2] = (si11 * yt1_1 + co11 * xt1_1 + 0x8000) >> 16 ;
        ; x2[l1+3] = (co11 * yt1_1 - si11 * xt1_1 + 0x8000) >> 16 ;
        ;                                                         ;
        ; These four results are retained in registers and a      ;
        ; double word is formed so that it can be stored with     ;
        ; one STDW.                                               ;
        ;---------------------------------------------------------;

        DOTP2.2    B_xt0_0_yt0_0,         B_co20_si20,        B_x_l1_0
        DOTPN2.2   B_yt0_0_xt0_0,         B_co20_si20,        B_x_l1_1
        DOTP2.2    B_xt0_1_yt0_1,         B_co21_si21,        B_x_l1_2
        DOTPN2.2   B_yt0_1_xt0_1,         B_co21_si21,        B_x_l1_3

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[h2  ] = (si20 * yt0_0 + co20 * xt0_0 + 0x8000) >> 16 ;
        ; x2[h2+1] = (co20 * yt0_0 - si20 * xt0_0 + 0x8000) >> 16 ;
        ; x2[h2+2] = (si21 * yt0_1 + co21 * xt0_1 + 0x8000) >> 16 ;
        ; x2[h2+3] = (co21 * yt0_1 - si21 * xt0_1 + 0x8000) >> 16 ;
        ;---------------------------------------------------------;


        DOTP2.1    A_xt1_0_yt1_0,         A_co10_si10,        A_x_h2_0
        DOTPN2.1   A_yt1_0_xt1_0,         A_co10_si10,        A_x_h2_1
        DOTP2.1    A_xt1_1_yt1_1,         A_co11_si11,        A_x_h2_2
        DOTPN2.1   A_yt1_1_xt1_1,         A_co11_si11,        A_x_h2_3

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0 + 0x8000) >> 16 ;
        ; x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0 + 0x8000) >> 16 ;
        ; x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1 + 0x8000) >> 16 ;
        ; x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1 + 0x8000) >> 16 ;
        ;---------------------------------------------------------;

        DOTP2.2x   B_co30_si30,           A_xt2_0_yt2_0,      B_x_l2_0
        DOTPN2.2x  B_co30_si30,           A_yt2_0_xt2_0,      B_x_l2_1
        DOTP2.2x   B_co31_si31,           A_xt2_1_yt2_1,      B_x_l2_2
        DOTPN2.2x  B_co31_si31,           A_yt2_1_xt2_1,      B_x_l2_3

        ;---------------------------------------------------------;
        ; Add the rounding term of 0x8000 to all the temporary    ;
        ; results. Shift right by 16 is implemented using pack's  ;
        ;---------------------------------------------------------;

        ADD.1      A_rnd,                 A_x_h2_0,           A_x_h2_0
        ADD.1      A_rnd,                 A_x_h2_1,           A_x_h2_1
        ADD.1      A_rnd,                 A_x_h2_2,           A_x_h2_2
        ADD.1      A_rnd,                 A_x_h2_3,           A_x_h2_3

        ADD.2      B_rnd,                 B_x_l1_0,           B_x_l1_0
        ADD.2      B_rnd,                 B_x_l1_1,           B_x_l1_1
        ADD.2      B_rnd,                 B_x_l1_2,           B_x_l1_2
        ADD.2      B_rnd,                 B_x_l1_3,           B_x_l1_3

        ADD.2      B_rnd,                 B_x_l2_0,           B_x_l2_0
        ADD.2      B_rnd,                 B_x_l2_1,           B_x_l2_1
        ADD.2      B_rnd,                 B_x_l2_2,           B_x_l2_2
        ADD.2      B_rnd,                 B_x_l2_3,           B_x_l2_3

        ;---------------------------------------------------------;
        ; Pack intermediate results retaining upper 16 bits. The  ;
        ; _packh2 performs the shift by 16 bits, by retaining the ;
        ; upper 16 bits and produces a packed 32 bit quantity.    ;
        ; This is the step that results in scaling by a bit per   ;
        ; stage.                                                  ;
        ;---------------------------------------------------------;

        PACKH2.1   A_x_h2_1,              A_x_h2_0,           A_xh2_1_0
        PACKH2.1   A_x_h2_3,              A_x_h2_2,           A_xh2_3_2

        PACKH2.2   B_x_l1_1,              B_x_l1_0,           B_xl1_1_0
        PACKH2.2   B_x_l1_3,              B_x_l1_2,           B_xl1_3_2

        PACKH2.2   B_x_l2_1,              B_x_l2_0,           B_xl2_1_0
        PACKH2.2   B_x_l2_3,              B_x_l2_2,           B_xl2_3_2

        ;---------------------------------------------------------;
        ; Store out the outputs to the four legs of the butterfly ;
        ; using aligned store double words. Notice the use of the ;
        ; indices "l1", "l2", "h2" to derive the pointers for the ;
        ; legs of the butterfly.                                  ;
        ;---------------------------------------------------------;

        STDW.D1T2  B_x_3_x_2:B_x_1_x_0,   *A_x_[0]
        STDW.D1T1  A_xh2_3_2:A_xh2_1_0,   *A_x__[A_l1]
        STDW.D1T2  B_xl1_3_2:B_xl1_1_0,   *A_x__[A_h2]
        STDW.D1T2  B_xl2_3_2:B_xl2_1_0,   *A_x__[A_l2]

        ;---------------------------------------------------------;
        ; Decrement and branch on loop variable A_i.              ;
        ;---------------------------------------------------------;

        BDEC.1     LOOP_Y,                A_i

        ;---------------------------------------------------------;
        ; Continue to use this loop as long as stride > radix     ;
        ;---------------------------------------------------------;

        CMPGTU.2   B_stride,              B_radix,            B_while
[B_while]B.2       LOOP_WHILE


        ;---------------------------------------------------------;
        ; The following condition allows fft to become a multiple ;
        ; call FFT as it exits as soon as stride, between two     ;
        ; legs becomes greater than the radix.                    ;
        ;---------------------------------------------------------;

        CMPGTU.2   B_radix,               4,                  B_early
[B_early]B.2       EARLY_EXIT

        ;---------------------------------------------------------;
        ; Check if radix is 2, and prepare zero for each data     ;
        ; path.                                                   ;
        ;---------------------------------------------------------;

        SUB.2      B_radix,               2,                  A_r2
        ZERO.1     A_zero
        ZERO.2     B_zero

        ;---------------------------------------------------------;
        ; Prepare twin data pointers. In addition prepare four    ;
        ; output pointers as follows:                             ;
        ; y0 = ptr_y                                              ;
        ; y1 = y0 + (nmax >> 1)                                   ;
        ; y2 = y1 + (nmax >> 1)                                   ;
        ; y3 = y2 + (nmax >> 1)                                   ;
        ;---------------------------------------------------------;

        MV.1x      B_ptr_x,               A_x0
        ADD.2      B_ptr_x,               8,                  B_x0

        MV.2x      A_ptr_y,               B_y0
        ADD.2      B_y0,                  B_nmax,             B_y1
        ADD.2      B_y1,                  B_nmax,             B_y2
        ADD.2      B_y2,                  B_nmax,             B_y3

        ;--------------------------------------------------------;
        ; Determine the norm, and derive shift amount by adding  ;
        ; 4 to it.                                               ;
        ;--------------------------------------------------------;

        NORM.2     B_nmax,                B_l1
        ADD.2      B_l1,                  4,                  B_l1

        ;--------------------------------------------------------;
        ; Loop trip counter is n >> 2. In addition deduct 2 for  ;
        ; BDEC. Set j to be offset >> 2                          ;
        ;--------------------------------------------------------;

        SHRU.1     A_n,                   2,                  A_i
        SUB.1      A_i,                   2,                  A_i
        SHRU.1     A_offset,              2,                  B_j

        ;--------------------------------------------------------;
        ; Infrom the compiler that there are twin data pointers  ;
        ; A_x0, B_x0. In addition inform compiler that there     ;
        ; is one data pointer for B side.                        ;
        ;--------------------------------------------------------;

        .mptr      A_x0,   A_x + 0, 16
        .mptr      B_x0,   A_x + 1, 16
        .mptr      B_y0,   A_x + 0, 0

LOOP_Z: .trip      4

        ;--------------------------------------------------------;
        ; The following performs bit reversal of index "j"       ;
        ; of size "l0" bits into index "k". This forms the index ;
        ; with respect to pointers y0, y1, y2, y3 into which  4  ;
        ; consecutive inputs map into.                           ;
        ;--------------------------------------------------------;

        BITR.2     B_j,                   B_h3
        SHRU.2     B_h3,                  B_l1,               B_h4
        ADD.2      B_j,                   1,                  B_j

        ;-------------------------------------------------------;
        ; Load input data using double word wide loads. In add- ;
        ; ition make partitioning copy using M unit to avoid    ;
        ; variables that live too long.                         ;
        ;-------------------------------------------------------;

        LDDW.D1T1  *A_x0++[2],            A_x3x2:A_x1x0
        LDDW.D2T2  *B_x0++[2],            B_x7x6:B_x5x4
        ROTL.1x    B_x7x6,                0,                  A_x7x6

        ;-------------------------------------------------------;
        ; Read in the input data, from the first eight locns.   ;
        ; These results are transformed as radix 4              ;
        ;  xl0_0  = x_0 - x_4; xl1_0  = x_1 - x_5;              ;
        ;  xl0_1  = x_2 - x_6; xl1_1  = x_3 - x_7;              ;
        ;-------------------------------------------------------;

        SUB2.1x    A_x1x0,                B_x5x4,             A_xl1_0_xl0_0
        SUB2.1     A_x3x2,                A_x7x6,             A_xl1_1_xl0_1

        ;-------------------------------------------------------;
        ; Swizzle the data and compute the negative for change  ;
        ; if radix is 2 rather than 4.                          ;
        ;-------------------------------------------------------;

        ROTL.1     A_xl1_1_xl0_1,         16,                 A_xl0_1_xl1_1
        SUB2.1     A_zero,                A_x7x6,             A_mx7mx6

        ;------------------------------------------------------;
        ; These results are appropriately changed if radix     ;
        ; is 2, so that when the next set of radix 4 steps     ;
        ; performed then the results are same as radix 2.      ;
        ;                                                      ;
        ; xl0_0   =   x_4;     xl1_0   =   x_5;                ;
        ; xl1_1   =   x_6;     xl0_1   =   -x_7;               ;
        ;------------------------------------------------------;

[!A_r2] ROTL.1x    B_x5x4,                0,                  A_xl1_0_xl0_0
[!A_r2] PACKHL2.1  A_mx7mx6,              A_x7x6,             A_xl0_1_xl1_1

        ;------------------------------------------------------;
        ; Perform nest step of radix4 for lower leg. This will ;
        ; result in the correct results radix4 or radix2       ;
        ; yt2  = xl0_0 + xl1_1; yt7  = xl1_0 + xl0_1;          ;
        ; yt6  = xl0_0 - xl1_1; yt3  = xl1_0 - xl0_1;          ;
        ;------------------------------------------------------;

        ADD2.1     A_xl1_0_xl0_0,         A_xl0_1_xl1_1,      A_yt7_yt2
        SUB2.1     A_xl1_0_xl0_0,         A_xl0_1_xl1_1,      A_yt3_yt6

        ;------------------------------------------------------;
        ; Repack results so that dajacent results are packed to;
        ; gether for comitting to memory as a store double word;
        ;------------------------------------------------------;


        PACKHL2.1  A_yt3_yt6,             A_yt7_yt2,          A_y3y2
        PACKHL2.1  A_yt7_yt2,             A_yt3_yt6,          A_y7y6

        ;-----------------------------------------------------;
        ; Zero out the contributions of x4..x7 for the high   ;
        ; leg if the radix is 2, rememebering that the cont-  ;
        ; ributions are restricted within four points.        ;
        ;  x_4 = x_5 = x_6 = x_7 = 0;                         ;
        ;-----------------------------------------------------;

[!A_r2] MPY2.2     B_zero,                B_zero,             B_x7x6:B_x5x4

        ;-----------------------------------------------------;
        ; Perform radix4 decomposition as a series of radix2  ;
        ; compositions. This yields yt1:yt0 and yt5:yt4       ;
        ;                                                     ;
        ;  xh0_0  = x_0   +  x_4;     xh1_0  = x_1 + x_5;     ;
        ;  xh0_1  = x_2   +  x_6;     xh1_1  = x_3 + x_7;     ;
        ;  yt0    = xh0_0 +  xh0_1;   yt1  = xh1_0 + xh1_1;   ;
        ;  yt4    = xh0_0 -  xh0_1;   yt5  = xh1_0 - xh1_1;   ;
        ;                                                     ;
        ;-----------------------------------------------------;

        ADD2.2     B_x5x4,                A_x1x0,             B_xh1_0_xh0_0
        ADD2.2     B_x7x6,                A_x3x2,             B_xh1_1_xh0_1
        ADD2.2     B_xh1_0_xh0_0,         B_xh1_1_xh0_1,      B_y1y0
        SUB2.2     B_xh1_0_xh0_0,         B_xh1_1_xh0_1,      B_y5y4

        ;-----------------------------------------------------;
        ;  Store out the results of the radix4 butterfly as 4 ;
        ; or the result of 2 radix2 butterflies. These results;
        ; are stored out using store words _amem4 intrinsic.  ;
        ;-----------------------------------------------------;

        STW.D2T2   B_y1y0,                *B_y0[B_h4]
        STW.D2T1   A_y3y2,                *B_y1[B_h4]
        STW.D2T2   B_y5y4,                *B_y2[B_h4]
        STW.D2T1   A_y7y6,                *B_y3[B_h4]

        ;-----------------------------------------------------;
        ; Decrement and branch on loop variable A_i.          ;
        ;-----------------------------------------------------;

        BDEC.1     LOOP_Z,                A_i

        ;-----------------------------------------------------;
        ;  Early exit for early return                        ;
        ;-----------------------------------------------------;

EARLY_EXIT:

        .return
        .endproc

*=========================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=========================================================================*

fft16x16t.sa/   1066929505  0     0     0       63690     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Aug 30 14:33:54 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*      fft: Mixed radix FFT for 2^M and 4^M, 16x16 with truncation          *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Dec-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*     void DSP_fft16x16t(const short * ptr_w, int  npoints, short * ptr_x,  *
*                    short * ptr_y)                                         *
*                                                                           *
*   where:                                                                  *
*   ptr_w: pointer to an array of twiddle factors generated as explained    *
*   below.                                                                  *
*   npoints: Number of points for the FFT transform, can be a multiple of   *
*   2 or 4.                                                                 *
*   ptr_x: Pointer to input data to be transformed.                         *
*   ptr_y: Pointer that contains the final FFT results in normal order.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs a Radix-4 FFT with digit reversal.  The code     *
*       uses a special ordering of twiddle factors and memory accesses      *
*       to improve performance in the presence of cache.  It operates       *
*       largely in-place, but the final digit-reversed output is written    *
*       out-of-place.                                                       *
*                                                                           *
*       This code requires a special sequence of twiddle factors stored     *
*       in 1Q15 fixed-point format.  The following C code illustrates       *
*       one way to generate the desired twiddle-factor array:               *
*                                                                           *
*       #include <math.h>                                                   *
*                                                                           *
*       #ifndef PI                                                          *
*       # define PI (3.14159265358979323846)                                *
*       #endif                                                              *
*                                                                           *
*       short d2s(double d)                                                 *
*       {                                                                   *
*           d = floor(0.5 + d);  /* Explicit rounding to integer */         *
*           if (d >=  32767.0) return  32767;                               *
*           if (d <= -32768.0) return -32768;                               *
*           return (short)d;                                                *
*       }                                                                   *
*                                                                           *
*       void gen_twiddle(short *w, int n)                                   *
*       {                                                                   *
*           double M = 32767.5;                                             *
*           int i, j, k;                                                    *
*                                                                           *
*           for (j = 1, k = 0; j < n >> 2; j = j << 2)                      *
*           {                                                               *
*               for (i = 0; i < n >> 2; i += j << 1)                        *
*               {                                                           *
*                   w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       *
*                   w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       *
*                   w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       *
*                   w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       *
*                   w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       *
*                   w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       *
*                   w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       *
*                   w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       *
*                   w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       *
*                   w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       *
*                                                                           *
*                   k += 12;                                                *
*               }                                                           *
*           }                                                               *
*           w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   *
*           w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The size of the FFT, n, must be a power of 4 or 2 and greater than  *
*       or equal to 16 and less than 32768.                                 *
*                                                                           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order. In addition if the number  *
*       of points to be transformed is a power of 2, the final stage        *
*       applies a radix2 pass instead of a radix 4. In any case the         *
*       outputs are returned in normal order.                               *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using _dotpn2           *
*       after the twiddle factors are swizzled within the half word.        *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   SPECIAL TECHNIQUES                                                      *
*       a) The _norm operator is used in determining the size of the        *
*       fft and also in dtermining whether a radix4 or radix2 stage         *
*       for the last pass of the transform.                                 *
*       b) The _dotp2 and _dotpn2 instructions are used for implementing    *
*       the complex multiplies. The subtract operator is not commutative.   *
*       Hence the use of the _dotpn2 instruction enforces a certain ord-    *
*       ering. This causes the data to be swizzled about the halfword,      *
*       using either a packlh or a rotate.                                  *
*       c) Individual stores to memory are accumulated and performed        *
*       as double word wide accesses as are loads from memory for data      *
*       which serves as the main inspiration for all the optimizations      *
*       performed on the FFT.                                               *
*       d) The digit reversal is performed through the combination of       *
*       deal, shfl, bitr, rotl. This helps to obtain a digit reversed       *
*       index from the normal index.                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_fft16x16t"
        .global _DSP_fft16x16t
_DSP_fft16x16t: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y
             .no_mdep
*============================================================================*
        .reg    A_j, B_j,  B_w0, A_w0, A_w1, B_w2, B_x, B_h2
        .reg    B_l1, B_l2, A_h2, A_l1, A_l2
        .reg    A_co11_si11:A_co10_si10
        .reg    B_co21_si21:B_co20_si20
        .reg    B_co31_si31:B_co30_si30
        .reg    B_xl1_3_xl1_2:B_xl1_1_xl1_0
        .reg    A_xh2_3_xh2_2:A_xh2_1_xh2_0
        .reg    B_xl2_3_xl2_2:B_xl2_1_xl2_0
        .reg    B_xh0_0_xh0_0, B_xh1_0_xh0_0
        .reg    A_xl1_0_xl0_0, B_xh1_1_xh0_1
        .reg    A_xl1_1_xl0_1, A_xl0_0_xl1_0
        .reg    B_xh21_0_xh20_0, B_xh21_1_xh20_1
        .reg    A_xl21_0_xl20_0, A_xl21_1_xl20_1
        .reg    A_x1,B_x1, A_x_, A_x__
        .reg    A_fft_jmp
        .reg    A_ifj, B_ifj
        .reg    B_fft_jmp
        .reg    A_x_3_x_2:A_x_1_x_0
        .reg    B_x_3_x_2:B_x_1_x_0
        .reg    A_xl20_0_xl21_0, A_xl20_1_xl21_1
        .reg    A_yt2_0_xt1_0, A_yt1_0_xt2_0
        .reg    A_yt2_1_xt1_1, A_yt1_1_xt2_1
        .reg    A_xt1_0_yt1_0, A_xt2_0_yt2_0
        .reg    A_xt1_1_yt1_1, A_xt2_1_yt2_1
        .reg    B_xt0_0_yt0_0, B_xt0_1_yt0_1
        .reg    A_yt1_0_xt1_0, A_yt1_1_xt1_1
        .reg    A_yt2_0_xt2_0, A_yt2_1_xt2_1
        .reg    A_xh1_0_xh0_0, A_xh21_0_xh20_0
        .reg    A_xt1_0_yt2_0, A_xt2_0_yt1_0
        .reg    A_x_h2_0, A_x_h2_1, A_x_h2_2, A_x_h2_3, B_x_l1_1, B_x_l1_0
        .reg    B_x_l1_2, B_x_l1_3, B_x_l2_0, B_x_l2_1, B_x_l2_2, B_x_l2_3
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride,B_stride_1, B_while
        .reg    B_c10, A_x0, A_xo2, B_xo3
        .reg    A_tbta, A_t3t2
        .reg    B_x7x6:B_x5x4, B_x3x2:B_x1x0
        .reg    A_x7x6:A_x5x4, A_x3x2:A_x1x0
        .reg    B_y9y8:B_y1y0, B_ydyc:B_y5y4
        .reg    A_yfye:A_y7y6, A_ybya:A_y3y2
        .reg    B_yt0_1_xt0_1:B_yt0_0_xt0_0
        .reg    B_fft_jmp_1, B_xl21_1_xl20_1
        .reg    A_xbxa:A_x9x8, B_xfxe:B_xdxc
        .reg    A_yt0_0_xt0_0, A_xt2_1_yt1_1
        .reg    B_xl1_1_xl0_1, A_xl0_1_xl1_1, A_xt1_1_yt2_1
        .reg    A_n, B_x0, B_n_2, B_nm2
        .reg    B_y0, B_y1, B_y2, B_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2
        .reg    A_i, A_r2, B_j0
        .reg    A_n_4, B_n_4

        .reg    B_x9x8, B_xbxa
*============================================================================*

        ;----------------------------------------------------------;
        ; Check the size of the FFT to dtermine whether it is      ;
        ; radix 4 or radix 2. This is done by anding norm with     ;
        ; 1, and checking result.                                  ;
        ;----------------------------------------------------------;

        MVK    .1       4,                 A_radix
        NORM   .2       B_n,               B_radix2
        AND    .2       B_radix2,          1,                  B_radix2
[B_radix2]MVK  .1       2,                 A_radix

        ;----------------------------------------------------------;
        ; Initially set stride = n. The "tw_offset" is set to zero ;
        ; and is the offset that is added to the twiddle factor    ;
        ; pointer "ptr_w" for the current iteration. At the start  ;
        ; of the program "tw_offset" is 0.                         ;
        ;----------------------------------------------------------;

        MV     .2       B_n,               B_stride
        ZERO   .1       A_tw_offset

LOOP_WHILE:

        ;---------------------------------------------------------;
        ; "j" is an index into the twiddle factor array. At the   ;
        ; start of every iteration of the outer loop, it is re    ;
        ; set to zero.                                            ;
        ;---------------------------------------------------------;

        ZERO   .1       A_j
        ZERO   .2       B_j

        ;---------------------------------------------------------;
        ; For every iteration of the inner loop, 6 * stride,      ;
        ; twiddle factors are loaded, where half of them are      ;
        ; cosines and the other half are sines. Since the data    ;
        ; is being accessed as double words. The fft_jmp is       ;
        ; set to fft_jmp/8                                        ;
        ;---------------------------------------------------------;

        SHL    .2       B_stride,          1,                  B_stride_1
        ADD    .2       B_stride,          B_stride_1,         B_fft_jmp
        SHRU   .1X      B_fft_jmp,         3,                  A_fft_jmp

        ;---------------------------------------------------------;
        ; Input data offsets are set for double words             ;
        ; h2: loads &x[N/2] where x is a short array, hence its   ;
        ; double word offset is N/8. Similar argument holds for   ;
        ; l1 and l2.                                              ;
        ;---------------------------------------------------------;

        SHRU   .2       B_stride,          3,                  B_h2
        SHRU   .2       B_stride,          2,                  B_l1
        ADD    .2       B_l1,              B_h2,               B_l2

        ;---------------------------------------------------------;
        ; Make partitioning copies of the indexes into oppsoite   ;
        ; data paths.                                             ;
        ;---------------------------------------------------------;


        MV     .1X      B_l1,              A_l1
        MV     .1X      B_h2,              A_h2
        MV     .1X      B_l2,              A_l2

        ;---------------------------------------------------------;
        ; Reset data pointer, derive twin twiddle factors.        ;
        ; Add twiddle offset to ptr_w to derive new twiddle       ;
        ; factor pointer.                                         ;
        ;---------------------------------------------------------;

        MV     .2X      A_ptr_x,           B_x
        ADDAH  .1       A_ptr_w,           A_tw_offset,        A_w0
        MV     .2X      A_w0,              B_w0
        ADD    .1       A_w0,              8,                  A_w1
        ADD    .2X      A_w1,              8,                  B_w2

        SHRU   .2       B_fft_jmp,         1,                  B_fft_jmp_1
        ADD    .1X      A_tw_offset,       B_fft_jmp_1,        A_tw_offset

        ;---------------------------------------------------------;
        ; The stride is quartered with every iteration of the     ;
        ; outer loop until stride = 4.                            ;
        ;---------------------------------------------------------;

        SHRU   .2       B_stride,          2,                  B_stride

        ;---------------------------------------------------------;
        ; The following loop iterates for N/8 iterations. Since   ;
        ; BDEC is used 2 needs to be subtracted from the loop     ;
        ; counter A_i. Adjust other thresholds as well for this   ;
        ;---------------------------------------------------------;


        SHRU   .1X      B_n,               3,                  A_i
        SUB    .1       A_i,               2,                  A_i
        SUB    .1       A_fft_jmp,         3,                  A_fft_jmp


        ;---------------------------------------------------------;
        ; Since the stride amount across iterations is variable,  ;
        ; it is tough to put an exact stride. However for this    ;
        ; loop stride is guranteed to be greater than or equal    ;
        ; to 16 complex samples, 32 half words. Since this str-   ;
        ; ide is wider than the bank width, of all the banks,     ;
        ; stride is specified as zero.                            ;
        ;---------------------------------------------------------;


        .mptr      B_w0,   x+0,     0
        .mptr      A_w1,   x+2,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_,   x+0,     0


LOOP_Y: .trip 16

        ;---------------------------------------------------------;
        ; Load three twiddle factors for the first radix4 butter- ;
        ; fly, and the next three twiddle factors for the second  ;
        ; radix4 butterfly.                                       ;
        ; si10=w[0]   co10=w[1]    si11=w[2]   co11=w[3]          ;
        ; si20=w[4]   co20=w[5]    si21=w[6]   co21=w[7]          ;
        ; si30=w[8]   co30=w[9]    si31=w[a]   co31=w[b]          ;
        ;---------------------------------------------------------;

        LDDW  .D2T1     *B_w0[B_j],        A_co11_si11:A_co10_si10
        LDDW  .D1T2     *A_w1[A_j],        B_co21_si21:B_co20_si20
        LDDW  .D2T2     *B_w2[B_j],        B_co31_si31:B_co30_si30

        ;---------------------------------------------------------;
        ; Load the complex input data for the first radix4 bfly.  ;
        ; x[0]    x[1]    x[2]    x[3]                            ;
        ; x[h2+0] x[h2+1] x[h2+2] x[h2+3]                         ;
        ; x[l1+0] x[l1+1] x[l1+2] x[l1+3]                         ;
        ; x[l2+0] x[l2+1] x[l2+2] x[l2+3]                         ;
        ; These loads cannot parallelize as they could have bank  ;
        ; conflicts.                                              ;
        ;---------------------------------------------------------;

        LDDW  .D2T1     *B_x[0],           A_x_3_x_2:A_x_1_x_0
        LDDW  .D2T1     *B_x[B_h2],        A_xh2_3_xh2_2:A_xh2_1_xh2_0
        LDDW  .D2T2     *B_x[B_l1],        B_xl1_3_xl1_2:B_xl1_1_xl1_0
        LDDW  .D2T2     *B_x[B_l2],        B_xl2_3_xl2_2:B_xl2_1_xl2_0

        ;--------------------------------------------------------;
        ; Perform radix2 style DIF equations on input data       ;
        ; The subscript "h" refers to high and "l" refers to low ;
        ; xh0_0  =  x[0] + x[l1]    xh1_0  =  x[1] + x[l1+1]     ;
        ; xh0_1  =  x[2] + x[l1+2]  xh1_1  =  x[3] + x[l1+3]     ;
        ; xl0_0  =  x[0] - x[l1]    xl1_0  =  x[1] - x[l1+1]     ;
        ; xl0_1  =  x[2] - x[l1+2]  xl1_1  =  x[3] - x[l1+3]     ;
        ;--------------------------------------------------------;

        ADD2  .2X       B_xl1_1_xl1_0,     A_x_1_x_0,         B_xh1_0_xh0_0
        ADD2  .2X       B_xl1_3_xl1_2,     A_x_3_x_2,         B_xh1_1_xh0_1
        SUB2  .1X       A_x_1_x_0,         B_xl1_1_xl1_0,     A_xl1_0_xl0_0
        SUB2  .1X       A_x_3_x_2,         B_xl1_3_xl1_2,     A_xl1_1_xl0_1

        ;--------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]   xh21_0 = x[h2+1] + x[l2+1];
        ; xh20_1 = x[h2+2] + x[l2+2]   xh21_1 = x[h2+3]+x[l2+3]  ;
        ; xl20_0 = x[h2  ] - x[l2  ];  xl21_0 = x[h2+1] - x[l2+1];
        ; xl20_1 = x[h2+2] - x[l2+2];  xl21_1 = x[h2+3] - x[l2+3];
        ;--------------------------------------------------------;

        ADD2  .2X       B_xl2_1_xl2_0,     A_xh2_1_xh2_0,     B_xh21_0_xh20_0
        ADD2  .2X       B_xl2_3_xl2_2,     A_xh2_3_xh2_2,     B_xh21_1_xh20_1
        SUB2  .1X       A_xh2_1_xh2_0,     B_xl2_1_xl2_0,     A_xl21_0_xl20_0
        SUB2  .1X       A_xh2_3_xh2_2,     B_xl2_3_xl2_2,     A_xl21_1_xl20_1

        ;---------------------------------------------------------;
        ; Make copies of the input pointer so that stores take    ;
        ; place. Use the delayed move instruction to avoid live   ;
        ; too longs.                                              ;
        ;---------------------------------------------------------;

        MVD   .1X       B_x,               A_x_
        MVD   .1        A_x_,              A_x__

        ;---------------------------------------------------------;
        ; Check if the current twiddle factor sub-table has been  ;
        ; exhausted. If so reest twiddle factor index to zero,    ;
        ; and increment the data pointer by the "fft_jmp" so      ;
        ; that the data elements that re-use the twiddle factor   ;
        ; may be loaded.                                          ;
        ;                                                         ;
        ; if (!(j - fft_jmp))                                     ;
        ; {                                                       ;
        ;     j += 12 shorts;                                     ;
        ;     x += fft_jmp;                                       ;
        ;     j = 0;                                              ;
        ; }                                                       ;
        ;     x += 4(shorts)                                      ;
        ;---------------------------------------------------------;

        ;---------------------------------------------------------;
        ; Since the twiddle factor array is loaded in as doubles  ;
        ; the increment by 12 shorts is done as an add by 3, as   ;
        ; the load double word scales this offset by 4.           ;
        ;---------------------------------------------------------;

        SUB   .1        A_fft_jmp,         A_j,               A_ifj
        ADD   .1        A_j,               3,                 A_j
        ADD   .2        B_j,               3,                 B_j
[!A_ifj]ADD   .2        B_x,               B_fft_jmp,         B_x
[!A_ifj]ZERO  .2        B_j
[!A_ifj]ZERO  .1        A_j

        ;---------------------------------------------------------;
        ; Increment x by 8, anyways, adjust fft_jmp to take this  ;
        ; increment into account.                                 ;
        ;---------------------------------------------------------;

        ADD   .2        B_x,               8,                 B_x

        ;----------------------------------------------------------;
        ; Compute first set of outputs:                            ;
        ;                                                          ;
        ;  x_0 = xh0_0 + xh20_0      x_1   = xh0_1 + xh20_1        ;
        ;  x_2 = xh1_0 + xh21_0      x_3   = xh1_1 + xh21_1        ;
        ;  xt0_0   = xh0_0 - xh20_0  yt0_0 = xh1_0 - xh21_0        ;
        ;  xt0_1   = xh0_1 - xh20_1  yt0_1 = xh1_1 - xh21_1        ;
        ;----------------------------------------------------------;


        ADD2  .2        B_xh21_0_xh20_0,   B_xh1_0_xh0_0,     B_x_1_x_0
        ADD2  .2        B_xh21_1_xh20_1,   B_xh1_1_xh0_1,     B_x_3_x_2
        SUB2  .2        B_xh1_0_xh0_0,     B_xh21_0_xh20_0,   B_yt0_0_xt0_0
        SUB2  .2        B_xh1_1_xh0_1,     B_xh21_1_xh20_1,   B_yt0_1_xt0_1

        ;----------------------------------------------------------;
        ; Perform a halfword swizzle so that xl0 can be combined   ;
        ; with xl21, xl1 can be combined with xl20. This is a      ;
        ; reult of the multiplication by the j term                ;
        ;----------------------------------------------------------;

        PACKLH2.1       A_xl21_0_xl20_0,   A_xl21_0_xl20_0,   A_xl20_0_xl21_0
        PACKLH2.1       A_xl21_1_xl20_1,   A_xl21_1_xl20_1,   A_xl20_1_xl21_1

        ;----------------------------------------------------------;
        ; xt1_0 = xl0_0 + xl21_0   yt2_0 = xl1_0 + xl20_0          ;
        ; xt1_1 = xl0_1 + xl21_1   yt2_1 = xl1_1 + xl20_1          ;
        ; xt2_0 = xl0_0 - xl21_0   yt1_0 = xl1_0 - xl20_0          ;
        ; xt2_1 = xl0_1 - xl21_1   yt1_1 = xl1_1 - xl20_1          ;
        ;----------------------------------------------------------;

        ADD2   .1       A_xl1_0_xl0_0,     A_xl20_0_xl21_0,   A_yt2_0_xt1_0
        ADD2   .1       A_xl1_1_xl0_1,     A_xl20_1_xl21_1,   A_yt2_1_xt1_1
        SUB2   .1       A_xl1_0_xl0_0,     A_xl20_0_xl21_0,   A_yt1_0_xt2_0
        SUB2   .1       A_xl1_1_xl0_1,     A_xl20_1_xl21_1,   A_yt1_1_xt2_1

        ;----------------------------------------------------------;
        ; Since yt2 and xt1 get packed together, we need to do     ;
        ; a few more packs to get terms yt1,xt1 packed together    ;
        ; This operation is akin to taking a 2x2 transpose.        ;
        ; This allows us to get packed xy's for  the three other   ;
        ; inputs of the butterfly.                                 ;
        ;----------------------------------------------------------;

        PACKLH2.1       A_yt2_0_xt1_0,     A_yt1_0_xt2_0,     A_xt1_0_yt1_0
        PACKLH2.1       A_yt2_1_xt1_1,     A_yt1_1_xt2_1,     A_xt1_1_yt1_1
        PACKLH2.1       A_yt1_0_xt2_0,     A_yt2_0_xt1_0,     A_xt2_0_yt2_0
        PACKLH2.1       A_yt1_1_xt2_1,     A_yt2_1_xt1_1,     A_xt2_1_yt2_1

        ;----------------------------------------------------------;
        ; In addition either the data terms or the twiddle factor  ;
        ; needs to be rotated by 16, to make use of dotp2 and      ;
        ; dotpn2 using the same twiddle factor to realize real     ;
        ; and imaginary multiplies.                                ;
        ;----------------------------------------------------------;

        ROTL   .2       B_yt0_0_xt0_0,     16,                B_xt0_0_yt0_0
        ROTL   .2       B_yt0_1_xt0_1,     16,                B_xt0_1_yt0_1
        ROTL   .1       A_xt1_0_yt1_0,     16,                A_yt1_0_xt1_0
        ROTL   .1       A_xt1_1_yt1_1,     16,                A_yt1_1_xt1_1
        ROTL   .1       A_xt2_0_yt2_0,     16,                A_yt2_0_xt2_0
        ROTL   .1       A_xt2_1_yt2_1,     16,                A_yt2_1_xt2_1

        ;---------------------------------------------------------;
        ; The following code is implemented on C64x using _dotp2  ;
        ; and _dotpn2. Notice that for the imaginary part, the    ;
        ; data has to be swizzled to get correct results with     ;
        ; _dotpn2, if an extyra negate is to be avoided.          ;
        ;                                                         ;
        ; x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0 ) >> 15         ;
        ; x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0 ) >> 15         ;
        ; x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1 ) >> 15         ;
        ; x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1 ) >> 15         ;
        ;                                                         ;
        ; These four results are retained in registers and a      ;
        ; double word is formed so that it can be stored with     ;
        ; one STDW.                                               ;
        ;---------------------------------------------------------;

        DOTP2  .1       A_xt1_0_yt1_0,     A_co10_si10,       A_x_h2_0
        DOTPN2 .1       A_yt1_0_xt1_0,     A_co10_si10,       A_x_h2_1
        DOTP2  .1       A_xt1_1_yt1_1,     A_co11_si11,       A_x_h2_2
        DOTPN2 .1       A_yt1_1_xt1_1,     A_co11_si11,       A_x_h2_3

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0 ) >> 15         ;
        ; x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0 ) >> 15         ;
        ; x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1 ) >> 15         ;
        ; x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1 ) >> 15         ;
        ;---------------------------------------------------------;

        DOTP2  .2       B_xt0_0_yt0_0,     B_co20_si20,       B_x_l1_0
        DOTPN2 .2       B_yt0_0_xt0_0,     B_co20_si20,       B_x_l1_1
        DOTP2  .2       B_xt0_1_yt0_1,     B_co21_si21,       B_x_l1_2
        DOTPN2 .2       B_yt0_1_xt0_1,     B_co21_si21,       B_x_l1_3

        ;---------------------------------------------------------;
        ; The following code computes intermediate results for:   ;
        ;                                                         ;
        ; x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0 ) >> 15         ;
        ; x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0 ) >> 15         ;
        ; x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1 ) >> 15         ;
        ; x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1 ) >> 15         ;
        ;---------------------------------------------------------;

        DOTP2 .2X       B_co30_si30,       A_xt2_0_yt2_0,     B_x_l2_0
        DOTPN2.2X       B_co30_si30,       A_yt2_0_xt2_0,     B_x_l2_1
        DOTP2 .2X       B_co31_si31,       A_xt2_1_yt2_1,     B_x_l2_2
        DOTPN2.2X       B_co31_si31,       A_yt2_1_xt2_1,     B_x_l2_3

        ;----------------------------------------------------------;
        ;  Add results onto themselves to achieve shift right by   ;
        ; 15. The results will then be packed together using the   ;
        ; packh2 instruction as a word, then a double word         ;
        ;----------------------------------------------------------;

        ADD   .1        A_x_h2_0,          A_x_h2_0,          A_x_h2_0
        ADD   .1        A_x_h2_1,          A_x_h2_1,          A_x_h2_1
        ADD   .1        A_x_h2_2,          A_x_h2_2,          A_x_h2_2
        ADD   .1        A_x_h2_3,          A_x_h2_3,          A_x_h2_3

        ADD   .2        B_x_l1_0,          B_x_l1_0,          B_x_l1_0
        ADD   .2        B_x_l1_1,          B_x_l1_1,          B_x_l1_1
        ADD   .2        B_x_l1_2,          B_x_l1_2,          B_x_l1_2
        ADD   .2        B_x_l1_3,          B_x_l1_3,          B_x_l1_3

        ADD   .2        B_x_l2_0,          B_x_l2_0,          B_x_l2_0
        ADD   .2        B_x_l2_1,          B_x_l2_1,          B_x_l2_1
        ADD   .2        B_x_l2_2,          B_x_l2_2,          B_x_l2_2
        ADD   .2        B_x_l2_3,          B_x_l2_3,          B_x_l2_3

        ;---------------------------------------------------------;
        ; Pack intermediate results retaining upper 16 bits. The  ;
        ; _packh2 performs the shift by 16 bits, by retaining the ;
        ; upper 16 bits and produces a packed 32 bit quantity.    ;
        ; This is the step that results in scaling by a bit per   ;
        ; stage.                                                  ;
        ;---------------------------------------------------------;

        PACKH2.1        A_x_h2_1,          A_x_h2_0,          A_xh2_1_0
        PACKH2.1        A_x_h2_3,          A_x_h2_2,          A_xh2_3_2
        PACKH2.2        B_x_l1_1,          B_x_l1_0,          B_xl1_1_0
        PACKH2.2        B_x_l1_3,          B_x_l1_2,          B_xl1_3_2
        PACKH2.2        B_x_l2_1,          B_x_l2_0,          B_xl2_1_0
        PACKH2.2        B_x_l2_3,          B_x_l2_2,          B_xl2_3_2

        ;---------------------------------------------------------;
        ; Store out the outputs to the four legs of the butterfly ;
        ; using aligned store double words. Notice the use of the ;
        ; indices "l1", "l2", "h2" to derive the pointers for the ;
        ; legs of the butterfly.                                  ;
        ;---------------------------------------------------------;

        STDW .D1T2      B_x_3_x_2:B_x_1_x_0,                  *A_x_[0]
        STDW .D1T1      A_xh2_3_2:A_xh2_1_0,                  *A_x__[A_h2]
        STDW .D1T2      B_xl1_3_2:B_xl1_1_0,                  *A_x__[A_l1]
        STDW .D1T2      B_xl2_3_2:B_xl2_1_0,                  *A_x__[A_l2]

        ;---------------------------------------------------------;
        ; Decrement and branch on loop variable A_i.              ;
        ;---------------------------------------------------------;

        BDEC  .1        LOOP_Y,            A_i

        ;---------------------------------------------------------;
        ; Continue to use this loop as long as stride > radix     ;
        ;---------------------------------------------------------;

        CMPGTU.2        B_stride,          A_radix,           B_while
[B_while]B    .1        LOOP_WHILE

        ;---------------------------------------------------------;
        ; Check if radix is 2, and prepare zero for each data     ;
        ; path.                                                   ;
        ;---------------------------------------------------------;

        SUB   .1        A_radix,           2,                 A_r2

        ;---------------------------------------------------------;
        ; Prepare twin data pointers. In addition prepare four    ;
        ; output pointers as follows:                             ;
        ; y0 = ptr_y                                              ;
        ; y1 = y0 + (nmax >> 1)                                   ;
        ; y2 = y1 + (nmax >> 1)                                   ;
        ; y3 = y2 + (nmax >> 1)                                   ;
        ;---------------------------------------------------------;

        MV    .1        A_ptr_x,           A_x0
        ADD   .2X       A_ptr_x,           8,                 B_x0

        MV    .1X       B_n,               A_n
        ADD   .1        A_ptr_x,           A_n,               A_x1
        ADD   .2X       A_x1,              8,                 B_x1

        MV    .2        B_ptr_y,           B_y0
        ADDAH .2        B_y0,              B_n,               B_y2


        ADD   .2        B_y0,              B_n,               B_y1
        ADD   .2        B_y2,              B_n,               B_y3

        ;--------------------------------------------------------;
        ; Determine the norm, and derive shift amount by adding  ;
        ; 4 to it.                                               ;
        ;--------------------------------------------------------;

        NORM  .2        B_n,               B_l1
        ADD   .2        B_l1,              3,                 B_l1

        SHRU  .2        B_n,               3,                 B_n_4
        SHRU  .1        B_n,               3,                 A_n_4
        SHRU  .2        B_n,               2,                 B_n_2
        SUB   .2        4,                 B_n_2,             B_nm2

        ;--------------------------------------------------------;
        ; Set j0 to 4, at start of loop, for computing index.    ;
        ; Re adjust pointers if radix == 2                       ;
        ;--------------------------------------------------------;

        MVK   .2        4,                 B_j0

[!A_r2] SHRU  .2        B_n,               1,                 B_n_2
[!A_r2] ADD   .2        B_y0,              B_n_2,             B_y1
[!A_r2] ADD   .2        B_y2,              B_n_2,             B_y3

[!A_r2] NORM  .2        B_n,               B_l1
[!A_r2] ADD   .2        B_l1,              2,                 B_l1
[!A_r2] SUB   .2        8,                 B_n_2,             B_nm2
[!A_r2] MVK   .2        8,                 B_j0

        ;-------------------------------------------------------------;
        ;  Following loop iterates for N/4 -2 times, because of BDEC  ;
        ;  Use j as input to find digit reversed index. The digit     ;
        ;  reversed index is in B_h4                                  ;
        ;-------------------------------------------------------------;

        SHRU  .1X       B_n,               3,                 A_i           ;
        SUB   .1        A_i,               2,                 A_i           ;
        ZERO  .2        B_j                                                 ;

        ;--------------------------------------------------------;
        ; Infrom the compiler that there are twin data pointers  ;
        ; A_x0, B_x0. In addition inform compiler that there     ;
        ; is one data pointer for B side.                        ;
        ;--------------------------------------------------------;

        .mptr      A_x0,   A_x + 0, 16
        .mptr      B_x0,   A_x + 1, 16
        .mptr      B_y0,   A_x + 0, 0
        .mptr      B_y1,   A_x + 0, 0
        .mptr      B_y2,   A_x + 0, 0
        .mptr      B_y3,   A_x + 0, 0

LOOP_Z: .trip 8

        ;-------------------------------------------------------------;
        ; The following combination of instructions act on "j" and    ;
        ; produce the digit reversed index in "h4" or "bit reversed"  ;
        ; offset for radix2.                                          ;
        ;-------------------------------------------------------------;

        DEAL  .2        B_j,               B_h0
        BITR  .2        B_h0,              B_h1
        ROTL  .2        B_h1,              16,                B_h2
        SHFL  .2        B_h2,              B_h3
        SHRU  .2        B_h3,              B_l1,              B_h4

        ;-------------------------------------------------------------;
        ;  Load input data at start of data array x, x0..x7. Perform  ;
        ; either radix4 style or radix2 style. Use rotates by 0, to   ;
        ; avoid live too longs, as these veriables simply live along  ;
        ; without any operations being performed on them.             ;
        ;-------------------------------------------------------------;

        LDDW .D1T1      *A_x0[A_n_4],      A_xbxa:A_x9x8
        LDDW .D2T2      *B_x0[B_n_4],      B_xfxe:B_xdxc
        LDDW .D1T1      *A_x0++[2],        A_x3x2:A_x1x0
        LDDW .D2T2      *B_x0++[2],        B_x7x6:B_x5x4
;------
        ;-------------------------------------------------------------;
        ;  xh0_0   = x0 + x4     xh1_0  = x1 +  x5                    ;
        ;  xh0_1   = x2 + x6     xh1_1  = x3 +  x7                    ;
        ;-------------------------------------------------------------;


        ADD2 .2X        B_x5x4,            A_x1x0,            B_xh1_0_xh0_0
        ADD2 .2X        B_x7x6,            A_x3x2,            B_xh21_0_xh20_0

        ;-------------------------------------------------------------;
        ;  Overwrite these results as follows for radix2:             ;
        ;  xh0_0 = x0, xh1_0 = x1, xh0_1 = x2 xh1_1 = x3              ;
        ;-------------------------------------------------------------;

[!A_r2] ROTL .2X        A_x1x0,            0,                 B_xh1_0_xh0_0
[!A_r2] ROTL .2X        A_x3x2,            0,                 B_xh21_0_xh20_0

        ;-------------------------------------------------------------;
        ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2         ;
        ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3         ;
        ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2         ;
        ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3         ;
        ;-------------------------------------------------------------;

        SUB2  .2        B_xh1_0_xh0_0,     B_xh21_0_xh20_0,   B_y5y4
        ADD2  .2        B_xh1_0_xh0_0,     B_xh21_0_xh20_0,   B_y1y0

        ;-------------------------------------------------------------;
        ;  xl0_0  = x0 - x4        xl1_0  = x1 - x5                   ;
        ;  xl0_1  = x2 - x6        xl1_1  = x3 - x7                   ;
        ;-------------------------------------------------------------;

        SUB2  .1X       A_x1x0,            B_x5x4,            A_xl1_0_xl0_0
        SUB2  .1X       A_x3x2,            B_x7x6,            A_xl21_0_xl20_0
        ROTL  .1        A_xl1_0_xl0_0,     16,                A_xl0_0_xl1_0

        ;------------------------------------------------------------;
        ; Overwrite these results as follows for radix2:             ;
        ; xl0_0 = x4, xl1_0 = x5, xl0_1 = x7 xl1_1 = x6              ;
        ;------------------------------------------------------------;

[!A_r2] ROTL  .1X       B_x5x4,            0,                 A_xl0_0_xl1_0
[!A_r2] ROTL  .1X       B_x7x6,            0,                 A_xl21_0_xl20_0

        ;-------------------------------------------------------------;
        ; radix4:  y2 = xl0_0 + xl1_1    radix2: y2 = x4 + x6         ;
        ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7         ;
        ; radix4:  y6 = xl0_0 - xl1_1    radix2: y6 = x4 - x6         ;
        ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7         ;
        ;-------------------------------------------------------------;

        ADD2  .1        A_xl0_0_xl1_0,     A_xl21_0_xl20_0,   A_xt1_0_yt2_0
        SUB2  .1        A_xl0_0_xl1_0,     A_xl21_0_xl20_0,   A_xt2_0_yt1_0

        PACKLH2.1       A_xt2_0_yt1_0,     A_xt1_0_yt2_0,     A_y3y2
        PACKLH2.1       A_xt1_0_yt2_0,     A_xt2_0_yt1_0,     A_y7y6

        ;------------------------------------------------------------;
        ; Overwrite these results as follows for radix2:             ;
        ; xl0_0 = x4, xl1_0 = x5, xl0_1 = x7 xl1_1 = x6              ;
        ;------------------------------------------------------------;

[!A_r2] ROTL  .1        A_xt1_0_yt2_0,     0,                 A_y3y2
[!A_r2] ROTL  .1        A_xt2_0_yt1_0,     0,                 A_y7y6
;-----

        ;------------------------------------------------------------;
        ; Unroll once again to get a second pair of FFT radix4       ;
        ; butterflies to store out contiguous results to the output  ;
        ; array.                                                     ;
        ;------------------------------------------------------------;

        MV    .2x       A_x9x8,            B_x9x8
        MV    .2x       A_xbxa,            B_xbxa

        ADD2  .2        B_xdxc,            B_x9x8,            B_xh1_1_xh0_1
        ADD2  .2        B_xfxe,            B_xbxa,            B_xh21_1_xh20_1

[!A_r2] ADD   .2        B_x9x8,            0,                 B_xh1_1_xh0_1
[!A_r2] ADD   .2        B_xbxa,            0,                 B_xh21_1_xh20_1

        SUB2  .2        B_xh1_1_xh0_1,     B_xh21_1_xh20_1,   B_ydyc
        ADD2  .2        B_xh1_1_xh0_1,     B_xh21_1_xh20_1,   B_y9y8

        SUB2  .1x       A_x9x8,            B_xdxc,            A_xl1_1_xl0_1
        SUB2  .1x       A_xbxa,            B_xfxe,            A_xl21_1_xl20_1
        ROTL  .1        A_xl1_1_xl0_1,     16,                A_xl0_1_xl1_1

[!A_r2] MV    .1x       B_xdxc,            A_xl0_1_xl1_1
[!A_r2] MV    .1x       B_xfxe,            A_xl21_1_xl20_1

        ADD2  .1        A_xl0_1_xl1_1,     A_xl21_1_xl20_1,   A_xt1_1_yt2_1
        SUB2  .1        A_xl0_1_xl1_1,     A_xl21_1_xl20_1,   A_xt2_1_yt1_1

        PACKLH2.1       A_xt1_1_yt2_1,     A_xt2_1_yt1_1,     A_yfye
        PACKLH2.1       A_xt2_1_yt1_1,     A_xt1_1_yt2_1,     A_ybya

[!A_r2] MV     .1       A_xt1_1_yt2_1,     A_ybya
[!A_r2] MV     .1       A_xt2_1_yt1_1,     A_yfye
;------
        ;---------------------------------------------------------;
        ;  Perform 4 store double words to memory to write out    ;
        ;  results using the digit reversed index. The results    ;
        ; are hence returned in normal order.                     ;
        ;---------------------------------------------------------;

        STDW .D2T2      B_y9y8:B_y1y0,     *B_y0[B_h4]
        STDW .D2T1      A_ybya:A_y3y2,     *B_y1[B_h4]
        STDW .D2T2      B_ydyc:B_y5y4,     *B_y2[B_h4]
        STDW .D2T1      A_yfye:A_y7y6,     *B_y3[B_h4]

        ;---------------------------------------------------------;
        ;  Reset data pointers if the number of twiddle factors   ;
        ; within the fft subtable has been used. Increment "j"    ;
        ; so that double swapping can be avoided.                 ;
        ;---------------------------------------------------------;

        AVG2 .2         B_j,               B_nm2,            B_ifj
        ADD  .2         B_j,               B_j0,             B_j
[!B_ifj]ADD  .2         B_j,               B_n_2,            B_j
[!B_ifj]ADD  .1         A_x0,              A_n,              A_x0
[!B_ifj]ADD  .2         B_x0,              B_n,              B_x0

        ;---------------------------------------------------------;
        ;  Decrement and branch back to LOOP_Z                    ;
        ;---------------------------------------------------------;

        BDEC  .1        LOOP_Z,            A_i

        .return
        .endproc

*============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*
fft16x32.sa/    1066929505  0     0     0       52722     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 17:51:07 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_fft16x32                                                   *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft16x32(const short * ptr_w, int  npoints,            *
*                            int   * ptr_x, int *ptr_y ) ;                  *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*         int i, j, k, n = N;                                               *
*         double theta1, theta2, theta3, x_t, y_t;                          *
*         const double M = 32768.0, PI = 3.141592654;                       *
*                                                                           *
*         for (j=1, k=0; j < n>>2; j = j<<2)                                *
*         {                                                                 *
*             for (i=0; i < n>>2; i += j<<1)                                *
*             {                                                             *
*                 theta1 = 2*PI*i/n;                                        *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+1] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+1] = 0x7fff;                            *
*                 w[k+0] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+0] = 0x7fff;                            *
*                                                                           *
*                 theta1 = 2*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+7] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+3] = 0x7fff;                            *
*                 w[k+6] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+2] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*i/n;                                        *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+3] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+5] = 0x7fff;                            *
*                 w[k+2] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+4] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+9] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+7] = 0x7fff;                            *
*                 w[k+8] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+6] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*i/n;                                        *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+5] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+9] = 0x7fff;                            *
*                 w[k+4] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+8] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+11] = (short) x_t;                                    *
*                 if (x_t >= M) w[k+11] = 0x7fff;                           *
*                 w[k+10] = (short) y_t;                                    *
*                 if (y_t >= M) w[k+10] = 0x7fff;                           *
*                                                                           *
*                 k += 12;                                                  *
*             }                                                             *
*         }                                                                 *
*         w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          *
*         w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       multiply and the imaginary part of the multiply is performed        *
*       using the 16x32 multiply instruction with rounding mpylir and       *
*       mpyhir.                                                             *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
            .sect ".data:copyright_p"


        .sect ".text:_fft16x32"
        .global _DSP_fft16x32
_DSP_fft16x32: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y
             .no_mdep
*=========================================================================== *
        .reg    A_j, B_j,  B_w0, A_w0, B_w1, A_w2, B_x, B_h2
        .reg    B_l1, B_l2, A_h2, A_l1, A_l2
        .reg    B_co20_si20:B_co10_si10
        .reg    A_co11_si11:A_co30_si30, B_co30_si30
        .reg    A_co31_si31:A_co21_si21
        .reg    A_xl1_3:A_xl1_2,B_xl1_1:B_xl1_0
        .reg    A_xh2_3:A_xh2_2,B_xh2_1:B_xh2_0
        .reg    A_xl2_3:A_xl2_2,B_xl2_1:B_xl2_0
        .reg    A_xh1_0, A_xh0_0
        .reg    B_xh1_0, B_xh0_0
        .reg    A_xl1_0,A_xl0_0, A_xh1_1, A_xh0_1
        .reg    A_xl1_1,A_xl0_1, B_xl0_0
        .reg    B_xh21_0,B_xh20_0, A_xh21_1,A_xh20_1
        .reg    B_xl21_0,B_xl20_0, A_xl21_1,A_xl20_1
        .reg    A_x_, A_x__, B_x__, A_x
        .reg    A_fft_jmp
        .reg    A_ifj, B_ifj
        .reg    B_fft_jmp
        .reg    A_x_3:A_x_2,B_x_1:B_x_0
        .reg    A_x_3o:A_x_2o,B_x_1o:B_x_0o
        .reg    B_xh2_1o:B_xh2_0o
        .reg    A_xh2_3o:A_xh2_2o
        .reg    B_xl1_1o:B_xl1_0o
        .reg    A_xl1_3o:A_xl1_2o
        .reg    B_xl2_1o:B_xl2_0o
        .reg    A_xl2_3o:A_xl2_2o
        .reg    B_xt0_0,B_yt0_0, A_xt0_1,A_yt0_1
        .reg    B_yt2_0,B_xt1_0, B_yt1_0,B_xt2_0
        .reg    A_yt2_1,A_xt1_1, A_yt1_1,A_xt2_1
        .reg    B_p0, B_p1, B_p2, B_p3, A_p4, A_p5, A_p6, A_p7
        .reg    B_p8, B_p9, B_pa, B_pb, A_pc, A_pd, A_pe, A_pf
        .reg    B_p10, B_p11, B_p12, B_p13, A_p14, A_p15, A_p16, A_p17
        .reg    B_x_l2_1:B_x_l2_0, A_x_h2_3:A_x_h2_2, B_x_l1_1:B_x_l1_0
        .reg    A_x_l2_3:A_x_l2_2, B_x_h2_1:B_x_h2_0, A_x_l1_3:A_x_l1_2
        .reg    A_xl1_3i:A_xl1_2i
        .reg    A_xl2_3i:A_xl2_2i
        .reg    A_xh2_3i:A_xh2_2i
        .reg    B_xl1_1i:B_xl1_0i
        .reg    B_xl2_1i:B_xl2_0i
        .reg    B_xh2_1i:B_xh2_0i
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride, B_while
        .reg    A_p_x0, B_p_x0
        .reg    B_x7:B_x6,A_x5:A_x4, B_x3:B_x2,A_x1:A_x0
        .reg    A_y7:A_y6,B_y5:B_y4, A_y3:A_y2,B_y1:B_y0
        .reg    B_xh1_1, B_xh0_1, B_xl0_1
        .reg    B_fft_jmp_1
        .reg    B_p_y0, B_p_y1, B_p_y2, B_p_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2, A_temp
        .reg    A_i, A_r2, B_j0

        ;-------------------------------------------------------------;
        ;  Assume radix is 4, by default. Check the norm of the # of  ;
        ; points to be transformed, and change radix to 2 if reqd.    ;
        ;-------------------------------------------------------------;

        MVK    .1        4,               A_radix
        NORM   .2        B_n,             B_radix2
        AND    .2        B_radix2,        1,                 B_radix2
[B_radix2]MVK  .1        2,               A_radix

        ;-------------------------------------------------------------;
        ; "stride" is a vraibale that denotes the speration between   ;
        ; the legs of the butterfly. "tw_offset" is the offset within ;
        ; the sub-table                                               ;
        ;-------------------------------------------------------------;

        MV     .2        B_n,             B_stride
        ZERO   .1        A_tw_offset

LOOP_WHILE:

        ;-------------------------------------------------------------;
        ; "j" is used as an index into the sub-table of twiddle fact- ;
        ; ors. Since the pointer to the sub-table of twiddle fators   ;
        ; resets with every iteration of the outer loop, the index    ;
        ; within the sub-table is also reset to zero. Copies are made ;
        ; so that it exists in both data paths.                       ;
        ;-------------------------------------------------------------;

        ZERO   .1        A_j
        ZERO   .2        B_j

        ;-------------------------------------------------------------;
        ; "fft_jmp" is a variable that relates the offset between     ;
        ; data elements that use the same twiddle factor. It is       ;
        ; always 6*stride halfwords, 1.5 * stride double words. It    ;
        ; quarters as does stride with every iteration of the outer   ;
        ; loop.                                                       ;
        ;-------------------------------------------------------------;

        MPYSU  .2        6,               B_stride,          B_fft_jmp
        SHRU   .1X       B_fft_jmp,       4,                 A_fft_jmp

        ;-------------------------------------------------------------;
        ; Determine offsets N/4, N/2, 3N/4 and make copies to both    ;
        ; data paths. Also copy input pointer as output pointer.      ;
        ;-------------------------------------------------------------;

        SHRU   .2        B_stride,        2,                 B_h2
        SHRU   .2        B_stride,        1,                 B_l1
        ADD    .2        B_l1,            B_h2,              B_l2

        MV     .1X       B_l1,            A_l1
        MV     .1X       B_h2,            A_h2
        MV     .1X       B_l2,            A_l2

        MV     .2X       A_ptr_x,         B_x
        ADDAH  .1        A_ptr_w,         A_tw_offset,        A_w0
        MV     .2X       A_w0,            B_w0

        SHRU   .2        B_fft_jmp,       2,                  B_fft_jmp_1
        ADD    .1X       A_tw_offset,     B_fft_jmp_1,        A_tw_offset
        SHRU   .2        B_stride,        2,                  B_stride

        ;-------------------------------------------------------------;
        ;  Adjustments for BDEC, as it iterates till -1. Deduct 2     ;
        ; from loop trip count of N/8.                                ;
        ;-------------------------------------------------------------;

        SUB    .1        A_fft_jmp,       3,                  A_fft_jmp
        SHRU   .1X       B_n,             3,                  A_i
        SUB    .1        A_i,             2,                  A_i

LOOP_Y: .trip 8

        ;-------------------------------------------------------------;
        ; si10 = w[0] co10 = w[1]  si11 = w[2]  co11 = w[3]           ;
        ; si20 = w[4] co20 = w[5]  si21 = w[6]  si21 = w[7]           ;
        ; si30 = w[8] co30 = w[9]  si31 = w[a]  co31 = w[b]           ;
        ;-------------------------------------------------------------;

        ADD    .2      B_w0,               8,                B_w1
        ADD    .1      B_w1,               8,                A_w2

        LDDW   .D2T2   *B_w0[B_j],         B_co20_si20:B_co10_si10
        LDDW   .D2T1   *B_w1[B_j],         A_co11_si11:A_co30_si30
        LDDW   .D1T1   *A_w2[A_j],         A_co31_si31:A_co21_si21

        ;-------------------------------------------------------------;
        ;  x[0]       x[1]       x[2]       x[3]                      ;
        ;  x[h2+0]    x[h2+1]    x[h2+2]    x[h2+3]                   ;
        ;  x[l1+0]    x[l1+1]    x[l1+2]    x[l1+3]                   ;
        ;  x[l2+0]    x[l2+1]    x[l2+2]    x[l2+3]                   ;
        ;-------------------------------------------------------------;

        LDDW   .D2T2   *B_x[0],            B_x_1:B_x_0
        LDDW   .D2T2   *B_x[B_l1],         B_xl1_1i:B_xl1_0i
        LDDW   .D2T2   *B_x[B_l2],         B_xl2_1i:B_xl2_0i
        LDDW   .D2T2   *B_x[B_h2],         B_xh2_1i:B_xh2_0i

        ADD    .1X     B_x,                8,                 A_x

        LDDW   .D1T1   *A_x[0],            A_x_3:A_x_2
        LDDW   .D1T1   *A_x[A_l1],         A_xl1_3i:A_xl1_2i
        LDDW   .D1T1   *A_x[A_l2],         A_xl2_3i:A_xl2_2i
        LDDW   .D1T1   *A_x[A_h2],         A_xh2_3i:A_xh2_2i

        ;-------------------------------------------------------------;
        ; xh0_0 = x[0] + x[l1];    xh1_0 = x[1] + x[l1+1]             ;
        ; xh0_1 = x[2] + x[l1+2];  xh1_1 = x[3] + x[l1+3]             ;
        ; xl0_0 = x[0] - x[l1];    xl1_0 = x[1] - x[l1+1]             ;
        ; xl0_1 = x[2] - x[l1+2];  xl1_1 = x[3] - x[l1+3]             ;
        ;-------------------------------------------------------------;

        ADD    .2      B_xl1_0i,            B_x_0,            B_xh0_0
        ADD    .2      B_xl1_1i,            B_x_1,            B_xh1_0

        ADD    .1      A_xl1_2i,            A_x_2,            A_xh0_1
        ADD    .1      A_xl1_3i,            A_x_3,            A_xh1_1

        SUB    .2      B_x_0,               B_xl1_0i,         B_xl0_0
        SUB    .2      B_x_1,               B_xl1_1i,         B_xl1_0

        SUB    .1      A_x_2,               A_xl1_2i,         A_xl0_1
        SUB    .1      A_x_3,               A_xl1_3i,         A_xl1_1

        ;------------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]; xh21_0 = x[h2+1] + x[l2+1]     ;
        ; xh20_1 = x[h2+2] + x[l2+2]; xh21_1 = x[h2+3] + x[l2+3]     ;
        ; xl20_0 = x[h2  ] - x[l2  ]; xl21_0 = x[h2+1] - x[l2+1]     ;
        ; xl20_1 = x[h2+2] - x[l2+2]; xl21_1 = x[h2+3] - x[l2+3]     ;
        ;------------------------------------------------------------;

        ADD    .2      B_xl2_0i,            B_xh2_0i,         B_xh20_0
        ADD    .2      B_xl2_1i,            B_xh2_1i,         B_xh21_0

        ADD    .1      A_xl2_2i,            A_xh2_2i,         A_xh20_1
        ADD    .1      A_xl2_3i,            A_xh2_3i,         A_xh21_1

        SUB    .2      B_xh2_1i,            B_xl2_1i,         B_xl21_0
        SUB    .2      B_xh2_0i,            B_xl2_0i,         B_xl20_0

        SUB    .1      A_xh2_2i,            A_xl2_2i,         A_xl20_1
        SUB    .1      A_xh2_3i,            A_xl2_3i,         A_xl21_1

        MVD    .1X     B_x,                 A_x_
        MVD    .2X     A_x_,                B_x__

        ;-------------------------------------------------------------;
        ;  if (!(j - fft_jmp))                                        ;
        ;  {                                                          ;
        ;    j += 12 shorts;                                          ;
        ;    x += fft_jmp;                                            ;
        ;    j = 0;                                                   ;
        ;    x += 4                                                   ;
        ;  }                                                          ;
        ;-------------------------------------------------------------;

        SUB    .1X     A_fft_jmp,           B_j,              A_ifj
        ADD    .2      B_j,                 3,                B_j
[!A_ifj]ADD    .2      B_x,                 B_fft_jmp,        B_x
[!A_ifj]ZERO   .2      B_j
        ADD    .2      B_x,                 16,               B_x
        MV     .1X     B_j,                 A_j

        ;-------------------------------------------------------------;
        ;  x0[0]  =  xh0_0  +  xh20_0  x0[1]  =  xh1_0  +  xh21_0     ;
        ;  x0[2]  =  xh0_1  +  xh20_1  x0[3]  =  xh1_1  +  xh21_1     ;
        ;-------------------------------------------------------------;

        ADD    .2      B_xh20_0,            B_xh0_0,          B_x_0o
        ADD    .2      B_xh21_0,            B_xh1_0,          B_x_1o
        ADD    .1      A_xh20_1,            A_xh0_1,          A_x_2o
        ADD    .1      A_xh21_1,            A_xh1_1,          A_x_3o

        ;-------------------------------------------------------------;
        ;   xt0_0 = xh0_0 - xh20_0     yt0_0 = xh1_0 - xh21_0         ;
        ;   xt0_1 = xh0_1 - xh20_1     yt0_1 = xh1_1 - xh21_1         ;
        ;-------------------------------------------------------------;

        SUB    .2      B_xh1_0,             B_xh21_0,         B_yt0_0
        SUB    .2      B_xh0_0,             B_xh20_0,         B_xt0_0
        SUB    .1      A_xh1_1,             A_xh21_1,         A_yt0_1
        SUB    .1      A_xh0_1,             A_xh20_1,         A_xt0_1

        ;-------------------------------------------------------------;
        ;  xt1_0  =  xl0_0  +  xl21_0   yt2_0  =  xl1_0  +  xl20_0    ;
        ;  xt1_1  =  xl0_1  +  xl21_1   yt2_1  =  xl1_1  +  xl20_1    ;
        ;  xt2_0  =  xl0_0  -  xl21_0   yt1_0  =  xl1_0  -  xl20_0    ;
        ;  xt2_1  =  xl0_1  -  xl21_1   yt1_1  =  xl1_1  -  xl20_1    ;
        ;-------------------------------------------------------------;

        ADD    .2       B_xl0_0,            B_xl21_0,         B_xt1_0
        ADD    .2       B_xl1_0,            B_xl20_0,         B_yt2_0
        ADD    .1       A_xl0_1,            A_xl21_1,         A_xt1_1
        ADD    .1       A_xl1_1,            A_xl20_1,         A_yt2_1

        SUB    .2       B_xl0_0,            B_xl21_0,         B_xt2_0
        SUB    .2       B_xl1_0,            B_xl20_0,         B_yt1_0
        SUB    .1       A_xl0_1,            A_xl21_1,         A_xt2_1
        SUB    .1       A_xl1_1,            A_xl20_1,         A_yt1_1

        ;-------------------------------------------------------------;
        ;   x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0) >> 15            ;
        ;   x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0) >> 15            ;
        ;   x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1) >> 15            ;
        ;   x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1) >> 15            ;
        ;-------------------------------------------------------------;

        MPYLIR  .2      B_co10_si10,        B_yt1_0,          B_p0
        MPYHIR  .2      B_co10_si10,        B_xt1_0,          B_p1
        ADD     .2      B_p0,               B_p1,             B_xh2_0o

        MPYHIR  .2      B_co10_si10,        B_yt1_0,          B_p2
        MPYLIR  .2      B_co10_si10,        B_xt1_0,          B_p3
        SUB     .2      B_p2,               B_p3,             B_xh2_1o

        MPYLIR  .1      A_co11_si11,        A_yt1_1,          A_p4
        MPYHIR  .1      A_co11_si11,        A_xt1_1,          A_p5
        ADD     .1      A_p4,               A_p5,             A_xh2_2o

        MPYHIR  .1      A_co11_si11,        A_yt1_1,          A_p6
        MPYLIR  .1      A_co11_si11,        A_xt1_1,          A_p7
        SUB     .1      A_p6,               A_p7,             A_xh2_3o

        ;-------------------------------------------------------------;
        ;   x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0) >> 15            ;
        ;   x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0) >> 15            ;
        ;   x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1) >> 15            ;
        ;   x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1) >> 15            ;
        ;-------------------------------------------------------------;

        MPYLIR  .2      B_co20_si20,        B_yt0_0,          B_p8
        MPYHIR  .2      B_co20_si20,        B_xt0_0,          B_p9
        ADD     .2      B_p8,               B_p9,             B_xl1_0o

        MPYHIR  .2      B_co20_si20,        B_yt0_0,          B_pa
        MPYLIR  .2      B_co20_si20,        B_xt0_0,          B_pb
        SUB     .2      B_pa,               B_pb,             B_xl1_1o

        MPYLIR  .1      A_co21_si21,        A_yt0_1,          A_pc
        MPYHIR  .1      A_co21_si21,        A_xt0_1,          A_pd
        ADD     .1      A_pc,               A_pd,             A_xl1_2o

        MPYHIR  .1      A_co21_si21,        A_yt0_1,          A_pe
        MPYLIR  .1      A_co21_si21,        A_xt0_1,          A_pf
        SUB     .1      A_pe,               A_pf,             A_xl1_3o

        ;-------------------------------------------------------------;
        ;   x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0) >> 15            ;
        ;   x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0) >> 15            ;
        ;   x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1) >> 15            ;
        ;   x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1) >> 15            ;
        ;-------------------------------------------------------------;

        MV      .2X     A_co30_si30,        B_co30_si30
        MPYLIR  .2      B_co30_si30,        B_yt2_0,          B_p10
        MPYHIR  .2      B_co30_si30,        B_xt2_0,          B_p11
        ADD     .2      B_p10,              B_p11,            B_xl2_0o

        MPYHIR  .2      B_co30_si30,        B_yt2_0,          B_p12
        MPYLIR  .2      B_co30_si30,        B_xt2_0,          B_p13
        SUB     .2      B_p12,              B_p13,            B_xl2_1o

        MPYLIR  .1      A_co31_si31,        A_yt2_1,          A_p14
        MPYHIR  .1      A_co31_si31,        A_xt2_1,          A_p15
        ADD     .1      A_p14,              A_p15,            A_xl2_2o

        MPYHIR  .1      A_co31_si31,        A_yt2_1,          A_p16
        MPYLIR  .1      A_co31_si31,        A_xt2_1,          A_p17
        SUB     .1      A_p16,              A_p17,            A_xl2_3o

        ADD    .1X      B_x__,              8,                A_x__

        ;-------------------------------------------------------------;
        ;  Store four outputs for all the four legs of butterfly      ;
        ;-------------------------------------------------------------;

        STDW   .D2T2    B_x_1o:B_x_0o,      *B_x__[0]
        STDW   .D1T1    A_x_3o:A_x_2o,      *A_x__[0]

        STDW   .D2T2    B_xh2_1o:B_xh2_0o,  *B_x__[B_h2]
        STDW   .D1T1    A_xh2_3o:A_xh2_2o,  *A_x__[A_h2]

        STDW   .D2T2    B_xl1_1o:B_xl1_0o,  *B_x__[B_l1]
        STDW   .D1T1    A_xl1_3o:A_xl1_2o,  *A_x__[A_l1]

        STDW   .D2T2    B_xl2_1o:B_xl2_0o,  *B_x__[B_l2]
        STDW   .D1T1    A_xl2_3o:A_xl2_2o,  *A_x__[A_l2]

        BDEC   .1       LOOP_Y,              A_i

        CMPGTU .2X      B_stride,            A_radix,         B_while

[B_while]B              LOOP_WHILE

        ;-------------------------------------------------------------;
        ; Set up input/output pointers depending on radix,            ;
        ; If radix == 4, then data maps to ptr_y, ptr_y + N/2,        ;
        ; ptr_y + N. ptr_y + 3N/2. If radix == 2, then data maps      ;
        ; ptr_y, ptr_y + N/4, ptr_y + N, ptr_y + 3N/4                 ;
        ; Input data is always read from x0, x0 + N/2.                ;
        ;-------------------------------------------------------------;

        SUB    .1       A_radix,             2,               A_r2

        MV     .1       A_ptr_x,             A_p_x0
        ADD    .2X      A_ptr_x,             8,               B_p_x0

        MV     .2       B_ptr_y,             B_p_y0
        ADDAW  .2       B_p_y0,              B_n,             B_p_y2


        ADDAH  .2       B_p_y0,              B_n,             B_p_y1
        ADDAH  .2       B_p_y2,              B_n,             B_p_y3

        NORM   .2       B_n,                 B_l1
        ADD    .2       B_l1,                2,               B_l1

        MVK    .2       4,                   B_j0

[!A_r2] ADD    .2       B_p_y0,              B_n,             B_p_y1
[!A_r2] ADD    .2       B_p_y2,              B_n,             B_p_y3

[!A_r2] NORM   .2       B_n,                 B_l1
[!A_r2] ADD    .2       B_l1,                1,               B_l1
[!A_r2] MVK    .2       8,                   B_j0

        ;-------------------------------------------------------------;
        ;  Following loop iterates for N/4 -2 times, because of BDEC  ;
        ;  Use j as input to find digit reversed index. The digit     ;
        ;  reversed index is in B_h4                                  ;
        ;-------------------------------------------------------------;

        SHRU   .1X      B_n,                 2,               A_i
        SUB    .1       A_i,                 2,               A_i
        ZERO   .2       B_j

LOOP_Z: .trip 8

        ;-------------------------------------------------------------;
        ; The following combination of instructions act on "j" and    ;
        ; produce the digit reversed index in "h4" or "bit reversed"  ;
        ; offset for radix2.                                          ;
        ;-------------------------------------------------------------;

        DEAL   .2       B_j,                 B_h0
        BITR   .2       B_h0,                B_h1
        ROTL   .2       B_h1,                16,              B_h2
        SHFL   .2       B_h2,                B_h3
        SHRU   .2       B_h3,                B_l1,            B_h4
        ADD    .2       B_j,                 B_j0,            B_j

        ;-------------------------------------------------------------;
        ;  Load input data at start of data array x, x0..x7. Perform  ;
        ; either radix4 style or radix2 style. Use rotates by 0, to   ;
        ; avoid live too longs, as these veriables simply live along  ;
        ; without any operations being performed on them.             ;
        ;-------------------------------------------------------------;


        LDDW   .D1T1    *A_p_x0++[2],        A_x1:A_x0
        LDDW   .D2T2    *B_p_x0++[2],        B_x3:B_x2
        LDDW   .D1T1    *A_p_x0++[2],        A_x5:A_x4
        LDDW   .D2T2    *B_p_x0++[2],        B_x7:B_x6

        ;-------------------------------------------------------------;
        ;  xh0_0   = x0 + x4     xh1_0  = x1 +  x5                    ;
        ;  xh0_1   = x2 + x6     xh1_1  = x3 +  x7                    ;
        ;-------------------------------------------------------------;

        ADD    .1       A_x4,                A_x0,            A_xh0_0
        ADD    .1       A_x5,                A_x1,            A_xh1_0
        ADD    .2       B_x6,                B_x2,            B_xh0_1
        ADD    .2       B_x7,                B_x3,            B_xh1_1

        ;-------------------------------------------------------------;
        ;  Overwrite these results as follows for radix2:             ;
        ;  xh0_0 = x0, xh1_0 = x1, xh0_1 = x2 xh1_1 = x3              ;
        ;-------------------------------------------------------------;

[!A_r2] ROTL   .1       A_x0,                0,               A_xh0_0
[!A_r2] ROTL   .1       A_x1,                0,               A_xh1_0
[!A_r2] ROTL   .2       B_x2,                0,               B_xh0_1
[!A_r2] ROTL   .2       B_x3,                0,               B_xh1_1

        ;-------------------------------------------------------------;
        ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2         ;
        ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3         ;
        ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2         ;
        ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3         ;
        ;-------------------------------------------------------------;

        ADD    .2X      A_xh0_0,             B_xh0_1,         B_y0
        ADD    .2X      A_xh1_0,             B_xh1_1,         B_y1
        SUB    .2X      A_xh0_0,             B_xh0_1,         B_y4
        SUB    .2X      A_xh1_0,             B_xh1_1,         B_y5

        ;-------------------------------------------------------------;
        ;  xl0_0  = x0 - x4        xl1_0  = x1 - x5                   ;
        ;  xl0_1  = x2 - x6        xl1_1  = x3 - x7                   ;
        ;-------------------------------------------------------------;

        SUB    .1       A_x0,                A_x4,            A_xl0_0
        SUB    .1       A_x1,                A_x5,            A_xl1_0
        SUB    .2       B_x2,                B_x6,            B_xl0_1
        SUB    .2       B_x3,                B_x7,            B_xl1_1

        ;------------------------------------------------------------;
        ; Overwrite these results as follows for radix2:             ;
        ; xl0_0 = x4, xl1_0 = x5, xl0_1 = x7 xl1_1 = x6              ;
        ;------------------------------------------------------------;

[!A_r2] ROTL   .1       A_x4,                0,               A_xl0_0
[!A_r2] ROTL   .1       A_x5,                0,               A_xl1_0
[!A_r2] MV     .2       B_x6,                B_xl1_1
[!A_r2] MV     .2       B_x7,                B_xl0_1

        ;-------------------------------------------------------------;
        ; radix4:  y2 = xl0_0 + xl1_1    radix2: y2 = x4 + x6         ;
        ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7         ;
        ; radix4:  y6 = xl0_0 - xl1_1    radix2: y6 = x4 - x6         ;
        ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7         ;
        ;-------------------------------------------------------------;

        ADD    .1X      A_xl0_0,             B_xl1_1,         A_y2
        SUB    .1X      A_xl1_0,             B_xl0_1,         A_y3
        SUB    .1X      A_xl0_0,             B_xl1_1,         A_y6
        ADD    .1X      A_xl1_0,             B_xl0_1,         A_y7

        ;-------------------------------------------------------------;
        ;  Swap y3, y7 if radix2   y2 = x4 + x6, y3 = x5 + x7,        ;
        ;                          y6 = x4 - x6, y7 = x5 - x7         ;
        ;-------------------------------------------------------------;

        MV     .1       A_y3,                A_temp
[!A_r2] MV     .1       A_y7,                A_y3
[!A_r2] MV     .1       A_temp,              A_y7

        ;-------------------------------------------------------------;
        ; Store using digit reversed index, bit reversed index and    ;
        ; and pointers p_y0,...p_y3                                   ;
        ;-------------------------------------------------------------;

        STDW   .D2T2    B_y1:B_y0,           *B_p_y0[B_h4]
        STDW   .D2T1    A_y3:A_y2,           *B_p_y1[B_h4]
        STDW   .D2T2    B_y5:B_y4,           *B_p_y2[B_h4]
        STDW   .D2T1    A_y7:A_y6,           *B_p_y3[B_h4]

        ;-------------------------------------------------------------;
        ;  Decrement and branch back to LOOP_Z                        ;
        ;-------------------------------------------------------------;

        BDEC   .1   LOOP_Z,                  A_i

        .return
        .endproc

*=========================================================================== *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=========================================================================== *
fft32x32.sa/    1066929505  0     0     0       57850     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 17:53:28 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_fft32x32: Double Precision FFT                             *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft32x32(const int  * ptr_w, int  npoints,             *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (_dotprsu2(yt1_0xt1_0, si10co10) << 1);            *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"


        .sect ".text:_fft32x32"
        .global _DSP_fft32x32
_DSP_fft32x32: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y

             .no_mdep
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .reg            B_w0,  B_x
        .reg            A_x
        .reg            B_xp1:B_xp0
        .reg            A_l1
        .reg            A_xl1p1:A_xl1p0
        .reg            A_h2
        .reg            B_xh2p1:B_xh2p0
        .reg            A_l2
        .reg            A_xl2p1:A_xl2p0
        .reg            A_xh0
        .reg            A_xh1
        .reg            B_xl0
        .reg            B_xl1
        .reg            A_xh20
        .reg            A_xh21
        .reg            B_xl20
        .reg            B_xl21
        .reg            A_y_h1_1:A_y_h1_0
        .reg            A_w0
        .reg            A_j
        .reg            B_co10:B_si10
        .reg            B_w1
        .reg            B_j
        .reg            A_co20:A_si20
        .reg            A_w2
        .reg            B_co30:B_si30
        .reg            A_xt0
        .reg            A_yt0
        .reg            B_xt1
        .reg            B_yt2
        .reg            B_xt2
        .reg            B_yt1
        .reg            B_co10si10
        .reg            A_co20si20
        .reg            B_co30si30
        .reg            B_si10co10
        .reg            A_si20co20
        .reg            B_si30co30
        .reg            A_yt0xt0
        .reg            B_yt1xt1
        .reg            B_yt2xt2
        .reg            A_si10
        .reg            B_p0r
        .reg            A_p1r
        .reg            B_p01r
        .reg            B_p0c
        .reg            A_p1c
        .reg            B_y_h2_1:B_y_h2_0
        .reg            B_p01c
        .reg            A_p2r
        .reg            A_p3r
        .reg            A_p23r
        .reg            A_p2c
        .reg            A_p3c
        .reg            A_y_l1_1:A_y_l1_0
        .reg            A_p23c
        .reg            B_p4r
        .reg            B_p5r
        .reg            B_p45r
        .reg            B_p4c
        .reg            B_p5c
        .reg            B_y_l2_1:B_y_l2_0
        .reg            B_p45c
        .reg            A_x_1
        .reg            B_x__
        .reg            B_fft_jmp
        .reg            A_ifj
        .reg            A_fft_jmp
        .reg            B_h2
        .reg            B_l1
        .reg            B_l2
        .reg            A_i
; ======================================================================
        .reg    A_xl1_3:A_xl1_2,B_xl1_1:B_xl1_0
        .reg    A_xh2_3:A_xh2_2,B_xh2_1:B_xh2_0
        .reg    A_xl2_3:A_xl2_2,B_xl2_1:B_xl2_0
        .reg    A_xh1_0, A_xh0_0
        .reg    B_xh1_0, B_xh0_0
        .reg    A_xl1_0,A_xl0_0, A_xh1_1, A_xh0_1
        .reg    A_xl1_1,A_xl0_1, B_xl0_0
        .reg    B_xh21_0,B_xh20_0, A_xh21_1,A_xh20_1
        .reg    B_xl21_0,B_xl20_0, A_xl21_1,A_xl20_1
        .reg    A_x_, A_x__
        .reg    A_x_3:A_x_2,B_x_1:B_x_0
        .reg    A_x_3o:A_x_2o,B_x_1o:B_x_0o
        .reg    B_xh2_1o:B_xh2_0o
        .reg    A_xh2_3o:A_xh2_2o
        .reg    B_xl1_1o:B_xl1_0o
        .reg    A_xl1_3o:A_xl1_2o
        .reg    B_xl2_1o:B_xl2_0o
        .reg    A_xl2_3o:A_xl2_2o
        .reg    B_xt0_0,B_yt0_0, A_xt0_1,A_yt0_1
        .reg    B_yt2_0,B_xt1_0, B_yt1_0,B_xt2_0
        .reg    A_yt2_1,A_xt1_1, A_yt1_1,A_xt2_1
        .reg    B_p0, B_p1, B_p2, B_p3, A_p4, A_p5, A_p6, A_p7
        .reg    B_p8, B_p9, B_pa, B_pb, A_pc, A_pd, A_pe, A_pf
        .reg    B_p10, B_p11, B_p12, B_p13, A_p14, A_p15, A_p16, A_p17
        .reg    B_x_l2_1:B_x_l2_0, A_x_h2_3:A_x_h2_2, B_x_l1_1:B_x_l1_0
        .reg    A_x_l2_3:A_x_l2_2, B_x_h2_1:B_x_h2_0, A_x_l1_3:A_x_l1_2
        .reg    A_xl1_3i:A_xl1_2i
        .reg    A_xl2_3i:A_xl2_2i
        .reg    A_xh2_3i:A_xh2_2i
        .reg    B_xl1_1i:B_xl1_0i
        .reg    B_xl2_1i:B_xl2_0i
        .reg    B_xh2_1i:B_xh2_0i
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride, B_while
        .reg    A_p_x0, B_p_x0
        .reg    B_x7:B_x6,A_x5:A_x4, B_x3:B_x2,A_x1:A_x0
        .reg    A_y7:A_y6,B_y5:B_y4, A_y3:A_y2,B_y1:B_y0
        .reg    B_xh1_1, B_xh0_1
        .reg    B_xl0_1
        .reg    A_fft_jmp_1
        .reg    B_p_y0, B_p_y1, B_p_y2, B_p_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2, A_temp
        .reg    A_r2, B_j0
        .reg    B_xl1_1c, A_xh1_0c


          ;-------------------------------------------------------------;
          ;  Assume radix is 4, by default. Check the norm of the # of  ;
          ; points to be transformed, and change radix to 2 if reqd.    ;
          ;-------------------------------------------------------------;

          MVK        .1       4,                A_radix
          NORM       .2       B_n,              B_radix2
          AND        .2       B_radix2,         1,                B_radix2
[B_radix2]MVK        .1       2,                A_radix

          ;-------------------------------------------------------------;
          ; "stride" is a vraibale that denotes the speration between   ;
          ; the legs of the butterfly. "tw_offset" is the offset within ;
          ; the sub-table                                               ;
          ;-------------------------------------------------------------;

          MV         .2       B_n,              B_stride
          ZERO       .1       A_tw_offset

LOOP_WHILE:

          ;-------------------------------------------------------------;
          ; "j" is used as an index into the sub-table of twiddle fact- ;
          ; ors. Since the pointer to the sub-table of twiddle fators   ;
          ; resets with every iteration of the outer loop, the index    ;
          ; within the sub-table is also reset to zero. Copies are made ;
          ; so that it exists in both data paths.                       ;
          ;-------------------------------------------------------------;

          ZERO       .1       A_j
          ZERO       .2       B_j

          ;-------------------------------------------------------------;
          ; "fft_jmp" is a variable that relates the offset between     ;
          ; data elements that use the same twiddle factor. It is       ;
          ; always 6*stride halfwords, 1.5 * stride double words. It    ;
          ; quarters as does stride with every iteration of the outer   ;
          ; loop.                                                       ;
          ;-------------------------------------------------------------;

          MPYSU      .1X      6,                B_stride,         A_fft_jmp
          SHRU       .2X      A_fft_jmp,        3,                B_fft_jmp
          SUB        .2       B_fft_jmp,        3,                B_fft_jmp

          ;-------------------------------------------------------------;
          ; Determine offsets N/4, N/2, 3N/4 and make copies to both    ;
          ; data paths. Also copy input pointer as output pointer.      ;
          ;-------------------------------------------------------------;

          SHRU       .2       B_stride,         2,                B_h2
          SHRU       .2       B_stride,         1,                B_l1
          ADD        .2       B_l1,             B_h2,             B_l2
          MV         .1X      B_l1,             A_l1
          MV         .1X      B_h2,             A_h2
          MV         .1X      B_l2,             A_l2

          MV         .1      A_ptr_x,           A_x
          ADDAH      .1      A_ptr_w,           A_tw_offset,      A_w0
          ADD        .2X     A_w0,              8,                B_w1
          ADD        .1X     B_w1,              8,                A_w2

          SHRU       .1      A_fft_jmp,         1,                A_fft_jmp_1
          ADD        .1      A_tw_offset,       A_fft_jmp_1,      A_tw_offset
          SHRU       .2      B_stride,          2,                B_stride

          ;-------------------------------------------------------------;
          ;  Adjustments for BDEC, as it iterates till -1. Deduct 2     ;
          ;  from loop trip count of N/4.                               ;
          ;-------------------------------------------------------------;

          SHRU       .1X     B_n,               2,                A_i
          SUB        .1      A_i,               2,                A_i

          ;-------------------------------------------------------------;
          ; Since the stride amount across iterations is variable,      ;
          ; it is tough to put an exact stride. However for this        ;
          ; loop stride is guranteed to be greater than or equal        ;
          ; to 16 complex samples, 32 half words. Since this str-       ;
          ; ide is wider than the bank width, of all the banks,         ;
          ; stride is specified as zero.                                ;
          ;-------------------------------------------------------------;


        .mptr      A_w0,   x+0,     0
        .mptr      B_w1,   x+2,     0
        .mptr      A_w2,   x+0,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_1,  x+0,     0
        .mptr      B_x__,  x+0,     0

LOOP_Y: .trip 8

          ;-------------------------------------------------------------;
          ;  x[0]       x[1]       x[2]       x[3]                      ;
          ;  x[h2+0]    x[h2+1]    x[h2+2]    x[h2+3]                   ;
          ;  x[l1+0]    x[l1+1]    x[l1+2]    x[l1+3]                   ;
          ;  x[l2+0]    x[l2+1]    x[l2+2]    x[l2+3]                   ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_x[0],           B_xp1:B_xp0
          LDDW      .D1T1    *A_x[A_l1],        A_xl1p1:A_xl1p0
          LDDW      .D1T2    *A_x[A_h2],        B_xh2p1:B_xh2p0
          LDDW      .D1T1    *A_x[A_l2],        A_xl2p1:A_xl2p0

          ;-------------------------------------------------------------;
          ; xh0_0 = x[0] + x[l1];    xh1_0 = x[1] + x[l1+1]             ;
          ; xh0_1 = x[2] + x[l1+2];  xh1_1 = x[3] + x[l1+3]             ;
          ; xl0_0 = x[0] - x[l1];    xl1_0 = x[1] - x[l1+1]             ;
          ; xl0_1 = x[2] - x[l1+2];  xl1_1 = x[3] - x[l1+3]             ;
          ;-------------------------------------------------------------;

          ADD       .1X      B_xp0,             A_xl1p0,          A_xh0
          ADD       .1X      B_xp1,             A_xl1p1,          A_xh1
          ADD       .1X      B_xh2p0,           A_xl2p0,          A_xh20
          ADD       .1X      B_xh2p1,           A_xl2p1,          A_xh21
          SUB       .2X      B_xp0,             A_xl1p0,          B_xl0
          SUB       .2X      B_xp1,             A_xl1p1,          B_xl1
          SUB       .2X      B_xh2p0,           A_xl2p0,          B_xl20
          SUB       .2X      B_xh2p1,           A_xl2p1,          B_xl21

          ;-------------------------------------------------------------;
          ; si10 = w[0] co10 = w[1]  si11 = w[2]  co11 = w[3]           ;
          ; si20 = w[4] co20 = w[5]  si21 = w[6]  si21 = w[7]           ;
          ; si30 = w[8] co30 = w[9]  si31 = w[a]  co31 = w[b]           ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_w0[A_j],        B_co10:B_si10
          LDDW      .D2T1    *B_w1[B_j],        A_co20:A_si20
          LDDW      .D1T2    *A_w2[A_j],        B_co30:B_si30

          ;------------------------------------------------------------;
          ; xh20_0 = x[h2  ] + x[l2  ]; xh21_0 = x[h2+1] + x[l2+1]     ;
          ; xh20_1 = x[h2+2] + x[l2+2]; xh21_1 = x[h2+3] + x[l2+3]     ;
          ; xl20_0 = x[h2  ] - x[l2  ]; xl21_0 = x[h2+1] - x[l2+1]     ;
          ; xl20_1 = x[h2+2] - x[l2+2]; xl21_1 = x[h2+3] - x[l2+3]     ;
          ;------------------------------------------------------------;

          ADD       .1       A_xh20,            A_xh0,            A_y_h1_0
          ADD       .1       A_xh21,            A_xh1,            A_y_h1_1
          SUB       .1       A_xh0,             A_xh20,           A_xt0
          SUB       .1       A_xh1,             A_xh21,           A_yt0

          ADD       .2       B_xl21,            B_xl0,            B_xt1
          ADD       .2       B_xl20,            B_xl1,            B_yt2
          SUB       .2       B_xl0,             B_xl21,           B_xt2
          SUB       .2       B_xl1,             B_xl20,           B_yt1

          ;------------------------------------------------------------;
          ; Pack coefficients as a word taking lower 16 bits for use   ;
          ; with DOTPRSU2 and DOTPNRSU2. In addition both orders of    ;
          ; twiddle factors are rquired because the DOTPNRSU2 does     ;
          ; not have cross access within a word.                       ;
          ;------------------------------------------------------------;

          PACK2     .2       B_co10,            B_si10,           B_co10si10
          PACK2     .1       A_co20,            A_si20,           A_co20si20
          PACK2     .2       B_co30,            B_si30,           B_co30si30
          PACK2     .2       B_si10,            B_co10,           B_si10co10
          PACK2     .1       A_si20,            A_co20,           A_si20co20
          PACK2     .2       B_si30,            B_co30,           B_si30co30

          ;------------------------------------------------------------;
          ; Pack high sixteen bits of data as one word, for use with   ;
          ; DOTPSU2 and DOTPNRSU2.                                     ;
          ;------------------------------------------------------------;

          PACKH2    .1       A_yt0,             A_xt0,            A_yt0xt0
          PACKH2    .2       B_yt1,             B_xt1,            B_yt1xt1
          PACKH2    .2       B_yt2,             B_xt2,            B_yt2xt2

          ;------------------------------------------------------------;
          ; Perform 32x32 multiply as shown below:                     ;
          ; x2[h2  ] = _mpyhir(si10 , yt1_0) + _mpyhir(co10 , xt1_0) + ;
          ;            (_dotprsu2(yt1_0xt1_0, si10co10) << 1)          ;
          ;                                                            ;
          ; x2[h2+1] = _mpyhir(co10 , yt1_0) - _mpyhir(si10 , xt1_0) + ;
          ;           (_dotpnrsu2(yt1_0xt1_0, co10si10) << 1)          ;
          ;------------------------------------------------------------;

          MV        .1X      B_si10,            A_si10
          MPYHIR    .2       B_co10,            B_xt1,            B_p0r
          MPYHIR    .1X      A_si10,            B_yt1,            A_p1r
          ADD       .2X      B_p0r,             A_p1r,            B_y_h2_0
          DOTPRSU2  .2       B_yt1xt1,          B_si10co10,       B_p01r
          ADDAH     .2       B_y_h2_0,          B_p01r,           B_y_h2_0

          MPYHIR    .2       B_co10,            B_yt1,            B_p0c
          MPYHIR    .1X      A_si10,            B_xt1,            A_p1c
          SUB       .2       B_p0c,             A_p1c,            B_y_h2_1
          DOTPNRSU2 .2       B_yt1xt1,          B_co10si10,       B_p01c
          ADDAH     .2       B_y_h2_1,          B_p01c,           B_y_h2_1

          ;------------------------------------------------------------;
          ; x2[l1  ] = _mpyhir(si20 , yt0_0) + _mpyhir(co20 , xt0_0) + ;
          ;           (_dotprsu2(yt0_0xt0_0, si20co20) << 1)           ;
          ;                                                            ;
          ; x2[l1+1] = _mpyhir(co20 , yt0_0) - _mpyhir(si20 , xt0_0) + ;
          ;           (_dotpnrsu2(yt0_0xt0_0, co20si20) << 1)          ;
          ;------------------------------------------------------------;

          MPYHIR    .1       A_co20,            A_xt0,            A_p2r
          MPYHIR    .1       A_si20,            A_yt0,            A_p3r
          ADD       .1       A_p2r,             A_p3r,            A_y_l1_0
          DOTPRSU2  .1       A_yt0xt0,          A_si20co20,       A_p23r
          ADDAH     .1       A_y_l1_0,          A_p23r,           A_y_l1_0

          MPYHIR    .1       A_co20,            A_yt0,            A_p2c
          MPYHIR    .1       A_si20,            A_xt0,            A_p3c
          SUB       .1       A_p2c,             A_p3c,            A_y_l1_1
          DOTPNRSU2 .1       A_yt0xt0,          A_co20si20,       A_p23c
          ADDAH     .1       A_y_l1_1,          A_p23c,           A_y_l1_1

         ;-------------------------------------------------------------;
         ; x2[l2  ] = _mpyhir(si30 , yt2_0) + _mpyhir(co30 , xt2_0) +  ;
         ;           (_dotprsu2(yt2_0xt2_0, si30co30) << 1)            ;
         ;                                                             ;
         ; x2[l2+1] = _mpyhir(co30 , yt2_0)   - _mpyhir(si30, xt2_0) + ;
         ;              (_dotpnrsu2(yt2_0xt2_0, co30si30) << 1)        ;
         ;-------------------------------------------------------------;

          MPYHIR    .2       B_co30,            B_xt2,            B_p4r
          MPYHIR    .2       B_si30,            B_yt2,            B_p5r
          ADD       .2       B_p4r,             B_p5r,            B_y_l2_0
          DOTPRSU2  .2       B_yt2xt2,          B_si30co30,       B_p45r
          ADDAH     .2       B_y_l2_0,          B_p45r,           B_y_l2_0

          MPYHIR    .2       B_co30,            B_yt2,            B_p4c
          MPYHIR    .2       B_si30,            B_xt2,            B_p5c
          SUB       .2       B_p4c,             B_p5c,            B_y_l2_1
          DOTPNRSU2 .2       B_yt2xt2,          B_co30si30,       B_p45c
          ADDAH     .2       B_y_l2_1,          B_p45c,           B_y_l2_1

          ;-----------------------------------------------------------;
          ; Derive output pointers using the input pointer "x"        ;
          ;-----------------------------------------------------------;

          MVD       .1       A_x,               A_x_1
          MV       .2X       A_x_1,             B_x__

          ;-----------------------------------------------------------;
          ; Loop control for loop coalescing                          ;
          ;                                                           ;
          ; When the twiddle factors are not to be re-used, j is      ;
          ; incremented by 6, to reflect the fact that 6 half words   ;
          ; are consumed in every iteration. The input data pointer   ;
          ; increments by 2. Note that within a stage, the stride     ;
          ; does not change and hence the offsets for the other three ;
          ; legs, 0, h2, l1, l2.                                      ;
          ;-----------------------------------------------------------;

          SUB      .1X       A_j,                  B_fft_jmp,       A_ifj
          ADD      .1        A_j,                  3,               A_j
[!A_ifj]  ADD      .1        A_x,                  A_fft_jmp,       A_x
          ADD      .1        A_x,                  8,               A_x
[!A_ifj]  ZERO     .1        A_j
          MV       .2        A_j,                  B_j

          ;-----------------------------------------------------------;
          ;  Perform stores to the four output legs of the butterfly  ;
          ;  The acceses are performed as double word wide accesses   ;
          ; to minimize the accesses to memory.                       ;
          ;-----------------------------------------------------------;

          STDW     .D1T1     A_y_h1_1:A_y_h1_0,   *A_x_1[0]
          STDW     .D2T2     B_y_h2_1:B_y_h2_0,   *B_x__[B_h2]
          STDW     .D2T1     A_y_l1_1:A_y_l1_0,   *B_x__[B_l1]
          STDW     .D2T2     B_y_l2_1:B_y_l2_0,   *B_x__[B_l2]

          ;-----------------------------------------------------------;
          ;  Perform decrement and branch on the loop counter "i"     ;
          ;-----------------------------------------------------------;

          BDEC     .1        LOOP_Y,              A_i

          CMPGTU   .2X       B_stride,            A_radix,         B_while
[B_while] B        .2        LOOP_WHILE

          ;-----------------------------------------------------------;
          ; The following code performs either a standard radix4 pass ;
          ; radix2 pass. Two pointers are used to access the input.   ;
          ; The input data is read "N/4" complex samples apart or     ;
          ; "N/2" words apart using pointers "x0" and "x2". This      ;
          ; produces outputs that are 0, N/4, N/2, 3N/4 for a radix4  ;
          ; FFT, and 0, N/8, N/2, 3N/8 for radix 2.                   ;
          ; The following pointers are therfore set up. They are set  ;
          ; up as twin pointers so that data accesses can parallelize ;
          ;                                                           ;
          ; y0 = ptr_y                                                ;
          ; y2 = ptr_y + (int) npoints                                ;
          ; x0 = ptr_x                                                ;
          ; x2 = ptr_x + (int) (npoints>>1)                           ;
          ;-----------------------------------------------------------;

          SUB      .1        A_radix,             2,               A_r2

          MV       .1      A_ptr_x,             A_p_x0
          ADD      .2X     A_ptr_x,             8,               B_p_x0
          MV       .2      B_ptr_y,             B_p_y0
          ADDAW    .2      B_p_y0,              B_n,             B_p_y2

          ADDAH    .2      B_p_y0,              B_n,             B_p_y1
          ADDAH    .2      B_p_y2,              B_n,             B_p_y3

          ;-----------------------------------------------------------;
          ; Prepare shift amount for digit reversed index and the     ;
          ; increment amount assuming that the radix is 4.            ;
          ;-----------------------------------------------------------;

          NORM     .2      B_n,                 B_l1
          ADD      .2      B_l1,                2,               B_l1
          MVK      .2      4,                   B_j0

          ;-----------------------------------------------------------;
          ;  Change pointers as required, and the increment amount if ;
          ; radix 2 is required.                                      ;
          ;                                                           ;
          ; if (radix == 2)                                           ;
          ; {                                                         ;
          ;    y1  = y0 + (int) (npoints >> 2)                        ;
          ;    y3  = y2 + (int) (npoints >> 2)                        ;
          ;    l1  = _norm(npoints) + 1                               ;
          ;    j0  = 8                                                ;
          ;    n0  = npoints >> 1                                     ;
          ; }                                                         ;
          ;-----------------------------------------------------------;

[!A_r2]   ADD      .2      B_p_y0,              B_n,             B_p_y1
[!A_r2]   ADD      .2      B_p_y2,              B_n,             B_p_y3
[!A_r2]   NORM     .2      B_n,                 B_l1
[!A_r2]   ADD      .2      B_l1,                1,               B_l1
[!A_r2]   MVK      .2      8,                   B_j0

          ;----------------------------------------------------------;
          ; Loop counter for the following loop is npoints >> 2. In  ;
          ; addition deduct 2 from the loop trip counter to account  ;
          ; for BDEC.                                                ;
          ;----------------------------------------------------------;

          SHRU     .1X     B_n,                 2,               A_i
          SUB      .1      A_i,                 2,               A_i
          ZERO     .2      B_j

          .mptr      A_p_x0, A_x+0, 16
          .mptr      B_p_x0, A_x+2, 16
          ;.mptr      B_p_y0, A_x+0, 0
          ;.mptr      B_p_y1, A_x+2, 0
          ;.mptr      B_p_y2, A_x+0, 0
          ;.mptr      B_p_y3, A_x+2, 0

LOOP_Z:  .trip 8

          ;----------------------------------------------------------;
          ; Digit reverse the index starting from 0. The increment   ;
          ; "j" is either by 4, or 8.                                ;
          ;                                                          ;
          ;  h2   = _deal(j)                                         ;
          ;  h2   = _bitr(h2)                                        ;
          ;  h2   = _rotl(h2, 16)                                    ;
          ;  h2   = _shfl(h2)                                        ;
          ;  h2  >>= l1                                              ;
          ;----------------------------------------------------------;
          DEAL     .2      B_j,                 B_h0
          BITR     .2      B_h0,                B_h1
          ROTL     .2      B_h1,                16,              B_h2
          SHFL     .2      B_h2,                B_h3
          SHRU     .2      B_h3,                B_l1,            B_h4
          ADD      .2      B_j,                 B_j0,            B_j

          ;----------------------------------------------------------;
          ; Read in the input data, from the first eight locations.  ;
          ; These are transformed either as a radix4 or as radix 2.  ;
          ;----------------------------------------------------------;

          LDDW    .D1T1    *A_p_x0++[2],        A_x1:A_x0
          LDDW    .D2T2    *B_p_x0++[2],        B_x3:B_x2
          LDDW    .D1T1    *A_p_x0++[2],        A_x5:A_x4
          LDDW    .D2T2    *B_p_x0++[2],        B_x7:B_x6

          ;----------------------------------------------------------;
          ;  xh0_0 = x_0 + x_4      xh1_0 = x_1 + x_5                ;
          ;  xl0_0 = x_0 - x_4      xl1_0 = x_1 - x_5                ;
          ;  xh0_1 = x_2 + x_6      xh1_1 = x_3 + x_7                ;
          ;  xl0_1 = x_2 - x_6      xl1_1 = x_3 - x_7                ;
          ;----------------------------------------------------------;

          ADD     .1       A_x4,                A_x0,           A_xh0_0
          ADD     .1       A_x5,                A_x1,           A_xh1_0
          ADD     .2       B_x6,                B_x2,           B_xh0_1
          ADD     .2       B_x7,                B_x3,           B_xh1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          SUB     .1       A_x1,                A_x5,           A_xl1_0
          SUB     .2       B_x2,                B_x6,           B_xl0_1
          SUB     .2       B_x3,                B_x7,           B_xl1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          MV      .2       B_xl1_1,             B_xl1_1c
          MV      .1       A_xh1_0,             A_xh1_0c

          ;----------------------------------------------------------;
          ;  Replace results conditionally if it is determined that  ;
          ;  it is a radix 2 pass as follows:                        ;
          ;                                                          ;
          ;  xh0_0 = x0              xh1_0  = x1                     ;
          ;  xh0_1 = x2              xh1_1  = x3                     ;
          ;  xl0_0 = x4              xl1_0  = x5,                    ;
          ;  xl0_1 = x7              xl1_1  = x6                     ;
          ;----------------------------------------------------------;

[!A_r2]   ROTL    .1       A_x0,                0,              A_xh0_0
[!A_r2]   ROTL    .1       A_x1,                0,              A_xh1_0c
[!A_r2]   ROTL    .2       B_x2,                0,              B_xh0_1
[!A_r2]   ROTL    .2       B_x3,                0,              B_xh1_1

[!A_r2]   ROTL    .1       A_x4,                0,              A_xl0_0
[!A_r2]   ROTL    .1       A_x5,                0,              A_xl1_0
[!A_r2]   MV      .2       B_x6,                B_xl1_1c
[!A_r2]   MV      .2       B_x7,                B_xl0_1

          ;---------------------------------------------------------;
          ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2     ;
          ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3     ;
          ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2     ;
          ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3     ;
          ;---------------------------------------------------------;

          ADD     .2X      A_xh0_0,             B_xh0_1,        B_y0
          ADD     .2X      A_xh1_0c,            B_xh1_1,        B_y1
          SUB     .2X      A_xh0_0,             B_xh0_1,        B_y4
          SUB     .2X      A_xh1_0c,            B_xh1_1,        B_y5

          ;---------------------------------------------------------;
          ; radix4:  y2 = xl0_0 + xl1_1    radix2: y2 = x4 + x6     ;
          ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7     ;
          ; radix4:  y6 = xl0_0 - xl1_1    radix2: y6 = x4 - x6     ;
          ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7     ;
          ;---------------------------------------------------------;

          ADD     .1X      A_xl0_0,             B_xl1_1c,       A_y2
          SUB     .1X      A_xl1_0,             B_xl0_1,        A_y3
          SUB     .1X      A_xl0_0,             B_xl1_1c,       A_y6
          ADD     .1X      A_xl1_0,             B_xl0_1,        A_y7

          ;---------------------------------------------------------;
          ;  Swap y3, y7 if radix2   y2 = x4 + x6, y3 = x5 + x7,    ;
          ;                          y6 = x4 - x6, y7 = x5 - x7     ;
          ;---------------------------------------------------------;

          MV      .1       A_y3,                A_temp
[!A_r2]   MV      .1       A_y7,                A_y3
[!A_r2]   MV      .1       A_temp,              A_y7

           ;--------------------------------------------------------;
           ; Store using digit reversed index, bit reversed index   ;
           ; and pointers p_y0,...p_y3                              ;
           ;--------------------------------------------------------;

          STDW    .D2T2    B_y1:B_y0,           *B_p_y0[B_h4]
          STDW    .D2T1    A_y3:A_y2,           *B_p_y1[B_h4]
          STDW    .D2T2    B_y5:B_y4,           *B_p_y2[B_h4]
          STDW    .D2T1    A_y7:A_y6,           *B_p_y3[B_h4]

          ;---------------------------------------------------------;
          ;  Decrement and branch back to LOOP_Z                    ;
          ;---------------------------------------------------------;

          BDEC    .1       LOOP_Z,              A_i

        .return
        .endproc

*============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*
fft32x32s.sa/   1066929505  0     0     0       58011     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 18:01:29 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            fft32x32: Double Precision FFT with scaling                    *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft32x32s(const int  * ptr_w, int  npoints,            *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (_dotprsu2(yt1_0xt1_0, si10co10) << 1);            *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"


        .sect ".text:_fft32x32s"
        .global _DSP_fft32x32s
_DSP_fft32x32s: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y

             .no_mdep
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .reg            B_w0,  B_x
        .reg            A_x
        .reg            B_xp1:B_xp0
        .reg            A_l1
        .reg            A_xl1p1:A_xl1p0
        .reg            A_h2
        .reg            B_xh2p1:B_xh2p0
        .reg            A_l2
        .reg            A_xl2p1:A_xl2p0
        .reg            A_xh0
        .reg            A_xh1
        .reg            B_xl0
        .reg            B_xl1
        .reg            A_xh20
        .reg            A_xh21
        .reg            B_xl20
        .reg            B_xl21
        .reg            A_y_h1_1:A_y_h1_0
        .reg            A_w0
        .reg            A_j
        .reg            B_co10:B_si10
        .reg            B_w1
        .reg            B_j
        .reg            A_co20:A_si20
        .reg            A_w2
        .reg            B_co30:B_si30
        .reg            A_xt0
        .reg            A_yt0
        .reg            B_xt1
        .reg            B_yt2
        .reg            B_xt2
        .reg            B_yt1
        .reg            B_co10si10
        .reg            A_co20si20
        .reg            B_co30si30
        .reg            B_si10co10
        .reg            A_si20co20
        .reg            B_si30co30
        .reg            A_yt0xt0
        .reg            B_yt1xt1
        .reg            B_yt2xt2
        .reg            A_si10
        .reg            B_p0r
        .reg            A_p1r
        .reg            B_p01r
        .reg            B_p0c
        .reg            A_p1c
        .reg            B_y_h2_1:B_y_h2_0
        .reg            B_p01c
        .reg            A_p2r
        .reg            A_p3r
        .reg            A_p23r
        .reg            A_p2c
        .reg            A_p3c
        .reg            A_y_l1_1:A_y_l1_0
        .reg            A_p23c
        .reg            B_p4r
        .reg            B_p5r
        .reg            B_p45r
        .reg            B_p4c
        .reg            B_p5c
        .reg            B_y_l2_1:B_y_l2_0
        .reg            B_p45c
        .reg            A_x_1
        .reg            B_x__
        .reg            B_fft_jmp
        .reg            A_ifj
        .reg            A_fft_jmp
        .reg            B_h2
        .reg            B_l1
        .reg            B_l2
        .reg            A_i
; ======================================================================
        .reg    A_xl1_3:A_xl1_2,B_xl1_1:B_xl1_0
        .reg    A_xh2_3:A_xh2_2,B_xh2_1:B_xh2_0
        .reg    A_xl2_3:A_xl2_2,B_xl2_1:B_xl2_0
        .reg    A_xh1_0, A_xh0_0
        .reg    B_xh1_0, B_xh0_0
        .reg    A_xl1_0,A_xl0_0, A_xh1_1, A_xh0_1
        .reg    A_xl1_1,A_xl0_1, B_xl0_0
        .reg    B_xh21_0,B_xh20_0, A_xh21_1,A_xh20_1
        .reg    B_xl21_0,B_xl20_0, A_xl21_1,A_xl20_1
        .reg    A_x_, A_x__
        .reg    A_x_3:A_x_2,B_x_1:B_x_0
        .reg    A_x_3o:A_x_2o,B_x_1o:B_x_0o
        .reg    B_xh2_1o:B_xh2_0o
        .reg    A_xh2_3o:A_xh2_2o
        .reg    B_xl1_1o:B_xl1_0o
        .reg    A_xl1_3o:A_xl1_2o
        .reg    B_xl2_1o:B_xl2_0o
        .reg    A_xl2_3o:A_xl2_2o
        .reg    B_xt0_0,B_yt0_0, A_xt0_1,A_yt0_1
        .reg    B_yt2_0,B_xt1_0, B_yt1_0,B_xt2_0
        .reg    A_yt2_1,A_xt1_1, A_yt1_1,A_xt2_1
        .reg    B_p0, B_p1, B_p2, B_p3, A_p4, A_p5, A_p6, A_p7
        .reg    B_p8, B_p9, B_pa, B_pb, A_pc, A_pd, A_pe, A_pf
        .reg    B_p10, B_p11, B_p12, B_p13, A_p14, A_p15, A_p16, A_p17
        .reg    B_x_l2_1:B_x_l2_0, A_x_h2_3:A_x_h2_2, B_x_l1_1:B_x_l1_0
        .reg    A_x_l2_3:A_x_l2_2, B_x_h2_1:B_x_h2_0, A_x_l1_3:A_x_l1_2
        .reg    A_xl1_3i:A_xl1_2i
        .reg    A_xl2_3i:A_xl2_2i
        .reg    A_xh2_3i:A_xh2_2i
        .reg    B_xl1_1i:B_xl1_0i
        .reg    B_xl2_1i:B_xl2_0i
        .reg    B_xh2_1i:B_xh2_0i
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride, B_while
        .reg    A_p_x0, B_p_x0
        .reg    B_x7:B_x6,A_x5:A_x4, B_x3:B_x2,A_x1:A_x0
        .reg    A_y7:A_y6,B_y5:B_y4, A_y3:A_y2,B_y1:B_y0
        .reg    B_xh1_1, B_xh0_1
        .reg    B_xl0_1
        .reg    A_fft_jmp_1
        .reg    B_p_y0, B_p_y1, B_p_y2, B_p_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2, A_temp
        .reg    A_r2, B_j0
        .reg    B_xl1_1c, A_xh1_0c


          ;-------------------------------------------------------------;
          ;  Assume radix is 4, by default. Check the norm of the # of  ;
          ; points to be transformed, and change radix to 2 if reqd.    ;
          ;-------------------------------------------------------------;

          MVK        .1       4,                A_radix
          NORM       .2       B_n,              B_radix2
          AND        .2       B_radix2,         1,                B_radix2
[B_radix2]MVK        .1       2,                A_radix

          ;-------------------------------------------------------------;
          ; "stride" is a vraibale that denotes the speration between   ;
          ; the legs of the butterfly. "tw_offset" is the offset within ;
          ; the sub-table                                               ;
          ;-------------------------------------------------------------;

          MV         .2       B_n,              B_stride
          ZERO       .1       A_tw_offset

LOOP_WHILE:

          ;-------------------------------------------------------------;
          ; "j" is used as an index into the sub-table of twiddle fact- ;
          ; ors. Since the pointer to the sub-table of twiddle fators   ;
          ; resets with every iteration of the outer loop, the index    ;
          ; within the sub-table is also reset to zero. Copies are made ;
          ; so that it exists in both data paths.                       ;
          ;-------------------------------------------------------------;

          ZERO       .1       A_j
          ZERO       .2       B_j

          ;-------------------------------------------------------------;
          ; "fft_jmp" is a variable that relates the offset between     ;
          ; data elements that use the same twiddle factor. It is       ;
          ; always 6*stride halfwords, 1.5 * stride double words. It    ;
          ; quarters as does stride with every iteration of the outer   ;
          ; loop.                                                       ;
          ;-------------------------------------------------------------;

          MPYSU      .1X      6,                B_stride,         A_fft_jmp
          SHRU       .2X      A_fft_jmp,        3,                B_fft_jmp
          SUB        .2       B_fft_jmp,        3,                B_fft_jmp

          ;-------------------------------------------------------------;
          ; Determine offsets N/4, N/2, 3N/4 and make copies to both    ;
          ; data paths. Also copy input pointer as output pointer.      ;
          ;-------------------------------------------------------------;

          SHRU       .2       B_stride,         2,                B_h2
          SHRU       .2       B_stride,         1,                B_l1
          ADD        .2       B_l1,             B_h2,             B_l2
          MV         .1X      B_l1,             A_l1
          MV         .1X      B_h2,             A_h2
          MV         .1X      B_l2,             A_l2

          MV         .1      A_ptr_x,           A_x
          ADDAH      .1      A_ptr_w,           A_tw_offset,      A_w0
          ADD        .2X     A_w0,              8,                B_w1
          ADD        .1X     B_w1,              8,                A_w2

          SHRU       .1      A_fft_jmp,         1,                A_fft_jmp_1
          ADD        .1      A_tw_offset,       A_fft_jmp_1,      A_tw_offset
          SHRU       .2      B_stride,          2,                B_stride

          ;-------------------------------------------------------------;
          ;  Adjustments for BDEC, as it iterates till -1. Deduct 2     ;
          ;  from loop trip count of N/4.                               ;
          ;-------------------------------------------------------------;

          SHRU       .1X     B_n,               2,                A_i
          SUB        .1      A_i,               2,                A_i

          ;-------------------------------------------------------------;
          ; Since the stride amount across iterations is variable,      ;
          ; it is tough to put an exact stride. However for this        ;
          ; loop stride is guranteed to be greater than or equal        ;
          ; to 16 complex samples, 32 half words. Since this str-       ;
          ; ide is wider than the bank width, of all the banks,         ;
          ; stride is specified as zero.                                ;
          ;-------------------------------------------------------------;


        .mptr      A_w0,   x+0,     0
        .mptr      B_w1,   x+2,     0
        .mptr      A_w2,   x+0,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_1,  x+0,     0
        .mptr      B_x__,  x+0,     0

LOOP_Y: .trip 8

          ;-------------------------------------------------------------;
          ;  x[0]       x[1]       x[2]       x[3]                      ;
          ;  x[h2+0]    x[h2+1]    x[h2+2]    x[h2+3]                   ;
          ;  x[l1+0]    x[l1+1]    x[l1+2]    x[l1+3]                   ;
          ;  x[l2+0]    x[l2+1]    x[l2+2]    x[l2+3]                   ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_x[0],           B_xp1:B_xp0
          LDDW      .D1T1    *A_x[A_l1],        A_xl1p1:A_xl1p0
          LDDW      .D1T2    *A_x[A_h2],        B_xh2p1:B_xh2p0
          LDDW      .D1T1    *A_x[A_l2],        A_xl2p1:A_xl2p0

          ;-------------------------------------------------------------;
          ; xh0_0 = x[0] + x[l1];    xh1_0 = x[1] + x[l1+1]             ;
          ; xh0_1 = x[2] + x[l1+2];  xh1_1 = x[3] + x[l1+3]             ;
          ; xl0_0 = x[0] - x[l1];    xl1_0 = x[1] - x[l1+1]             ;
          ; xl0_1 = x[2] - x[l1+2];  xl1_1 = x[3] - x[l1+3]             ;
          ;-------------------------------------------------------------;

          ADD       .1X      B_xp0,             A_xl1p0,          A_xh0
          ADD       .1X      B_xp1,             A_xl1p1,          A_xh1
          ADD       .1X      B_xh2p0,           A_xl2p0,          A_xh20
          ADD       .1X      B_xh2p1,           A_xl2p1,          A_xh21
          SUB       .2X      B_xp0,             A_xl1p0,          B_xl0
          SUB       .2X      B_xp1,             A_xl1p1,          B_xl1
          SUB       .2X      B_xh2p0,           A_xl2p0,          B_xl20
          SUB       .2X      B_xh2p1,           A_xl2p1,          B_xl21

          ;-------------------------------------------------------------;
          ; si10 = w[0] co10 = w[1]  si11 = w[2]  co11 = w[3]           ;
          ; si20 = w[4] co20 = w[5]  si21 = w[6]  si21 = w[7]           ;
          ; si30 = w[8] co30 = w[9]  si31 = w[a]  co31 = w[b]           ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_w0[A_j],        B_co10:B_si10
          LDDW      .D2T1    *B_w1[B_j],        A_co20:A_si20
          LDDW      .D1T2    *A_w2[A_j],        B_co30:B_si30

          ;------------------------------------------------------------;
          ; xh20_0 = x[h2  ] + x[l2  ]; xh21_0 = x[h2+1] + x[l2+1]     ;
          ; xh20_1 = x[h2+2] + x[l2+2]; xh21_1 = x[h2+3] + x[l2+3]     ;
          ; xl20_0 = x[h2  ] - x[l2  ]; xl21_0 = x[h2+1] - x[l2+1]     ;
          ; xl20_1 = x[h2+2] - x[l2+2]; xl21_1 = x[h2+3] - x[l2+3]     ;
          ;------------------------------------------------------------;

          ADD       .1       A_xh20,            A_xh0,            A_y_h1_0
          ADD       .1       A_xh21,            A_xh1,            A_y_h1_1
          SUB       .1       A_xh0,             A_xh20,           A_xt0
          SUB       .1       A_xh1,             A_xh21,           A_yt0

          ADD       .2       B_xl21,            B_xl0,            B_xt1
          ADD       .2       B_xl20,            B_xl1,            B_yt2
          SUB       .2       B_xl0,             B_xl21,           B_xt2
          SUB       .2       B_xl1,             B_xl20,           B_yt1

          ;------------------------------------------------------------;
          ; Pack coefficients as a word taking lower 16 bits for use   ;
          ; with DOTPRSU2 and DOTPNRSU2. In addition both orders of    ;
          ; twiddle factors are rquired because the DOTPNRSU2 does     ;
          ; not have cross access within a word.                       ;
          ;------------------------------------------------------------;

          PACK2     .2       B_co10,            B_si10,           B_co10si10
          PACK2     .1       A_co20,            A_si20,           A_co20si20
          PACK2     .2       B_co30,            B_si30,           B_co30si30
          PACK2     .2       B_si10,            B_co10,           B_si10co10
          PACK2     .1       A_si20,            A_co20,           A_si20co20
          PACK2     .2       B_si30,            B_co30,           B_si30co30

          ;------------------------------------------------------------;
          ; Pack high sixteen bits of data as one word, for use with   ;
          ; DOTPSU2 and DOTPNRSU2.                                     ;
          ;------------------------------------------------------------;

          PACKH2    .1       A_yt0,             A_xt0,            A_yt0xt0
          PACKH2    .2       B_yt1,             B_xt1,            B_yt1xt1
          PACKH2    .2       B_yt2,             B_xt2,            B_yt2xt2

          ;------------------------------------------------------------;
          ; Perform 32x32 multiply as shown below:                     ;
          ; x2[h2  ] = _mpyhir(si10 , yt1_0) + _mpyhir(co10 , xt1_0) + ;
          ;            (_dotprsu2(yt1_0xt1_0, si10co10) << 1)          ;
          ;                                                            ;
          ; x2[h2+1] = _mpyhir(co10 , yt1_0) - _mpyhir(si10 , xt1_0) + ;
          ;           (_dotpnrsu2(yt1_0xt1_0, co10si10) << 1)          ;
          ;------------------------------------------------------------;

          MV        .1X      B_si10,            A_si10
          MPYHIR    .2       B_co10,            B_xt1,            B_p0r
          MPYHIR    .1X      A_si10,            B_yt1,            A_p1r
          ADD       .2X      B_p0r,             A_p1r,            B_y_h2_0
          DOTPRSU2  .2       B_yt1xt1,          B_si10co10,       B_p01r
          ADDAH     .2       B_y_h2_0,          B_p01r,           B_y_h2_0

          MPYHIR    .2       B_co10,            B_yt1,            B_p0c
          MPYHIR    .1X      A_si10,            B_xt1,            A_p1c
          SUB       .2       B_p0c,             A_p1c,            B_y_h2_1
          DOTPNRSU2 .2       B_yt1xt1,          B_co10si10,       B_p01c
          ADDAH     .2       B_y_h2_1,          B_p01c,           B_y_h2_1

          ;------------------------------------------------------------;
          ; x2[l1  ] = _mpyhir(si20 , yt0_0) + _mpyhir(co20 , xt0_0) + ;
          ;           (_dotprsu2(yt0_0xt0_0, si20co20) << 1)           ;
          ;                                                            ;
          ; x2[l1+1] = _mpyhir(co20 , yt0_0) - _mpyhir(si20 , xt0_0) + ;
          ;           (_dotpnrsu2(yt0_0xt0_0, co20si20) << 1)          ;
          ;------------------------------------------------------------;

          MPYHIR    .1       A_co20,            A_xt0,            A_p2r
          MPYHIR    .1       A_si20,            A_yt0,            A_p3r
          ADD       .1       A_p2r,             A_p3r,            A_y_l1_0
          DOTPRSU2  .1       A_yt0xt0,          A_si20co20,       A_p23r
          ADDAH     .1       A_y_l1_0,          A_p23r,           A_y_l1_0

          MPYHIR    .1       A_co20,            A_yt0,            A_p2c
          MPYHIR    .1       A_si20,            A_xt0,            A_p3c
          SUB       .1       A_p2c,             A_p3c,            A_y_l1_1
          DOTPNRSU2 .1       A_yt0xt0,          A_co20si20,       A_p23c
          ADDAH     .1       A_y_l1_1,          A_p23c,           A_y_l1_1

         ;-------------------------------------------------------------;
         ; x2[l2  ] = _mpyhir(si30 , yt2_0) + _mpyhir(co30 , xt2_0) +  ;
         ;           (_dotprsu2(yt2_0xt2_0, si30co30) << 1)            ;
         ;                                                             ;
         ; x2[l2+1] = _mpyhir(co30 , yt2_0)   - _mpyhir(si30, xt2_0) + ;
         ;              (_dotpnrsu2(yt2_0xt2_0, co30si30) << 1)        ;
         ;-------------------------------------------------------------;

          MPYHIR    .2       B_co30,            B_xt2,            B_p4r
          MPYHIR    .2       B_si30,            B_yt2,            B_p5r
          ADD       .2       B_p4r,             B_p5r,            B_y_l2_0
          DOTPRSU2  .2       B_yt2xt2,          B_si30co30,       B_p45r
          ADDAH     .2       B_y_l2_0,          B_p45r,           B_y_l2_0

          MPYHIR    .2       B_co30,            B_yt2,            B_p4c
          MPYHIR    .2       B_si30,            B_xt2,            B_p5c
          SUB       .2       B_p4c,             B_p5c,            B_y_l2_1
          DOTPNRSU2 .2       B_yt2xt2,          B_co30si30,       B_p45c
          ADDAH     .2       B_y_l2_1,          B_p45c,           B_y_l2_1

          ;-----------------------------------------------------------;
          ; Derive output pointers using the input pointer "x"        ;
          ;-----------------------------------------------------------;

          MVD       .1       A_x,               A_x_1
          MV       .2X       A_x_1,             B_x__

          ;-----------------------------------------------------------;
          ; Loop control for loop coalescing                          ;
          ;                                                           ;
          ; When the twiddle factors are not to be re-used, j is      ;
          ; incremented by 6, to reflect the fact that 6 half words   ;
          ; are consumed in every iteration. The input data pointer   ;
          ; increments by 2. Note that within a stage, the stride     ;
          ; does not change and hence the offsets for the other three ;
          ; legs, 0, h2, l1, l2.                                      ;
          ;-----------------------------------------------------------;

          SUB      .1X       A_j,                  B_fft_jmp,       A_ifj
          ADD      .1        A_j,                  3,               A_j
[!A_ifj]  ADD      .1        A_x,                  A_fft_jmp,       A_x
          ADD      .1        A_x,                  8,               A_x
[!A_ifj]  ZERO     .1        A_j
          MV       .2        A_j,                  B_j

          ;-----------------------------------------------------------;
          ;  Perform stores to the four output legs of the butterfly  ;
          ;  The acceses are performed as double word wide accesses   ;
          ; to minimize the accesses to memory.                       ;
          ;-----------------------------------------------------------;

          SHR      .1        A_y_h1_0,             1,               A_y_h1_0
          SHR      .1        A_y_h1_1,             1,               A_y_h1_1

          STDW     .D1T1     A_y_h1_1:A_y_h1_0,   *A_x_1[0]
          STDW     .D2T2     B_y_h2_1:B_y_h2_0,   *B_x__[B_h2]
          STDW     .D2T1     A_y_l1_1:A_y_l1_0,   *B_x__[B_l1]
          STDW     .D2T2     B_y_l2_1:B_y_l2_0,   *B_x__[B_l2]

          ;-----------------------------------------------------------;
          ;  Perform decrement and branch on the loop counter "i"     ;
          ;-----------------------------------------------------------;

          BDEC     .1        LOOP_Y,              A_i

          CMPGTU   .2X       B_stride,            A_radix,         B_while
[B_while] B        .2        LOOP_WHILE

          ;-----------------------------------------------------------;
          ; The following code performs either a standard radix4 pass ;
          ; radix2 pass. Two pointers are used to access the input.   ;
          ; The input data is read "N/4" complex samples apart or     ;
          ; "N/2" words apart using pointers "x0" and "x2". This      ;
          ; produces outputs that are 0, N/4, N/2, 3N/4 for a radix4  ;
          ; FFT, and 0, N/8, N/2, 3N/8 for radix 2.                   ;
          ; The following pointers are therfore set up. They are set  ;
          ; up as twin pointers so that data accesses can parallelize ;
          ;                                                           ;
          ; y0 = ptr_y                                                ;
          ; y2 = ptr_y + (int) npoints                                ;
          ; x0 = ptr_x                                                ;
          ; x2 = ptr_x + (int) (npoints>>1)                           ;
          ;-----------------------------------------------------------;

          SUB      .1        A_radix,             2,               A_r2

          MV       .1      A_ptr_x,             A_p_x0
          ADD      .2X     A_ptr_x,             8,               B_p_x0
          MV       .2      B_ptr_y,             B_p_y0
          ADDAW    .2      B_p_y0,              B_n,             B_p_y2

          ADDAH    .2      B_p_y0,              B_n,             B_p_y1
          ADDAH    .2      B_p_y2,              B_n,             B_p_y3

          ;-----------------------------------------------------------;
          ; Prepare shift amount for digit reversed index and the     ;
          ; increment amount assuming that the radix is 4.            ;
          ;-----------------------------------------------------------;

          NORM     .2      B_n,                 B_l1
          ADD      .2      B_l1,                2,               B_l1
          MVK      .2      4,                   B_j0

          ;-----------------------------------------------------------;
          ;  Change pointers as required, and the increment amount if ;
          ; radix 2 is required.                                      ;
          ;                                                           ;
          ; if (radix == 2)                                           ;
          ; {                                                         ;
          ;    y1  = y0 + (int) (npoints >> 2)                        ;
          ;    y3  = y2 + (int) (npoints >> 2)                        ;
          ;    l1  = _norm(npoints) + 1                               ;
          ;    j0  = 8                                                ;
          ;    n0  = npoints >> 1                                     ;
          ; }                                                         ;
          ;-----------------------------------------------------------;

[!A_r2]   ADD      .2      B_p_y0,              B_n,             B_p_y1
[!A_r2]   ADD      .2      B_p_y2,              B_n,             B_p_y3
[!A_r2]   NORM     .2      B_n,                 B_l1
[!A_r2]   ADD      .2      B_l1,                1,               B_l1
[!A_r2]   MVK      .2      8,                   B_j0

          ;----------------------------------------------------------;
          ; Loop counter for the following loop is npoints >> 2. In  ;
          ; addition deduct 2 from the loop trip counter to account  ;
          ; for BDEC.                                                ;
          ;----------------------------------------------------------;

          SHRU     .1X     B_n,                 2,               A_i
          SUB      .1      A_i,                 2,               A_i
          ZERO     .2      B_j

          .mptr      A_p_x0, A_x+0, 16
          .mptr      B_p_x0, A_x+2, 16
          ;.mptr      B_p_y0, A_x+0, 0
          ;.mptr      B_p_y1, A_x+2, 0
          ;.mptr      B_p_y2, A_x+0, 0
          ;.mptr      B_p_y3, A_x+2, 0

LOOP_Z:  .trip 8

          ;----------------------------------------------------------;
          ; Digit reverse the index starting from 0. The increment   ;
          ; "j" is either by 4, or 8.                                ;
          ;                                                          ;
          ;  h2   = _deal(j)                                         ;
          ;  h2   = _bitr(h2)                                        ;
          ;  h2   = _rotl(h2, 16)                                    ;
          ;  h2   = _shfl(h2)                                        ;
          ;  h2  >>= l1                                              ;
          ;----------------------------------------------------------;
          DEAL     .2      B_j,                 B_h0
          BITR     .2      B_h0,                B_h1
          ROTL     .2      B_h1,                16,              B_h2
          SHFL     .2      B_h2,                B_h3
          SHRU     .2      B_h3,                B_l1,            B_h4
          ADD      .2      B_j,                 B_j0,            B_j

          ;----------------------------------------------------------;
          ; Read in the input data, from the first eight locations.  ;
          ; These are transformed either as a radix4 or as radix 2.  ;
          ;----------------------------------------------------------;

          LDDW    .D1T1    *A_p_x0++[2],        A_x1:A_x0
          LDDW    .D2T2    *B_p_x0++[2],        B_x3:B_x2
          LDDW    .D1T1    *A_p_x0++[2],        A_x5:A_x4
          LDDW    .D2T2    *B_p_x0++[2],        B_x7:B_x6

          ;----------------------------------------------------------;
          ;  xh0_0 = x_0 + x_4      xh1_0 = x_1 + x_5                ;
          ;  xl0_0 = x_0 - x_4      xl1_0 = x_1 - x_5                ;
          ;  xh0_1 = x_2 + x_6      xh1_1 = x_3 + x_7                ;
          ;  xl0_1 = x_2 - x_6      xl1_1 = x_3 - x_7                ;
          ;----------------------------------------------------------;

          ADD     .1       A_x4,                A_x0,           A_xh0_0
          ADD     .1       A_x5,                A_x1,           A_xh1_0
          ADD     .2       B_x6,                B_x2,           B_xh0_1
          ADD     .2       B_x7,                B_x3,           B_xh1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          SUB     .1       A_x1,                A_x5,           A_xl1_0
          SUB     .2       B_x2,                B_x6,           B_xl0_1
          SUB     .2       B_x3,                B_x7,           B_xl1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          MV      .2       B_xl1_1,             B_xl1_1c
          MV      .1       A_xh1_0,             A_xh1_0c

          ;----------------------------------------------------------;
          ;  Replace results conditionally if it is determined that  ;
          ;  it is a radix 2 pass as follows:                        ;
          ;                                                          ;
          ;  xh0_0 = x0              xh1_0  = x1                     ;
          ;  xh0_1 = x2              xh1_1  = x3                     ;
          ;  xl0_0 = x4              xl1_0  = x5,                    ;
          ;  xl0_1 = x7              xl1_1  = x6                     ;
          ;----------------------------------------------------------;

[!A_r2]   ROTL    .1       A_x0,                0,              A_xh0_0
[!A_r2]   ROTL    .1       A_x1,                0,              A_xh1_0c
[!A_r2]   ROTL    .2       B_x2,                0,              B_xh0_1
[!A_r2]   ROTL    .2       B_x3,                0,              B_xh1_1

[!A_r2]   ROTL    .1       A_x4,                0,              A_xl0_0
[!A_r2]   ROTL    .1       A_x5,                0,              A_xl1_0
[!A_r2]   MV      .2       B_x6,                B_xl1_1c
[!A_r2]   MV      .2       B_x7,                B_xl0_1

          ;---------------------------------------------------------;
          ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2     ;
          ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3     ;
          ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2     ;
          ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3     ;
          ;---------------------------------------------------------;

          ADD     .2X      A_xh0_0,             B_xh0_1,        B_y0
          ADD     .2X      A_xh1_0c,            B_xh1_1,        B_y1
          SUB     .2X      A_xh0_0,             B_xh0_1,        B_y4
          SUB     .2X      A_xh1_0c,            B_xh1_1,        B_y5

          ;---------------------------------------------------------;
          ; radix4:  y2 = xl0_0 + xl1_1    radix2: y2 = x4 + x6     ;
          ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7     ;
          ; radix4:  y6 = xl0_0 - xl1_1    radix2: y6 = x4 - x6     ;
          ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7     ;
          ;---------------------------------------------------------;

          ADD     .1X      A_xl0_0,             B_xl1_1c,       A_y2
          SUB     .1X      A_xl1_0,             B_xl0_1,        A_y3
          SUB     .1X      A_xl0_0,             B_xl1_1c,       A_y6
          ADD     .1X      A_xl1_0,             B_xl0_1,        A_y7

          ;---------------------------------------------------------;
          ;  Swap y3, y7 if radix2   y2 = x4 + x6, y3 = x5 + x7,    ;
          ;                          y6 = x4 - x6, y7 = x5 - x7     ;
          ;---------------------------------------------------------;

          MV      .1       A_y3,                A_temp
[!A_r2]   MV      .1       A_y7,                A_y3
[!A_r2]   MV      .1       A_temp,              A_y7

           ;--------------------------------------------------------;
           ; Store using digit reversed index, bit reversed index   ;
           ; and pointers p_y0,...p_y3                              ;
           ;--------------------------------------------------------;

          STDW    .D2T2    B_y1:B_y0,           *B_p_y0[B_h4]
          STDW    .D2T1    A_y3:A_y2,           *B_p_y1[B_h4]
          STDW    .D2T2    B_y5:B_y4,           *B_p_y2[B_h4]
          STDW    .D2T1    A_y7:A_y6,           *B_p_y3[B_h4]

          ;---------------------------------------------------------;
          ;  Decrement and branch back to LOOP_Z                    ;
          ;---------------------------------------------------------;

          BDEC    .1       LOOP_Z,              A_i

        .return
        .endproc

*============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*

fir_cplx.sa/    1066929506  0     0     0       20177     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Thu Jan 10 19:03:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*  NAME                                                                     *
*      DSP_fir_cplx -- Partitioned Serial Assembly code for                 *
*      Complex Filter.                                                      *
*                                                                           *
*  REVISION DATE                                                            *
*      06-Aug-2001                                                          *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           short                 nh,                                       *
*           short                 nr                                        *
*      )                                                                    *
*                                                                           *
*      x[2*(nr+nh-1)] : Complex input data. x must point to x[2*(nh-1)].    *
*      h[2*nh]        : Complex coefficients (in normal order).             *
*      r[2*nr]        : Complex output data.                                *
*      nh             : Number of complex coefficients.                     *
*                       Must be multiple of 2.                              *
*      nr             : Number of complex output samples.                   *
*                       Must be multiple of 4.                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This complex FIR computes nr complex output samples using nh        *
*       complex coefficients. It operates on 16-bit data with a 32-bit      *
*       accumulate. Each array consists of an even and odd term with even   *
*       terms representing the real part of the element and the odd terms   *
*       the imaginary part. The pointer to input array x must point to the  *
*       (nh)th complex sample, i.e. element 2*(nh-1), upon entry to the     *
*       function. The coefficients are expected in normal order.            *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           short nh,                                                       *
*           short nr                                                        *
*       )                                                                   *
*       {                                                                   *
*           short i,j;                                                      *
*           int imag, real;                                                 *
*                                                                           *
*           for (i = 0; i < 2*nr; i += 2)                                   *
*           {                                                               *
*               imag = 0;                                                   *
*               real = 0;                                                   *
*               for (j = 0; j < 2*nh; j += 2)                               *
*               {                                                           *
*                   real += h[j] * x[i-j]   - h[j+1] * x[i+1-j];            *
*                   imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];              *
*               }                                                           *
*               r[i]   = (real >> 15);                                      *
*               r[i+1] = (imag >> 15);                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer loop is unrolled 4 times while inner loop is not unrolled.    *
*       Both inner and outer loops are collapsed into one loop.             *
*       ADDAH and SUBAH are used alongwith PACKH2 to perform accumulation,  *
*       shift and data packing.                                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nr must be a multiple of 4 and >= 4.                                *
*       nh must be a multiple of 2 and >= 2.                                *
*                                                                           *
*   NOTE                                                                    *
*       This function is little Endian.                                     *
*       This function is interrupt-tolerant but not interruptible.          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_fir_cplx"
        .global _DSP_fir_cplx
_DSP_fir_cplx  .cproc A_inadd, B_tapadd, A_outadd, B_nh, A_nr 
              .reg    B_h1:B_h0, A_h1:A_h0 ; Filter Taps are loaded as dword
              .reg    B_1h,B_0h          ; Swiping the Filter Taps
              .reg    A_1h,A_0h          ; Swiping the Filter Taps
              .reg    A_xn_1             ; Input Xn-1 is loaded for h1
              .reg    A_xn1:A_xn0        ; Input Xn+1:Xn+0 are loaded as dword
              .reg    B_xn3:B_xn2        ; Input Xn+3:Xn+2 are loaded as dword
              .reg    B_incount, B_st    ; Define outer and inner loop counter
              .reg    A_imag0:A_real0    ; Accumulators for four output
              .reg    A_imag1:A_real1    ; samples
              .reg    B_imag2:B_real2
              .reg    B_imag3:B_real3
              .reg    B_real3x, B_real2x, A_real1x, A_real0x
              .reg    B_imag3x, B_imag2x, A_imag1x, A_imag0x
              .reg    B_real3_, B_real2_, A_real1_, A_real0_
              .reg    B_imag3_, B_imag2_, A_imag1_, A_imag0_
              .reg    A_stor1:A_stor0
              .reg    B_stor3:B_stor2
              .reg    A_niter
              .reg    A_saveinadd
              .reg    A_savetapadd
              .reg    A_tempr0, A_tempi0, A_rtemp0, A_itemp0
              .reg    A_tempr1, A_tempi1, A_rtemp1, A_itemp1
              .reg    B_tempr2, B_tempi2, B_rtemp2, B_itemp2
              .reg    B_tempr3, B_tempi3, B_rtemp3, B_itemp3
              .reg    A_temp, B_outadd, B_inadd, A_tapadd
              .no_mdep

              ;-----------------------------------------------------------;
              ; B_tapadd and A_tapdd are registers that point to filter   ;
              ; taps. inadd points to the input data vector.              ;
              ;-----------------------------------------------------------;

              MV.1x                B_tapadd,         A_tapadd
              ADD.2x               A_outadd,         8,             B_outadd
              MV .1                A_inadd,          A_saveinadd
              MV.1                 A_tapadd,         A_savetapadd

              ;-----------------------------------------------------------;
              ; Set up overall loop trip count. The filter taps are pro-  ;
              ; cessed 2 at a time, hence they are halved. The output     ;
              ; samples are processed four at a time, and hence overall   ;
              ; trip count "niter" for the loop is figured out.           ;
              ; "2" is deducted off overasll loop trip count as BDEC      ;
              ; is used.                                                  ;
              ;-----------------------------------------------------------;

              SHR.2                B_nh,             1,             B_nh
              SHR.1                A_nr,             2,             A_nr
              MPY.1x               A_nr,             B_nh,          A_niter
              SUB.1                A_niter,          2,             A_niter

              ;-----------------------------------------------------------;
              ; A_temp is register used to reset the input pointer for    ;
              ; filtering for the next four samples.                      ;
              ;-----------------------------------------------------------;

              MV.2                 B_nh,             B_incount
              SHL.1x               B_nh,             3,             A_temp
              ADDK.1               16,               A_temp

              ;-----------------------------------------------------------;
              ; Make partitioning copy of input pointer to B side         ;
              ;-----------------------------------------------------------;

              MV.2x                 A_inadd,          B_inadd

              ;-----------------------------------------------------------;
              ; Zero out accumulators for output samples                  ;
              ;-----------------------------------------------------------;

              ZERO.1               A_imag0:A_real0
              ZERO.1               A_imag1:A_real1
              ZERO.2               B_imag2:B_real2
              ZERO.2               B_imag3:B_real3

              .mptr                A_tapadd,         tap + 0,       8
              .mptr                A_inadd,          in  + 0,       -8
              .mptr                B_inadd,          in  + 0,       -8
              .mptr                A_outadd,         out + 0,       16
              .mptr                B_outadd,         out + 8,       16

out_loop:     .trip   4

              ;------------------------------------------------------------;
              ; Load filter taps require for FIR                           ;
              ;------------------------------------------------------------;

              LDNDW.D1T1          * A_tapadd,       A_h1:A_h0
              LDNDW.D1T2          * A_tapadd++,     B_h1:B_h0

              ;------------------------------------------------------------;
              ; Load input data required for FIR                           ;
              ;------------------------------------------------------------;

              LDNW.D2T1           *-B_inadd[1],     A_xn_1
              LDNDW.D2T2          *+B_inadd[1],     B_xn3:B_xn2
              LDNDW.D1T1          * A_inadd--,      A_xn1:A_xn0

              ;-------------------------------------------------------------;
              ; Check if filter pointers, input pointers needs to be reset  ;
              ; Make a copy of reset counter, to decouple input/output      ;
              ; dependencies. Reset counter if required                     ;
              ;-------------------------------------------------------------;

              SUB.2                B_incount,        1,               B_incount
              MV .2                B_incount,        B_st

 [!B_incount] ADD.1                A_inadd,          A_temp,          A_inadd
 [!B_incount] MV .1                A_savetapadd,     A_tapadd
              MV .2x               A_inadd,          B_inadd

 [!B_incount] MV .2                B_nh,             B_incount

              ;------------------------------------------------------------;
              ;  Perform flip of filter taps, using SWAP2                  ;
              ;------------------------------------------------------------;

              SWAP2.1              A_h0,             A_0h
              SWAP2.1              A_h1,             A_1h
              SWAP2.2              B_h0,             B_0h
              SWAP2.2              B_h1,             B_1h

              ;------------------------------------------------------------;
              ; Perform multiply and subtract using DOTPN2.                ;
              ; Perform multiply an  add      using DOTP2                  ;
              ;------------------------------------------------------------;

              DOTPN2.1             A_h0,             A_xn0,           A_tempr0
              DOTPN2.1             A_h0,             A_xn1,           A_tempr1
              DOTPN2.2             B_h0,             B_xn2,           B_tempr2
              DOTPN2.2             B_h0,             B_xn3,           B_tempr3

              DOTPN2.1             A_h1,             A_xn_1,          A_rtemp0
              DOTPN2.1             A_h1,             A_xn0,           A_rtemp1
              DOTPN2.2X            B_h1,             A_xn1,           B_rtemp2
              DOTPN2.2             B_h1,             B_xn2,           B_rtemp3

              DOTP2.1              A_0h,             A_xn0,           A_tempi0
              DOTP2.1              A_0h,             A_xn1,           A_tempi1
              DOTP2.2              B_0h,             B_xn2,           B_tempi2
              DOTP2.2              B_0h,             B_xn3,           B_tempi3

              DOTP2.1              A_1h,             A_xn_1,          A_itemp0
              DOTP2.1              A_1h,             A_xn0,           A_itemp1
              DOTP2.2x             B_1h,             A_xn1,           B_itemp2
              DOTP2.2              B_1h,             B_xn2,           B_itemp3

              ADD.1                A_tempr0,         A_rtemp0,        A_real0x
              ADD.1                A_tempr1,         A_rtemp1,        A_real1x
              ADD.2                B_tempr2,         B_rtemp2,        B_real2x
              ADD.2                B_tempr3,         B_rtemp3,        B_real3x

              ADD.1                A_tempi0,         A_itemp0,        A_imag0x
              ADD.1                A_tempi1,         A_itemp1,        A_imag1x
              ADD.2                B_tempi2,         B_itemp2,        B_imag2x
              ADD.2                B_tempi3,         B_itemp3,        B_imag3x

              ;--------------------------------------------------------------;
              ; Use D unit to accomplish the shift and add results together  ;
              ;--------------------------------------------------------------;

              SUBAH.1              A_real0,          A_real0x,        A_real0
              SUBAH.1              A_real1,          A_real1x,        A_real1
              SUBAH.2              B_real2,          B_real2x,        B_real2
              SUBAH.2              B_real3,          B_real3x,        B_real3

              ADDAH.1              A_imag0,          A_imag0x,        A_imag0
              ADDAH.1              A_imag1,          A_imag1x,        A_imag1
              ADDAH.2              B_imag2,          B_imag2x,        B_imag2
              ADDAH.2              B_imag3,          B_imag3x,        B_imag3

              ;--------------------------------------------------------------;
              ; Pack results together to form packed word imag:real          ;
              ;--------------------------------------------------------------;

              PACKH2.1             A_imag0,          A_real0,         A_stor0
              PACKH2.1             A_imag1,          A_real1,         A_stor1
              PACKH2.2             B_imag2,          B_real2,         B_stor2
              PACKH2.2             B_imag3,          B_real3,         B_stor3

              ;--------------------------------------------------------------;
              ; Use copy of reset counter to store outputs, reset accumul.   ;
              ;--------------------------------------------------------------;


 [!B_st]      STNDW.D2T2            B_stor3:B_stor2,  *B_outadd++[2]
 [!B_st]      STNDW.D1T1            A_stor1:A_stor0,  *A_outadd++[2]

 [!B_st]      ZERO.1               A_imag0:A_real0
 [!B_st]      ZERO.1               A_imag1:A_real1
 [!B_st]      ZERO.2               B_imag2:B_real2
 [!B_st]      ZERO.2               B_imag3:B_real3

              ;--------------------------------------------------------------;
              ;  Decrement and branch back to loop                           ;
              ;--------------------------------------------------------------;

              BDEC.1               out_loop,         A_niter

              .endproc

* ========================================================================= *
*   End of file:  dsp_fir_cplx.sa                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_gen.sa/     1066929506  0     0     0       26321     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.8     Tue Nov  5 21:27:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_gen: FIR Filter (general purpose)                           *
*                                                                           *
*   REVISION DATE                                                           *
*       22-Mar-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_gen                                                    *
*       (                                                                   *
*           const short *restrict x,  /* Input ('nr + nh - 1' samples) */   *
*           const short *restrict h,  /* Filter coefficients (nh taps) */   *
*           short       *restrict r,  /* Output array ('nr' samples)   */   *
*           int                   nh, /* Length of filter (nh >= 5)    */   *
*           int                   nr  /* Length of output (nr >= 1)    */   *
*       );                                                                  *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code. Note that the        *
*       assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*       void DSP_fir_gen                                                    *
*       (                                                                   *
*           const short *restrict x,  /* Input ('nr + nh - 1' samples) */   *
*           const short *restrict h,  /* Filter coefficients (nh taps) */   *
*           short       *restrict r,  /* Output array ('nr' samples)   */   *
*           int                   nh, /* Length of filter (nh >= 5)    */   *
*           int                   nr  /* Length of output (nr >= 1)    */   *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*                                                                           *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients         *
*       stored in vector h. The real data input is stored in vector x.      *
*       The filter output result is stored in vector r. This FIR            *
*       assumes the number of filter coefficients is greater than or        *
*       equal to 5. It operates on 16-bit data with a 32-bit                *
*       accumulate. This routine has no memory hits regardless of where     *
*       x, h, and r arrays are located in memory. The filter is nr          *
*       output samples and nh coefficients. The assembly routine            *
*       performs 4 output samples at a time.                                *
*                                                                           *
*   NOTES                                                                   *
*       There are 2 versions of code in this file. The one with seperate    *
*       loops for the filter taps and output samples performs well, if the  *
*       ratio of filter taps to output samples is comparable. If the        *
*       number of output samples to be computed is about four times the     *
*       number of filter taps, then the version with the collpased          *
*       loop performs better.                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       1. Load double word instruction is used to simultaneously load      *
*          four values in a single clock cycle.                             *
*                                                                           *
*       2. The inner loop is unrolled four times and will always            *
*          compute a multiple of 4 of nh and nr. If nh % 4 != 0, the        *
*          code will fill in 0s to make nh a multiple of 4. If nr % 4       *
*          != 0, the code will still perform a mutiple of 4 outputs.        *
*                                                                           *
*       3. Both the inner and outer loops are software pipelined.           *
*                                                                           *
*       4. This code yields best performance when ratio of outer            *
*          loop to inner loop is less than or equal to 4.                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. Little Endian is assumed for LDNDW.                              *
*       2. nh >= 5.                                                         *
*       3. nr multiple of 4.                                                *
*       4. Output array r[] must be word-aligned                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

              .text
        .sect ".text:_fir_gen"
        .global _DSP_fir_gen
_DSP_fir_gen: .cproc  A_xptr, B_hptr, A_rptr, B_nh, A_nr
        .no_mdep

       .reg     B_m,          B_3,             B_2          ;
       .reg     B_1,          B_ofs,           B_h32:B_h10  ;
       .reg     B_h32_n,      B_h10_n,         A_nr_l       ;
       .reg     B_ij,         B_nh_l,          A_nh_l       ;
       .reg     A_i,          B_ic,            A_il         ;
       .reg     A_hptr,       B_rptr,          B_ptr        ;

       .reg     A_sum1:A_sum0                               ;
       .reg     B_sum3:B_sum2                               ;
;--

       .reg     A_fg,         A_x32:A_x10                   ;
       .reg     B_x76:B_x54,  A_x76:A_x54                   ;
       .reg     A_x21,        B_x43,           B_x65        ;
       .reg     A_prod0_10,   A_prod0_32,      A_prod2_32   ;
       .reg     B_prod2_54,   A_prod1_21,      B_prod1_43   ;
       .reg     B_prod3_43,   B_prod3_65,      A_sum0_0     ;
       .reg     A_sum0_1,     A_sum1_0,        B_sum1_1     ;
       .reg     B_sum2_0,     B_sum2_1,        B_sum3_0     ;
       .reg     B_sum3_1,     B_sum0_s,        A_sum1_s     ;
       .reg     B_sum2_s,     B_sum3_s,        B_r32:B_r10  ;
       .reg     B_fl,         A_h32,           A_h10        ;
       .reg     B_sum1_s

       .if 1

       ;--------------------------------------------------------;
       ;  Use the following code if ratio of output sampl-      ;
       ;  es to filter taps is >= 5. nh/nr >= 5                 ;
       ;--------------------------------------------------------;

       AND.2    3,            B_nh,            B_m              ; m = nh & 3
[!B_m] MVK.2    4,            B_m                               ; m = 4

       ;--------------------------------------------------------;
       ; Detect if mask is a multiple of 4 or not               ;
       ; If mask is of the form 4n + 3, then h3 = 0             ;
       ; If mask is of the form 4n + 2, then h3h2 = 0           ;
       ; If mask is of the from 4n + 1, then h3,h2,h1 = 0       ;
       ;--------------------------------------------------------;

       CMPEQ.2  3,            B_m,             B_3              ; m == 3
       CMPEQ.2  2,            B_m,             B_2              ; m == 2
       CMPEQ.1  1,            B_m,             B_1              ; m == 1

       SUB.2    B_nh,         B_m,             B_ofs            ; ofs = nh - m

       ;--------------------------------------------------------;
       ; Read the filter taps speculatively. If the filter      ;
       ; tap is not valid it is replaced with zero. At most     ;
       ; 3 values past the end of the array may be read.        ;
       ;--------------------------------------------------------;

       ADDAH    B_hptr,       B_ofs,           B_ptr            ; ptr = &h[ofs]
       LDNDW    *B_ptr,       B_h32:B_h10                       ; Load h32:h10

[B_3]  CLR      B_h32,        16, 31,          B_h32            ; h32 = 00XX
[B_2]  ZERO     B_h32                                           ; h32 = 0
[B_1]  ZERO     B_h32                                           ; h10 = 0
[B_1]  CLR      B_h10,        16, 31,          B_h10            ; h10 = 00XX

       ;--------------------------------------------------------;
       ; Pack either modified h3, h2, h1, h0 or unmodified      ;
       ; h3,h2,h1,h0 to form a new double word h3210_n, to      ;
       ; be used on the last stage.                             ;
       ;--------------------------------------------------------;

       MV       B_h32,        B_h32_n                           ; h32_n = h32
       MV       B_h10,        B_h10_n                           ; h10_n = h10

       ;--------------------------------------------------------;
       ; Round up the filter taps, number of output samples     ;
       ; to the nearest multiple of four.                       ;
       ;--------------------------------------------------------;


       ADD      A_nr,         3,               A_nr_l           ; nr + 3
       ADD      B_nh,         3,               B_nh_l           ; nh + 3
       SHRU     A_nr_l,       2,               A_nr_l           ; nr_l >> 2
       SHRU     B_nh_l,       2,               B_nh_l           ; nr_h >> 2

       MPY      A_nr_l,        B_nh_l,         B_ij             ; nr_l * nh_l
       MV       B_nh_l,        A_nh_l                           ; Copy
       MV       A_nh_l,        A_i                              ; i = nh_l
       MV       A_nh_l,        B_ic                             ; ic = nh_l
       MV       A_nh_l,        A_il                             ; il = nh_l

       ZERO     A_sum1:A_sum0                                   ; Zero accum.
       ZERO     B_sum3:B_sum2                                   ; for 4 samples

       ;--------------------------------------------------------;
       ; Perform copy of filter pointer to A side.              ;
       ; Decrement by 2 for BDEC                                ;
       ;--------------------------------------------------------;

       MV       B_hptr,       A_hptr                            ; Copy of ptr.
       SUB      B_ij,         2,               B_ij             ; ij -= 2

       .mptr   A_xptr, A_x+0, 8
       .mptr   A_hptr, A_x+0, 8
       .mptr   A_rptr, A_x+0, 8

LOOP:  .trip   1                                                ; Loop

       SUB.1        A_nh_l,       A_i,             A_fg         ; fg = i - nh_l
[!A_fg]ZERO.1       A_i                                         ; (!fg) i = 0
[!A_i] LDNDW.D1T1  *A_xptr++,     A_x32:A_x10                   ; Load x32:x10

       LDNDW.D1T2  *A_hptr[A_i],  B_h32:B_h10                   ; Load h32:h10
       LDNDW.D1T2  *A_xptr[A_i],  B_x76:B_x54                   ; Load x76:x54
       LDNDW.D1T1  *A_xptr[A_i],  A_x76:A_x54                   ; Load x76:x54
       ADD.1        A_i,          1,               A_i          ; i ++

       SUB.2        A_il,         1,               B_fl         ; fl = il - 1
[!A_il]MV.1         A_nh_l,       A_il                          ; il = nh_l
[!B_fl]MV.2         B_h32_n,      B_h32                         ; h32 = h32_n
[!B_fl]MV.2         B_h10_n,      B_h10                         ; h10 = h10_n
       SUB.1        A_il,         1,               A_il         ; il --

       MV.1x        B_h32,        A_h32                         ; Partitioning
       MV.1x        B_h10,        A_h10                         ; copy

       PACKLH2.1    A_x32,        A_x10,           A_x21        ; Prepare
       PACKLH2.2x   B_x54,        A_x32,           B_x43        ; x21, x43
       PACKLH2.2    B_x76,        B_x54,           B_x65        ; x65

       DOTP2.1      A_x10,        A_h10,           A_prod0_10   ; x1h1 + x0h0
       DOTP2.1      A_x32,        A_h32,           A_prod0_32   ; x3h3 + x2h2
       DOTP2.1      A_x32,        A_h10,           A_prod2_32   ; x3h1 + x2h0
       DOTP2.2      B_x54,        B_h32,           B_prod2_54   ; x5h3 + x4h2

       DOTP2.1      A_x21,        A_h10,           A_prod1_21   ; x2h1 + x1h0
       DOTP2.2      B_x43,        B_h32,           B_prod1_43   ; x4h3 + x3h2
       DOTP2.2      B_x43,        B_h10,           B_prod3_43   ; x4h1 + x3h0
       DOTP2.2      B_x65,        B_h32,           B_prod3_65   ; x6h3 + x5h2

       ADD.1        A_sum0,       A_prod0_10,      A_sum0_0     ; += prod0_10
       ADD.1        A_sum0_0,     A_prod0_32,      A_sum0       ; += prod0_32
       ADD.1        A_sum1,       A_prod1_21,      A_sum1_0     ; += prod1_21
       ADD.1x       A_sum1_0,     B_prod1_43,      A_sum1       ; += prod1_43

       ADD.2x       B_sum2,       A_prod2_32,      B_sum2_0     ; += prod2_32
       ADD.2        B_sum2_0,     B_prod2_54,      B_sum2       ; += prod2_54
       ADD.2        B_sum3,       B_prod3_43,      B_sum3_0     ; += prod3_43
       ADD.2        B_sum3_0,     B_prod3_65,      B_sum3       ; += prod3_65

       SHR.2x       A_sum0,       15,              B_sum0_s     ; sum0 >> 15
       ADD.1        A_sum1,       A_sum1,          A_sum1_s     ; sum1 >> 15
       SHR.2        B_sum2,       15,              B_sum2_s     ; sum2 >> 15
       ADD.2        B_sum3,       B_sum3,          B_sum3_s     ; sum3 >> 15

       MV.2x        A_sum1_s,     B_sum1_s                      ; Pack res.
       PACKHL2.2    B_sum1_s,     B_sum0_s,        B_r10        ; into
       PACKHL2.2    B_sum3_s,     B_sum2_s,        B_r32        ; doubleword

       MV.1         A_x76,        A_x32                         ; x32 = x76
       MV.1         A_x54,        A_x10                         ; x54 = x10

       SUB.2        B_ic,         1,               B_ic         ; ic --
[!B_ic]STDW.D1T2    B_r32:B_r10,  *A_rptr++                     ; Store
[!B_ic]ZERO.1       A_sum1:A_sum0                               ; Zero
[!B_ic]ZERO.2       B_sum3:B_sum2                               ; accum.
[!B_ic]MV.2         B_nh_l,         B_ic                        ; Reset

       BDEC.2       LOOP,          B_ij                         ; Branch

       .endif

       .if 0

       .reg    B_m,            B_3,            B_2
       .reg    B_1,            B_ofs,          A_ofs
       .reg    B_ptr,          B_h32_n,        B_h10_n
       .reg    B_h32:B_h10,    A_h32:A_h10,    A_nr_l
       .reg    B_nh_l,         B_j,            A_hptr
       .reg    A_ptr_x,        A_it_i,         A_sum1:A_sum0
       .reg    B_sum3:B_sum2,  A_x32:A_x10

;--

       .reg    B_x76:B_x54,    A_x21,          B_x43
       .reg    B_x65,          A_prod0_10,     A_prod0_32
       .reg    A_prod2_10,     A_prod2_32,     B_prod1_10
       .reg    B_prod1_32,     B_prod3_10,     B_prod3_32
       .reg    A_sum0_0,       A_sum2_0,       B_sum1_0
       .reg    B_sum3_0,       B_sum0_s,       B_sum1_s
       .reg    B_sum2_s,       B_sum3_s,       B_r32:B_r10

       ;----------------------------------------------------;
       ; Detect if mask is a multiple of 4 or not           ;
       ; If mask is of the form 4n + 3, then h3 = 0         ;
       ; If mask is of the form 4n + 2, then h3h2 = 0       ;
       ; If mask is of the from 4n + 1, then h3,h2,h1 = 0   ;
       ;----------------------------------------------------;

       AND      3,            B_nh,            B_m          ; mask = nh & 3
[!B_m] MVK      4,            B_m                           ; mask = 4

       CMPEQ    3,            B_m,             B_3          ; m == 3
       CMPEQ    2,            B_m,             B_2          ; m == 2
       CMPEQ    1,            B_m,             B_1          ; m == 1

       SUB      B_nh,         B_m,             B_ofs        ; ofs = nh - m

       ;----------------------------------------------------;
       ; Read the filter taps speculatively. If the filter  ;
       ; tap is not valid it is replaced with zero. At most ;
       ; 3 values past the end of the array may be read.    ;
       ;----------------------------------------------------;

       ADDAH    B_hptr,       B_ofs,           B_ptr        ; ptr = &h[ofs]
       LDNDW    *B_ptr--,     B_h32:B_h10                   ; Load h32:h10


[B_3]  CLR      B_h32,        16, 31,          B_h32        ; h32 = 00XX
[B_2]  ZERO     B_h32                                       ; h32 = 0
[B_1]  ZERO     B_h32                                       ; h32 = 0
[B_1]  CLR      B_h10,        16, 31,          B_h10        ; h10 = 00XX

       ;----------------------------------------------------;
       ; Pack either modified h3, h2, h1, h0 or unmodified  ;
       ; h3,h2,h1,h0 to form a new double word h3210_n, to  ;
       ; be used on the last stage.                         ;
       ;----------------------------------------------------;

       MV       B_h32,        B_h32_n                       ; h32_n
       MV       B_h10,        B_h10_n                       ; h10_n

       ;----------------------------------------------------;
       ; Round up the filter taps, number of output samples ;
       ; to the nearest multiple of four.                   ;
       ;----------------------------------------------------;

       ADD      A_nr,         3,               A_nr_l       ; nr + 3
       ADD      B_nh,         3,               B_nh_l       ; nh + 3
       SHRU     A_nr_l,       2,               A_nr_l       ; nr_l >> 2
       SHRU     B_nh_l,       2,               B_nh_l       ; nh_l >> 2

       SUB      A_nr_l,       0,               B_j          ; j = nr_l
       ADD      B_ofs,        4,               A_ofs        ; ofs -= 4

LOOPJ:

       MV       B_h32_n,      B_h32                         ; h32 = h32_n
       MV       B_h10_n,      B_h10                         ; h10 = h10_n
       MV       B_h32_n,      A_h32                         ; Copy to
       MV       B_h10_n,      A_h10                         ; A side.

       MV       B_ptr,        A_hptr                        ; Filter ptr.

       ADDAH    A_xptr,       A_ofs,           A_ptr_x      ; Data ptr.
       ADD      A_ofs,        4,               A_ofs        ; Incr. start

       LDNDW    *A_ptr_x--,   B_x76:B_x54                   ; Load x76:x54

       MV       B_nh_l,       A_it_i                        ; loop cnt.
       SUB      A_it_i,       2,                A_it_i      ; it_i -= 2

       ZERO     A_sum1:A_sum0                               ; Zero accum.
       ZERO     B_sum3:B_sum2                               ; Zero accum.

       .trip    3                                           ; nh >= 12
LOOPI:                                                      ; LOOPI

        LDNDW    *A_ptr_x--,   A_x32:A_x10                  ; Load x32:x10

        PACKLH2  A_x32,        A_x10,          A_x21        ; Prepare x21
        PACKLH2  B_x54,        A_x32,          B_x43        ; Prepare x43
        PACKLH2  B_x76,        B_x54,          B_x65        ; Prepare x65

        DOTP2    A_x10,        A_h10,          A_prod0_10   ; x1h1 + x0h0
        DOTP2    A_x32,        A_h32,          A_prod0_32   ; x3h3 + x2h2
        DOTP2    A_x32,        A_h10,          A_prod2_10   ; x3h1 + x2h0
        DOTP2    B_x54,        A_h32,          A_prod2_32   ; x5h3 + x4h2

        DOTP2    A_x21,        B_h10,          B_prod1_10   ; x2h1 + x1h0
        DOTP2    B_x43,        B_h32,          B_prod1_32   ; x4h3 + x3h2
        DOTP2    B_x43,        B_h10,          B_prod3_10   ; x4h1 + x3h0
        DOTP2    B_x65,        B_h32,          B_prod3_32   ; x6h3 + x5h2

        ;---------------------------------------------------;
        ;  Redundant loading of filter coefficients is      ;
        ; done to get partitioning of filter coefficients   ;
        ; on both A and B data paths.                       ;
        ;---------------------------------------------------;

        LDNDW    *A_hptr,      A_h32:A_h10                  ; Load h32:h10
        LDNDW    *A_hptr--,    B_h32:B_h10                  ; Load h32:h10

        ADD      A_sum0,       A_prod0_10,     A_sum0_0     ; sum0 += prod0
        ADD      A_sum0_0,     A_prod0_32,     A_sum0       ; sum0 += prod0
        ADD      A_prod2_10,   A_prod2_32,     A_sum2_0     ; sum2 += prod2
        ADD      B_sum2,       A_sum2_0,       B_sum2       ; sum2 += prod2

        ADD      B_prod1_10,   B_prod1_32,     B_sum1_0     ; sum1 += prod1
        ADD      A_sum1,       B_sum1_0,       A_sum1       ; sum1 += prod1
        ADD      B_sum3,       B_prod3_10,     B_sum3_0     ; sum3 += prod3
        ADD      B_sum3_0,     B_prod3_32,     B_sum3       ; sum3 += prod3

        MV       A_x10,        B_x54                        ; x54 = x10
        MV       A_x32,        B_x76                        ; x76 = x32

        SHR      A_sum0,       15,             B_sum0_s     ; sum0 >> 15
        SHR      B_sum2,       15,             B_sum2_s     ; sum2 >> 15
        SHR      A_sum1,       15,             B_sum1_s     ; sum1 >> 15
        SHR      B_sum3,       15,             B_sum3_s     ; sum3 >> 15

        BDEC     LOOPI,        A_it_i                       ; Branch.


        PACK2    B_sum1_s,     B_sum0_s,       B_r10        ; Packed
        PACK2    B_sum3_s,     B_sum2_s,       B_r32        ; output samples.

        STDW     B_r32:B_r10,  *A_rptr++                    ; Store

[B_j]   SUB      B_j,          1,              B_j          ; j --
[B_j]   B        LOOPJ                                      ; Branch.

       .endif


       .endproc                                             ; End

* ========================================================================= *
*   End of file:  dsp_fir_gen.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_r4.sa/      1066929506  0     0     0       14007     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Thu Sep  6 16:41:52 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r4: FIR Filter (radix 4)                                    *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *restrict x,  /* Input array [nr+nh-1 elements] */  *
*           const short *restrict h,  /* Coeff array [nh elements]      */  *
*           short       *restrict r,  /* Output array [nr elements]     */  *
*           int nh,                   /* Number of coefficients.        */  *
*           int nr                    /* Number of output samples.      */  *
*       )                                                                   *
*                                                                           *
*   ARGUMENTS PASSED                                                        *
*       *x    ->      A4                                                    *
*       *h    ->      B4                                                    *
*       *r    ->      A6                                                    *
*       nh    ->      B6                                                    *
*       nr    ->      A8                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients         *
*       stored in vector h.  The real data input is stored in vector x.     *
*       The filter output result is stored in vector r.  Input data and     *
*       filter taps are 16-bit, with intermediate values kept at 32-bit     *
*       precision.  Filter taps are expected in Q15 format.                 *
*                                                                           *
*       The following is a natural C implementation with no restrictions.   *
*       This version has restrictions as noted in the ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Number of taps:    'nh' >= 8, multiple of 4                         *
*       Number of samples: 'nr' >= 4, multiple of 4                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double word instruction is used to simultaneously          *
*           load four values in a single clock cycle.                       *
*       2.  The inner loop is unrolled four times                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"

        .sect ".text:_fir_r4"
        .global _DSP_fir_r4
_DSP_fir_r4: .cproc A_x_ptr, B_h_ptr, A_r_ptr, B_nh, A_nr ;arg_list

        .no_mdep
        .reg    A_i            ; outer loop flag;when = 0,branch to iloop
        .reg    A_j            ; inner loop count = 2
        .reg    A_x_ptr1       ; input array pointer
        .reg    A_h32:A_h10    ; coef: h[3:2],h[1:0]
        .reg    A_x32:A_x10    ; input: x[3:2],x[1:0]
        .reg    A_x21          ; input: x[2:1]
        .reg    A_prod00_11    ; = x[0]*h[0] + x[1]*h[1]
        .reg    A_prod22_33    ; = x[2]*h[2] + x[3]*h[3]
        .reg    A_prod20_31    ; = x[2]*h[0] + x[3]*h[1]
        .reg    A_prod10_21    ; = x[1]*h[0] + x[2]*h[1]
        .reg    A_sum0         ; = sum of prod and sum0 >>15 for r[0]
        .reg    A_sum1         ; = sum of prod and  sum1 >>15 for r[1]
        .reg    B_i            ; outer loop flag;when = 0,branch to iloop
        .reg    B_iloop        ; iloop label address
        .reg    B_h_ptr1       ; coef array pointer
        .reg    B_r32:B_r10    ; output: r[3:2],r[1:0]
        .reg    B_h32:B_h10    ; coef: h[3:2],h[1:0]
        .reg    B_x76:B_x54    ; input: x[7:6],x[5:4]
        .reg    B_x43          ; input: x[4:3]
        .reg    B_x65          ; input: x[6:5]
        .reg    B_prod42_53    ; = x[4]*h[2] + x[5]*h[3]
        .reg    B_prod32_43    ; = x[3]*h[2] + x[4]*h[3]
        .reg    B_prod30_41    ; = x[3]*h[0] + x[4]*h[1]
        .reg    B_prod52_63    ; = x[5]*h[2] + x[6]*h[3]
        .reg    B_sum1         ; = A_sum1
        .reg    B_sum2         ; = sum of prod and  sum2 >>15 for r[2]
        .reg    B_sum3         ; = sum of prod and  sum3 >>15 for r[3]

       ADD.1        -1,          A_nr,        A_j               ; nr + 3 - 4
       ADD.2        -4,          B_nh,        B_nh              ; nh - 4
       SHR.1        A_j,         2,           A_j               ; (nr+3)>>2 - 1
       SHR.1x       B_nh,        2,           A_i               ; nh>>2 - 1
       LDNDW.D1T1  *A_x_ptr,   A_x32:A_x10                    ; load x32:x10
       MV.2         B_h_ptr,     B_h_ptr1                       ; twin h ptr
       MV.1         A_x_ptr,     A_x_ptr1                       ; twin x ptr

       ZERO.1       A_sum0                                      ; Zero accum.
       ZERO.1       A_sum1                                      ; for 0th
       ZERO.2       B_sum2                                      ; - 3rd out-
       ZERO.2       B_sum3                                      ; puts

       .mptr        A_r_ptr1,     x,            8
       .mptr        A_x_ptr1,     x,            8
       .mptr        B_h_ptr,      x,            8
       .mptr        A_x_ptr,      x,            8

iloop: .trip    2

       LDNDW.D2T1  *B_h_ptr,      A_h32:A_h10                   ; load h32:h10
       LDNDW.D2T2  *B_h_ptr++,    B_h32:B_h10                   ; load h32:h10
       LDNDW.D1T2  *++A_x_ptr,    B_x76:B_x54                   ; load x76:x54

       PACKLH2.1    A_x32,        A_x10,        A_x21           ; input: x[2:1]
       PACKLH2.2x   B_x54,        A_x32,        B_x43           ; input: x[4:3]
       PACKLH2.2    B_x76,        B_x54,        B_x65           ; input: x[6:5]

       DOTP2.1      A_x10,        A_h10,        A_prod00_11     ; x0*h0 + x1*h1
       DOTP2.1      A_x32,        A_h32,        A_prod22_33     ; x2*h2 + x3*h3
       DOTP2.1      A_x32,        A_h10,        A_prod20_31     ; x2*h0 + x3*h1
       DOTP2.2x     B_x54,        A_h32,        B_prod42_53     ; x4*h2 + x5*h3
       DOTP2.1x     A_x21,        B_h10,        A_prod10_21     ; x1*h0 + x2*h1
       DOTP2.2      B_x43,        B_h32,        B_prod32_43     ; x3*h2 + x4*h3
       DOTP2.2      B_x43,        B_h10,        B_prod30_41     ; x3*h0 + x4*h1
       DOTP2.2      B_x65,        B_h32,        B_prod52_63     ; x5*h2 + x6*h3

       ADD.1        A_sum0,       A_prod00_11,  A_sum0          ; x0*h0 + x1*h1
       ADD.1        A_sum0,       A_prod22_33,  A_sum0          ; x2*h2 + x3*h3
       ADD.1x       A_sum1,       B_prod32_43,  A_sum1          ; x3*h2 + x4*h3
       ADD.2x       B_sum2,       A_prod20_31,  B_sum2          ; x2*h0 + x3*h1
       ADD.2        B_sum2,       B_prod42_53,  B_sum2          ; x4*h2 + x5*h3
       ADD.1        A_sum1,       A_prod10_21,  A_sum1          ; x1*h0 + x2*h1
       ADD.2        B_sum3,       B_prod52_63,  B_sum3          ; x5*h2 + x6*h3
       ADD.2        B_sum3,       B_prod30_41,  B_sum3          ; x3*h0 + x4*h1

       LDNDW.D1T1   *A_x_ptr,      A_x32:A_x10                   ; load x32:x10
 [ A_i]BDEC.1       iloop,        A_i                           ; brach iloop

; end of iloop

       SHR.1        A_sum0,       15,           A_sum0          ; sum0 >>15
       SHR.2x       A_sum1,       15,           B_sum1          ; sum1 >>15
       ADD.2        B_sum2,       B_sum2,       B_sum2          ; sum2 << 1
       ADD.2        B_sum3,       B_sum3,       B_sum3          ; sum3 << 1

       PACK2.2x     B_sum1,       A_sum0,       B_r10           ; r[1:0]
       PACKH2.2     B_sum3,       B_sum2,       B_r32           ; r[3:2]
       STNDW.D1T2   B_r32:B_r10,  *A_r_ptr++                    ; Store r32:r10

       LDNDW.D1T1   *++A_x_ptr1,  A_x32:A_x10                   ; Load x32:x10

       MV.2         B_h_ptr1,     B_h_ptr                       ; twin h ptr
       MV.1         A_x_ptr1,     A_x_ptr                       ; twin h ptr
       SHR.1x       B_nh,         2,            A_i             ; i_cnt

       ZERO.1       A_sum0                                      ; Reset acc.
       ZERO.1       A_sum1                                      ; for four
       ZERO.2       B_sum2                                      ; output
       ZERO.2       B_sum3                                      ; samples

 [ A_j]BDEC.1       iloop,        A_j                           ; Br.outer loop

; end of jloop

       .endproc                                                 ; End of proc.

* ========================================================================= *
*   End of file:  fir_r4_n.sa                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_r8.sa/      1066929506  0     0     0       16636     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Wed Jan 16 00:03:58 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r8: FIR Filter (radix 8)                                    *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Jun-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,  /* Input array [nr+nh-1 elements] */  *
*           const short *restrict h,  /* Coeff array [nh elements]      */  *
*           short       *restrict r,  /* Output array [nr elements]     */  *
*           int nh,                   /* Number of coefficients.        */  *
*           int nr                    /* Number of output samples.      */  *
*       )                                                                   *
*                                                                           *
*   ARGUMENTS PASSED                                                        *
*       *x    ->      A4                                                    *
*       *h    ->      B4                                                    *
*       *r    ->      A6                                                    *
*       nh    ->      B6                                                    *
*       nr    ->      A8                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients         *
*       stored in vector h.  The real data input is stored in vector x.     *
*       The filter output result is stored in vector r.  Input data and     *
*       filter taps are 16-bit, with intermediate values kept at 32-bit     *
*       precision.  Filter taps are expected in Q15 format.                 *
*                                                                           *
*       The following is a natural C implementation with no restrictions.   *
*       This version has restrictions as noted in the ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Number of taps:    'nh' >= 8, multiple of 8                         *
*       Number of samples: 'nr' >= 4, multiple of 4                         *
*       Array 'r' is word aligned.                                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double word instruction is used to simultaneously load     *
*           four values in a single clock cycle.                            *
*                                                                           *
*       2.  The inner loop is unrolled four times and will always           *
*           compute a multiple of 4 of nr.                                  *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"

        .sect ".text:_fir_r8"
        .global _DSP_fir_r8
_DSP_fir_r8: .cproc A_x_ptr, B_h_ptr, A_r_ptr, B_nh, A_nr ;arg_list

        .no_mdep
        .reg    A_i             ; inner loop flag;when = 0,branch to iloop
        .reg    B_i, B_i2       ; inner loop flag;when = 0,branch to iloop
        .reg    A_x0_ptr        ; input array pointer that init. point to x[0]
        .reg    A_h32:A_h10     ; coef: h[3:2],h[1:0]
        .reg    A_h76:A_h54     ; coef: h[7:6],h[5:4]
        .reg    A_x76:A_x54     ; input: x[7:6],x[5:4]
        .reg    A_prod0_10      ; = x[1]*h[1] + x[0]*h[0]
        .reg    A_prod0_32      ; = x[3]*h[3] + x[2]*h[2]
        .reg    A_prod0_54      ; = x[5]*h[5] + x[4]*h[4]
        .reg    A_prod0_76      ; = x[7]*h[7] + x[6]*h[6]
        .reg    A_prod2_10      ; = x[3]*h[1] + x[2]*h[0]
        .reg    A_prod2_32      ; = x[5]*h[3] + x[4]*h[2]
        .reg    A_prod2_54      ; = x[7]*h[5] + x[6]*h[4]
        .reg    A_prod2_76      ; = x[9]*h[7] + x[8]*h[6]
        .reg    A_sum2:A_sum0   ; sum2, sum0
        .reg    A_r10           ; output: r[1:0]
        .reg    A_r0            ; output: r[0]
        .reg    A_r1            ; output: r[1]
        .reg    A_r2            ; output: r[2]
        .reg    B_j             ; outer loop count
        .reg    B_h0_ptr        ; coef array pointer that always point to h[0]
        .reg    B_r32           ; output: r[3:2]
        .reg    B_r3            ; output: r[3]
        .reg    B_h21:B_h0X     ; coef: h[2:1],h[0:-1]
        .reg    B_h65:B_h43     ; coef: h[6:5],h[4:3]
        .reg    B_x32:B_x10     ; input: x[3:2],x[1:0]
        .reg    B_xba:B_x98     ; input: x[11:10],x[9:8]
        .reg    B_x18           ; input: x[1:8]
        .reg    B_x3a           ; input: x[3:10]
        .reg    B_h07           ; input: h[0:7]
        .reg    B_prod1_21      ; = x[3]*h[2] + x[2]*h[1]
        .reg    B_prod1_43      ; = x[5]*h[4] + x[4]*h[3]
        .reg    B_prod1_65      ; = x[7]*h[6] + x[6]*h[5]
        .reg    B_prod1_07      ; = x[1]*h[0] + x[8]*h[7]
        .reg    B_prod3_21      ; = x[5]*h[2] + x[4]*h[1]
        .reg    B_prod3_43      ; = x[7]*h[4] + x[6]*h[3]
        .reg    B_prod3_65      ; = x[9]*h[6] + x[8]*h[5]
        .reg    B_prod3_07      ; = x[3]*h[0] + x[a]*h[7]
        .reg    B_sum3:B_sum1   ; sum3, sum1
        .reg    B_r_ptr         ; twin reg for r_ptr


       MV.2        B_h_ptr,        B_h0_ptr                   ; B_h0_ptr-> h[0]
       MV.1        A_x_ptr,        A_x0_ptr                   ; A_x0_ptr-> x[0]
       ADD.1       3,              A_nr,          A_nr        ; nr + 3
       SHR.2x      A_nr,           2,             B_j         ; (nr+3)/4
       MPY.2       B_j,            B_nh,          B_j         ; (nr+3)/4*nh
       SHR.2       B_j,            3,             B_j         ; (nr+3)/4*nh/8
       SUB.2       B_j,            1,             B_j         ; (nr+3)/4*nh/8-1
       MV.1x       B_nh,           A_i                        ; nh
       ADD.2x      A_r_ptr,        4,             B_r_ptr     ; A_rptr -> r[0]
                                                              ; B_rptr -> r[2]
       ZERO.1      A_sum2:A_sum0                              ; clear sum2, 0
       ZERO.2      B_sum3:B_sum1                              ; clear sum3, 1

       .mptr       A_x_ptr,         x + 0,        16
       .mptr       B_h_ptr,         h + 0,        16
       .mptr       A_r_ptr,         r + 0,        0
       .mptr       B_r_ptr,         r + 4,        0

jloop: .trip         2

       LDNDW.D1T2  *A_x_ptr++,      B_x32:B_x10               ; load x32:x10
       LDNDW.D1T1  *A_x_ptr++,      A_x76:A_x54               ; load x76:x54
       LDNDW.D1T2  *A_x_ptr,        B_xba:B_x98               ; load xBA:x98

       LDNDW.D2T1  *B_h_ptr++,      A_h32:A_h10               ; load h32:h10
       LDNDW.D2T2  *-B_h_ptr(10),   B_h21:B_h0X               ; load h21:h0X
       LDNDW.D2T1  *B_h_ptr++,      A_h76:A_h54               ; load h76:h54
       LDNDW.D2T2  *-B_h_ptr(10),   B_h65:B_h43               ; load  h65:h43

       PACKH2.2x   B_h0X,           A_h76,        B_h07       ; coef: h[0:7]
       PACKHL2.2   B_x32,           B_xba,        B_x3a       ; input: x[3:10]
       PACKHL2.2   B_x10,           B_x98,        B_x18       ; input: x[1:8]

       DOTP2.1x    B_x10,           A_h10,        A_prod0_10  ; x1*h1 + x0*h0
       DOTP2.1x    B_x32,           A_h32,        A_prod0_32  ; x3*h3 + x2*h2
       DOTP2.1     A_x54,           A_h54,        A_prod0_54  ; x5*h5 + x4*h4
       DOTP2.1     A_x76,           A_h76,        A_prod0_76  ; x7*h7 + x6*h6
       ADD.1       A_sum0,          A_prod0_10,   A_sum0      ; += A_prod0_10
       ADD.1       A_sum0,          A_prod0_32,   A_sum0      ; += A_prod0_32
       ADD.1       A_sum0,          A_prod0_54,   A_sum0      ; += A_prod0_54
       ADD.1       A_sum0,          A_prod0_76,   A_sum0      ; += A_prod0_76

       DOTP2.2     B_x32,           B_h21,        B_prod1_21  ; x3*h2 + x2*h1
       DOTP2.2x    A_x54,           B_h43,        B_prod1_43  ; x5*h4 + x4*h3
       DOTP2.2x    A_x76,           B_h65,        B_prod1_65  ; x7*h6 + x6*h5
       DOTP2.2     B_x18,           B_h07,        B_prod1_07  ; x1*h0 + x8*h7
       ADD.2       B_sum1,          B_prod1_21,   B_sum1      ; += B_prod1_21
       ADD.2       B_sum1,          B_prod1_43,   B_sum1      ; += B_prod1_43
       ADD.2       B_sum1,          B_prod1_65,   B_sum1      ; += B_prod1_65
       ADD.2       B_sum1,          B_prod1_07,   B_sum1      ; += B_prod1_07

       DOTP2.1x    B_x32,           A_h10,        A_prod2_10  ; x3*h1 + x2*h0
       DOTP2.1     A_x54,           A_h32,        A_prod2_32  ; x5*h3 + x4*h2
       DOTP2.1     A_x76,           A_h54,        A_prod2_54  ; x7*h5 + x6*h4
       DOTP2.1x    B_x98,           A_h76,        A_prod2_76  ; x9*h7 + x8*h6
       ADD.1       A_sum2,          A_prod2_10,   A_sum2      ; += A_prod2_10
       ADD.1       A_sum2,          A_prod2_32,   A_sum2      ; += A_prod2_32
       ADD.1       A_sum2,          A_prod2_54,   A_sum2      ; += A_prod2_54
       ADD.1       A_sum2,          A_prod2_76,   A_sum2      ; += A_prod2_76

       DOTP2.2x    A_x54,           B_h21,        B_prod3_21  ; x5*h2 + x4*h1
       DOTP2.2x    A_x76,           B_h43,        B_prod3_43  ; x7*h4 + x6*h3
       DOTP2.2     B_x98,           B_h65,        B_prod3_65  ; x9*h6 + x8*h5
       DOTP2.2     B_x3a,           B_h07,        B_prod3_07  ; x3*h0 + xA*h7
       ADD.2       B_sum3,          B_prod3_21,   B_sum3      ; += B_prod3_21
       ADD.2       B_sum3,          B_prod3_43,   B_sum3      ; += B_prod3_43
       ADD.2       B_sum3,          B_prod3_65,   B_sum3      ; += B_prod3_65
       ADD.2       B_sum3,          B_prod3_07,   B_sum3      ; += B_prod3_07

       SUB.2x      A_i,             8,            B_i         ; Copy
       SUB.1       A_i,             8,            A_i         ; i_cnt -=8
       SHR.1       A_sum0,          15,           A_r0        ; sum0 >>15
       SHR.1x      B_sum1,          15,           A_r1        ; sum1 >>15
       SHR.1       A_sum2,          15,           A_r2        ; sum2 >>15
       SHR.2       B_sum3,          15,           B_r3        ; sum3 >>15
       PACK2.1     A_r1,            A_r0,         A_r10       ; r[1:0]
       PACK2.2x    B_r3,            A_r2,         B_r32       ; r[3:2]

 [!A_i] MV.2       B_h0_ptr,        B_h_ptr                   ; reset h ptr
 [!A_i] ADD.1      A_x0_ptr,        8,            A_x_ptr     ; reset x ptr
 [!A_i] ADD.1      A_x0_ptr,        8,            A_x0_ptr    ; update x0_ptr
 [!A_i] MV.1x      B_nh,            A_i                       ; reset i_cnt

 [!B_i] ZERO.1     A_sum2:A_sum0                              ; clear sum0
 [!B_i] ZERO.2     B_sum3:B_sum1                              ; clear sum1
 [!B_i] STW.D1T1   A_r10,           *A_r_ptr++[2]             ; output r[1:0]
 [!B_i] STW.D2T2   B_r32,           *B_r_ptr++[2]             ; output r[3:2]

        BDEC.2     jloop,            B_j                      ; out. loop br.

; end of jloop

       .endproc

* ========================================================================= *
*   End of file:  fir_r8_n.sa                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fir_sym.sa/     1066929506  0     0     0       25519     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Tue Mar 12 01:06:06 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_sym -- Symmetric FIR                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Mar-2002                                                         *
*                                                                           *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and may be called as follows:          *
*                                                                           *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           const short * x,      /* Input samples                   */     *
*           const short * h ,     /* Filter taps                     */     *
*           short * restrict r,   /* Output samples                  */     *
*           int nh,               /* Number of symmetric filter taps */     *
*           int nr,               /* Number of output samples        */     *
*           int s                 /* Final output shift.             */     *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function applies a symmetric filter to the input samples.      *
*       The filter tap array h[] provides 'nh + 1' total filter taps.       *
*       The filter tap at h[nh] forms the center point of the filter.       *
*       The taps at h[nh - 1] through h[0] form a symmetric filter          *
*       about this central tap.  The effective filter length is thus        *
*       2*nh + 1 taps.                                                      *
*                                                                           *
*       The filter is performed on 16-bit data with 16-bit coefficients,    *
*       accumulating intermediate results to 40-bit precision.  The         *
*       accumulator is rounded and truncated according to the value         *
*       provided in 's'.  This allows a variety of Q-points to be used.     *
*                                                                           *
*       Note that samples are added together before multiplication, and     *
*       so overflow *may* result for large-scale values, despite the        *
*       40-bit accumulation.                                                *
*                                                                           *
*   C CODE                                                                  *
*       Below is a C code implementation without restrictions.  The         *
*       optimized implementations have restrictions, as noted under         *
*       "ASSUMPTIONS" and "MEMORY NOTE" below.                              *
*                                                                           *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           const short * x,      /* Input samples                   */     *
*           const short * h ,     /* Filter taps                     */     *
*           short * restrict r,   /* Output samples                  */     *
*           int nh,               /* Number of symmetric filter taps */     *
*           int nr,               /* Number of output samples        */     *
*           int s                 /* Final output shift.             */     *
*       )                                                                   *
*       {                                                                   *
*           int  i, j;                                                      *
*           long y0, round = (long) 1 << (s - 1);                           *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               y0 = round;                                                 *
*                                                                           *
*               for (i = 0; i < nh; i++)                                    *
*                   y0 += ((short) (x[j + i] + x[j + 2 * nh - i])) * h[i];  *
*                                                                           *
*               y0 += x[j + nh] * h[nh];                                    *
*                                                                           *
*               r[j] = (int) (y0 >> s);                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The optimized versions of this kernel may assume that nr is         *
*       a multiple of 4 and nh is a multiple of 8.                          *
*                                                                           *
*   MEMORY NOTE.                                                            *
*       The code assumes that 'x' and 'h' are double-word aligned, and      *
*       that 'r' is word alignend.                                          *
*                                                                           *
*       The code expects the device to be in LITTLE ENDIAN mode.            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_fir_sym"
        .global _DSP_fir_sym
_DSP_fir_sym: .cproc  A_xf_ptr, B_h_ptr, A_r_ptr, B_nh, A_nr, B_s
        .no_mdep
        .reg            A_round     ; round = 1 << (s - 1)
        .reg            A_i         ; inner loop count
        .reg            A_s         ; = s
        .reg            A_h_ptr     ; coeff pointer
        .reg            A_nhi       ; initial inner loop count
        .reg            A_h_offset  ; offset to h[0]
        .reg            A_nr3       ; = nr + 3
        .reg            A_r_ptr1    ; output pointer
        .reg            A_xf_offset ; offset to x[4*i]
        .reg            A_h_32:A_h_10; = h[3,2], h[1,0]
        .reg            A_h_76:A_h_54; = h[7,6], h[5,4]
        .reg            A_xf32:A_xf10; = x[3,2], x[1,0]
        .reg            A_xr45:A_xr67; = x[nh*2-1,nh*2-2], x[nh*2-3,nh*2-4]
        .reg            A_xr89:A_xrAB; = x[nh*2-5,nh*2-6], x[nh*2-7,nh*2-8]
        .reg            A_xr43      ; = x[nh*2-1,nh*2]
        .reg            A_xr65      ; = x[nh*2-3,nh*2-2]
        .reg            A_xr87      ; = x[nh*2-5,nh*2-4]
        .reg            A_xrA9      ; = x[nh*2-7,nh*2-6]
        .reg            A_xs0_10    ; point 0: xs2_3:xs2_2
        .reg            A_xs0_32    ; point 0: xs0_3:xs0_2
        .reg            A_xs0_54    ; point 0: xs0_5:xs0_4
        .reg            A_xs0_76    ; point 0: xs0_7:xs0_6
        .reg            A_xs2_10    ; point 2: xs2_3:xs2_2
        .reg            A_xs2_32    ; (xf5+xr4)<<16 | (xf4+xr3) for r[2]
        .reg            A_xs2_54    ; (xf5+xr4)<<16 | (xf4+xr3) for r[2]
        .reg            A_xs2_76    ; point 2: xs2_7:xs2_6
        .reg            A_y0_32     ; = xs0_32 * h32 for r[0]
        .reg            A_y0_54     ; = xs0_54 * h54 for r[0]
        .reg            A_y0_76     ; = xs0_76 * h76 for r[0]
        .reg            A_y2_10     ; = xs2_10 * h10 for r[2]
        .reg            A_y2_32     ; = xs2_32 * h32 for r[2]
        .reg            A_y2_54     ; = xs2_54 * h54 for r[2]
        .reg            A_y2_76     ; = xs2_76 * h76 for r[2]
        .reg            A_y1_8:A_y0_8; = x[nh+1]*h[nh] | x[nh]*h[nh]
        .reg            A_y2_8      ; = x[nh+2]*h[nh] for r[2]
        .reg            A_r32       ; = r[3,2]
        .reg            A_y0_10     ; = xs0_10 * h10 for r[0]
        .reg            A_y0h:A_y0l ; = y0
        .reg            A_y2h:A_y2l ; = y2
        .reg            A_y3l       ; = y3 (lower reg)

        .reg    A_h32:A_h10; coef: h[3:2],h[1:0]

        .reg            B_round     ; round = 1 << (s - 1)
        .reg            B_one       ; B_one = 1
        .reg            B_p         ; flag for add = 1
        .reg            B_j         ; output loop count
        .reg            B_nh1       ; B_nh1 = B_nh >>1
        .reg            B_r_ptr     ; output pointer
        .reg            B_s1        ; = s - 1
        .reg            B_y1_8      ; = x[nh+1]*h[nh] for r[1]
        .reg            B_y0l       ; = y0 (lower reg)
        .reg            B_nh2       ; = nh/4
        .reg            B_h_nh32:B_h_nh10    ; = h[nh]>>16 | h[nh]
        .reg            B_xr_ptr    ; input reverse pointer
        .reg            B_xf_ptr    ; input forword pointer
        .reg            B_xr_offset ; offset to x[nh*2+4]
        .reg            B_xf_offset ; offset to x[4*i]
        .reg            B_r10       ; r[1,0]
        .reg            B_h_07      ; = h[0,7]
        .reg            B_ss        ; = s
        .reg            B_xr07      ; = x[nh*2+3,nh*2-4]
        .reg            B_xr21      ; = x[nh*2+1,nh*2+2]
        .reg            B_xr29      ; = x[nh*2+1,nh*2-6]
        .reg            B_xf3A      ; = x[9,8]
        .reg            B_xf18      ; = x[1,8]
        .reg            B_h_21:B_h_0X; = h[2,1], h[0,-1]
        .reg            B_h_65:B_h_43; = x[6,5], h[4,3]
        .reg            B_xf32:B_xf10; = x[3,2], x[1,0]
        .reg            B_xf76:B_xf54; = x[9,8], x[9,8]
        .reg            B_xfBA:B_xf98; = x[11,10], x[9,8]
        .reg            B_xr01:B_xr23; = x[nh*2+3,nh*2+2], x[nh*2+1,nh*2]
        .reg            B_xs1_07    ; point 1: xs1_0:xs1_7
        .reg            B_xs1_21    ; point 1: xs1_2:xs1_1
        .reg            B_xs1_43    ; point 1: xs1_4:xs1_3
        .reg            B_xs1_65    ; point 1: xs1_6:xs1_5
        .reg            B_xs3_07    ; point 3: xs3_0:xs3_7
        .reg            B_xs3_21    ; point 3: xs3_2:xs3_1
        .reg            B_xs3_43    ; point 3: xs3_4:xs3_3
        .reg            B_xs3_65    ; point 3: xs3_6:xs3_5
        .reg            B_y1_07     ; = xs1_07 * h07 for r[1]
        .reg            B_y1_21     ; = xs1_21 * h21 for r[1]
        .reg            B_y1_43     ; = xs1_43 * h43 for r[1]
        .reg            B_y1_65     ; = xs1_65 * h65 for r[1]
        .reg            B_y3_07     ; = xs3_07 * h07 for r[3]
        .reg            B_y3_21     ; = xs3_21 * h21 for r[3]
        .reg            B_y3_43     ; = xs3_43 * h43 for r[3]
        .reg            B_y3_65     ; = xs3_65 * h65 for r[3]
        .reg            B_y3_8:B_y2_8; = x[nh+3]*h[nh] | x[nh+2]*h[nh]
        .reg            B_y1h:B_y1l ; = y1
        .reg            B_y3h:B_y3l ; = y3

        SUB.2     B_s,           1,           B_s1          ; = s - 1
        MVK.2     1,             B_one                      ; B_one (B_p) = 1
        SHL.2     B_one,         B_s1,        B_y1h:B_y1l   ; 1 << (s - 1)
        ADD.1X    B_s1,          1,           A_s           ; = s

        LDH.D2T2  *B_h_ptr[B_nh],B_h_nh10                   ; h[nh]
        PACK2.2   B_h_nh10,      B_h_nh10,    B_h_nh32      ; h[nh]<<16 | h[nh]
        PACK2.2   B_h_nh10,      B_h_nh10,    B_h_nh10      ; h[nh]<<16 | h[nh]
        SHR.2     B_nh,          2,           B_nh2         ; B_nh/4

        SHR.2     B_nh,        3,              A_nhi        ; init. inner lp cnt
        SUB.1     A_nhi,       2,              A_i          ; set inner lp cnt
        ADD.1     A_nr,        3,              A_nr3        ; nr+3
        SHR.2x    A_nr3,       2,              B_j          ; outer loop count
        SUB.2     B_j,         2,              B_j          ; decrement outer lp

        MVD.2     B_y1l,       B_round                      ; store round value
        MV.1x     B_y1l,       A_y0l                        ; round
        MVD.1     A_y0l,       A_round                      ;  round
        MPY.1     A_y0h,       0,              A_y0h        ; Initialize B_y1h
        MV.2      B_y1h:B_y1l, B_y3h:B_y3l                  ; y3 = round
        MV.1      A_y0h:A_y0l, A_y2h:A_y2l                  ; y2 = round

        MV.2x     A_xf_ptr,    B_xr_ptr                     ; B_xr_ptr = &x[0]
        ADDAW.2   B_xr_ptr,    B_nh,           B_xr_ptr     ; B_xr_ptr -> x[nh*2]
        ADD.2x    A_xf_ptr,    8,              B_xf_ptr     ; B_xf_ptr = &x[4]
        ADD.2     B_nh2,       1,              B_xr_offset  ; = nh/4 + 1
        MPY.1x    8,           B_nh2,          A_h_offset   ; = 2*nh bytes
        MV.1x     B_h_ptr,     A_h_ptr                      ; A_h_ptr = &h[0]
        MV.2x     A_r_ptr,     B_r_ptr                      ; output twin reg

;=============================== PIPE LOOP KERNEL ==============================
            ; point 0:   add xs0_0 = xf0 + xr3
            ;            add xs0_1 = xf1 + xr4
            ;            add xs0_2 = xf2 + xr5
            ;            add xs0_3 = xf3 + xr6
            ;            add xs0_4 = xf4 + xr7
            ;            add xs0_5 = xf5 + xr8
            ;            add xs0_6 = xf6 + xr9
            ;            add xs0_7 = xf7 + xrA

            ; point 1:   add xs1_0 = xf1 + xr2
            ;            add xs1_1 = xf2 + xr3
            ;            add xs1_2 = xf3 + xr4
            ;            add xs1_3 = xf4 + xr5
            ;            add xs1_4 = xf5 + xr6
            ;            add xs1_5 = xf6 + xr7
            ;            add xs1_6 = xf7 + xr8
            ;            add xs1_7 = xf8 + xr9

            ; point 2:   add xs2_0 = xf2 + xr1
            ;            add xs2_1 = xf3 + xr2
            ;            add xs2_2 = xf4 + xr3
            ;            add xs2_3 = xf5 + xr4
            ;            add xs2_4 = xf6 + xr5
            ;            add xs2_5 = xf7 + xr6
            ;            add xs2_6 = xf8 + xr7
            ;            add xs2_7 = xf9 + xr8

            ; point 3:   add xs3_0 = xf3 + xr0
            ;            add xs3_1 = xf4 + xr1
            ;            add xs3_2 = xf5 + xr2
            ;            add xs3_3 = xf6 + xr3
            ;            add xs3_4 = xf7 + xr4
            ;            add xs3_5 = xf8 + xr5
            ;            add xs3_6 = xf9 + xr6
            ;            add xs3_7 = xfA + xr7

        .mptr         B_xr_ptr,   x+0, -16
        .mptr         A_xf_ptr,   x+0, 16
        .mptr         B_xf_ptr,   x+1, 16
        .mptr         A_h_ptr,    x+0, 16
iloop:
        LDDW.D2T2    *B_xr_ptr--,    B_xr01:B_xr23               ;
        LDDW.D2T1    *B_xr_ptr--,    A_xr45:A_xr67               ;
        LDDW.D2T1    *B_xr_ptr,      A_xr89:A_xrAB               ;
        LDDW.D1T2    *A_xf_ptr,      B_xf32:B_xf10               ;
        LDDW.D1T1    *A_xf_ptr++[2], A_xf32:A_xf10               ;
        LDDW.D2T2    *B_xf_ptr++[2], B_xf76:B_xf54               ;
        LDDW.D1T2    *A_xf_ptr,      B_xfBA:B_xf98               ;
        LDDW.D1T1    *A_h_ptr++,     A_h_32:A_h_10               ;
        LDNDW.D1T2   *-A_h_ptr(10),  B_h_21:B_h_0X               ;
        LDDW.D1T1    *A_h_ptr++,     A_h_76:A_h_54               ;
        LDNDW.D1T2   *-A_h_ptr(10),  B_h_65:B_h_43               ;

        PACKHL2.2x   B_xr01,         A_xr67,        B_xr07       ;
        PACKHL2.2x   B_xr23,         A_xr89,        B_xr29       ;
        PACKHL2.1x   A_xr45,         B_xr23,        A_xr43       ;
        PACKHL2.1    A_xr67,         A_xr45,        A_xr65       ;
        PACKHL2.1    A_xr89,         A_xr67,        A_xr87       ;
        PACKHL2.1    A_xrAB,         A_xr89,        A_xrA9       ;
        PACKHL2.2    B_xr23,         B_xr01,        B_xr21       ;
        PACKHL2.2    B_xf10,         B_xf98,        B_xf18       ;
        PACKHL2.2    B_xf32,         B_xfBA,        B_xf3A       ;
        PACKH2.2x    B_h_0X,         A_h_76,        B_h_07       ;

        ADD2.1       A_xf10,         A_xr43,        A_xs0_10     ;
        ADD2.1       A_xf32,         A_xr65,        A_xs0_32     ;
        ADD2.2x      B_xf54,         A_xr87,        A_xs0_54     ;
        ADD2.1x      B_xf76,         A_xrA9,        A_xs0_76     ;
        ADD2.2       B_xf18,         B_xr29,        B_xs1_07     ;
        ADD2.2x      B_xf32,         A_xr43,        B_xs1_21     ;
        ADD2.2x      B_xf54,         A_xr65,        B_xs1_43     ;
        ADD2.2x      B_xf76,         A_xr87,        B_xs1_65     ;
        ADD2.1x      A_xf32,         B_xr21,        A_xs2_10     ;
        ADD2.1x      B_xf54,         A_xr43,        A_xs2_32     ;
        ADD2.1x      B_xf76,         A_xr65,        A_xs2_54     ;
        ADD2.1x      B_xf98,         A_xr87,        A_xs2_76     ;
        ADD2.2       B_xf3A,         B_xr07,        B_xs3_07     ;
        ADD2.2       B_xf54,         B_xr21,        B_xs3_21     ;
        ADD2.2x      B_xf76,         A_xr43,        B_xs3_43     ;
        ADD2.2x      B_xf98,         A_xr65,        B_xs3_65     ;

        DOTP2.1      A_xs0_10,       A_h_10,        A_y0_10      ;xs01*h1+xs00*h0
        DOTP2.1      A_xs0_32,       A_h_32,        A_y0_32      ;xs03*h3+xs02*h2
        DOTP2.1      A_xs0_54,       A_h_54,        A_y0_54      ;xs05*h5+xs04*h4
        DOTP2.1      A_xs0_76,       A_h_76,        A_y0_76      ;xs07*h7+xs06*h6
        DOTP2.2      B_xs1_07,       B_h_07,        B_y1_07      ;xs10*h0+xs17*h7
        DOTP2.2      B_xs1_21,       B_h_21,        B_y1_21      ;xs12*h2+xs11*h1
        DOTP2.2      B_xs1_43,       B_h_43,        B_y1_43      ;xs14*h4+xs13*h3
        DOTP2.2      B_xs1_65,       B_h_65,        B_y1_65      ;xs16*h6+xs15*h5
        DOTP2.1      A_xs2_10,       A_h_10,        A_y2_10      ;xs21*h1+xs20*h0
        DOTP2.1      A_xs2_32,       A_h_32,        A_y2_32      ;xs23*h3+xs22*h2
        DOTP2.1      A_xs2_54,       A_h_54,        A_y2_54      ;xs25*h5+xs24*h4
        DOTP2.1      A_xs2_76,       A_h_76,        A_y2_76      ;xs27*h7+xs26*h6
        DOTP2.2      B_xs3_07,       B_h_07,        B_y3_07      ;xs30*h0+xs37*h7
        DOTP2.2      B_xs3_21,       B_h_21,        B_y3_21      ;xs32*h2+xs31*h1
        DOTP2.2      B_xs3_43,       B_h_43,        B_y3_43      ;xs34*h4 + xs33*h3
        DOTP2.2      B_xs3_65,       B_h_65,        B_y3_65      ;xs36*h6 + xs35*h5

        ADD.1     A_y0_10,      A_y0h:A_y0l,   A_y0h:A_y0l    ;
        ADD.1     A_y0_32,      A_y0h:A_y0l,   A_y0h:A_y0l    ;
        ADD.1     A_y0_54,      A_y0h:A_y0l,   A_y0h:A_y0l    ;
        ADD.1     A_y0_76,      A_y0h:A_y0l,   A_y0h:A_y0l    ;
        ADD.2     B_y1_07,      B_y1h:B_y1l,   B_y1h:B_y1l    ;
        ADD.2     B_y1_21,      B_y1h:B_y1l,   B_y1h:B_y1l    ;
        ADD.2     B_y1_43,      B_y1h:B_y1l,   B_y1h:B_y1l    ;
        ADD.2     B_y1_65,      B_y1h:B_y1l,   B_y1h:B_y1l    ;
        ADD.1     A_y2_10,      A_y2h:A_y2l,   A_y2h:A_y2l    ;
        ADD.1     A_y2_32,      A_y2h:A_y2l,   A_y2h:A_y2l    ;
        ADD.1     A_y2_54,      A_y2h:A_y2l,   A_y2h:A_y2l    ;
        ADD.1     A_y2_76,      A_y2h:A_y2l,   A_y2h:A_y2l    ;
        ADD.2     B_y3_21,      B_y3h:B_y3l,   B_y3h:B_y3l    ;
        ADD.2     B_y3_43,      B_y3h:B_y3l,   B_y3h:B_y3l    ;
        ADD.2     B_y3_65,      B_y3h:B_y3l,   B_y3h:B_y3l    ;
        ADD.2     B_y3_07,      B_y3h:B_y3l,   B_y3h:B_y3l    ;

        BDEC.1    iloop,        A_i                           ;

;       end if iloop

        MV.2x     B_h_nh10,     A_h_10
        MPY2.2    B_xfBA,       B_h_nh32,      B_y3_8:B_y2_8  ;
        MPY2.1x   B_xf98,       A_h_10,        A_y1_8:A_y0_8  ;
        MV.1x     B_y2_8,       A_y2_8                        ;o
        MV.2x     A_y1_8,       B_y1_8                        ;o
        ADD.1     A_y0_8,       A_y0h:A_y0l,   A_y0h:A_y0l    ; last add for y0
        ADD.2     B_y1_8,       B_y1h:B_y1l,   B_y1h:B_y1l    ; last add for y1
        ADD.1     A_y2_8,       A_y2h:A_y2l,   A_y2h:A_y2l    ; last add for y2
        ADD.2     B_y3_8,       B_y3h:B_y3l,   B_y3h:B_y3l    ;o last add for y3
        MV.2x     A_s,          B_ss                          ; twin reg for s
        SHR.1     A_y0h:A_y0l,  A_s,           A_y0h:A_y0l    ; = y0 >> s
        SHR.2     B_y1h:B_y1l,  B_ss,          B_y1h:B_y1l    ; = y1 >> s
        SHR.1     A_y2h:A_y2l,  A_s,           A_y2h:A_y2l    ; = y2 >> s
        SHR.2     B_y3h:B_y3l,  B_ss,          B_y3h:B_y3l    ; = y3 >> s
        MV.2x     A_y0l,        B_y0l
        MV.1x     B_y3l,        A_y3l
        PACK2.2   B_y1l,        B_y0l,         B_r10          ; r[1,0]
        PACK2.1   A_y3l,        A_y2l,         A_r32          ; r[3,2]
        MV.1x     B_r_ptr,      A_r_ptr1
        STW.D2T2  B_r10,        *B_r_ptr++[2]                 ; store r[1,0]
        STW.D1T1  A_r32,        *+A_r_ptr1[1]                 ; store r[3,2]

        ADDAD.2   B_xr_ptr,     B_xr_offset,   B_xr_ptr       ;+=nh/4+1dblwords
        SUB.1     A_h_ptr,      A_h_offset,    A_h_ptr        ;+= nh*2 bytes
        SUB.1     A_xf_ptr,     A_h_offset,    A_xf_ptr       ;
        ADD.1     A_xf_ptr,     8,             A_xf_ptr       ;
        ADD.1     A_xf_ptr,     8,             B_xf_ptr       ;

        MVD.1     A_round,      A_y0l                         ; round
        MVD.2     B_round,      B_y3l                         ; round
        MPY.1     A_y0h,        0,             A_y0h          ; clear y0
        MPY.2     B_y3h,        0,             B_y3h          ; clear y3
        MV.1      A_y0h:A_y0l,  A_y2h:A_y2l                   ; y2 = round
        MV.2      B_y3h:B_y3l,  B_y1h:B_y1l                   ; y1 = round

        SUB.1     A_nhi,        2,             A_i            ; inner lp cnt
        BDEC.2    iloop,        B_j                           ;o

;       end of jloop

            .endproc


* ========================================================================= *
*   End of file:  dsp_fir_sym.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

firlms2.sa/     1066929506  0     0     0       10017     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Wed Mar 13 23:55:53 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ======================================================================== *
*  NAME                                                                    *
*      DSP_firlms2 -- Least Mean Square Adaptive Filter                    *
*                 Partitioned Serial Assembly Implementation               *
*                                                                          *
*  REVISION DATE                                                           *
*      13-Mar-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
*                                                                          *
*      This routine has the following C prototype:                         *
*                                                                          *
*          long DSP_firlms2                                                *
*          (                                                               *
*              short       *restrict h,  // Filter Coefficients            *
*              const short *restrict x,  // Input Data                     *
*              short                 b,  // Error from previous FIR        *
*              int                   nh  // Number of Coefficients         *
*          )                                                               *
*                                                                          *
*      The DSP_firlms2 routine accepts a list of 'nh' input data and 'nh'  *
*      adaptive filter coefficients and updates the coefficients by        *
*      adding weighted error times the inputs to the original              *
*      coefficients. This assumes single sample input followed by the      *
*      last nh-1 inputs and nh coefficients.                               *
*                                                                          *
*  DESCRIPTION                                                             *
*                                                                          *
*      The algorithm is simple and Natural C implementation is as follows: *
*                                                                          *
*          long DSP_firlms2                                                *
*          (                                                               *
*              short       *restrict h,  // Filter Coefficients            *
*              const short *restrict x,  // Input Data                     *
*              short                 b,  // Error from previous FIR        *
*              int                   nh  // Number of Coefficients         *
*          )                                                               *
*          {                                                               *
*              int  i;                                                     *
*              long r=0;                                                   *
*                                                                          *
*              for(i = 0; i < nh; i++)                                     *
*              {                                                           *
*                * Update the filter coefficients *                        *
*                                                                          *
*                  h[i] += (x[i] * b) >> 15;                               *
*                                                                          *
*                * Calculate the filter output    *                        *
*                                                                          *
*                  r    += x[i + 1] * h[i];                                *
*              }                                                           *
*              return r;                                                   *
*          }                                                               *
*                                                                          *
*  TECHNIQUES                                                              *
*                                                                          *
*      - The loop is unrolled 4 times                                      *
*      - MPY2, PACKH2 and ADD2 are used to update the filter coefficients  *
*      - DOTP2 is used to calculate filter output                          *
*                                                                          *
*  ASSUMPTIONS                                                             *
*                                                                          *
*      - Assumes 16-bit input data, error and filter coefficients.         *
*      - nh > = 4 and is a multiple of 4                                   *
*                                                                          *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ======================================================================== *


        .sect ".text:_firlms2"
        .global _DSP_firlms2
_DSP_firlms2 .cproc A_hadd, B_inadd, A_err, B_nh
            .no_mdep
            .reg    A_inadd, B_err, B_hadd            ; Copy on other side
            .reg    A_h32:A_h10                       ; Filter Coefficients
            .reg    B_x32:B_x10, A_x43:A_x21          ; Non-aligned data
            .reg    B_xb32H:B_xb32L, A_xb10H:A_xb10L  ; MPY2 results
            .reg    B_xb32, A_xb10                    ; Packed 16-bit result
            .reg    A_h1h0, B_h3h2:B_h1h0             ; Updated Filter Coeff
            .reg    A_r1_, B_r2_, A_temp              ; Temporary variables
            .reg    B_rH:B_rL, A_rH:A_rL              ; Accumulators

            SHR    .2      B_nh,          2,          B_nh
            MVK    .1      2,             A_temp
            PACK2  .1      A_err,         A_err,      A_err
            MV     .2x     A_hadd,        B_hadd
            SUB    .2      B_nh,          2,          B_nh
            MV     .2x     A_err,         B_err
            ADD    .1x     B_inadd,       A_temp,     A_inadd
            ZERO   .2      B_rH:B_rL
            ZERO   .1      A_rH:A_rL

loop:       .trip   8
            LDDW   .D1T1   *A_hadd++,     A_h32:A_h10
            LDNDW  .D2T2   *B_inadd++,    B_x32:B_x10
            LDNDW  .D1T1   *A_inadd++,    A_x43:A_x21

            SMPY2  .2      B_err,         B_x32,      B_xb32H:B_xb32L
            SMPY2  .1      A_err,         B_x10,      A_xb10H:A_xb10L

            PACKH2 .2      B_xb32H,       B_xb32L,    B_xb32
            PACKH2 .1      A_xb10H,       A_xb10L,    A_xb10

            ADD2   .2x     B_xb32,        A_h32,      B_h3h2
            ADD2   .1      A_xb10,        A_h10,      A_h1h0

            DOTP2  .1      A_x21,         A_h1h0,     A_r1_
            DOTP2  .2x     A_x43,         B_h3h2,     B_r2_

            ADD    .2      B_r2_,         B_rH:B_rL,  B_rH:B_rL
            ADD    .1      A_r1_,         A_rH:A_rL,  A_rH:A_rL
            MV     .2x     A_h1h0,        B_h1h0

            STDW   .D2T2   B_h3h2:B_h1h0, *B_hadd++

            BDEC   .S2     loop,          B_nh

            ADDU   .1x     B_rL,          A_rH:A_rL,  A_rH:A_rL
            ADD    .1x     B_rH,          A_rH,       A_rH

            .return        A_rH:A_rL

            .endproc

* ======================================================================== *
*   End of file:  dsp_firlms2.sa                                           *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ======================================================================== *

fltoq15.sa/     1066929506  0     0     0       10373     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Tue Mar 12 15:53:54 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_fltoq15                                                     *
*                                                                           *
*     REVISION DATE                                                         *
*         27-JUL-2001                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fltoq15(float x[], short r[], short nx)                    *
*                                                                           *
*       x[nx] : Pointer to values of type float                             *
*       r[nx] : Contains Q15 values from x[nx]                              *
*       nx    : Number of elements in arrays                                *
*                                                                           *
*   DESCRIPTION                                                             *
*       Convert the IEEE floating point numbers stored in vector x[] into   *
*       Q.15 format numbers stored in vector r[]. Results are truncated     *
*       towards zero. Values that exceed the size limit will be saturated   *
*       to 0x7fff if value is positive and 0x8000 if value is negative.     *
*       All values too small to be correctly represented will be truncated  *
*       to 0.                                                               *
*                                                                           *
*       The 16-bit Q.15 format is defined as follows:                       *
*                                                                           *
*           1 11111                                                         *
*           5 432109876543210                                               *
*           S.XXXXXXXXXXXXXXX                                               *
*                                                                           *
*           range: 1.000000000000000 = -1.0               <-> -32768        *
*                  0.111111111111111 =  0.999969482421875 <->  32767        *
*                                                                           *
*       IEEE floating point format is defined as follows:                   *
*                                                                           *
*           31 30....23  22.....0                                           *
*            S EXPONENT  MANTISSA                                           *
*                                                                           *
*       The value is obtained as: (-1)^S * 1.MANTISSA * 2^(EXPONENT-127)    *
*                                                                           *
*     C CODE                                                                *
*         void DSP_fltoq15(float x[], short r[], short nx)                  *
*         {                                                                 *
*             int i, a;                                                     *
*                                                                           *
*             for(i = 0; i < nx; i++)                                       *
*             {                                                             *
*                 a = 32768 * x[i];                                         *
*                                                                           *
*                 // saturate to 16-bit //                                  *
*                 if (a>32767)  a =  32767;                                 *
*                 if (a<-32768) a = -32768;                                 *
*                                                                           *
*                 r[i] = (short) a;                                         *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*     ASSUMPTIONS                                                           *
*         1.  nx >= 2                                                       *
*         2.  nx is a multiple of 2                                         *
*                                                                           *
*     NOTES                                                                 *
*         This implementation is ENDIAN NEUTRAL.                            *
*                                                                           *
*     TECHNIQUE                                                             *
*         Loop is unrolled twice.                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_fltoq15"
        .global _DSP_fltoq15
_DSP_fltoq15: .cproc A_x_ptr, B_r_ptr, A_nx 

        .no_mdep

        .reg    A_ma_mask, B_ma_mask, A_c31, B_c31, A_bit23, B_bit23
        .reg    A_offset, B_offset
        .reg    B_fl_val_1:B_fl_val, B_mant, B_exp, B_sign
        .reg    B_manti, B_shift, B_fract
        .reg    A_fl_val_1, A_mant_1, A_exp_1, A_sign_1, A_manti_1
        .reg    A_shift_1, A_fract_1, A_fracts_1

        .mptr   x_ptr, a, 8
        .mptr   r_ptr, b, 4

        SHR     .S1     A_nx,       1,        A_nx
        SUB     .D1     A_nx,       2,        A_nx

        MVKL    .S1     0x7FFFFF,   A_ma_mask
        MVKH    .S1     0x7FFFFF,   A_ma_mask
        MV      .L2X    A_ma_mask,  B_ma_mask

        MVK     .S2     31,         B_c31
        MV      .L1X    B_c31,      A_c31

        ZERO    .L1     A_bit23
        SET     .S1     A_bit23,    23, 23,   A_bit23
        MV      .L2X    A_bit23,    B_bit23

        MVK     .S2     135,        B_offset
        MV      .L1X    B_offset,   A_offset

loop:       .trip   1

; 1st iteration:
            LDNDW .D1T2 *A_x_ptr++,     B_fl_val_1:B_fl_val
            AND   .2    B_fl_val,       B_ma_mask,  B_mant
            EXTU  .2    B_fl_val,       1, 24,      B_exp
            SSHVR .2    B_fl_val,       B_c31,      B_sign
            ADD   .2    B_mant,         B_bit23,    B_manti
            SUB   .2    B_offset,       B_exp,      B_shift
            SSHVR .2    B_manti,        B_shift,    B_fract
 [B_sign]   NEG   .2    B_fract,        B_fract

; 2nd iteration:
            MV    .1    B_fl_val_1,     A_fl_val_1
            AND   .1    A_fl_val_1,     A_ma_mask,  A_mant_1
            EXTU  .1    A_fl_val_1,     1, 24,      A_exp_1
            SSHVR .1    A_fl_val_1,     A_c31,      A_sign_1
            ADD   .1    A_mant_1,       A_bit23,    A_manti_1
            SUB   .1    A_offset,       A_exp_1,    A_shift_1
            SSHVR .1    A_manti_1,      A_shift_1,  A_fract_1
 [A_sign_1] NEG   .1    A_fract_1,      A_fract_1

            SPACK2.1    A_fract_1,      B_fract,    A_fracts_1
            STW   .D2T1 A_fracts_1,     *B_r_ptr++

            BDEC  .1    loop,           A_nx

        .endproc

* ========================================================================= *
*   End of file:  dsp_fltoq15.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

ifft16x32.sa/   1066929506  0     0     0       53468     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 18:03:36 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_ifft16x32                                                  *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_ifft16x32(const short * ptr_w, int  npoints,           *
*                            int   * ptr_x, int *ptr_y ) ;                  *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*       In reality one can re-use fft16x32 to perform IFFT, by first        *
*       conjugating the input, performing the FFT, conjugating again.       *
*       This allows fft16x32 to perform the IFFT as well. However if        *
*       the double conjugation needs to be avoided then this routine        *
*       uses the same twiddle factors as the FFT and performs an IFFT.      *
*       The change in the sign of the twiddle factors is adjusted for       *
*       software. Hence this routine uses the same twiddle factors as       *
*       the FFT routine.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix IFFT for "npoints" which  *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*         int i, j, k, n = N;                                               *
*         double theta1, theta2, theta3, x_t, y_t;                          *
*         const double M = 32768.0, PI = 3.141592654;                       *
*                                                                           *
*         for (j=1, k=0; j < n>>2; j = j<<2)                                *
*         {                                                                 *
*             for (i=0; i < n>>2; i += j<<1)                                *
*             {                                                             *
*                 theta1 = 2*PI*i/n;                                        *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+1] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+1] = 0x7fff;                            *
*                 w[k+0] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+0] = 0x7fff;                            *
*                                                                           *
*                 theta1 = 2*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+7] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+3] = 0x7fff;                            *
*                 w[k+6] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+2] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*i/n;                                        *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+3] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+5] = 0x7fff;                            *
*                 w[k+2] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+4] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+9] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+7] = 0x7fff;                            *
*                 w[k+8] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+6] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*i/n;                                        *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+5] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+9] = 0x7fff;                            *
*                 w[k+4] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+8] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+11] = (short) x_t;                                    *
*                 if (x_t >= M) w[k+11] = 0x7fff;                           *
*                 w[k+10] = (short) y_t;                                    *
*                 if (y_t >= M) w[k+10] = 0x7fff;                           *
*                                                                           *
*                 k += 12;                                                  *
*             }                                                             *
*         }                                                                 *
*         w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          *
*         w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF IFFT. It accepts the inputs in normal order and   *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 - xl21;                                 *
*                        yt2  = xl1 - xl20;                                 *
*                        xt2  = xl0 + xl21;                                 *
*                        yt1  = xl1 + xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       multiply and the imaginary part of the multiply is performed        *
*       using the 16x32 multiply instruction with rounding mpylir and       *
*       mpyhir.                                                             *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
            .sect ".data:copyright_p"

        .sect ".text:_ifft16x32"
        .global _DSP_ifft16x32
_DSP_ifft16x32: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y
             .no_mdep
*=========================================================================== *
        .reg    A_j, B_j,  B_w0, A_w0, B_w1, A_w2, B_x, B_h2
        .reg    B_l1, B_l2, A_h2, A_l1, A_l2
        .reg    B_co20_si20:B_co10_si10
        .reg    A_co11_si11:A_co30_si30, B_co30_si30
        .reg    A_co31_si31:A_co21_si21
        .reg    A_xl1_3:A_xl1_2,B_xl1_1:B_xl1_0
        .reg    A_xh2_3:A_xh2_2,B_xh2_1:B_xh2_0
        .reg    A_xl2_3:A_xl2_2,B_xl2_1:B_xl2_0
        .reg    A_xh1_0, A_xh0_0
        .reg    B_xh1_0, B_xh0_0
        .reg    A_xl1_0,A_xl0_0, A_xh1_1, A_xh0_1
        .reg    A_xl1_1,A_xl0_1, B_xl0_0
        .reg    B_xh21_0,B_xh20_0, A_xh21_1,A_xh20_1
        .reg    B_xl21_0,B_xl20_0, A_xl21_1,A_xl20_1
        .reg    A_x_, A_x__, B_x__, A_x
        .reg    A_fft_jmp
        .reg    A_ifj, B_ifj
        .reg    B_fft_jmp
        .reg    A_x_3:A_x_2,B_x_1:B_x_0
        .reg    A_x_3o:A_x_2o,B_x_1o:B_x_0o
        .reg    B_xh2_1o:B_xh2_0o
        .reg    A_xh2_3o:A_xh2_2o
        .reg    B_xl1_1o:B_xl1_0o
        .reg    A_xl1_3o:A_xl1_2o
        .reg    B_xl2_1o:B_xl2_0o
        .reg    A_xl2_3o:A_xl2_2o
        .reg    B_xt0_0,B_yt0_0, A_xt0_1,A_yt0_1
        .reg    B_yt2_0,B_xt1_0, B_yt1_0,B_xt2_0
        .reg    A_yt2_1,A_xt1_1, A_yt1_1,A_xt2_1
        .reg    B_p0, B_p1, B_p2, B_p3, A_p4, A_p5, A_p6, A_p7
        .reg    B_p8, B_p9, B_pa, B_pb, A_pc, A_pd, A_pe, A_pf
        .reg    B_p10, B_p11, B_p12, B_p13, A_p14, A_p15, A_p16, A_p17
        .reg    B_x_l2_1:B_x_l2_0, A_x_h2_3:A_x_h2_2, B_x_l1_1:B_x_l1_0
        .reg    A_x_l2_3:A_x_l2_2, B_x_h2_1:B_x_h2_0, A_x_l1_3:A_x_l1_2
        .reg    A_xl1_3i:A_xl1_2i
        .reg    A_xl2_3i:A_xl2_2i
        .reg    A_xh2_3i:A_xh2_2i
        .reg    B_xl1_1i:B_xl1_0i
        .reg    B_xl2_1i:B_xl2_0i
        .reg    B_xh2_1i:B_xh2_0i
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride, B_while
        .reg    A_p_x0, B_p_x0
        .reg    B_x7:B_x6,A_x5:A_x4, B_x3:B_x2,A_x1:A_x0
        .reg    A_y7:A_y6,B_y5:B_y4, A_y3:A_y2,B_y1:B_y0
        .reg    B_xh1_1, B_xh0_1, B_xl0_1
        .reg    B_fft_jmp_1
        .reg    B_p_y0, B_p_y1, B_p_y2, B_p_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2, A_temp
        .reg    A_i, A_r2, B_j0

        ;-------------------------------------------------------------;
        ;  Assume radix is 4, by default. Check the norm of the # of  ;
        ; points to be transformed, and change radix to 2 if reqd.    ;
        ;-------------------------------------------------------------;

        MVK    .1        4,               A_radix
        NORM   .2        B_n,             B_radix2
        AND    .2        B_radix2,        1,                 B_radix2
[B_radix2]MVK  .1        2,               A_radix

        ;-------------------------------------------------------------;
        ; "stride" is a vraibale that denotes the speration between   ;
        ; the legs of the butterfly. "tw_offset" is the offset within ;
        ; the sub-table                                               ;
        ;-------------------------------------------------------------;

        MV     .2        B_n,             B_stride
        ZERO   .1        A_tw_offset

LOOP_WHILE:

        ;-------------------------------------------------------------;
        ; "j" is used as an index into the sub-table of twiddle fact- ;
        ; ors. Since the pointer to the sub-table of twiddle fators   ;
        ; resets with every iteration of the outer loop, the index    ;
        ; within the sub-table is also reset to zero. Copies are made ;
        ; so that it exists in both data paths.                       ;
        ;-------------------------------------------------------------;

        ZERO   .1        A_j
        ZERO   .2        B_j

        ;-------------------------------------------------------------;
        ; "fft_jmp" is a variable that relates the offset between     ;
        ; data elements that use the same twiddle factor. It is       ;
        ; always 6*stride halfwords, 1.5 * stride double words. It    ;
        ; quarters as does stride with every iteration of the outer   ;
        ; loop.                                                       ;
        ;-------------------------------------------------------------;

        MPYSU  .2        6,               B_stride,          B_fft_jmp
        SHRU   .1X       B_fft_jmp,       4,                 A_fft_jmp

        ;-------------------------------------------------------------;
        ; Determine offsets N/4, N/2, 3N/4 and make copies to both    ;
        ; data paths. Also copy input pointer as output pointer.      ;
        ;-------------------------------------------------------------;

        SHRU   .2        B_stride,        2,                 B_h2
        SHRU   .2        B_stride,        1,                 B_l1
        ADD    .2        B_l1,            B_h2,              B_l2

        MV     .1X       B_l1,            A_l1
        MV     .1X       B_h2,            A_h2
        MV     .1X       B_l2,            A_l2

        MV     .2X       A_ptr_x,         B_x
        ADDAH  .1        A_ptr_w,         A_tw_offset,        A_w0
        MV     .2X       A_w0,            B_w0

        SHRU   .2        B_fft_jmp,       2,                  B_fft_jmp_1
        ADD    .1X       A_tw_offset,     B_fft_jmp_1,        A_tw_offset
        SHRU   .2        B_stride,        2,                  B_stride

        ;-------------------------------------------------------------;
        ;  Adjustments for BDEC, as it iterates till -1. Deduct 2     ;
        ; from loop trip count of N/8.                                ;
        ;-------------------------------------------------------------;

        SUB    .1        A_fft_jmp,       3,                  A_fft_jmp
        SHRU   .1X       B_n,             3,                  A_i
        SUB    .1        A_i,             2,                  A_i

LOOP_Y: .trip 8

        ;-------------------------------------------------------------;
        ; si10 = w[0] co10 = w[1]  si11 = w[2]  co11 = w[3]           ;
        ; si20 = w[4] co20 = w[5]  si21 = w[6]  si21 = w[7]           ;
        ; si30 = w[8] co30 = w[9]  si31 = w[a]  co31 = w[b]           ;
        ;-------------------------------------------------------------;

        ADD    .2      B_w0,               8,                B_w1
        ADD    .1      B_w1,               8,                A_w2

        LDDW   .D2T2   *B_w0[B_j],         B_co20_si20:B_co10_si10
        LDDW   .D2T1   *B_w1[B_j],         A_co11_si11:A_co30_si30
        LDDW   .D1T1   *A_w2[A_j],         A_co31_si31:A_co21_si21

        ;-------------------------------------------------------------;
        ;  x[0]       x[1]       x[2]       x[3]                      ;
        ;  x[h2+0]    x[h2+1]    x[h2+2]    x[h2+3]                   ;
        ;  x[l1+0]    x[l1+1]    x[l1+2]    x[l1+3]                   ;
        ;  x[l2+0]    x[l2+1]    x[l2+2]    x[l2+3]                   ;
        ;-------------------------------------------------------------;

        LDDW   .D2T2   *B_x[0],            B_x_1:B_x_0
        LDDW   .D2T2   *B_x[B_l1],         B_xl1_1i:B_xl1_0i
        LDDW   .D2T2   *B_x[B_l2],         B_xl2_1i:B_xl2_0i
        LDDW   .D2T2   *B_x[B_h2],         B_xh2_1i:B_xh2_0i

        ADD    .1X     B_x,                8,                 A_x

        LDDW   .D1T1   *A_x[0],            A_x_3:A_x_2
        LDDW   .D1T1   *A_x[A_l1],         A_xl1_3i:A_xl1_2i
        LDDW   .D1T1   *A_x[A_l2],         A_xl2_3i:A_xl2_2i
        LDDW   .D1T1   *A_x[A_h2],         A_xh2_3i:A_xh2_2i

        ;-------------------------------------------------------------;
        ; xh0_0 = x[0] + x[l1];    xh1_0 = x[1] + x[l1+1]             ;
        ; xh0_1 = x[2] + x[l1+2];  xh1_1 = x[3] + x[l1+3]             ;
        ; xl0_0 = x[0] - x[l1];    xl1_0 = x[1] - x[l1+1]             ;
        ; xl0_1 = x[2] - x[l1+2];  xl1_1 = x[3] - x[l1+3]             ;
        ;-------------------------------------------------------------;

        ADD    .2      B_xl1_0i,            B_x_0,            B_xh0_0
        ADD    .2      B_xl1_1i,            B_x_1,            B_xh1_0

        ADD    .1      A_xl1_2i,            A_x_2,            A_xh0_1
        ADD    .1      A_xl1_3i,            A_x_3,            A_xh1_1

        SUB    .2      B_x_0,               B_xl1_0i,         B_xl0_0
        SUB    .2      B_x_1,               B_xl1_1i,         B_xl1_0

        SUB    .1      A_x_2,               A_xl1_2i,         A_xl0_1
        SUB    .1      A_x_3,               A_xl1_3i,         A_xl1_1

        ;------------------------------------------------------------;
        ; xh20_0 = x[h2  ] + x[l2  ]; xh21_0 = x[h2+1] + x[l2+1]     ;
        ; xh20_1 = x[h2+2] + x[l2+2]; xh21_1 = x[h2+3] + x[l2+3]     ;
        ; xl20_0 = x[h2  ] - x[l2  ]; xl21_0 = x[h2+1] - x[l2+1]     ;
        ; xl20_1 = x[h2+2] - x[l2+2]; xl21_1 = x[h2+3] - x[l2+3]     ;
        ;------------------------------------------------------------;

        ADD    .2      B_xl2_0i,            B_xh2_0i,         B_xh20_0
        ADD    .2      B_xl2_1i,            B_xh2_1i,         B_xh21_0

        ADD    .1      A_xl2_2i,            A_xh2_2i,         A_xh20_1
        ADD    .1      A_xl2_3i,            A_xh2_3i,         A_xh21_1

        SUB    .2      B_xh2_1i,            B_xl2_1i,         B_xl21_0
        SUB    .2      B_xh2_0i,            B_xl2_0i,         B_xl20_0

        SUB    .1      A_xh2_2i,            A_xl2_2i,         A_xl20_1
        SUB    .1      A_xh2_3i,            A_xl2_3i,         A_xl21_1

        MVD    .1X     B_x,                 A_x_
        MVD    .2X     A_x_,                B_x__

        ;-------------------------------------------------------------;
        ;  if (!(j - fft_jmp))                                        ;
        ;  {                                                          ;
        ;    j += 12 shorts;                                          ;
        ;    x += fft_jmp;                                            ;
        ;    j = 0;                                                   ;
        ;    x += 4                                                   ;
        ;  }                                                          ;
        ;-------------------------------------------------------------;

        SUB    .1X     A_fft_jmp,           B_j,              A_ifj
        ADD    .2      B_j,                 3,                B_j
[!A_ifj]ADD    .2      B_x,                 B_fft_jmp,        B_x
[!A_ifj]ZERO   .2      B_j
        ADD    .2      B_x,                 16,               B_x
        MV     .1X     B_j,                 A_j

        ;-------------------------------------------------------------;
        ;  x0[0]  =  xh0_0  +  xh20_0  x0[1]  =  xh1_0  +  xh21_0     ;
        ;  x0[2]  =  xh0_1  +  xh20_1  x0[3]  =  xh1_1  +  xh21_1     ;
        ;-------------------------------------------------------------;

        ADD    .2      B_xh20_0,            B_xh0_0,          B_x_0o
        ADD    .2      B_xh21_0,            B_xh1_0,          B_x_1o
        ADD    .1      A_xh20_1,            A_xh0_1,          A_x_2o
        ADD    .1      A_xh21_1,            A_xh1_1,          A_x_3o

        ;-------------------------------------------------------------;
        ;   xt0_0 = xh0_0 - xh20_0     yt0_0 = xh1_0 - xh21_0         ;
        ;   xt0_1 = xh0_1 - xh20_1     yt0_1 = xh1_1 - xh21_1         ;
        ;-------------------------------------------------------------;

        SUB    .2      B_xh1_0,             B_xh21_0,         B_yt0_0
        SUB    .2      B_xh0_0,             B_xh20_0,         B_xt0_0
        SUB    .1      A_xh1_1,             A_xh21_1,         A_yt0_1
        SUB    .1      A_xh0_1,             A_xh20_1,         A_xt0_1

        ;-------------------------------------------------------------;
        ;  xt1_0  =  xl0_0  -  xl21_0   yt2_0  =  xl1_0  -  xl20_0    ;
        ;  xt1_1  =  xl0_1  -  xl21_1   yt2_1  =  xl1_1  -  xl20_1    ;
        ;  xt2_0  =  xl0_0  +  xl21_0   yt1_0  =  xl1_0  +  xl20_0    ;
        ;  xt2_1  =  xl0_1  +  xl21_1   yt1_1  =  xl1_1  +  xl20_1    ;
        ;-------------------------------------------------------------;

        SUB    .2       B_xl0_0,            B_xl21_0,         B_xt1_0
        SUB    .2       B_xl1_0,            B_xl20_0,         B_yt2_0
        SUB    .1       A_xl0_1,            A_xl21_1,         A_xt1_1
        SUB    .1       A_xl1_1,            A_xl20_1,         A_yt2_1

        ADD    .2       B_xl0_0,            B_xl21_0,         B_xt2_0
        ADD    .2       B_xl1_0,            B_xl20_0,         B_yt1_0
        ADD    .1       A_xl0_1,            A_xl21_1,         A_xt2_1
        ADD    .1       A_xl1_1,            A_xl20_1,         A_yt1_1

        ;-------------------------------------------------------------;
        ;   x2[h2  ] = (co10 * xt1_0 - si10 * yt1_0) >> 15            ;
        ;   x2[h2+1] = (co10 * yt1_0 + si10 * xt1_0) >> 15            ;
        ;   x2[h2+2] = (co11 * yt1_1 - si11 * xt1_1) >> 15            ;
        ;   x2[h2+3] = (co11 * yt1_1 + si11 * xt1_1) >> 15            ;
        ;-------------------------------------------------------------;

        MPYHIR  .2      B_co10_si10,        B_xt1_0,          B_p0
        MPYLIR  .2      B_co10_si10,        B_yt1_0,          B_p1
        SUB     .2      B_p0,               B_p1,             B_xh2_0o

        MPYHIR  .2      B_co10_si10,        B_yt1_0,          B_p2
        MPYLIR  .2      B_co10_si10,        B_xt1_0,          B_p3
        ADD     .2      B_p2,               B_p3,             B_xh2_1o

        MPYHIR  .1      A_co11_si11,        A_xt1_1,          A_p4
        MPYLIR  .1      A_co11_si11,        A_yt1_1,          A_p5
        SUB     .1      A_p4,               A_p5,             A_xh2_2o

        MPYHIR  .1      A_co11_si11,        A_yt1_1,          A_p6
        MPYLIR  .1      A_co11_si11,        A_xt1_1,          A_p7
        ADD     .1      A_p6,               A_p7,             A_xh2_3o

        ;-------------------------------------------------------------;
        ;   x2[l1  ] = (co20 * xt0_0 - si20 * yt0_0) >> 15            ;
        ;   x2[l1+1] = (co20 * yt0_0 + si20 * xt0_0) >> 15            ;
        ;   x2[l1+2] = (co21 * xt0_1 - co21 * yt0_1) >> 15            ;
        ;   x2[l1+3] = (co21 * yt0_1 + si21 * xt0_1) >> 15            ;
        ;-------------------------------------------------------------;

        MPYHIR  .2      B_co20_si20,        B_xt0_0,          B_p8
        MPYLIR  .2      B_co20_si20,        B_yt0_0,          B_p9
        SUB     .2      B_p8,               B_p9,             B_xl1_0o

        MPYHIR  .2      B_co20_si20,        B_yt0_0,          B_pa
        MPYLIR  .2      B_co20_si20,        B_xt0_0,          B_pb
        ADD     .2      B_pa,               B_pb,             B_xl1_1o

        MPYHIR  .1      A_co21_si21,        A_xt0_1,          A_pc
        MPYLIR  .1      A_co21_si21,        A_yt0_1,          A_pd
        SUB     .1      A_pc,               A_pd,             A_xl1_2o

        MPYHIR  .1      A_co21_si21,        A_yt0_1,          A_pe
        MPYLIR  .1      A_co21_si21,        A_xt0_1,          A_pf
        ADD     .1      A_pe,               A_pf,             A_xl1_3o

        ;-------------------------------------------------------------;
        ;   x2[l2  ] = (co30 * xt2_0 - si30 * yt2_0) >> 15            ;
        ;   x2[l2+1] = (co30 * yt2_0 + si30 * xt2_0) >> 15            ;
        ;   x2[l2+2] = (co31 * xt2_1 - si31 * yt2_1) >> 15            ;
        ;   x2[l2+3] = (co31 * yt2_1 + si31 * xt2_1) >> 15            ;
        ;-------------------------------------------------------------;

        MV      .2X     A_co30_si30,        B_co30_si30
        MPYHIR  .2      B_co30_si30,        B_xt2_0,          B_p10
        MPYLIR  .2      B_co30_si30,        B_yt2_0,          B_p11
        SUB     .2      B_p10,              B_p11,            B_xl2_0o

        MPYHIR  .2      B_co30_si30,        B_yt2_0,          B_p12
        MPYLIR  .2      B_co30_si30,        B_xt2_0,          B_p13
        ADD     .2      B_p12,              B_p13,            B_xl2_1o

        MPYHIR  .1      A_co31_si31,        A_xt2_1,          A_p14
        MPYLIR  .1      A_co31_si31,        A_yt2_1,          A_p15
        SUB     .1      A_p14,              A_p15,            A_xl2_2o

        MPYHIR  .1      A_co31_si31,        A_yt2_1,          A_p16
        MPYLIR  .1      A_co31_si31,        A_xt2_1,          A_p17
        ADD     .1      A_p16,              A_p17,            A_xl2_3o

        ADD    .1X      B_x__,              8,                A_x__

        ;-------------------------------------------------------------;
        ;  Store four outputs for all the four legs of butterfly      ;
        ;-------------------------------------------------------------;

        STDW   .D2T2    B_x_1o:B_x_0o,      *B_x__[0]
        STDW   .D1T1    A_x_3o:A_x_2o,      *A_x__[0]

        STDW   .D2T2    B_xh2_1o:B_xh2_0o,  *B_x__[B_h2]
        STDW   .D1T1    A_xh2_3o:A_xh2_2o,  *A_x__[A_h2]

        STDW   .D2T2    B_xl1_1o:B_xl1_0o,  *B_x__[B_l1]
        STDW   .D1T1    A_xl1_3o:A_xl1_2o,  *A_x__[A_l1]

        STDW   .D2T2    B_xl2_1o:B_xl2_0o,  *B_x__[B_l2]
        STDW   .D1T1    A_xl2_3o:A_xl2_2o,  *A_x__[A_l2]

        BDEC   .1       LOOP_Y,              A_i

        CMPGTU .2X      B_stride,            A_radix,         B_while

[B_while]B              LOOP_WHILE

        ;-------------------------------------------------------------;
        ; Set up input/output pointers depending on radix,            ;
        ; If radix == 4, then data maps to ptr_y, ptr_y + N/2,        ;
        ; ptr_y + N. ptr_y + 3N/2. If radix == 2, then data maps      ;
        ; ptr_y, ptr_y + N/4, ptr_y + N, ptr_y + 3N/4                 ;
        ; Input data is always read from x0, x0 + N/2.                ;
        ;-------------------------------------------------------------;

        SUB    .1       A_radix,             2,               A_r2

        MV     .1       A_ptr_x,             A_p_x0
        ADD    .2X      A_ptr_x,             8,               B_p_x0

        MV     .2       B_ptr_y,             B_p_y0
        ADDAW  .2       B_p_y0,              B_n,             B_p_y2


        ADDAH  .2       B_p_y0,              B_n,             B_p_y1
        ADDAH  .2       B_p_y2,              B_n,             B_p_y3

        NORM   .2       B_n,                 B_l1
        ADD    .2       B_l1,                2,               B_l1

        MVK    .2       4,                   B_j0

[!A_r2] ADD    .2       B_p_y0,              B_n,             B_p_y1
[!A_r2] ADD    .2       B_p_y2,              B_n,             B_p_y3

[!A_r2] NORM   .2       B_n,                 B_l1
[!A_r2] ADD    .2       B_l1,                1,               B_l1
[!A_r2] MVK    .2       8,                   B_j0

        ;-------------------------------------------------------------;
        ;  Following loop iterates for N/4 -2 times, because of BDEC  ;
        ;  Use j as input to find digit reversed index. The digit     ;
        ;  reversed index is in B_h4                                  ;
        ;-------------------------------------------------------------;

        SHRU   .1X      B_n,                 2,               A_i
        SUB    .1       A_i,                 2,               A_i
        ZERO   .2       B_j

LOOP_Z: .trip 8

        ;-------------------------------------------------------------;
        ; The following combination of instructions act on "j" and    ;
        ; produce the digit reversed index in "h4" or "bit reversed"  ;
        ; offset for radix2.                                          ;
        ;-------------------------------------------------------------;

        DEAL   .2       B_j,                 B_h0
        BITR   .2       B_h0,                B_h1
        ROTL   .2       B_h1,                16,              B_h2
        SHFL   .2       B_h2,                B_h3
        SHRU   .2       B_h3,                B_l1,            B_h4
        ADD    .2       B_j,                 B_j0,            B_j

        ;-------------------------------------------------------------;
        ;  Load input data at start of data array x, x0..x7. Perform  ;
        ; either radix4 style or radix2 style. Use rotates by 0, to   ;
        ; avoid live too longs, as these veriables simply live along  ;
        ; without any operations being performed on them.             ;
        ;-------------------------------------------------------------;


        LDDW   .D1T1    *A_p_x0++[2],        A_x1:A_x0
        LDDW   .D2T2    *B_p_x0++[2],        B_x3:B_x2
        LDDW   .D1T1    *A_p_x0++[2],        A_x5:A_x4
        LDDW   .D2T2    *B_p_x0++[2],        B_x7:B_x6

        ;-------------------------------------------------------------;
        ;  xh0_0   = x0 + x4     xh1_0  = x1 +  x5                    ;
        ;  xh0_1   = x2 + x6     xh1_1  = x3 +  x7                    ;
        ;-------------------------------------------------------------;

        ADD    .1       A_x4,                A_x0,            A_xh0_0
        ADD    .1       A_x5,                A_x1,            A_xh1_0
        ADD    .2       B_x6,                B_x2,            B_xh0_1
        ADD    .2       B_x7,                B_x3,            B_xh1_1

        ;-------------------------------------------------------------;
        ;  Overwrite these results as follows for radix2:             ;
        ;  xh0_0 = x0, xh1_0 = x1, xh0_1 = x2 xh1_1 = x3              ;
        ;-------------------------------------------------------------;

[!A_r2] ROTL   .1       A_x0,                0,               A_xh0_0
[!A_r2] ROTL   .1       A_x1,                0,               A_xh1_0
[!A_r2] ROTL   .2       B_x2,                0,               B_xh0_1
[!A_r2] ROTL   .2       B_x3,                0,               B_xh1_1

        ;-------------------------------------------------------------;
        ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2         ;
        ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3         ;
        ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2         ;
        ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3         ;
        ;-------------------------------------------------------------;

        ADD    .2X      A_xh0_0,             B_xh0_1,         B_y0
        ADD    .2X      A_xh1_0,             B_xh1_1,         B_y1
        SUB    .2X      A_xh0_0,             B_xh0_1,         B_y4
        SUB    .2X      A_xh1_0,             B_xh1_1,         B_y5

        ;-------------------------------------------------------------;
        ;  xl0_0  = x0 - x4        xl1_0  = x1 - x5                   ;
        ;  xl0_1  = x2 - x6        xl1_1  = x3 - x7                   ;
        ;-------------------------------------------------------------;

        SUB    .1       A_x0,                A_x4,            A_xl0_0
        SUB    .1       A_x1,                A_x5,            A_xl1_0
        SUB    .2       B_x2,                B_x6,            B_xl0_1
        SUB    .2       B_x3,                B_x7,            B_xl1_1

        ;------------------------------------------------------------;
        ; Overwrite these results as follows for radix2:             ;
        ; xl0_0 = x4, xl1_0 = x5, xl0_1 = x7 xl1_1 = x6              ;
        ;------------------------------------------------------------;

[!A_r2] ROTL   .1       A_x4,                0,               A_xl0_0
[!A_r2] ROTL   .1       A_x5,                0,               A_xl1_0
[!A_r2] SUB    .2       0,                   B_x6,            B_xl1_1
[!A_r2] SUB    .2       0,                   B_x7,            B_xl0_1

        ;-------------------------------------------------------------;
        ; radix4:  y2 = xl0_0 - xl1_1    radix2: y2 = x4 + x6         ;
        ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7         ;
        ; radix4:  y6 = xl0_0 + xl1_1    radix2: y6 = x4 - x6         ;
        ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7         ;
        ;-------------------------------------------------------------;

        SUB    .1X      A_xl0_0,             B_xl1_1,         A_y2
        ADD    .1X      A_xl1_0,             B_xl0_1,         A_y3
        ADD    .1X      A_xl0_0,             B_xl1_1,         A_y6
        SUB    .1X      A_xl1_0,             B_xl0_1,         A_y7

        ;-------------------------------------------------------------;
        ;  Swap y3, y7 if radix2   y2 = x4 + x6, y3 = x5 + x7,        ;
        ;                          y6 = x4 - x6, y7 = x5 - x7         ;
        ;-------------------------------------------------------------;

        MV     .1       A_y3,                A_temp
[!A_r2] MV     .1       A_y7,                A_y3
[!A_r2] MV     .1       A_temp,              A_y7

        ;-------------------------------------------------------------;
        ; Store using digit reversed index, bit reversed index and    ;
        ; and pointers p_y0,...p_y3                                   ;
        ;-------------------------------------------------------------;

        STDW   .D2T2    B_y1:B_y0,           *B_p_y0[B_h4]
        STDW   .D2T1    A_y3:A_y2,           *B_p_y1[B_h4]
        STDW   .D2T2    B_y5:B_y4,           *B_p_y2[B_h4]
        STDW   .D2T1    A_y7:A_y6,           *B_p_y3[B_h4]

        ;-------------------------------------------------------------;
        ;  Decrement and branch back to LOOP_Z                        ;
        ;-------------------------------------------------------------;

        BDEC   .1   LOOP_Z,                  A_i

        .return
        .endproc

*=========================================================================== *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=========================================================================== *
ifft32x32.sa/   1066929506  0     0     0       58664     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Sep  6 18:04:21 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_ifft32x32: Double Precision FFT                            *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_ifft32x32(const int  * ptr_w, int  npoints,            *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*       In reality one can re-use fft32x32 to perform IFFT, by first        *
*       conjugating the input, performing the FFT, conjugating again.       *
*       This allows fft32x32 to perform the IFFT as well. However if        *
*       the double conjugation needs to be avoided then this routine        *
*       uses the same twiddle factors as the FFT and performs an IFFT.      *
*       The change in the sign of the twiddle factors is adjusted for       *
*       software. Hence this routine uses the same twiddle factors as       *
*       the FFT routine.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix IFFT for "npoints" which  *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(co10 , xt1_0)  - _mpyhir(si10 , yt1_0) +                    *
*                        (((MPYLUHS(co10,xt1_0) - MPYLUHS(si10, yt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(co10 , xt1_0)  - _mpyhir(co10 , xt1_0) +                    *
*                        (_dotpnrsu2(xt1_0yt1_0, co10si10) << 1);           *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 - xl21;                                 *
*                        yt2  = xl1 - xl20;                                 *
*                        xt2  = xl0 + xl21;                                 *
*                        yt1  = xl1 + xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"


        .sect ".text:_ifft32x32"
        .global _DSP_ifft32x32
_DSP_ifft32x32: .cproc A_ptr_w, B_n, A_ptr_x, B_ptr_y

             .no_mdep
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .reg            B_w0,  B_x
        .reg            A_x
        .reg            B_xp1:B_xp0
        .reg            A_l1
        .reg            A_xl1p1:A_xl1p0
        .reg            A_h2
        .reg            B_xh2p1:B_xh2p0
        .reg            A_l2
        .reg            A_xl2p1:A_xl2p0
        .reg            A_xh0
        .reg            A_xh1
        .reg            B_xl0
        .reg            B_xl1
        .reg            A_xh20
        .reg            A_xh21
        .reg            B_xl20
        .reg            B_xl21
        .reg            A_y_h1_1:A_y_h1_0
        .reg            A_w0
        .reg            A_j
        .reg            B_co10:B_si10
        .reg            B_w1
        .reg            B_j
        .reg            A_co20:A_si20
        .reg            A_w2
        .reg            B_co30:B_si30
        .reg            A_xt0
        .reg            A_yt0
        .reg            B_xt1
        .reg            B_yt2
        .reg            B_xt2
        .reg            B_yt1
        .reg            B_co10si10
        .reg            A_co20si20
        .reg            B_co30si30
        .reg            B_si10co10
        .reg            A_si20co20
        .reg            B_si30co30
        .reg            A_yt0xt0
        .reg            B_yt1xt1
        .reg            B_yt2xt2
        .reg            A_si10
        .reg            B_p0r
        .reg            A_p1r
        .reg            B_p01r
        .reg            B_p0c
        .reg            A_p1c
        .reg            B_y_h2_1:B_y_h2_0
        .reg            B_p01c
        .reg            A_p2r
        .reg            A_p3r
        .reg            A_p23r
        .reg            A_p2c
        .reg            A_p3c
        .reg            A_y_l1_1:A_y_l1_0
        .reg            A_p23c
        .reg            B_p4r
        .reg            B_p5r
        .reg            B_p45r
        .reg            B_p4c
        .reg            B_p5c
        .reg            B_y_l2_1:B_y_l2_0
        .reg            B_p45c
        .reg            A_x_1
        .reg            B_x__
        .reg            B_fft_jmp
        .reg            A_ifj
        .reg            A_fft_jmp
        .reg            B_h2
        .reg            B_l1
        .reg            B_l2
        .reg            A_i
; ======================================================================
        .reg    A_xl1_3:A_xl1_2,B_xl1_1:B_xl1_0
        .reg    A_xh2_3:A_xh2_2,B_xh2_1:B_xh2_0
        .reg    A_xl2_3:A_xl2_2,B_xl2_1:B_xl2_0
        .reg    A_xh1_0, A_xh0_0
        .reg    B_xh1_0, B_xh0_0
        .reg    A_xl1_0,A_xl0_0, A_xh1_1, A_xh0_1
        .reg    A_xl1_1,A_xl0_1, B_xl0_0
        .reg    B_xh21_0,B_xh20_0, A_xh21_1,A_xh20_1
        .reg    B_xl21_0,B_xl20_0, A_xl21_1,A_xl20_1
        .reg    A_x_, A_x__
        .reg    A_x_3:A_x_2,B_x_1:B_x_0
        .reg    A_x_3o:A_x_2o,B_x_1o:B_x_0o
        .reg    B_xh2_1o:B_xh2_0o
        .reg    A_xh2_3o:A_xh2_2o
        .reg    B_xl1_1o:B_xl1_0o
        .reg    A_xl1_3o:A_xl1_2o
        .reg    B_xl2_1o:B_xl2_0o
        .reg    A_xl2_3o:A_xl2_2o
        .reg    B_xt0_0,B_yt0_0, A_xt0_1,A_yt0_1
        .reg    B_yt2_0,B_xt1_0, B_yt1_0,B_xt2_0
        .reg    A_yt2_1,A_xt1_1, A_yt1_1,A_xt2_1
        .reg    B_p0, B_p1, B_p2, B_p3, A_p4, A_p5, A_p6, A_p7
        .reg    B_p8, B_p9, B_pa, B_pb, A_pc, A_pd, A_pe, A_pf
        .reg    B_p10, B_p11, B_p12, B_p13, A_p14, A_p15, A_p16, A_p17
        .reg    B_x_l2_1:B_x_l2_0, A_x_h2_3:A_x_h2_2, B_x_l1_1:B_x_l1_0
        .reg    A_x_l2_3:A_x_l2_2, B_x_h2_1:B_x_h2_0, A_x_l1_3:A_x_l1_2
        .reg    A_xl1_3i:A_xl1_2i
        .reg    A_xl2_3i:A_xl2_2i
        .reg    A_xh2_3i:A_xh2_2i
        .reg    B_xl1_1i:B_xl1_0i
        .reg    B_xl2_1i:B_xl2_0i
        .reg    B_xh2_1i:B_xh2_0i
        .reg    A_xh2_3_2:A_xh2_1_0
        .reg    B_xl1_3_2:B_xl1_1_0
        .reg    B_xl2_3_2:B_xl2_1_0
        .reg    A_tw_offset, B_stride, B_while
        .reg    A_p_x0, B_p_x0
        .reg    B_x7:B_x6,A_x5:A_x4, B_x3:B_x2,A_x1:A_x0
        .reg    A_y7:A_y6,B_y5:B_y4, A_y3:A_y2,B_y1:B_y0
        .reg    B_xh1_1, B_xh0_1
        .reg    B_xl0_1
        .reg    A_fft_jmp_1
        .reg    B_p_y0, B_p_y1, B_p_y2, B_p_y3, B_h0, B_h1, B_h3, B_h4
        .reg    A_radix, B_radix2, A_temp
        .reg    A_r2, B_j0
        .reg    B_xl1_1c, A_xh1_0c
        .reg    A_xt0yt0
        .reg    B_xt1yt1
        .reg    B_xt2yt2

          ;-------------------------------------------------------------;
          ;  Assume radix is 4, by default. Check the norm of the # of  ;
          ; points to be transformed, and change radix to 2 if reqd.    ;
          ;-------------------------------------------------------------;

          MVK        .1       4,                A_radix
          NORM       .2       B_n,              B_radix2
          AND        .2       B_radix2,         1,                B_radix2
[B_radix2]MVK        .1       2,                A_radix

          ;-------------------------------------------------------------;
          ; "stride" is a vraibale that denotes the speration between   ;
          ; the legs of the butterfly. "tw_offset" is the offset within ;
          ; the sub-table                                               ;
          ;-------------------------------------------------------------;

          MV         .2       B_n,              B_stride
          ZERO       .1       A_tw_offset

LOOP_WHILE:

          ;-------------------------------------------------------------;
          ; "j" is used as an index into the sub-table of twiddle fact- ;
          ; ors. Since the pointer to the sub-table of twiddle fators   ;
          ; resets with every iteration of the outer loop, the index    ;
          ; within the sub-table is also reset to zero. Copies are made ;
          ; so that it exists in both data paths.                       ;
          ;-------------------------------------------------------------;

          ZERO       .1       A_j
          ZERO       .2       B_j

          ;-------------------------------------------------------------;
          ; "fft_jmp" is a variable that relates the offset between     ;
          ; data elements that use the same twiddle factor. It is       ;
          ; always 6*stride halfwords, 1.5 * stride double words. It    ;
          ; quarters as does stride with every iteration of the outer   ;
          ; loop.                                                       ;
          ;-------------------------------------------------------------;

          MPYSU      .1X      6,                B_stride,         A_fft_jmp
          SHRU       .2X      A_fft_jmp,        3,                B_fft_jmp
          SUB        .2       B_fft_jmp,        3,                B_fft_jmp

          ;-------------------------------------------------------------;
          ; Determine offsets N/4, N/2, 3N/4 and make copies to both    ;
          ; data paths. Also copy input pointer as output pointer.      ;
          ;-------------------------------------------------------------;

          SHRU       .2       B_stride,         2,                B_h2
          SHRU       .2       B_stride,         1,                B_l1
          ADD        .2       B_l1,             B_h2,             B_l2
          MV         .1X      B_l1,             A_l1
          MV         .1X      B_h2,             A_h2
          MV         .1X      B_l2,             A_l2

          MV         .1      A_ptr_x,           A_x
          ADDAH      .1      A_ptr_w,           A_tw_offset,      A_w0
          ADD        .2X     A_w0,              8,                B_w1
          ADD        .1X     B_w1,              8,                A_w2

          SHRU       .1      A_fft_jmp,         1,                A_fft_jmp_1
          ADD        .1      A_tw_offset,       A_fft_jmp_1,      A_tw_offset
          SHRU       .2      B_stride,          2,                B_stride

          ;-------------------------------------------------------------;
          ;  Adjustments for BDEC, as it iterates till -1. Deduct 2     ;
          ;  from loop trip count of N/4.                               ;
          ;-------------------------------------------------------------;

          SHRU       .1X     B_n,               2,                A_i
          SUB        .1      A_i,               2,                A_i

          ;-------------------------------------------------------------;
          ; Since the stride amount across iterations is variable,      ;
          ; it is tough to put an exact stride. However for this        ;
          ; loop stride is guranteed to be greater than or equal        ;
          ; to 16 complex samples, 32 half words. Since this str-       ;
          ; ide is wider than the bank width, of all the banks,         ;
          ; stride is specified as zero.                                ;
          ;-------------------------------------------------------------;


        .mptr      A_w0,   x+0,     0
        .mptr      B_w1,   x+2,     0
        .mptr      A_w2,   x+0,     0
        .mptr      B_x,    x+0,     0
        .mptr      A_x_1,  x+0,     0
        .mptr      B_x__,  x+0,     0

LOOP_Y: .trip 8

          ;-------------------------------------------------------------;
          ;  x[0]       x[1]       x[2]       x[3]                      ;
          ;  x[h2+0]    x[h2+1]    x[h2+2]    x[h2+3]                   ;
          ;  x[l1+0]    x[l1+1]    x[l1+2]    x[l1+3]                   ;
          ;  x[l2+0]    x[l2+1]    x[l2+2]    x[l2+3]                   ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_x[0],           B_xp1:B_xp0
          LDDW      .D1T1    *A_x[A_l1],        A_xl1p1:A_xl1p0
          LDDW      .D1T2    *A_x[A_h2],        B_xh2p1:B_xh2p0
          LDDW      .D1T1    *A_x[A_l2],        A_xl2p1:A_xl2p0

          ;-------------------------------------------------------------;
          ; xh0_0 = x[0] + x[l1];    xh1_0 = x[1] + x[l1+1]             ;
          ; xh0_1 = x[2] + x[l1+2];  xh1_1 = x[3] + x[l1+3]             ;
          ; xl0_0 = x[0] - x[l1];    xl1_0 = x[1] - x[l1+1]             ;
          ; xl0_1 = x[2] - x[l1+2];  xl1_1 = x[3] - x[l1+3]             ;
          ;-------------------------------------------------------------;

          ADD       .1X      B_xp0,             A_xl1p0,          A_xh0
          ADD       .1X      B_xp1,             A_xl1p1,          A_xh1
          ADD       .1X      B_xh2p0,           A_xl2p0,          A_xh20
          ADD       .1X      B_xh2p1,           A_xl2p1,          A_xh21
          SUB       .2X      B_xp0,             A_xl1p0,          B_xl0
          SUB       .2X      B_xp1,             A_xl1p1,          B_xl1
          SUB       .2X      B_xh2p0,           A_xl2p0,          B_xl20
          SUB       .2X      B_xh2p1,           A_xl2p1,          B_xl21

          ;-------------------------------------------------------------;
          ; si10 = w[0] co10 = w[1]  si11 = w[2]  co11 = w[3]           ;
          ; si20 = w[4] co20 = w[5]  si21 = w[6]  si21 = w[7]           ;
          ; si30 = w[8] co30 = w[9]  si31 = w[a]  co31 = w[b]           ;
          ;-------------------------------------------------------------;

          LDDW      .D1T2    *A_w0[A_j],        B_co10:B_si10
          LDDW      .D2T1    *B_w1[B_j],        A_co20:A_si20
          LDDW      .D1T2    *A_w2[A_j],        B_co30:B_si30

          ;------------------------------------------------------------;
          ; xh20_0 = x[h2  ] + x[l2  ]; xh21_0 = x[h2+1] + x[l2+1]     ;
          ; xh20_1 = x[h2+2] + x[l2+2]; xh21_1 = x[h2+3] + x[l2+3]     ;
          ; xl20_0 = x[h2  ] - x[l2  ]; xl21_0 = x[h2+1] - x[l2+1]     ;
          ; xl20_1 = x[h2+2] - x[l2+2]; xl21_1 = x[h2+3] - x[l2+3]     ;
          ;------------------------------------------------------------;

          ADD       .1       A_xh20,            A_xh0,            A_y_h1_0
          ADD       .1       A_xh21,            A_xh1,            A_y_h1_1
          SUB       .1       A_xh0,             A_xh20,           A_xt0
          SUB       .1       A_xh1,             A_xh21,           A_yt0

          SUB       .2       B_xl0,             B_xl21,           B_xt1
          SUB       .2       B_xl1,             B_xl20,           B_yt2
          ADD       .2       B_xl0,             B_xl21,           B_xt2
          ADD       .2       B_xl1,             B_xl20,           B_yt1

          ;------------------------------------------------------------;
          ; Pack coefficients as a word taking lower 16 bits for use   ;
          ; with DOTPRSU2 and DOTPNRSU2. In addition both orders of    ;
          ; twiddle factors are rquired because the DOTPNRSU2 does     ;
          ; not have cross access within a word.                       ;
          ;------------------------------------------------------------;

          PACK2     .2       B_co10,            B_si10,           B_co10si10
          PACK2     .1       A_co20,            A_si20,           A_co20si20
          PACK2     .2       B_co30,            B_si30,           B_co30si30

          ;------------------------------------------------------------;
          ; Pack high sixteen bits of data as one word, for use with   ;
          ; DOTPSU2 and DOTPNRSU2.                                     ;
          ;------------------------------------------------------------;

          PACKH2    .1       A_xt0,             A_yt0,            A_xt0yt0
          PACKH2    .2       B_xt1,             B_yt1,            B_xt1yt1
          PACKH2    .2       B_xt2,             B_yt2,            B_xt2yt2
          PACKH2    .1       A_yt0,             A_xt0,            A_yt0xt0
          PACKH2    .2       B_yt1,             B_xt1,            B_yt1xt1
          PACKH2    .2       B_yt2,             B_xt2,            B_yt2xt2

          ;------------------------------------------------------------;
          ; Perform 32x32 multiply as shown below:                     ;
          ; x2[h2  ] = _mpyhir(si10 , yt1_0) - _mpyhir(co10 , xt1_0) + ;
          ;            (_dotpnrsu2(yt1_0xt1_0, si10co10) << 1)         ;
          ;                                                            ;
          ; x2[h2+1] = _mpyhir(co10 , yt1_0) + _mpyhir(si10 , xt1_0) + ;
          ;           (_dotprsu2(yt1_0xt1_0, co10si10) << 1)           ;
          ;------------------------------------------------------------;

          MV        .1X      B_si10,            A_si10
          MPYHIR    .2       B_co10,            B_xt1,            B_p0r
          MPYHIR    .1X      A_si10,            B_yt1,            A_p1r
          SUB       .2X      B_p0r,             A_p1r,            B_y_h2_0
          DOTPNRSU2 .2       B_xt1yt1,          B_co10si10,       B_p01r
          ADDAH     .2       B_y_h2_0,          B_p01r,           B_y_h2_0

          MPYHIR    .2       B_co10,            B_yt1,            B_p0c
          MPYHIR    .1X      A_si10,            B_xt1,            A_p1c
          ADD       .2       B_p0c,             A_p1c,            B_y_h2_1
          DOTPRSU2  .2       B_yt1xt1,          B_co10si10,       B_p01c
          ADDAH     .2       B_y_h2_1,          B_p01c,           B_y_h2_1

          ;------------------------------------------------------------;
          ; x2[l1  ] = _mpyhir(si20 , yt0_0) - _mpyhir(co20 , xt0_0) + ;
          ;           (_dotprsu2(yt0_0xt0_0, si20co20) << 1)           ;
          ;                                                            ;
          ; x2[l1+1] = _mpyhir(co20 , yt0_0) + _mpyhir(si20 , xt0_0) + ;
          ;           (_dotpnrsu2(yt0_0xt0_0, co20si20) << 1)          ;
          ;------------------------------------------------------------;

          MPYHIR    .1       A_co20,            A_xt0,            A_p2r
          MPYHIR    .1       A_si20,            A_yt0,            A_p3r
          SUB       .1       A_p2r,             A_p3r,            A_y_l1_0
          DOTPNRSU2 .1       A_xt0yt0,          A_co20si20,       A_p23r
          ADDAH     .1       A_y_l1_0,          A_p23r,           A_y_l1_0

          MPYHIR    .1       A_co20,            A_yt0,            A_p2c
          MPYHIR    .1       A_si20,            A_xt0,            A_p3c
          ADD       .1       A_p2c,             A_p3c,            A_y_l1_1
          DOTPRSU2  .1       A_yt0xt0,          A_co20si20,       A_p23c
          ADDAH     .1       A_y_l1_1,          A_p23c,           A_y_l1_1

         ;-------------------------------------------------------------;
         ; x2[l2  ] = _mpyhir(si30 , yt2_0) + _mpyhir(co30 , xt2_0) +  ;
         ;           (_dotprsu2(yt2_0xt2_0, si30co30) << 1)            ;
         ;                                                             ;
         ; x2[l2+1] = _mpyhir(co30 , yt2_0)   - _mpyhir(si30, xt2_0) + ;
         ;              (_dotpnrsu2(yt2_0xt2_0, co30si30) << 1)        ;
         ;-------------------------------------------------------------;

          MPYHIR    .2       B_co30,            B_xt2,            B_p4r
          MPYHIR    .2       B_si30,            B_yt2,            B_p5r
          SUB       .2       B_p4r,             B_p5r,            B_y_l2_0
          DOTPNRSU2 .2       B_xt2yt2,          B_co30si30,       B_p45r
          ADDAH     .2       B_y_l2_0,          B_p45r,           B_y_l2_0

          MPYHIR    .2       B_co30,            B_yt2,            B_p4c
          MPYHIR    .2       B_si30,            B_xt2,            B_p5c
          ADD       .2       B_p4c,             B_p5c,            B_y_l2_1
          DOTPRSU2  .2       B_yt2xt2,          B_co30si30,       B_p45c
          ADDAH     .2       B_y_l2_1,          B_p45c,           B_y_l2_1

          ;-----------------------------------------------------------;
          ; Derive output pointers using the input pointer "x"        ;
          ;-----------------------------------------------------------;

          MVD       .1       A_x,               A_x_1
          MV       .2X       A_x_1,             B_x__

          ;-----------------------------------------------------------;
          ; Loop control for loop coalescing                          ;
          ;                                                           ;
          ; When the twiddle factors are not to be re-used, j is      ;
          ; incremented by 6, to reflect the fact that 6 half words   ;
          ; are consumed in every iteration. The input data pointer   ;
          ; increments by 2. Note that within a stage, the stride     ;
          ; does not change and hence the offsets for the other three ;
          ; legs, 0, h2, l1, l2.                                      ;
          ;-----------------------------------------------------------;

          SUB      .1X       A_j,                  B_fft_jmp,       A_ifj
          ADD      .1        A_j,                  3,               A_j
[!A_ifj]  ADD      .1        A_x,                  A_fft_jmp,       A_x
          ADD      .1        A_x,                  8,               A_x
[!A_ifj]  ZERO     .1        A_j
          MV       .2        A_j,                  B_j

          ;-----------------------------------------------------------;
          ;  Perform stores to the four output legs of the butterfly  ;
          ;  The acceses are performed as double word wide accesses   ;
          ; to minimize the accesses to memory.                       ;
          ;-----------------------------------------------------------;

          STDW     .D1T1     A_y_h1_1:A_y_h1_0,   *A_x_1[0]
          STDW     .D2T2     B_y_h2_1:B_y_h2_0,   *B_x__[B_h2]
          STDW     .D2T1     A_y_l1_1:A_y_l1_0,   *B_x__[B_l1]
          STDW     .D2T2     B_y_l2_1:B_y_l2_0,   *B_x__[B_l2]

          ;-----------------------------------------------------------;
          ;  Perform decrement and branch on the loop counter "i"     ;
          ;-----------------------------------------------------------;

          BDEC     .1        LOOP_Y,              A_i

          CMPGTU   .2X       B_stride,            A_radix,         B_while
[B_while] B        .2        LOOP_WHILE

          ;-----------------------------------------------------------;
          ; The following code performs either a standard radix4 pass ;
          ; radix2 pass. Two pointers are used to access the input.   ;
          ; The input data is read "N/4" complex samples apart or     ;
          ; "N/2" words apart using pointers "x0" and "x2". This      ;
          ; produces outputs that are 0, N/4, N/2, 3N/4 for a radix4  ;
          ; FFT, and 0, N/8, N/2, 3N/8 for radix 2.                   ;
          ; The following pointers are therfore set up. They are set  ;
          ; up as twin pointers so that data accesses can parallelize ;
          ;                                                           ;
          ; y0 = ptr_y                                                ;
          ; y2 = ptr_y + (int) npoints                                ;
          ; x0 = ptr_x                                                ;
          ; x2 = ptr_x + (int) (npoints>>1)                           ;
          ;-----------------------------------------------------------;

          SUB      .1      A_radix,             2,               A_r2

          MV       .1      A_ptr_x,             A_p_x0
          ADD      .2X     A_ptr_x,             8,               B_p_x0
          MV       .2      B_ptr_y,             B_p_y0
          ADDAW    .2      B_p_y0,              B_n,             B_p_y2

          ADDAH    .2      B_p_y0,              B_n,             B_p_y1
          ADDAH    .2      B_p_y2,              B_n,             B_p_y3

          ;-----------------------------------------------------------;
          ; Prepare shift amount for digit reversed index and the     ;
          ; increment amount assuming that the radix is 4.            ;
          ;-----------------------------------------------------------;

          NORM     .2      B_n,                 B_l1
          ADD      .2      B_l1,                2,               B_l1
          MVK      .2      4,                   B_j0

          ;-----------------------------------------------------------;
          ;  Change pointers as required, and the increment amount if ;
          ; radix 2 is required.                                      ;
          ;                                                           ;
          ; if (radix == 2)                                           ;
          ; {                                                         ;
          ;    y1  = y0 + (int) (npoints >> 2)                        ;
          ;    y3  = y2 + (int) (npoints >> 2)                        ;
          ;    l1  = _norm(npoints) + 1                               ;
          ;    j0  = 8                                                ;
          ;    n0  = npoints >> 1                                     ;
          ; }                                                         ;
          ;-----------------------------------------------------------;

[!A_r2]   ADD      .2      B_p_y0,              B_n,             B_p_y1
[!A_r2]   ADD      .2      B_p_y2,              B_n,             B_p_y3
[!A_r2]   NORM     .2      B_n,                 B_l1
[!A_r2]   ADD      .2      B_l1,                1,               B_l1
[!A_r2]   MVK      .2      8,                   B_j0

          ;----------------------------------------------------------;
          ; Loop counter for the following loop is npoints >> 2. In  ;
          ; addition deduct 2 from the loop trip counter to account  ;
          ; for BDEC.                                                ;
          ;----------------------------------------------------------;

          SHRU     .1X     B_n,                 2,               A_i
          SUB      .1      A_i,                 2,               A_i
          ZERO     .2      B_j

          .mptr      A_p_x0, A_x+0, 16
          .mptr      B_p_x0, A_x+2, 16
          ;.mptr      B_p_y0, A_x+0, 0
          ;.mptr      B_p_y1, A_x+2, 0
          ;.mptr      B_p_y2, A_x+0, 0
          ;.mptr      B_p_y3, A_x+2, 0

LOOP_Z:  .trip 8

          ;----------------------------------------------------------;
          ; Digit reverse the index starting from 0. The increment   ;
          ; "j" is either by 4, or 8.                                ;
          ;                                                          ;
          ;  h2   = _deal(j)                                         ;
          ;  h2   = _bitr(h2)                                        ;
          ;  h2   = _rotl(h2, 16)                                    ;
          ;  h2   = _shfl(h2)                                        ;
          ;  h2  >>= l1                                              ;
          ;----------------------------------------------------------;
          DEAL     .2      B_j,                 B_h0
          BITR     .2      B_h0,                B_h1
          ROTL     .2      B_h1,                16,              B_h2
          SHFL     .2      B_h2,                B_h3
          SHRU     .2      B_h3,                B_l1,            B_h4
          ADD      .2      B_j,                 B_j0,            B_j

          ;----------------------------------------------------------;
          ; Read in the input data, from the first eight locations.  ;
          ; These are transformed either as a radix4 or as radix 2.  ;
          ;----------------------------------------------------------;

          LDDW    .D1T1    *A_p_x0++[2],        A_x1:A_x0
          LDDW    .D2T2    *B_p_x0++[2],        B_x3:B_x2
          LDDW    .D1T1    *A_p_x0++[2],        A_x5:A_x4
          LDDW    .D2T2    *B_p_x0++[2],        B_x7:B_x6

          ;----------------------------------------------------------;
          ;  xh0_0 = x_0 + x_4      xh1_0 = x_1 + x_5                ;
          ;  xl0_0 = x_0 - x_4      xl1_0 = x_1 - x_5                ;
          ;  xh0_1 = x_2 + x_6      xh1_1 = x_3 + x_7                ;
          ;  xl0_1 = x_2 - x_6      xl1_1 = x_3 - x_7                ;
          ;----------------------------------------------------------;

          ADD     .1       A_x4,                A_x0,           A_xh0_0
          ADD     .1       A_x5,                A_x1,           A_xh1_0
          ADD     .2       B_x6,                B_x2,           B_xh0_1
          ADD     .2       B_x7,                B_x3,           B_xh1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          SUB     .1       A_x1,                A_x5,           A_xl1_0
          SUB     .2       B_x2,                B_x6,           B_xl0_1
          SUB     .2       B_x3,                B_x7,           B_xl1_1
          SUB     .1       A_x0,                A_x4,           A_xl0_0
          MV      .2       B_xl1_1,             B_xl1_1c
          MV      .1       A_xh1_0,             A_xh1_0c

          ;----------------------------------------------------------;
          ;  Replace results conditionally if it is determined that  ;
          ;  it is a radix 2 pass as follows:                        ;
          ;                                                          ;
          ;  xh0_0 = x0              xh1_0  = x1                     ;
          ;  xh0_1 = x2              xh1_1  = x3                     ;
          ;  xl0_0 = x4              xl1_0  = x5,                    ;
          ;  xl0_1 = x7              xl1_1  = x6                     ;
          ;----------------------------------------------------------;

[!A_r2]   ROTL    .1       A_x0,                0,              A_xh0_0
[!A_r2]   ROTL    .1       A_x1,                0,              A_xh1_0c
[!A_r2]   ROTL    .2       B_x2,                0,              B_xh0_1
[!A_r2]   ROTL    .2       B_x3,                0,              B_xh1_1

[!A_r2]   ROTL    .1       A_x4,                0,              A_xl0_0
[!A_r2]   ROTL    .1       A_x5,                0,              A_xl1_0
[!A_r2]   SUB     .2       0,                   B_x6,           B_xl1_1c
[!A_r2]   SUB     .2       0,                   B_x7,           B_xl0_1

          ;---------------------------------------------------------;
          ; radix4:  y0 = xh0_0 + xh0_1    radix2: y0 = x0 + x2     ;
          ; radix4:  y1 = xh1_0 + xh1_1    radix2: y1 = x1 + x3     ;
          ; radix4:  y4 = xh0_0 - xh1_1    radix2: y4 = x0 - x2     ;
          ; radix4:  y5 = xh1_0 - xh1_1    radix2: y5 = x1 - x3     ;
          ;---------------------------------------------------------;

          ADD     .2X      A_xh0_0,             B_xh0_1,        B_y0
          ADD     .2X      A_xh1_0c,            B_xh1_1,        B_y1
          SUB     .2X      A_xh0_0,             B_xh0_1,        B_y4
          SUB     .2X      A_xh1_0c,            B_xh1_1,        B_y5

          ;---------------------------------------------------------;
          ; radix4:  y2 = xl0_0 + xl1_1    radix2: y2 = x4 + x6     ;
          ; radix4:  y3 = xl1_0 + xl0_1    radix2: y7 = x5 + x7     ;
          ; radix4:  y6 = xl0_0 - xl1_1    radix2: y6 = x4 - x6     ;
          ; radix4:  y7 = xl1_0 - xl0_1    radix2: y3 = x5 - x7     ;
          ;---------------------------------------------------------;

          SUB     .1X      A_xl0_0,             B_xl1_1c,       A_y2
          ADD     .1X      A_xl1_0,             B_xl0_1,        A_y3
          ADD     .1X      A_xl0_0,             B_xl1_1c,       A_y6
          SUB     .1X      A_xl1_0,             B_xl0_1,        A_y7

          ;---------------------------------------------------------;
          ;  Swap y3, y7 if radix2   y2 = x4 + x6, y3 = x5 + x7,    ;
          ;                          y6 = x4 - x6, y7 = x5 - x7     ;
          ;---------------------------------------------------------;

          MV      .1       A_y3,                A_temp
[!A_r2]   MV      .1       A_y7,                A_y3
[!A_r2]   MV      .1       A_temp,              A_y7

           ;--------------------------------------------------------;
           ; Store using digit reversed index, bit reversed index   ;
           ; and pointers p_y0,...p_y3                              ;
           ;--------------------------------------------------------;

          STDW    .D2T2    B_y1:B_y0,           *B_p_y0[B_h4]
          STDW    .D2T1    A_y3:A_y2,           *B_p_y1[B_h4]
          STDW    .D2T2    B_y5:B_y4,           *B_p_y2[B_h4]
          STDW    .D2T1    A_y7:A_y6,           *B_p_y3[B_h4]

          ;---------------------------------------------------------;
          ;  Decrement and branch back to LOOP_Z                    ;
          ;---------------------------------------------------------;

          BDEC    .1       LOOP_Z,              A_i

        .return
        .endproc

*============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*
iirlat.sa/      1066929506  0     0     0       11160     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Thu Oct  3 16:41:44 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_iirlat                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       22-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int          nx,                                                *
*           const short *restrict k,                                        *
*           int          nk,                                                *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       );                                                                  *
*                                                                           *
*       x[nx]   : Input vector (16-bit)                                     *
*       nx      : Length of input vector.                                   *
*       k[nk]   : Reflection coefficients in Q.15 format                    *
*       nk      : Number of reflection coefficients/lattice stages          *
*       b[nk+1] : Delay line elements from previous call. Should be         *
*                 initialized to all zeros prior to the first call.         *
*       r[nx]   : Output vector (16-bit)                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine implements a real all-pole IIR filter in lattice       *
*       structure (AR lattice). The filter consists of nk lattice stages.   *
*       Each stage requires one reflection coefficient k and one delay      *
*       element b. The routine takes an input vector x[] and returns the    *
*       filter output in r[]. Prior to the first call of the routine the    *
*       delay elements in b[] should be set to zero. The input data may     *
*       have to be pre-scaled to avoid overflow or achieve better SNR. The  *
*       reflections coefficients lie in the range -1.0 < k < 1.0. The       *
*       order of the coefficients is such that k[nk-1] corresponds to the   *
*       first lattice stage after the input and k[0] corresponds to the     *
*       last stage.                                                         *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int         nx,                                                 *
*           const short *restrict k,                                        *
*           int         nk,                                                 *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       )                                                                   *
*       {                                                                   *
*           int rt;     /* output       */                                  *
*           int i, j;                                                       *
*                                                                           *
*           for (j=0; j<nx; j++)                                            *
*           {                                                               *
*               rt = x[j] << 15;                                            *
*                                                                           *
*               for (i = nk - 1; i >= 0; i--)                               *
*               {                                                           *
*                   rt       = rt   - (short)(b[i] >> 15) * k[i];           *
*                   b[i + 1] = b[i] + (short)(rt   >> 15) * k[i];           *
*               }                                                           *
*                                                                           *
*               b[0] = rt;                                                  *
*                                                                           *
*               r[j] = rt >> 15;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_iirlat"
        .global _DSP_iirlat
_DSP_iirlat:  .cproc  A_xp, B_nx, A_kp, B_nk, A_bp, B_rp
;                    A4,   B4,   A6,   B6,   A8,   B8

    .no_mdep

    .reg A_x, A_rt, B_i, B_nk1, B_bp, B_bpn, A_bpn
    .reg A_b1, B_b2, A_k1k2, A_k1k2x, A_bk1, B_bk2
    .reg A_rt1, A_rtk1, A_rtk2, B_b2x, A_b1x, A_b1xx
    .reg A_b0n, B_b1n, A_r, B_j, A_nk, B_kp
    .reg A_bp_rst, A_nk4_4, A_nk4, B_nk2, B_i_rst


        SUB   .2    B_nx,       2,      B_j
        SHL   .1X   B_nk,       2,      A_nk4     ; nk*=4
        ADD   .1    A_nk4,      4,      A_nk4_4   ; nk+=4
        ADD   .1    A_bp,       A_nk4_4,A_bp_rst  ; &b[nk+1]

        SHR   .2    B_nk,       1,      B_nk2
        SUB   .2    B_nk2,      2,      B_i_rst

loop_j:
        LDH   .D1T1 *A_xp++,    A_x               ; x[j]
        SHL   .1    A_x,        16,     A_rt      ; rt=x[j]<<16

        MV    .2    B_i_rst,    B_i               ; i=nk/2-2

        MV    .1    A_bp_rst,   A_bp              ; &b[nk+1] (load)
        SUB   .2X   A_bp_rst,   4,      B_bp      ; &b[nk]   (load)
        SUB   .1    A_bp_rst,   4,      A_bpn     ; store new b
        SUB   .2X   A_bp_rst,   8,      B_bpn     ; store new b

        ADDAH .2X   A_kp,       B_nk,   B_kp      ; &k[nk]

    .mptr   A_bp,  x,    -8
    .mptr   B_bp,  x+4,  -8
    .mptr   A_bpn, x,    -8
    .mptr   B_bpn, x+4,  -8
    .mptr   B_kp,  y,    4
loop_i:
        LDW   .D1T1 *--A_bp[2], A_b1              ; b[nk-1]
        LDW   .D2T2 *--B_bp[2], B_b2              ; b[nk-2]
        LDW   .D2T1 *--B_kp,    A_k1k2            ; k[nk-1],k[nk-2]
        LDW   .D2T1 *B_kp,      A_k1k2x           ; split live-to-long

        SMPYH .1   A_b1,        A_k1k2,  A_bk1    ; bk1=b[nk-1]*k[nk-1]
        SMPYHL.2X  B_b2,        A_k1k2,  B_bk2    ; bk2=b[nk-2]*k[nk-2]

        SUB   .1   A_rt,        A_bk1,  A_rt1     ; rt1=rt-bk1
        SUB   .1X  A_rt1,       B_bk2,  A_rt      ; rt=rt1-bk2

        SMPYH .1   A_rt1,       A_k1k2x, A_rtk1   ; rtk1=rt1*k[nk-1]
        SMPYHL.1   A_rt,        A_k1k2x, A_rtk2   ; rtk2=rt *k[nk-2]

        MVD   .2   B_b2,        B_b2x             ; split live-to-long
        MVD   .1   A_b1,        A_b1x             ; split live-to-long
        MV    .1   A_b1x,       A_b1xx            ; split live-to-long
        ADD   .1   A_b1xx,      A_rtk1, A_b0n     ; b0n=b[nk-1]+rtk1
        ADD   .2X  B_b2x,       A_rtk2, B_b1n     ; b1n=b[nk-2]+rtk2

        STW   .D1T1 A_b0n,      *A_bpn--[2]       ; b[nk]=b0n
        STW   .D2T2 B_b1n,      *B_bpn--[2]       ; b[nk-1]=b1n

        BDEC  .2   loop_i,      B_i

        STW   .D1T1 A_rt,       *A_bpn            ; b[0]=rt
        SHR   .1    A_rt,       16,     A_r       ; r=rt>>16
        STH   .D2T1 A_r,        *B_rp++           ; r[j]=r

        BDEC  .2    loop_j,     B_j

       .endproc

* ========================================================================= *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

iir.sa/         1066929506  0     0     0       15103     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Tue Jun 24 17:03:37 2003 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       iir -- Infinite Impulse Response Filter/ ARMA filter,               *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable and can be called as:                    *
*                                                                           *
*       void DSP_iir                                                        *
*       (                                                                   *
*           short *restrict r1,                                             *
*           const short *x,                                                 *
*           short *restrict r2,                                             *
*           const short *h2,                                                *
*           const short *h1,                                                *
*           int nr                                                          *
*       )                                                                   *
*                                                                           *
*       r1[nr+4] : Output array (used).                                     *
*       x[nr+4]  : Input array.                                             *
*       r2[nr]   : Output array (stored).                                   *
*       h1[5]    : 4 Autoregressive filter coefficients (h1[0] is not used) *
*       h2[5]    : 5 Moving-average filter coefficients.                    *
*       nr       : Number of output samples. Must be >= 8.                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IIR performs an auto-regressive moving-average (ARMA) filter    *
*       with 4 auto-regressive filter coefficients and 5 moving-average     *
*       filter coefficients for nr output samples. The output vector is     *
*       stored in two locations.  This routine is used as a high pass       *
*       filter in the VSELP vocoder.                                        *
*                                                                           *
*   C CODE                                                                  *
*       void iir(short *restrict r1, const short *x, short *restrict r2,    *
*                const short *h2, const short *h1, int nr)                  *
*       {                                                                   *
*           int j,i;                                                        *
*           int sum;                                                        *
*                                                                           *
*           for (i=0; i<nr; i++)                                            *
*           {                                                               *
*               sum = h2[0] * x[4+i];                                       *
*                  for (j = 1; j <= 4; j++)                                 *
*                   sum += h2[j]*x[4+i-j] - h1[j]*r1[4+i-j];                *
*               r1[4+i] = (sum >> 15);                                      *
*               r2[i] = r1[4+i];                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Reads to the output array to get the previous output samples        *
*       for AR filtering are avoided by maintaining copies of the           *
*       samples in the register file.  The accumulator for the "AR"         *
*       part and the "FIR" part are de-coupled to break data                *
*       dependencies.  Inner loop that iterates through the filter          *
*       coefficients is completely unrolled.                                *
*                                                                           *
*       C64x multiply instructions such as DOTP2 are used for the FIR       *
*       portion of the computation, and the lower latency MPY               *
*       instructions are used for the IIR portion.                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       "nr" is greater than or equal to 8.                                 *
*                                                                           *
*       Input data array "x" contains "nr + 4" input samples to produce     *
*       "nr" output samples.                                                *
*                                                                           *
*       Output array "r1" contains "nr + 4" locations, "r2" contains        *
*       "nr" locations for storing "nr" output samples. The output          *
*       samples are stored with an offset of 4 into the "r1" array.         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_iir_DSPLIB"
        .global _DSP_iir
_DSP_iir:  .cproc  A_r1,  B_x,  A_r2,  B_h2,  A_h1,  B_nr
                 .no_mdep

          .reg      B_h20,        B_h24_h23:B_h22_h21
          .reg      A_h24_h23,    B_h1
          .reg      B_h11,        A_h12
          .reg      A_h13,        B_h14
          .reg      B_h12,        A_h14
          .reg      A_i,          A_x
          .reg      B_r2_ptr,     B_r1_ptr
          .reg      B_sum0_s,     B_sum1_s
          .reg      A_sum2_s,     A_sum3_s
          .reg      B_r1
          .reg      A_h23_h24
          .reg      A_h21_h22

          ; Variables within the loop

          .reg     B_x4,          A_x32:A_x10
          .reg     A_prod0,       A_prod1
          .reg     B_prod2,       A_prod3
          .reg     B_sum0,        B_mpy0
          .reg     B_mpy1,        A_mpy2
          .reg     A_mpy3,        A_add1
          .reg     B_sumA,        B_sumB
          .reg     B_sumC,        B_h21_h22

          ;--------------------------------------------------------------;
          ; Pre-read the filter coefficients for the FIR part, as        ;
          ; packed coeffients so that _dotp2 can be used.                ;
          ;--------------------------------------------------------------;

          LDH.D2T2   *B_h2[0],      B_h20
          LDNDW.D2T2 *+B_h2(2),     B_h24_h23:B_h22_h21
          MV.1x       B_h24_h23,    A_h24_h23

          PACKLH2.1   A_h24_h23,    A_h24_h23,      A_h23_h24
          PACKLH2.2   B_h22_h21,    B_h22_h21,      B_h21_h22
          MV     .1x  B_h21_h22,    A_h21_h22

          ;--------------------------------------------------------------;
          ; Set up twin pointers to the "h1" array and read the filter   ;
          ; coefficients as half words so that _mpy's can be used.       ;
          ;--------------------------------------------------------------;

          ADD.1       A_h1,          2,              A_h1
          ADD.2x      A_h1,          2,              B_h1

          LDH.D1T2    *A_h1++[2],    B_h11
          LDH.D2T1    *B_h1++[2],    A_h12
          LDH.D1T1    *A_h1++[2],    A_h13
          LDH.D2T2    *B_h1++[2],    B_h14

          ;--------------------------------------------------------------;
          ; Negate all these coefficients so that all accumulates can    ;
          ; be performed as add's.                                       ;
          ;--------------------------------------------------------------;

          NEG.2      B_h11,         B_h11
          NEG.2x     A_h12,         B_h12
          NEG.1      A_h13,         A_h13
          NEG.1x     B_h14,         A_h14

          ;--------------------------------------------------------------;
          ; Decrement 2 from the loop trip counter as "BDEC" is being    ;
          ; used. In addition set up pointers to "r1" and "r2" arrays.   ;
          ;--------------------------------------------------------------;

          SUB.1x     B_nr,          2,              A_i
          MV.1x      B_x,           A_x
          MV.2x      A_r2,          B_r2_ptr
          ADD.2x     A_r1,          8,              B_r1_ptr

          MV.2x      A_r1,          B_r1
          LDH.D1T2   *A_r1[3],      B_sum0_s
          LDH.D1T2   *A_r1[2],      B_sum1_s
          LDH.D2T1   *B_r1[1],      A_sum2_s
          LDH.D2T1   *B_r1[0],      A_sum3_s

          .mptr      A_x,          A_x+0,   2
          .mptr      B_r1_ptr,     A_x+0,   2
          .mptr      B_r2_ptr,     A_x+0,   2
LOOP:     .trip      8

          ;-------------------------------------------------------------;
          ; Load the five input data samples, using one load half word  ;
          ; and a non-aligned load double word. The data pointer incr-  ;
          ; ements by 1 half-word or 2 bytes with every iteration.      ;
          ;-------------------------------------------------------------;

          LDH.D1T2   *+A_x[4],     B_x4
          LDNDW.D1T1 *A_x++(2),    A_x32:A_x10

          ;-------------------------------------------------------------;
          ; Perform FIR part of the ARMA filter, using DOTP2's. Use     ;
          ; seperate accumualtor for the FIR and AR parts.              ;
          ;-------------------------------------------------------------;

          DOTP2.1    A_x10,        A_h23_h24,       A_prod0
          DOTP2.1    A_x32,        A_h21_h22,       A_prod1
          MPY.2      B_x4,         B_h20,           B_prod2

          ADD.1      A_prod1,      A_prod0,         A_prod3
          ADD.2x     A_prod3,      B_prod2,         B_sum0

          ;-------------------------------------------------------------;
          ; Perform AR part of the filter using normal MPY's because    ;
          ; of the loop carried dependencies. Latency of the multiply   ;
          ; instruction is critical as it is on the critical path.      ;
          ;-------------------------------------------------------------;

          MPY.2      B_sum0_s,     B_h11,           B_mpy0
          MPY.2      B_sum1_s,     B_h12,           B_mpy1
          MPY.1      A_sum2_s,     A_h13,           A_mpy2
          MPY.1      A_sum3_s,     A_h14,           A_mpy3

          ADD.1      A_mpy2,       A_mpy3,          A_add1
          ADD.2x     B_mpy1,       A_add1,          B_sumA
          ADD.2      B_sumA,       B_sum0,          B_sumB

          ;-------------------------------------------------------------;
          ; Combine results of the FIR and AR part of the filter eq-    ;
          ; uations. Maintain past outputs in rotating register file    ;
          ; Shift present output by 15, and then store out to the       ;
          ; output arrays.                                              ;
          ;-------------------------------------------------------------;

          ADD.2      B_sumB,       B_mpy0,          B_sumC

          MV.1       A_sum2_s,     A_sum3_s
          MV.2x      B_sum1_s,     A_sum2_s
          MV.2       B_sum0_s,     B_sum1_s
          EXT.2      B_sumC,       1, 16,           B_sum0_s

          STH.D2T2   B_sum0_s,     *B_r1_ptr++
          STH.D2T2   B_sum0_s,     *B_r2_ptr++

          ;-------------------------------------------------------------;
          ; Decrement and branch back to the loop.                      ;
          ;-------------------------------------------------------------;

          BDEC.1     LOOP,         A_i

         .endproc

* ========================================================================= *
*   End of file:  dsp_iir.sa                                                *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mat_mul.sa/     1066929506  0     0     0       21444     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.1     Mon Feb 11 15:32:08 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_mat_mul -- Matrix Multiply, Little Endian                       *
*                                                                           *
*    REVISION DATE                                                          *
*        06-Feb-2002                                                        *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mat_mul                                                *
*           (                                                               *
*               const short *restrict x, int r1, int c1,                    *
*               const short *restrict y,         int c2,                    *
*               short       *restrict r,                                    *
*               int                   qs                                    *
*           );                                                              *
*                                                                           *
*       x  == Pointer to r1 by c1 input matrix.                             *
*       y  == Pointer to c1 by c2 input matrix.                             *
*       r  == Pointer to r1 by c2 output matrix.                            *
*                                                                           *
*       r1 == Number of rows in x.                                          *
*       c1 == Number of columns in x.  Also number of rows in y.            *
*       c2 == Number of columns in y.                                       *
*                                                                           *
*       qs == Final right-shift to apply to the result.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function computes the expression "r = x * y" for the           *
*       matrices x and y.  The columnar dimension of x must match           *
*       the row dimension of y.  The resulting matrix has the same          *
*       number of rows as x and the same number of columns as y.            *
*                                                                           *
*       The values stored in the matrices are assumed to be fixed-point     *
*       or integer values.  All intermediate sums are retained to 32-bit    *
*       precision, and no overflow checking is performed.  The results      *
*       are right-shifted by a user-specified amount, and then truncated    *
*       to 16 bits.                                                         *
*                                                                           *
*       This code is suitable for dense matrices.  No optimizations are     *
*       made for sparse matrices.                                           *
*                                                                           *
*       The following is a C description of the algorithm.  The assembly    *
*       code may place restrictions on the inputs that the C code version   *
*       does not.  These restrictions are noted under ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_mat_mul                                                    *
*       (                                                                   *
*           const short *restrict x, int r1, int c1,                        *
*           const short *restrict y,         int c2,                        *
*           short       *restrict r,                                        *
*           int                   qs                                        *
*       )                                                                   *
*       {                                                                   *
*           int i, j, k;                                                    *
*           int sum;                                                        *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Multiply each row in x by each column in y.  The    */      *
*           /*  product of row m in x and column n in y is placed   */      *
*           /*  in position (m,n) in the result.                    */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < r1; i++)                                        *
*               for (j = 0; j < c2; j++)                                    *
*               {                                                           *
*                   sum = 0;                                                *
*                                                                           *
*                   for (k = 0; k < c1; k++)                                *
*                       sum += x[k + i*c1] * y[j + k*c2];                   *
*                                                                           *
*                   r[j + i*c2] = sum >> qs;                                *
*               }                                                           *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That   *
*       is, in-place processing is not allowed.                             *
*                                                                           *
*       The input matrices have minimum dimensions of at least 1 row and    *
*       1 column, and maximum dimensions of 32767 rows and 32767 columns.   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 'i' loop and 'k' loops are unrolled 2x.  The 'j' loop is        *
*       unrolled 4x.  For dimensions that are not multiples of the          *
*       various loops' unroll factors, this code calculates extra results   *
*       beyond the edges of the matrix.  These extra results are            *
*       ultimately discarded.  This allows the loops to be unrolled for     *
*       efficient operation on large matrices, while not losing             *
*       flexibility.                                                        *
*                                                                           *
*       The outer two levels of loop nest are collapsed, further reducing   *
*       the overhead of the looping structure.                              *
*                                                                           *
*   NOTES                                                                   *
*       When calculating the loop trip counts, the values of r1 and c1      *
*       are rounded up to the next even value.  The value of c2 is          *
*       rounded up to the next multiple of 4.  This does not affect         *
*       the memory layout of the input or output matrices.                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code has no memory alignment requirements, as non-aligned      *
*       loads are used for accessing the inputs, and individual STHs are    *
*       used for writing the results.                                       *
*                                                                           *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mat_mul"
        .global _DSP_mat_mul
_DSP_mat_mul .cproc  A_xa, B_r1, A_c1, B_y, A_c2, B_r, A_qs
            .no_mdep


            ; Generate scaled versions of c1 and c2, since we're using
            ; non-scaled addition for our pointer updates in a few places.
            .reg            A_c1_2, A_c1_4, B_c2_2, B_c2_4, B_c2
            SHL     .1      A_c1,       1,          A_c1_2
            SHL     .1      A_c1,       2,          A_c1_4
            MV      .2X     A_c2,       B_c2
            SHL     .2      B_c2,       1,          B_c2_2
            SHL     .2      B_c2,       2,          B_c2_4


            ; Set up the modified loop trip counters.
            ; A_kc is the counter reload for B_k
            ;
            ;   i  = (r1 + r1o) >> 1
            ;   kc = (c1 + c1o) >> 1

            .reg            B_r1o,      B_ic_,      A_i
            AND     .2      B_r1,       1,          B_r1o
            ADD     .2      B_r1o,      B_r1,       B_ic_
            SHRU    .1X     B_ic_,      1,          A_i

            ; Initialize the J loop
            .reg            A_j
            SUB             A_c2,       0,          A_j

            .reg            A_c1o,      A_kc_,      A_kc,       A_k
            AND     .1      A_c1,       1,          A_c1o
            ADD     .1      A_c1o,      A_c1,       A_kc_
            SHRU    .1      A_kc_,      1,          A_kc


            ; Set up the xa re-init pointer
            ; If c1 is odd, rewind xa one halfword
            .reg            A_xa_sv,    A_xb
            SUBAH           A_xa,       A_c1o,      A_xa
            MV              A_xa,       A_xa_sv

            ; Set up the ya, yb re-init pointers.
            ; B_ya_sv is the saved ya value.  B_ya_yb is the offset between
            ; B_ya and B_yb.
            ;
            ; If c1 is even:    B_y starts at &y[  0]
            ; If c1 is odd:     B_y starts at &y[-c1]

            .reg            B_y_sv, B_y_sv2
  [ A_c1o]  SUB     .2      B_y,        B_c2_2,     B_y

            MV              B_y,        B_y_sv
            MV              B_y,        B_y_sv2


            ; Set up the r re-init pointer
            .reg            B_r_sv
            MV              B_r,        B_r_sv

            ; Twin A_qs
            .reg            B_qs
            MV      .2X     A_qs,       B_qs

            ;   for (i = 0; i < r1; i += 2)
            ;       for (j = 0; j < c2; j += 4)
            ;       {
  [ A_c1o]  ZERO            A_y32:A_y10
  [!A_c1o]  LDNDW   .D2T1   *B_y_sv,                A_y32:A_y10
            ADD             B_y_sv,     B_c2_4,     B_ya
            ADD             B_y_sv,     B_c2_2,     B_y
loop_ij:    .trip 1
            .reg    B_s13:B_s11, B_s12:B_s10
            .reg    A_s03:A_s01, A_s02:A_s00
            .reg    A_y32:A_y10, B_y32:B_y10
            .reg    B_xNA:B_x11, A_x00
            .reg    B_y33,B_y22, B_y11,B_y00
            .reg    B_p13,B_p12, B_p11,B_p10
            .reg    A_p03,A_p02, A_p01,A_p00


            SUB     .1      A_kc,       2,          A_k
            ZERO    .2      B_s13:B_s11
            ZERO    .2      B_s12:B_s10
            ZERO    .1      A_s03:A_s01
            ZERO    .1      A_s02:A_s00

            ; A_xa points to &x[k + (i + 0) * c1]
            ; A_xb points to &x[k + (i + 1) * c1]
            ;
            ; c1_2 == c1 * 2
            ; c1_4 == c1 * 4
            ; c2_2 == c2 * 2
            ; c2_4 == c2 * 4
            .reg B_ya

            ADD             A_xa,       A_c1_2,     A_xb

            ;           for (k = 0; k < c1; k++)
            ;           {
loop_k:     .trip 1

            ;               x11     = _mem4_const(&x[k + (i + 1)*c1]);
            ;               x00     = _mem4_const(&x[k + (i + 0)*c1]);

            LDNW    .D1T2   *A_xb++[1],             B_x11
            LDNW    .D1T1   *A_xa++[1],             A_x00

            ;               y32b    = _mem4_const(&y[(j + 2) + (k + 1)*c2]);
            ;               y10b    = _mem4_const(&y[(j + 0) + (k + 1)*c2]);
            LDNDW   .D2T2   *B_y++(B_c2_4),         B_y32:B_y10

            ;
            ;               y33     = _packh2(y32b, y32a);
            ;               y22     = _pack2 (y32b, y32a);
            ;               y11     = _packh2(y10b, y10a);
            ;               y00     = _pack2 (y10b, y10a);

            PACKH2  .2X     B_y32,      A_y32,      B_y33
            PACK2   .2X     B_y32,      A_y32,      B_y22
            PACKH2  .2X     B_y10,      A_y10,      B_y11
            PACK2   .2X     B_y10,      A_y10,      B_y00

            ;
            ;               sum13  += _dotp2(x11, y33);
            ;               sum12  += _dotp2(x11, y22);
            ;               sum11  += _dotp2(x11, y11);
            ;               sum10  += _dotp2(x11, y00);
            ;
            ;               sum03  += _dotp2(x00, y33);
            ;               sum02  += _dotp2(x00, y22);
            ;               sum01  += _dotp2(x00, y11);
            ;               sum00  += _dotp2(x00, y00);

            DOTP2   .2      B_x11,      B_y33,      B_p13
            DOTP2   .2      B_x11,      B_y22,      B_p12
            DOTP2   .2      B_x11,      B_y11,      B_p11
            DOTP2   .2      B_x11,      B_y00,      B_p10
            DOTP2   .1X     A_x00,      B_y33,      A_p03
            DOTP2   .1X     A_x00,      B_y22,      A_p02
            DOTP2   .1X     A_x00,      B_y11,      A_p01
            DOTP2   .1X     A_x00,      B_y00,      A_p00

            ADD             B_p13,      B_s13,      B_s13
            ADD             B_p12,      B_s12,      B_s12
            ADD             B_p11,      B_s11,      B_s11
            ADD             B_p10,      B_s10,      B_s10
            ADD             A_p03,      A_s03,      A_s03
            ADD             A_p02,      A_s02,      A_s02
            ADD             A_p01,      A_s01,      A_s01
            ADD             A_p00,      A_s00,      A_s00

            LDNDW   .D2T1   *B_ya++(B_c2_4),        A_y32:A_y10
            ;
            ;               y32a = _mem4_const(&y[(j + 2) + (k + 2)*c2]);
            ;               y10a = _mem4_const(&y[(j + 0) + (k + 2)*c2]);

            BDEC    .1      loop_k,     A_k

            ;             }
            ;============ End of loop_k


            ;               sum13 >>= qs;    sum03 >>= qs;
            ;               sum12 >>= qs;    sum02 >>= qs;
            ;               sum11 >>= qs;    sum01 >>= qs;
            ;               sum10 >>= qs;    sum00 >>= qs;
            .reg            B_t13, B_t12, A_t11, A_t10
            .reg            B_t03, B_t02, A_t01, A_t00

            SHR     .2      B_s13,      B_qs,       B_t13
            SHR     .2      B_s12,      B_qs,       B_t12
            SHR     .1X     B_s11,      A_qs,       A_t11
            SHR     .1X     B_s10,      A_qs,       A_t10
            SHR     .2X     A_s03,      B_qs,       B_t03
            SHR     .2X     A_s02,      B_qs,       B_t02
            SHR     .1      A_s01,      A_qs,       A_t01
            SHR     .1      A_s00,      A_qs,       A_t00

            ;               ok_01 = (j + 1 < c2);
            ;               ok_02 = (j + 2 < c2);
            ;               ok_03 = (j + 3 < c2);
            ;               ok_10 = (i + 1 < r1);
            ;               ok_11 = ok_01 & ok_10;
            ;               ok_12 = ok_02 & ok_10;
            ;               ok_13 = ok_03 & ok_10;

            .reg            B_ok10, A_lj

            CMPGT   .2X     A_i,        B_r1o,      B_ok10
            CMPLT   .1      A_j,        5,          A_lj


            ;                          r[(i + 0)*c2 + (j + 0)] = sum00;
            ;               if (ok_01) r[(i + 0)*c2 + (j + 1)] = sum01;
            ;               if (ok_10) r[(i + 1)*c2 + (j + 0)] = sum10;
            ;               if (ok_11) r[(i + 1)*c2 + (j + 1)] = sum11;

            .reg            A_r
            .mptr           A_r,        r + 4,      0
            .mptr           B_r,        r + 0,      0


                    ;
            ADD     .1X     B_r,        4,          A_r
  [ B_ok10] STH     .D2T1   A_t10,      *B_r  [B_c2]
            STH     .D2T1   A_t00,      *B_r++[1]

  [ A_j]    SUB             A_j,        1,          A_j
  [!A_j]    ZERO            B_ok10
  [ B_ok10] STH     .D2T1   A_t11,      *B_r  [B_c2]
  [ A_j]    STH     .D2T1   A_t01,      *B_r

  [ A_j]    SUB             A_j,        1,          A_j
  [!A_j]    ZERO            B_ok10
  [ B_ok10] STH     .D1T2   B_t12,      *A_r  [A_c2]
  [ A_j]    STH     .D1T2   B_t02,      *A_r++[1]

  [ A_j]    SUB             A_j,        1,          A_j
  [!A_j]    ZERO            B_ok10
  [ B_ok10] STH     .D1T2   B_t13,      *A_r  [A_c2]
  [ A_j]    STH     .D1T2   B_t03,      *A_r


  [ A_j]    SUB             A_j,        1,          A_j

            ADD             B_r,        6,          B_r


            ; Do loop-end pointer updates.

            ADD             B_y_sv,     8,          B_y_sv  ; Adv. y 4 cols.

  [ A_lj]   MV              B_y_sv2,    B_y_sv              ; Rewind y
  [ A_lj]   ADD             A_xa_sv,    A_c1_4,     A_xa_sv ; Adv. x 2 rows
  [ A_lj]   ADD             B_r_sv,     B_c2_4,     B_r_sv  ; Adv. r 2 rows
  [ A_lj]   MV              B_r_sv,     B_r                 ; Adv. r 2 rows


  [ A_lj]   SUB             A_i,        1,          A_i
  [ A_lj]   SUB             A_c2,       0,          A_j

;           MV              B_y_sv,                 B_y
            MV              A_xa_sv,                A_xa

  [ A_c1o]  ZERO            A_y32:A_y10
  [!A_c1o]  LDNDW   .D2T1   *B_y_sv,                A_y32:A_y10
            ADD             B_y_sv,     B_c2_4,     B_ya
            ADD             B_y_sv,     B_c2_2,     B_y

  [ A_i]    B               loop_ij
            ;         }
            ;======== End of loop_ij

            .return
            .endproc



* ========================================================================= *
*   End of file:  dsp_mat_mul.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mat_trans.sa/   1066929506  0     0     0       11229     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Mon Jan 21 20:27:10 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_mat_trans                                                   *
*                                                                           *
*     REVISION DATE                                                         *
*         13-May-2001                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_mat_trans(const short *x, short rows, short columns, short *r) *
*                                                                           *
*       x       : Pointer to input matrix containing 16-bit elements        *
*       rows    : Number of rows in matrix                                  *
*       columns : Number of columnss in matrix                              *
*       r       : Pointer to output matrix (transpose of input matrix)      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The program transposes a matrix of 16-bit values and user-          *
*       determined dimensions. The result of a matrix transpose is a        *
*       matrix with the number of rows = number of columns of input matrix  *
*       and number of columns = number of rows of input matrix The value    *
*       of an elements of the output matrix is equal to the value of the    *
*       element from the input matrix with switched coordinates (rows,      *
*       columns).                                                           *
*                                                                           *
*     C CODE                                                                *
*         void DSP_mat_trans(short *x, short rows, short columns, short *r) *
*         {                                                                 *
*             short i,j;                                                    *
*             for(i=0; i<columns; i++)                                      *
*                 for(j=0; j<rows; j++)                                     *
*                     *(r+i*rows+j)=*(x+i+columns*j);                       *
*         }                                                                 *
*                                                                           *
*     TECHNIQUES                                                            *
*         Data from four adjacent rows, spaced columns apart are read, and  *
*         local 4x4 transpose is performed in the register file. This leads *
*         to four double words, that are "rows" apart. These loads and      *
*         stores can cause bank conflicts, hence non-aligned loads and      *
*         stores are used.                                                  *
*                                                                           *
*     ASSUMPTIONS                                                           *
*         rows and columns must be a multiple of 4                          *
*                                                                           *
*     NOTES                                                                 *
*         LITTLE ENDIAN Configuration used.                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_mat_trans"
        .global _DSP_mat_trans
_DSP_mat_trans: .cproc  A_x,  B_rows, A_columns,   B_r

            .no_mdep

            .reg    A_it_c,         B_it_r,      A_of_0
            .reg    A_of_1,         A_of_2,      B_of_0
            .reg    B_of_1,         B_of_2,      B_i

            .reg    A_a0z0:A_y0x0,  A_a1z1:A_y1x1
            .reg    B_a2z2:B_y2x2,  B_a3z3:B_y3x3
            .reg    B_x3x2,         B_z3z2
            .reg    A_y1y0,         B_y3y2:B_y1y0
            .reg    A_x3x2:A_x1x0
            .reg    A_z3z2:A_z1z0
            .reg    A_a1a0,         B_a3a2:B_a1a0
            .reg    A_xold,         A_of_3
            .reg    A_zero,         B_zero

            ;-------------------------------------------;
            ; Unroll the columns loop by 4. Also unroll ;
            ; inner loop. iAlos set up various constants;
            ; that will be used to access elements.     ;
            ;-------------------------------------------;

            SHRU.1      A_columns,      2,           A_it_c
            SHRU.2      B_rows,         2,           B_it_r

            ZERO.1      A_zero
            ZERO.2      B_zero

            ;------------------------------------------;
            ; Taking into account the fact that the    ;
            ; array is an array of shorts, the offsets ;
            ; are prepared as byte offsets. Thus       ;
            ; of_0 = 2 * columns                       ;
            ; of_1 = 4 * columns                       ;
            ; of_2 = 6 * columns                       ;
            ; of_3 = 8 * columns                       ;
            ;------------------------------------------;

            ADD.1       A_columns,      A_columns,   A_of_0
            ADDAW.1     A_zero,         A_columns,   A_of_1
            ADD.1       A_of_0,         A_of_1,      A_of_2
            MPY.1       A_columns,      8,           A_of_3

            ;------------------------------------------;
            ; Compute offsets to write data into       ;
            ; succesive "rows". Recall that rows of    ;
            ; the transposed matrix are "rows" apart.  ;
            ;------------------------------------------;

            ADD.2       B_rows,         B_rows,      B_of_0
            ADDAW.2     B_zero,         B_rows,      B_of_1
            MPY.2       B_rows,         6,           B_of_2

            ;------------------------------------------;
            ; Remember "x" pointer to perform move by  ;
            ; 4 columns.                               ;
            ;------------------------------------------;

            MV.1        A_x,            A_xold
LOOP_1:

            ;------------------------------------------;
            ; "i" is inner loop counter. This is ad-   ;
            ; justed by decrementing by 2 for BDEC.    ;
            ;------------------------------------------;

            SUB.2       B_it_r,         2,           B_i

            .mptr       A_x,            x+0,         0
            .mptr       B_r,            r+0,         8

LOOP_2:     .trip       1

            LDNDW.D1T1   *+A_x(A_of_0),  A_a1z1:A_y1x1
            LDNDW.D1T2   *+A_x(A_of_1),  B_a2z2:B_y2x2
            LDNDW.D1T2   *+A_x(A_of_2),  B_a3z3:B_y3x3
            LDNDW.D1T1   *A_x++(A_of_3), A_a0z0:A_y0x0

            PACK2.1       A_y1x1,         A_y0x0,      A_x1x0
            PACK2.2       B_y3x3,         B_y2x2,      B_x3x2
            PACKH2.1      A_y1x1,         A_y0x0,      A_y1y0
            PACKH2.2      B_y3x3,         B_y2x2,      B_y3y2

            MV.1x         B_x3x2,         A_x3x2
            MV.2x         A_y1y0,         B_y1y0

            PACK2.1       A_a1z1,         A_a0z0,      A_z1z0
            PACK2.2       B_a3z3,         B_a2z2,      B_z3z2
            PACKH2.1      A_a1z1,         A_a0z0,      A_a1a0
            PACKH2.2      B_a3z3,         B_a2z2,      B_a3a2

            MV.1x         B_z3z2,         A_z3z2
            MV.2x         A_a1a0,         B_a1a0

            STNDW.D2T2    B_y3y2:B_y1y0,  *+B_r(B_of_0)
            STNDW.D2T1    A_z3z2:A_z1z0,  *+B_r(B_of_1)
            STNDW.D2T2    B_a3a2:B_a1a0,  *+B_r(B_of_2)
            STNDW.D2T1    A_x3x2:A_x1x0,  *B_r++(8)

            BDEC.2        LOOP_2,         B_i

            ADD.2         B_r,            B_of_2,      B_r
            ADD.1         A_xold,         8,           A_xold
            MV.1          A_xold,         A_x

[A_it_c]    SUB.1         A_it_c,         1,           A_it_c
[A_it_c]    B.1           LOOP_1

            .return
            .endproc

* ========================================================================= *
*   End of file:  dsp_mat_trans.sa                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

maxidx.sa/      1066929506  0     0     0       14924     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.2     Wed Aug 29 10:29:57 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*=============================================================================*
*                                                                             *
*     TEXAS INSTRUMENTS, INC.                                                 *
*                                                                             *
*     NAME                                                                    *
*         DSP_maxidx                                                          *
*                                                                             *
*                                                                             *
*     REVISION DATE                                                           *
*         13-Aug-2001                                                         *
*                                                                             *
*     USAGE                                                                   *
*         This routine is C callable, and has the following C prototype:      *
*                                                                             *
*         int DSP_maxidx(short *x, int nx);                                   *
*                                                                             *
*         x       = pointer to input data                                     *
*         nx      = number of samples                                         *
*         return  = max index                                                 *
*                                                                             *
*     DESCRIPTION                                                             *
*        This routine finds the maximum value of the vector x[ ] and          *
*        returns the index of that value.                                     *
*        The input array is treated as 16 separate "columns" that are         *
*        interleaved throughout the array.  If values in different columns    *
*        are equal to the maximum value, then the element in the leftmost     *
*        column is returned.  If two values within a column are equal to      *
*        the maximum, then the one with the lower index is returned.          *
*        Column takes precedence over index.                                  *
*                                                                             *
*        int DSP_maxidx(short *x, int nx);                                    *
*        {                                                                    *
*         int    i;                                                           *
*         int    maxLocation;                                                 *
*         short  maxValue;                                                    *
*         maxLocation = 0;                                                    *
*         maxValue = Input[0];                                                *
*         for (i = 1; i < nInputs; i++) {                                     *
*                 if (maxValue < Input[i]) {                                  *
*                         maxValue = Input[i];                                *
*                         maxLocation = i;                                    *
*                 }                                                           *
*         }                                                                   *
*         return  maxLocation;                                                *
*        }                                                                    *
*                                                                             *
*        The above C code is a general implementation without  restrictions.  *
*        The assembly code may have some restrictions, as noted below.        *
*                                                                             *
*     TECHNIQUES                                                              *
*        The code is unrolled 16 times to enable the full bandwidth of LDDW   *
*        and MAX2 instructions to be utilized. This splits the search into    *
*        16 subranges. The global maximum is then found from the list of      *
*        maximums of the subsranges.                                          *
*        Then using this offset from the subranges, the global maximum and    *
*        the index of it are found using a simple match.                      *
*        For common maximums in multiple ranges, the index will be            *
*        different to the above C code.                                       *
*        A buffer of 32 bytes is reserved in .bss to hold intermediate results*
*                                                                             *
*     ASSUMPTIONS                                                             *
*        The input data are stored on double-word aligned boundaries.         *
*        nx must be a multiple of 16 and >= 48                                *
*                                                                             *
*     MEMORY NOTE                                                             *
*        This code is LITTLE_ENDIAN.                                          *
*                                                                             *
*=============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=============================================================================*
            .sect ".data:copyright_p"

            .bss    maxidx_buf, 32, 8

        .sect ".text:_maxidx"
        .global _DSP_maxidx
_DSP_maxidx:.cproc  A_Input, B_nInputs 

            .no_mdep
            .reg    B_j
            .reg    B_k
            .reg    B_n
            .reg    B_Input
            .reg    B_MaxBuf
            .reg    A_MaxBuf
            .reg    A_m3m2:A_m1m0
            .reg    B_m7m6:B_m5m4
            .reg    A_mbma:A_m9m8
            .reg    B_mfme:B_mdmc
            .reg    A_d3d2:A_d1d0
            .reg    B_d7d6:B_d5d4
            .reg    A_dbda:A_d9d8
            .reg    B_dfde:B_dddc
            .reg    A_GMax
            .reg    B_argmax
            .reg    A_max
            .reg    A_mi
            .reg    A_d0
            .reg    B_i
            .reg    A_c0
*=============================================================================*

        MVKL    maxidx_buf, A_MaxBuf
        MVKH    maxidx_buf, A_MaxBuf

        ;-------------------------------------------------;
        ; The stream is divided into 16 sub sections.     ;
        ; This allows for 16 parallel searches to be      ;
        ; perfomed.                                       ;
        ;-------------------------------------------------;

        SHRU.2      B_nInputs,     4,        B_j
        SUB.2       B_j,           3,        B_j

        ;-------------------------------------------------;
        ; Set up twin pointers for the input data array   ;
        ; Load 16 consecutive values. These are loaded    ;
        ; into the register file. This allows for 16      ;
        ; maximums ro be searched in parallel.            ;
        ;-------------------------------------------------;

        ADD.2x      A_Input,       8,        B_Input
        LDDW.D1T1   *A_Input++[2], A_m3m2:A_m1m0
        LDDW.D2T2   *B_Input++[2], B_m7m6:B_m5m4
        LDDW.D1T1   *A_Input++[2], A_mbma:A_m9m8
        LDDW.D2T2   *B_Input++[2], B_mfme:B_mdmc

        ;-------------------------------------------------;
        ; Inform the compiler that the twin pointers sh-  ;
        ; ould start on seperate memory banks.            ;
        ;-------------------------------------------------;

        .mptr        A_input,  input + 0, 32
        .mptr        B_input,  input + 8, 32

        ;-------------------------------------------------;
        ; The input data is loaded using load double      ;
        ; words. This is used to search through 16 po-    ;
        ; ssible maximums in parallel.                    ;
        ;-------------------------------------------------;

LOOPJ:  .trip 2

        ;-------------------------------------------------;
        ; Use twin input data pointers to perform loads   ;
        ;-------------------------------------------------;

        LDDW.D1T1   *A_Input++[2], A_d3d2:A_d1d0
        LDDW.D2T2   *B_Input++[2], B_d7d6:B_d5d4
        LDDW.D1T1   *A_Input++[2], A_dbda:A_d9d8
        LDDW.D2T2   *B_Input++[2], B_dfde:B_dddc

        ;-------------------------------------------------;
        ; Perform 16 way parallel search, and update the  ;
        ; maximums.                                       ;
        ;-------------------------------------------------;

        MAX2.1      A_d1d0,    A_m1m0,   A_m1m0
        MAX2.1      A_d3d2,    A_m3m2,   A_m3m2
        MAX2.2      B_d5d4,    B_m5m4,   B_m5m4
        MAX2.2      B_d7d6,    B_m7m6,   B_m7m6
        MAX2.1      A_d9d8,    A_m9m8,   A_m9m8
        MAX2.1      A_dbda,    A_mbma,   A_mbma
        MAX2.2      B_dddc,    B_mdmc,   B_mdmc
        MAX2.2      B_dfde,    B_mfme,   B_mfme

        ;-------------------------------------------------;
        ; Decrement and branch to loop.                   ;
        ;-------------------------------------------------;

        BDEC.2     LOOPJ,     B_j

        ;-------------------------------------------------;
        ; Add memory dependencies to force strict order-  ;
        ; ing of the stores and loads.                    ;
        ;-------------------------------------------------;

        .mdep       a, e
        .mdep       a, f
        .mdep       b, f
        .mdep       c, f
        .mdep       d, f

        ;-------------------------------------------------;
        ; Twin pointers are used to partition amongst     ;
        ; data paths. Indicate to compiler that they      ;
        ; point to same location.                         ;
        ;-------------------------------------------------;

        .mptr       A_MaxBuf,         max   + 0,       0
        .mptr       B_MaxBuf,         max   + 0,       0

        MV.2X       A_MaxBuf,         B_MaxBuf
        STDW.D1T1   A_m3m2:A_m1m0,   *A_MaxBuf[0]{a}
        STDW.D2T2   B_m7m6:B_m5m4,   *B_MaxBuf[1]{b}
        STDW.D1T1   A_mbma:A_m9m8,   *A_MaxBuf[2]{c}
        STDW.D2T2   B_mfme:B_mdmc,   *B_MaxBuf[3]{d}

        MV.1        A_MaxBuf,        A_GMax
        ZERO.2      B_argmax
        ZERO.2      B_i
        MVK.2       13,              B_k

        ;-------------------------------------------------;
        ; The 16 local maximas are sorted to find arggmax,;
        ; gmax. "argmax" is the maximum value found and   ;
        ; is stored at MaxBuf[0].                         ;
        ;-------------------------------------------------;

        LDH.D1T1    *A_GMax++[1]{e}, A_max

LOOPG:  .trip 15,15,15
        LDH.D1T1    *A_GMax++[1]{f}, A_mi
        CMPGT2.1    A_mi,            A_max,       A_d0
        MAX2.1      A_mi,            A_max,       A_max
        ADD.2       B_i,             1,           B_i
 [A_d0] MPY.2       1,               B_i,         B_argmax
        BDEC.2      LOOPG,           B_k

        ;--------------------------------------------------;
        ; The exact location of the maximum within the     ;
        ; column is searched and the index is returned     ;
        ; in MaxBuf[1]                                     ;
        ;--------------------------------------------------;

        SUB.2       B_nInputs,       16,           B_n
        ADD.2       B_n,             B_argmax,     B_i
        SUBAW.2     B_Input,         18,           B_Input
        ADDAH.2     B_Input,         B_argmax,     B_Input
        MV.2        B_i,             B_argmax

        ;--------------------------------------------------;
        ; Obtainthe index of the element that was detected ;
        ; as the maximum.                                  ;
        ;--------------------------------------------------;

LOOPS:  .trip 1
        LDH.D2T1   *B_Input--[16],  A_d0
        SUB.1       A_d0,            A_max,        A_c0
        SUB.2       B_i,             16,           B_i
 [!A_c0]MV .2       B_i,             B_argmax
  [ B_n]SUB.2       B_n,             16,           B_n
  [ B_n]B.2         LOOPS

            .return B_argmax                                    ; OPS
            .endproc
*=============================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=============================================================================*
maxval.sa/      1066929506  0     0     0       7160      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Mon Jan 21 15:38:01 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_maxval                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       07-May-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           short DSP_maxval(const short *x, int nx);                       *
*                                                                           *
*           x = address to array of values                                  *
*           nx = number of values in array                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the maximum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*   C CODE                                                                  *
*           short DSP_maxval(const short *x, int nx)                        *
*           {                                                               *
*               int  i, max;                                                *
*               max = -32768;                                               *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] > max)                                         *
*                        max = x[i];                                        *
*               return max;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx is a multiple of 8.                                              *
*       Nx is greater then or equal to 32.                                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_maxval"
        .global _DSP_maxval
_DSP_maxval: .cproc A_x, B_nx
            .no_mdep
            .reg  A_maxA, B_maxB, A_x_hi:A_x_lo
            .reg  A_compareA
            .reg  B_compareB
            .reg  A_ret, B_i

            MVKL  .1    0x80008000,   A_maxA            ; Init. max value
            MVKH  .1    0x80008000,   A_maxA            ; Init. max value
            MV    .2x   A_maxA,   B_maxB                ; Part. copy
            SHR         B_nx,     2,            B_i     ; Divide nx by 4
            SUB         B_i,      1,            B_i     ; BDEC stops at 0

LOOP:       .trip       8
            LDNDW .D1T1 *A_x++,   A_x_hi:A_x_lo         ; Load four shorts
            MAX2  .1    A_x_hi,   A_maxA,       A_maxA  ; update max
            MAX2  .2X   A_x_lo,   B_maxB,       B_maxB  ; update max
 [ B_i]     BDEC        LOOP,     B_i                   ; Loop till done

            SWAP2       A_maxA,   A_compareA            ; Swap hi and low
            SWAP2       B_maxB,   B_compareB            ;
            MAX2        A_maxA,   A_compareA,   A_maxA  ; Find A side maximum
            MAX2        B_maxB,   B_compareB,   B_maxB  ; Find B side maximum
            MAX2  .1X   A_maxA,   B_maxB,       A_maxA  ; Find overall max
            EXT         A_maxA,   16, 16,       A_ret   ; Cast to short

            .return     A_ret
            .endproc

* ========================================================================= *
*   End of file:  dsp_maxval.sa                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
minerror.sa/    1066929506  0     0     0       23113     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Mon Mar 11 22:27:07 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_minerror: Minimum Energy Error Search                           *
*                                                                           *
*   REVISION DATE                                                           *
*       30-Mar-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           const short *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       );                                                                  *
*                                                                           *
*       GSP0_TABLE[256*9] :  Pointer to GSP0 terms array.                   *
*                            Must be double-word aligned.                   *
*       errCoefs[9]       :  Array of error coefficients.                   *
*       max_index         :  Index to GSP0_TABLE[max_index], the first      *
*                            element of the 9-element vector that resulted  *
*                            in the maximum dot product.                    *
*       return int        :  Maximum dot product result.                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Performs a dot product on 256 pairs of 9 element vectors and        *
*       searches for the pair of vectors which produces the maximum dot     *
*       product result. This is a large part of the VSELP vocoder codebook  *
*       search.                                                             *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without restrictions  *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           const short *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       )                                                                   *
*       {                                                                   *
*           int val, maxVal = -50;                                          *
*           int i, j;                                                       *
*                                                                           *
*           for (i = 0; i < GSP0_NUM; i++)                                  *
*           {                                                               *
*               for (val = 0, j = 0; j < GSP0_TERMS; j++)                   *
*                   val += GSP0_TABLE[i*GSP0_TERMS+j] * errCoefs[j];        *
*                                                                           *
*               if (val > maxVal)                                           *
*               {                                                           *
*                   maxVal = val;                                           *
*                   *max_index = i*GSP0_TERMS;                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return (maxVal);                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Load double word instruction is used to simultaneously              *
*       load four values in a single clock cycle.                           *
*       The jloop is totally unrolled                                       *
*       The iloop is unrolled 4 times                                       *
*       A flag is used to set the exit program location                     *
*       The MV is used to move the data                                     *
*       The loop is software pipelined.                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Array GSP0_TABLE[] must be double-word aligned.                     *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
              .asg      9,    GSP0_TERMS
              .asg    256,    GSP0_NUM


        .sect ".text:_minerr"
        .global _DSP_minerror
_DSP_minerror: .cproc A_TB_ptr, B_coef_ptr, A_save_ptr_ret ;arg_list

            .no_mdep

        .reg            A_i         ; loop count
        .reg            A_c         ; flat for updating maxVal & savePtr
        .reg            A_max       ; return int
        .reg            A_v0        ; point0: sum of dot prod
        .reg            A_v1        ; point1: sum of dot prod
        .reg            A_v2        ; point2: sum of dot prod
        .reg            A_v3        ; point3: sum of dot prod
        .reg            A_c32:A_c10 ; = coef[3,2],coef[1,0]
        .reg            A_c76:A_c54 ; = coef[7,6],coef[5,4]
        .reg            A_tb0_32:A_tb0_10 ; = table[4i][3,2],table[4i][1,0]
        .reg            A_tb0_76:A_tb0_54 ; = table[4i][7,6],table[4i][5,4]
        .reg            A_tb2_10    ; = table[4i+2][1,0]
        .reg            A_tb2_54:A_tb2_32; = table[4i+2][5,4],table[4i+2][3,2]
        .reg            A_tb32_08:A_tb2_76; = table[4i+3][0],[4i+2][8],table[4i+2][7,6]
        .reg            A_tc0_10    ; = tc0_1 | tc0_0
        .reg            A_tc2_10    ; = tc2_1 | tc2_0
        .reg            A_tc0_32    ; = tc0_3 | tc0_2
        .reg            A_tc0_54    ; = tc0_5 | tc0_4
        .reg            A_tc0_76    ; = tc0_7 | tc0_6
        .reg            A_tc2_32    ; = tc2_3 | tc2_2
        .reg            A_tc2_54    ; = tc2_5 | tc2_4
        .reg            A_tc2_76    ; = tc2_7 | tc2_6
        .reg            A_tc3_0:A_tc2_8 ; = tc3_0, tc2_8

        .reg            B_p         ; flag to activate the compare
        .reg            B_c         ; flat for updating maxVal & savePtr
        .reg            B_TB_ptr    ; GSP0_TABLE pointer
        .reg            B_dist      ; = GSP0_TABLE[i+1]-[i] in bytes
        .reg            B_cnt       ; = GSP0_TABLE[i+1]-[0] in bytes
        .reg            B_c10       ; = coef[1,0]
        .reg            B_save      ; = B_cnt which gives max dotprod
        .reg            B_c08       ; = coef[0,8]
        .reg            B_c43:B_c21 ; = coef[4,3], coef[2,1]
        .reg            B_c87:B_c65 ; = coef[8,7], coef[6,5]
        .reg            B_tb1_21:B_tb10_08;table[4i+1][2,1]
                                          ;table[4i+1][0],[4i][8]
        .reg            B_tb1_65:B_tb1_43 ;table[4i+1][6,5]
                                          ;table[4i+1][4,3]
        .reg            B_tb1_87          ;table[4i+1][8,7]
        .reg            B_tb3_87:B_tb3_65 ;table[4i+3][8,7]
                                          ;table[4i+3][6,5]
        .reg            B_tb3_43:B_tb3_21 ;table[4i+3][4,3]
                                          ;table[4i+3][2,1]
        .reg            B_tc1_43    ; = tc1_4 | tc1_3
        .reg            B_tc1_21    ; = tc1_2 | tc1_1
        .reg            B_tc1_87    ; = tc1_8 | tc1_7
        .reg            B_tc1_65    ; = tc1_6 | tc1_5
        .reg            B_v1        ; point1: sum of dot prod
        .reg            B_tc3_65    ; = tc3_6 | tc0_5
        .reg            B_tc3_21    ; = tc3_2 | tc0_1
        .reg            B_tc3_43    ; = tc3_4 | tc0_3
        .reg            B_tc1_0:B_tc0_8; = tc1_0,tc0_8
        .reg            B_tc3_87    ; = tc3_8 | tc0_7
        .reg            B_v3        ; point3: sum of dot prod

        ;-------------------------------------------------;
        ; Error coefficient table is assumed to           ;
        ; be non-double word aligned. Hence non-          ;
        ; aligned double word wide loads are used         ;
        ; to load the 9 coefficients in different         ;
        ; alignments.                                     ;
        ;-------------------------------------------------;

        LDNDW   .D2T1   *B_coef_ptr,A_c32:A_c10           ;
        LDNDW   .D2T1   *+B_coef_ptr[1],A_c76:A_c54       ;
        LDNDW   .D2T2   *+B_coef_ptr(2),B_c43:B_c21       ;
        LDNDW   .D2T2   *+B_coef_ptr(10),B_c87:B_c65      ;

        MVK     .2     -GSP0_TERMS, B_cnt                 ; init cnt = -9
        MVK     .2     GSP0_TERMS, B_dist                 ; = 9
        MV      .2X    A_c10,      B_c10                  ; twin reg
        PACKLH2 .2     B_c10,      B_c87,     B_c08       ;
        MV      .2X    A_TB_ptr,   B_TB_ptr               ; *TABLE
        ADD     .2     B_TB_ptr,   16,        B_TB_ptr    ; = &TABLE[0][8]
        MVK     .1     GSP0_NUM,   A_i                    ; loop count = 256
        SHR     .1     A_i,        2,         A_i         ; loop count = 64
        SUB     .1     A_i,        1,         A_i         ; loop count = 63
        MVK     .1     -50,        A_max                  ; int maxVal = -50

        ;-------------------------------------------------;
        ; Use aligned loads to load the GSP0_TABLE        ;
        ; four rows at a time using twin pointers         ;
        ;-------------------------------------------------;

        LDDW    .D1T1   *A_TB_ptr++,A_tb0_32:A_tb0_10     ;
        LDDW    .D1T1   *A_TB_ptr++[4],A_tb0_76:A_tb0_54  ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb1_21:B_tb10_08    ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb1_65:B_tb1_43     ;
        LDW     .D2T2   *B_TB_ptr++[6],B_tb1_87           ;
        LDW     .D1T1   *-A_TB_ptr[1],A_tb2_10            ;
        LDDW    .D1T1   *A_TB_ptr++,A_tb2_54:A_tb2_32     ;
        LDDW    .D1T1   *A_TB_ptr++[3],A_tb32_08:A_tb2_76 ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb3_43:B_tb3_21     ;
        LDDW    .D2T2   *B_TB_ptr++[3],B_tb3_87:B_tb3_65  ;

        .mptr    A_TB_ptr, A_x+0, 72
        .mptr    B_TB_ptr, A_x+2, 72

iloop:
        ;-------------------------------------------------;
        ; Perform multiply and accumulates for row0       ;
        ; tc0_10 = b00 * c0 + b01 * c1                    ;
        ; tc0_32 = b02 * c2 + b03 * c3                    ;
        ; tc0_54 = b04 * c4 + b05 * c5                    ;
        ; tc0_76 = b06 * c6 + b07 * c7                    ;
        ; tc0_8  = b08 * c8                               ;
        ;-------------------------------------------------;

        DOTP2   .1     A_tb0_10,   A_c10,      A_tc0_10   ;
        DOTP2   .1     A_tb0_32,   A_c32,      A_tc0_32   ;
        DOTP2   .1     A_tb0_54,   A_c54,      A_tc0_54   ;
        DOTP2   .1     A_tb0_76,   A_c76,      A_tc0_76   ;
        MPY2    .2     B_tb10_08,  B_c08,      B_tc1_0:B_tc0_8;

        ;-------------------------------------------------;
        ; Perform multiply and accumulates for row1       ;
        ; tc1_0  = b10 * c0                               ;
        ; tc1_21 = b11 * c1 + b12 * c2                    ;
        ; tc1_43 = b13 * c3 + b14 * c4                    ;
        ; tc1_65 = b15 * c5 + b16 * c6                    ;
        ; tc1_87 = b17 * c7 + b18 * c8                    ;
        ;-------------------------------------------------;


        DOTP2   .2     B_tb1_21,   B_c21,      B_tc1_21   ;
        DOTP2   .2     B_tb1_43,   B_c43,      B_tc1_43   ;
        DOTP2   .2     B_tb1_65,   B_c65,      B_tc1_65   ;
        DOTP2   .2     B_tb1_87,   B_c87,      B_tc1_87   ;

        ;-------------------------------------------------;
        ; Perform multiply and accumulates for row2       ;
        ; tc2_10 = b20 * c0 + b21 * c1                    ;
        ; tc2_32 = b22 * c2 + b23 * c3                    ;
        ; tc2_54 = b24 * c4 + b25 * c5                    ;
        ; tc2_76 = b26 * c6 + b27 * c7                    ;
        ; tc2_8  = b28 * c8                               ;
        ;-------------------------------------------------;


        DOTP2   .1     A_tb2_10,   A_c10,      A_tc2_10   ;
        DOTP2   .1     A_tb2_32,   A_c32,      A_tc2_32   ;
        DOTP2   .1     A_tb2_54,   A_c54,      A_tc2_54   ;
        DOTP2   .1     A_tb2_76,   A_c76,      A_tc2_76   ;
        MPY2    .1X    A_tb32_08,  B_c08,      A_tc3_0:A_tc2_8;

        ;-------------------------------------------------;
        ; Perform multiply and accumulates for row3       ;
        ; tc3_0  = b30 * c0                               ;
        ; tc3_21 = b31 * c1 + b32 * c2                    ;
        ; tc3_43 = b33 * c3 + b34 * c4                    ;
        ; tc3_65 = b35 * c5 + b36 * c6                    ;
        ; tc3_87 = b37 * c7 + b38 * c8                    ;
        ;-------------------------------------------------;


        DOTP2   .2     B_tb3_21,   B_c21,      B_tc3_21   ;
        DOTP2   .2     B_tb3_43,   B_c43,      B_tc3_43   ;
        DOTP2   .2     B_tb3_65,   B_c65,      B_tc3_65   ;
        DOTP2   .2     B_tb3_87,   B_c87,      B_tc3_87   ;

        ;-------------------------------------------------;
        ; Zero out accumulators for four rows             ;
        ;-------------------------------------------------;

        ZERO    .1     A_v0
        ZERO    .2     B_v1
        ZERO    .1     A_v2
        ZERO    .2     B_v3

        ;-------------------------------------------------;
        ; Add partial accumulated results for row0        ;
        ; v0 += tc0_10 + tc0_32 + tc0_54 + tc0_76         ;
        ;              + tc0_8x                           ;
        ;-------------------------------------------------;

        ADD     .1     A_v0,       A_tc0_10,   A_v0       ;
        ADD     .1     A_v0,       A_tc0_32,   A_v0       ;
        ADD     .1     A_v0,       A_tc0_54,   A_v0       ;
        ADD     .1     A_v0,       A_tc0_76,   A_v0       ;
        ADD     .1X    A_v0,       B_tc0_8,    A_v0       ;

        ;-------------------------------------------------;
        ; Add partial accumulated results for row1        ;
        ; v1 += tc1_0 + tc1_21 + tc1_43 + tc1_65          ;
        ;             + tc1_87                            ;
        ;-------------------------------------------------;


        ADD     .2     B_v1,       B_tc1_0,    B_v1       ;
        ADD     .2     B_v1,       B_tc1_21,   B_v1       ;
        ADD     .2     B_v1,       B_tc1_43,   B_v1       ;
        ADD     .2     B_v1,       B_tc1_65,   B_v1       ;
        ADD     .2     B_v1,       B_tc1_87,   B_v1       ;
        MV      .1X    B_v1,       A_v1                   ;

        ;-------------------------------------------------;
        ; Add partial accumulated results for row2        ;
        ; v2 += tc2_10 + tc2_32 + tc2_54 + tc2_76         ;
        ;              + tc2_8x                           ;
        ;-------------------------------------------------;


        ADD     .1     A_v2,       A_tc2_10,   A_v2       ;
        ADD     .1     A_v2,       A_tc2_32,   A_v2       ;
        ADD     .1     A_v2,       A_tc2_54,   A_v2       ;
        ADD     .1     A_v2,       A_tc2_76,   A_v2       ;
        ADD     .1     A_v2,       A_tc2_8,    A_v2       ;

        ;-------------------------------------------------;
        ; Add partial accumulated results for row3        ;
        ; v3 += tc3_0 + tc3_21 + tc3_43 + tc3_65          ;
        ;             + tc3_87                            ;
        ;-------------------------------------------------;


        ADD     .2X    B_v3,       A_tc3_0,    B_v3       ;
        ADD     .2     B_v3,       B_tc3_21,   B_v3       ;
        ADD     .2     B_v3,       B_tc3_43,   B_v3       ;
        ADD     .2     B_v3,       B_tc3_65,   B_v3       ;
        ADD     .2     B_v3,       B_tc3_87,   B_v3       ;
        MV      .1X    B_v3,       A_v3                   ;

        ;-------------------------------------------------;
        ; Perform compare of four potential               ;
        ; candidates against maxVal. If candidate         ;
        ; is larger than maxVal, then store the           ;
        ; candidate as maxVal                             ;
        ;-------------------------------------------------;

        CMPGT   .1     A_v0,       A_max,      A_c        ;
        ADD     .2     B_cnt,      B_dist,     B_cnt      ;
  [ A_c]MV      .1     A_v0,       A_max                  ;
  [ A_c]MV      .2     B_cnt,      B_save                 ;



        CMPGT   .1     A_v1,       A_max,      A_c        ;
        ADD     .2     B_cnt,      B_dist,     B_cnt      ;
  [ A_c]MV      .1     A_v1,       A_max                  ;
  [ A_c]MV      .2     B_cnt,      B_save                 ;

        CMPGT   .1     A_v2,       A_max,      A_c        ;
        ADD     .2     B_cnt,      B_dist,     B_cnt      ;
  [ A_c]MV      .1     A_v2,       A_max                  ;
  [ A_c]MV      .2     B_cnt,      B_save                 ;

        CMPGT   .1     A_v3,       A_max,      A_c        ;
        ADD     .2     B_cnt,      B_dist,     B_cnt      ;
  [ A_c]MV      .1     A_v3,       A_max                  ;
  [ A_c]MV      .2     B_cnt,      B_save                 ;

        ;-------------------------------------------------;
        ; Use aligned loads to load the GSP0_TABLE        ;
        ; four rows at a time using twin pointers         ;
        ;-------------------------------------------------;

        LDDW    .D1T1   *A_TB_ptr++,A_tb0_32:A_tb0_10      ;
        LDDW    .D1T1   *A_TB_ptr++[4],A_tb0_76:A_tb0_54   ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb1_21:B_tb10_08     ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb1_65:B_tb1_43      ;
        LDW     .D2T2   *B_TB_ptr++[6],B_tb1_87            ;
        LDW     .D1T1   *-A_TB_ptr[1],A_tb2_10             ;
        LDDW    .D1T1   *A_TB_ptr++,A_tb2_54:A_tb2_32      ;
        LDDW    .D1T1   *A_TB_ptr++[3],A_tb32_08:A_tb2_76  ;
        LDDW    .D2T2   *B_TB_ptr++,B_tb3_43:B_tb3_21      ;
        LDDW    .D2T2   *B_TB_ptr++[3],B_tb3_87:B_tb3_65   ;

        ;--------------------------------------------------;
        ; Use predicated form of BDEC to stop              ;
        ; looping when i is 0                              ;
        ;--------------------------------------------------;

  [ A_i]BDEC    iloop,      A_i                            ;

        ;--------------------------------------------------;
        ; Store out saved value and return maximum         ;
        ;--------------------------------------------------;

        STW     .D1T2   B_save,     *A_save_ptr_ret        ;
        .return  A_max
        .endproc

*===========================================================================*
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*===========================================================================*

minval.sa/      1066929506  0     0     0       7081      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Mon Jan 21 16:47:48 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_minval                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       07-May-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           short DSP_minval(const short *x, int nx);                       *
*                                                                           *
*           x = address to array of values                                  *
*           nx = number of values in array                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the minimum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*           short DSP_minval(const short *x, int nx)                        *
*           {                                                               *
*               int  i, min;                                                *
*               min = 32767;                                                *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] < min)                                         *
*                        min = x[i];                                        *
*               return min;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx is a multiple of 4.                                              *
*       Nx is greater then or equal to 20.                                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_minval"
        .global _DSP_minval
_DSP_minval: .cproc A_x, B_nx
            .no_mdep
            .reg  A_minA, B_minB, A_x_hi:A_x_lo
            .reg  A_compareA
            .reg  B_compareB
            .reg  A_ret, B_i

            MVKL  .1    0x7FFF7FFF,   A_minA            ; Init. min value
            MVKH  .1    0x7FFF7FFF,   A_minA            ; Init. min value
            MV    .2x   A_minA,   B_minB                ; Part. copy
            SHR         B_nx,     2,            B_i     ; Divide nx by 4
            SUB         B_i,      1,            B_i     ; BDEC stops at 0

LOOP:       .trip       8
            LDNDW .D1T1 *A_x++,   A_x_hi:A_x_lo         ; Load four shorts
            MIN2  .1    A_x_hi,   A_minA,       A_minA  ; update min
            MIN2  .2X   A_x_lo,   B_minB,       B_minB  ; update min
 [ B_i]     BDEC        LOOP,     B_i                   ; Loop till done

            SWAP2       A_minA,   A_compareA            ; Swap hi and low
            SWAP2       B_minB,   B_compareB            ;
            MIN2        A_minA,   A_compareA,   A_minA  ; Find A side minimum
            MIN2        B_minB,   B_compareB,   B_minB  ; Find B side minimum
            MIN2  .1X   A_minA,   B_minB,       A_minA  ; Find overall min
            EXT         A_minA,   16, 16,       A_ret   ; Cast to short

            .return     A_ret
            .endproc

* ========================================================================= *
*   End of file:  dsp_minval.sa                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mul32.sa/       1066929506  0     0     0       19345     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Fri Mar 29 19:26:27 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       DSP_mul32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mul32                                                  *
*           (                                                               *
*               const int    *x,   /* Input array of length nx  */          *
*               const int    *y,   /* Input array of length nx  */          *
*               int *restrict r,   /* Output array of length nx */          *
*               int           nx   /* Number of elements.       */          *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs a 32-bit by 32-bit multiply, returning the    *
*       upper 32 bits of the 64-bit result.  This is equivalent to a        *
*       Q31 x Q31 multiply, yielding a Q30 result.                          *
*                                                                           *
*       The 32 x 32 multiply is constructed from 16 x 16 multiplies.        *
*       For efficiency reasons, the 'lo * lo' term of the 32 x 32           *
*       multiply is omitted, as it has minimal impact on the final          *
*       result.  This is due to the fact that the 'lo * lo' term            *
*       primarily affects the lower 32 bits of the result, and these        *
*       are not returned.  Due to this omission, the results of this        *
*       function differ from the exact results of a 32 x 32 multiply by     *
*       at most 1.                                                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm without      *
*       restrictions.  This implementation may have restrictions,           *
*       as noted under "ASSUMPTIONS" below.                                 *
*                                                                           *
*       void DSP_mul32                                                      *
*       (                                                                   *
*           const int    *x,   /* Input array of length nx  */              *
*           const int    *y,   /* Input array of length nx  */              *
*           int *restrict r,   /* Output array of length nx */              *
*           int           nx   /* Number of elements.       */              *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               short           a_hi, b_hi;                                 *
*               unsigned short  a_lo, b_lo;                                 *
*               int             hihi, lohi, hilo, hllh;                     *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  A full 32x32 multiply can be constructed from   */      *
*               /*  four 16x16 multiplies.  If you divide the two   */      *
*               /*  32-bit multiplicands into hi and lo halves,     */      *
*               /*  then the 32x32 product is constructed from the  */      *
*               /*  sum of 'hi * hi', 'hi * lo', 'lo * hi', and     */      *
*               /*  'lo * lo', each shifted appropriately.  The     */      *
*               /*  'hi' terms are signed terms, and the 'lo'       */      *
*               /*  terms are unsigned.                             */      *
*               /* ------------------------------------------------ */      *
*               a_hi = (short)(x[i] >> 16);                                 *
*               b_hi = (short)(y[i] >> 16);                                 *
*               a_lo = (unsigned short)x[i];                                *
*               b_lo = (unsigned short)y[i];                                *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  For our result alignment, the 'hi * hi' term    */      *
*               /*  requires no shift.                              */      *
*               /* ------------------------------------------------ */      *
*               hihi = a_hi * b_hi;                                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  The 'lo * hi' and the 'hi * lo' terms will      */      *
*               /*  both be shifted right by 16.  Therefore, we     */      *
*               /*  will compute them, then add them together.      */      *
*               /*  Note that this sum can be 33 bits long, and we  */      *
*               /*  need the upper 17 bits of that 33-bit sum.      */      *
*               /*  Hence, we use longs.                            */      *
*               /* ------------------------------------------------ */      *
*               hilo = a_hi * b_lo;                                         *
*               lohi = a_lo * b_hi;                                         *
*               hllh = (hilo + (long)lohi) >> 16;                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Merge the middle and upper sums to form the     */      *
*               /*  final result.                                   */      *
*               /* ------------------------------------------------ */      *
*               r[i] = hihi + hllh;                                         *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The MPYHI instruction is used to perform a 16 by 32 multiply        *
*       to form a 48 bit result.  This reduces the number of multiplies     *
*       required by the algorithm from 3 to 2.                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       "nx" is a multiple of 8.                                            *
*       "nx" is greater than or equal to 16, multiple of 8.                 *
*       input and output vectors are double word aligned.                   *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This function is ENDIAN NEUTRAL.                                    *
*                                                                           *
*   NOTES                                                                   *
*       The 32x32 multiply is an approximation, as described above.         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_mul32"
        .global _DSP_mul32
_DSP_mul32:  .cproc A_x, B_y, A_r, B_nx

             .reg   A_i,           A_x1:A_x0,   A_y1:A_y0
             .reg   A_xhigh0,      A_xlow0
             .reg   A_xhigh1,      A_xlow1
             .reg   A_xh0:A_xl0,   A_p1:A_p0
             .reg   A_xh1:A_xl1,   A_p3:A_p2
             .reg   A_xhi0,        A_c0
             .reg   A_xhi1,        A_c1
             .reg   A_s1:A_s0

             .reg   B_xhigh2,      B_xlow2
             .reg   B_xhigh3,      B_xlow3
             .reg   B_xh2:B_xl2,   B_p5:B_p4
             .reg   B_xh3:B_xl3,   B_p7:B_p6
             .reg   B_xhi2,        B_c2
             .reg   B_xhi3,        B_c3
             .reg   B_s3:B_s2,     B_x3:B_x2
             .reg   B_y3:B_y2

             .reg   A_x5:A_x4,     A_y5:A_y4
             .reg   A_xhigh4,      A_xlow4
             .reg   A_xhigh5,      A_xlow5
             .reg   A_xh4:A_xl4,   A_p9:A_p8
             .reg   A_xh5:A_xl5,   A_pB:A_pA
             .reg   A_xhi4,        A_c4
             .reg   A_xhi5,        A_c5
             .reg   A_s5:A_s4

             .reg   B_xhigh6,      B_xlow6
             .reg   B_xhigh7,      B_xlow7
             .reg   B_xh6:B_xl6,   B_pD:B_pC
             .reg   B_xh7:B_xl7,   B_pF:B_pE
             .reg   B_xhi6,        B_c6
             .reg   B_xhi7,        B_c7
             .reg   B_s7:B_s6,     B_x7:B_x6
             .reg   B_y7:B_y6

             .reg   B_x,           A_y,          B_r

             .no_mdep

             ;-------------------------------------------------------------;
             ; Loop trip count is nx /8. Deduct 2 for DEC from trip count  ;
             ;-------------------------------------------------------------;

             SHR.2     B_nx,            3,               B_nx
             SUB.1x    B_nx,            2,               A_i

             ;-------------------------------------------------------------;
             ; Twin pointers for input data access and output writes       ;
             ;-------------------------------------------------------------;

             ADD.2x    A_x,             8,               B_x
             ADD.1x    B_y,             8,               A_y
             ADD.2x    A_r,             8,               B_r

             ;-------------------------------------------------------------;
             ; The worst case alignment is assumed where, all arrays "x"   ;
             ; "y" and "r" are all in the same bank.                       ;
             ;-------------------------------------------------------------;

             .mptr  A_x, x+0, 32
             .mptr  B_x, x+8, 32
             .mptr  B_y, y+0, 32
             .mptr  A_y, y+8, 32
             .mptr  A_r, r+0, 32
             .mptr  B_r, r+8, 32


LOOP:        .trip 2

             ;------------------------------------------------------------;
             ; Load input data from "x" and "y" arrays using twin pointers;
             ;------------------------------------------------------------;
             LDDW.D1T1 *A_x++[2],       A_x1:A_x0
             LDDW.D2T2 *B_x++[2],       B_x3:B_x2
             LDDW.D1T1 *A_x++[2],       A_x5:A_x4
             LDDW.D2T2 *B_x++[2],       B_x7:B_x6

             LDDW.D2T1 *B_y++[2],       A_y1:A_y0
             LDDW.D1T2 *A_y++[2],       B_y3:B_y2
             LDDW.D2T1 *B_y++[2],       A_y5:A_y4
             LDDW.D1T2 *A_y++[2],       B_y7:B_y6

             ;-------------------------------------------------------------;
             ; Perform multiplies for 8 inputs, using MPYHI and MPYLUHS.   ;
             ; Add intermediate results using 40 bit adds. Pack the        ;
             ; results to form 32 bit quantity. Outputs are A_s0..A_s7     ;
             ; and are stored out to the output array using twin data      ;
             ; pointers.                                                   ;
             ;-------------------------------------------------------------;


             MPYHI.1   A_x0,            A_y0,            A_xh0:A_xl0
             MPYLUHS.1 A_x0,            A_y0,            A_xlow0
             SHR.1     A_xlow0,         31,              A_c0
             ADDU.1    A_xl0,           A_xlow0,         A_p1:A_p0
             ADD.1     A_xh0,           A_p1,            A_xhigh0
             ADD.1     A_xhigh0,        A_c0,            A_xhi0
             PACKLH2.1 A_xhi0,          A_p0,            A_s0

             MPYHI.1   A_x1,            A_y1,            A_xh1:A_xl1
             MPYLUHS.1 A_x1,            A_y1,            A_xlow1
             SHR.1     A_xlow1,         31,              A_c1
             ADDU.1    A_xl1,           A_xlow1,         A_p3:A_p2
             ADD.1     A_xh1,           A_p3,            A_xhigh1
             ADD.1     A_xhigh1,        A_c1,            A_xhi1
             PACKLH2.1 A_xhi1,          A_p2,            A_s1

             MPYHI.2   B_x2,            B_y2,            B_xh2:B_xl2
             MPYLUHS.2 B_x2,            B_y2,            B_xlow2
             SHR.2     B_xlow2,         31,              B_c2
             ADDU.2    B_xl2,           B_xlow2,         B_p5:B_p4
             ADD.2     B_xh2,           B_p5,            B_xhigh2
             ADD.2     B_xhigh2,        B_c2,            B_xhi2
             PACKLH2.2 B_xhi2,          B_p4,            B_s2

             MPYHI.2   B_x3,            B_y3,            B_xh3:B_xl3
             MPYLUHS.2 B_x3,            B_y3,            B_xlow3
             SHR.2     B_xlow3,         31,              B_c3
             ADDU.2    B_xl3,           B_xlow3,         B_p7:B_p6
             ADD.2     B_xh3,           B_p7,            B_xhigh3
             ADD.2     B_xhigh3,        B_c3,            B_xhi3
             PACKLH2.2 B_xhi3,          B_p6,            B_s3

             MPYHI.1   A_x4,            A_y4,            A_xh4:A_xl4
             MPYLUHS.1 A_x4,            A_y4,            A_xlow4
             SHR.1     A_xlow4,         31,              A_c4
             ADDU.1    A_xl4,           A_xlow4,         A_p9:A_p8
             ADD.1     A_xh4,           A_p9,            A_xhigh4
             ADD.1     A_xhigh4,        A_c4,            A_xhi4
             PACKLH2.1 A_xhi4,          A_p8,            A_s4

             MPYHI.1   A_x5,            A_y5,            A_xh5:A_xl5
             MPYLUHS.1 A_x5,            A_y5,            A_xlow5
             SHR.1     A_xlow5,         31,              A_c5
             ADDU.1    A_xl5,           A_xlow5,         A_pB:A_pA
             ADD.1     A_xh5,           A_pB,            A_xhigh5
             ADD.1     A_xhigh5,        A_c5,            A_xhi5
             PACKLH2.1 A_xhi5,          A_pA,            A_s5

             MPYHI.2   B_x6,            B_y6,            B_xh6:B_xl6
             MPYLUHS.2 B_x6,            B_y6,            B_xlow6
             SHR.2     B_xlow6,         31,              B_c6
             ADDU.2    B_xl6,           B_xlow6,         B_pD:B_pC
             ADD.2     B_xh6,           B_pD,            B_xhigh6
             ADD.2     B_xhigh6,        B_c6,            B_xhi6
             PACKLH2.2 B_xhi6,          B_pC,            B_s6

             MPYHI.2   B_x7,            B_y7,            B_xh7:B_xl7
             MPYLUHS.2 B_x7,            B_y7,            B_xlow7
             SHR.2     B_xlow7,         31,              B_c7
             ADDU.2    B_xl7,           B_xlow7,         B_pF:B_pE
             ADD.2     B_xh7,           B_pF,            B_xhigh7
             ADD.2     B_xhigh7,        B_c7,            B_xhi7
             PACKLH2.2 B_xhi7,          B_pE,            B_s7

             STDW.D1T1 A_s1:A_s0,       *A_r++[2]
             STDW.D2T2 B_s3:B_s2,       *B_r++[2]
             STDW.D1T1 A_s5:A_s4,       *A_r++[2]
             STDW.D2T2 B_s7:B_s6,       *B_r++[2]

             BDEC.1    LOOP,            A_i

             .return
             .endproc

* ========================================================================= *
*   End of file:  dsp_mul32.sa                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

neg32.sa/       1066929506  0     0     0       7321      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Mon Dec 10 20:54:21 2001 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_neg32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and may be called using the following   *
*       C function prototype:                                               *
*                                                                           *
*           void DSP_neg32                                                  *
*           (                                                               *
*               int   *x,      /* Input data array     */                   *
*               int   *r,      /* Output data array    */                   *
*               short nx       /* Number of elements.  */                   *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine negates an array of 32-bit integers, and stores        *
*       the result either in a new array, or back to the same array.        *
*                                                                           *
*           void DSP_neg32                                                  *
*           (                                                               *
*               int   *x,      /* Input data array     */                   *
*               int   *r,      /* Output data array    */                   *
*               short nx       /* Number of elements.  */                   *
*           )                                                               *
*           {                                                               *
*               int i;                                                      *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   r[i] = -x[i];                                           *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input must be at least 8 elements long, and a multiple of 4.    *
*                                                                           *
*       The input and output arrays must not overlap, except in the         *
*       special case where the input and output pointers are exactly        *
*       equal.                                                              *
*                                                                           *
*       The x and r arrays must be double-word aligned                      *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_neg32"
        .global _DSP_neg32
_DSP_neg32: .cproc A_x, B_r, A_nx

            .no_mdep

            .reg  B_x,         A_r,     A_x1:A_x0
            .reg  B_x3:B_x2,   A_rx1:A_rx0
            .reg  B_rx3:B_rx2

            SHR.1   A_nx,     2,        A_nx
            SUB.1   A_nx,     2,        A_nx
            ADD.2x  A_x,      8,        B_x
            ADD.1x  B_r,      8,        A_r

            .mptr   A_x, x+0, 16
            .mptr   B_x, x+8, 16
            .mptr   A_r, x+0, 16
            .mptr   B_r, x+8, 16

LOOP:       .trip 2
            LDDW.D1T1   *A_x++[2],      A_x1:A_x0    ;
            LDDW.D2T2   *B_x++[2],      B_x3:B_x2    ;

            NEG.1        A_x1,          A_rx1        ;
            NEG.1        A_x0,          A_rx0        ;
            NEG.2        B_x3,          B_rx3        ;
            NEG.2        B_x2,          B_rx2        ;

            STDW.D2T1    A_rx1:A_rx0,   *B_r++[2]    ;
            STDW.D1T2    B_rx3:B_rx2,   *A_r++[2]    ;

            BDEC.1       LOOP,          A_nx         ;

           .endproc


* ========================================================================= *
*   End of file:  dsp_neg32.sa                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

q15tofl.sa/     1066929506  0     0     0       8749      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.4     Mon Mar 11 20:57:08 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_q15tofl -- Q.15 to IEEE float conversion                        *
*                                                                           *
*   REVISION DATE                                                           *
*       17-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_q15tofl (short *x, float *r, int nx)                   *
*                                                                           *
*           x[nx]  ---  Pointer to Q15 input vector of size nx              *
*           r[nx]  ---  Pointer to floating-point output data vector        *
*                       of size nx containing the floating-point equivalent *
*                       of vector input                                     *
*           nx     ---  length of input and output data vectors             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       Converts the Q15 stored in vector input to IEEE floating point      *
*       numbers stored in vector output.                                    *
*                                                                           *
*       void DSP_q15tofl (short *x, float *r, int nx)                       *
*       {                                                                   *
*        int i;                                                             *
*                                                                           *
*        for (i=0;i<nx;i++)                                                 *
*             r[i]=(float)x[i]/0x8000;                                      *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code may have some restrictions, as     *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       unrolled loop 2x                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >=2 and multiple of 2                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .sect ".text:_q15tofl"
        .global _DSP_q15tofl
_DSP_q15tofl: .cproc A_q15_ptr, B_float_ptr, A_n  

        .no_mdep

        .reg    B_mask, A_offset

        .reg    B_input_1, B_input_cp_1, A_exp_1, B_sign_1, B_u_float_1
        .reg    B_float32_1, A_mant_1
        .reg    A_inputa_1, A_mants_1, A_exp128_1, B_exp128s_1

        .reg    B_input_2, B_input_cp_2, A_exp_2, B_sign_2, B_u_float_2
        .reg    B_float32_2, A_mant_2
        .reg    A_inputa_2, A_mants_2, A_exp128_2, B_exp128s_2

        .mptr   A_q15_ptr,      a, 4
        .mptr   B_float_ptr,    b, 8

        MVK     143,    A_offset            ;IEEE uses offset 127 exponent
        MVK     0x1,    B_mask
        SHL     B_mask, 31,     B_mask      ;set mask = 0x80000000

        SHR     A_n,      1,      A_n
        SUB     A_n,      2,      A_n

loop:

; 1st iteration:
        LDH     *A_q15_ptr++,   B_input_1                ;read input value
        MV      B_input_1,      B_input_cp_1
        AND     B_input_cp_1,   B_mask,       B_sign_1   ;sign bit
        ABS     B_input_1,      A_inputa_1               ;make positive
        LMBD    1,              A_inputa_1,   A_exp_1    ;significant bit
        ROTL    A_inputa_1,     A_exp_1,      A_mant_1   ;normalize mantissa
        EXTU    A_mant_1,       1, 9,         A_mants_1  ;get rid of implied
                                                         ;1 and shift
[A_inputa_1]SUB A_offset,       A_exp_1,      A_exp128_1 ;generate exponent
[!A_inputa_1]MPY 0,             A_exp128_1,   A_exp128_1 ;zero exp if input=0
        SHL     A_exp128_1,     23,           B_exp128s_1;shift exp in place
        OR      A_mants_1,      B_exp128s_1,  B_u_float_1;or exp and mantissa
        OR      B_u_float_1,    B_sign_1,     B_float32_1;replace the sign
        STW     B_float32_1,    *B_float_ptr++           ;store the float

; 2nd iteration:
        LDH     *A_q15_ptr++,   B_input_2
        MV      B_input_2,      B_input_cp_2
        AND     B_input_cp_2,   B_mask,         B_sign_2
        ABS     B_input_2,      A_inputa_2
        LMBD    1,              A_inputa_2,     A_exp_2
        ROTL    A_inputa_2,     A_exp_2,        A_mant_2
        EXTU    A_mant_2,       1, 9,           A_mants_2
[A_inputa_2]SUB A_offset,       A_exp_2,        A_exp128_2
[!A_inputa_2]MPY 0,             A_exp128_2,     A_exp128_2
        SHL     A_exp128_2,     23,             B_exp128s_2
        OR      A_mants_2,      B_exp128s_2,    B_u_float_2
        OR      B_u_float_2,    B_sign_2,       B_float32_2
        STW     B_float32_2,    *B_float_ptr++
        BDEC    loop,           A_n

        .endproc

* ========================================================================= *
*   End of file:  dsp_q15tofl.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

recip16.sa/     1066929506  0     0     0       10566     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.3     Mon Mar  4 02:24:21 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_recip16                                                         *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx);   *
*                                                                           *
*       x[nx]     = Pointer to input vector of size nx                      *
*       rfrac[nx] = Pointer to output vector of size nx to                  *
*                   contain the fractional part of the reciprocal           *
*       rexp[nx]  = Pointer to output vector of size nx to                  *
*                   contain the exponent part of the reciprocal             *
*       nx        = Number of elements in input vector                      *
*                                                                           *
*       (See the C compiler reference guide.)                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This program performs a reciprocal on a vector of Q15 numbers.      *
*       The result is stored in two parts: a Q15 part and an exponent       *
*       (power of two) of the fraction.                                     *
*       First, the input is loaded, then its absolute value is taken,       *
*       then it is normalized, then divided using a loop of conditional     *
*       subtracts, and finally it is negated if the original input was      *
*       negative.                                                           *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx)    *
*       {                                                                   *
*          int i,j,a,b;                                                     *
*          short neg, normal;                                               *
*                                                                           *
*          for(i = nx; i > 0; i--)                                          *
*          {                                                                *
*              a = *(x++);                                                  *
*              if(a < 0)             /* take absolute value */              *
*              {                                                            *
*                  a = -a;                                                  *
*                  neg = 1;                                                 *
*              }                                                            *
*              else                                                         *
*                  neg = 0;                                                 *
*              normal = _norm(a);              /* normalize */              *
*              a = a << normal;                                             *
*              *(rexp++) = normal - 15;   /* store exponent */              *
*              b = 0x80000000;              /* dividend = 1 */              *
*              for(j = 15; j > 0; j--)                                      *
*                  b = _subc(b,a);                /* divide */              *
*              b = b & 0x7FFF;           /* clear remainder */              *
*              if(neg) b = -b;       /* if negative, negate */              *
*              *(rfrac++) = b;            /* store fraction */              *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       LITTLE ENDIAN Configuration used                                    *
*       x and rfrac are Q15 format                                          *
*       output is accurate up to the least significant bit of rfrac, but    *
*       note that this bit could carry over and change rexp too             *
*                                                                           *
*   TECHNIQUES                                                              *
*       The conditional subtract instruction, SUBC, is used for division    *
*       SUBC is used once for every bit of quotient needed (15).            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .sect ".data:copyright_p"

        .sect ".text:_recip16"
        .global _DSP_recip16
_DSP_recip16 .cproc A_x, B_rfrac, A_rexp, B_nx
            .no_mdep
;                  A4,  B4,      A6,     B6

            .reg    A_a, A_neg, A_neg_st, A_n, B_norm, A_norm
            .reg    A_b, A_b1, A_b2, A_b3, A_b4, A_b5, A_b6, A_b7
            .reg    B_b7, B_b8, B_b9, B_b10, B_b11, B_b12, B_b13, B_b14
            .reg    B_b15, B_bc
            .reg    B_exp

            .mptr   A_x,     a, 2
            .mptr   A_rexp,  b, 2
            .mptr   B_rfrac, c, 2

            ZERO    .1      A_b
            MVKH    .1      0x80000000, A_b             ; dividend=1
            SUB     .2      B_nx,       2,      B_nx

loop:      .trip 1
            LDH             *A_x++,     A_a             ; load value
            SHR             A_a,        31,     A_neg
  [A_neg]   NEG             A_a,        A_a             ; yes: take abs

            NORM            A_a,        A_n
            SHL             A_a,        A_n,    A_norm  ; normalized val

            SUB             A_n,        15,     B_exp   ; determine exp
            STH             B_exp,      *A_rexp++       ; store exp

            SUBC    .1      A_b,        A_norm, A_b1    ; 15x SUBC
            SUBC    .1      A_b1,       A_norm, A_b2
            SUBC    .1      A_b2,       A_norm, A_b3
            SUBC    .1      A_b3,       A_norm, A_b4
            SUBC    .1      A_b4,       A_norm, A_b5

            SUBC    .1      A_b5,       A_norm, A_b6
            SUBC    .1      A_b6,       A_norm, A_b7
            MV      .2      A_b7,       B_b7
            MV      .2      A_norm,     B_norm          ; copy
            SUBC    .2      B_b7,       B_norm, B_b8
            SUBC    .2      B_b8,       B_norm, B_b9
            SUBC    .2      B_b9,       B_norm, B_b10

            SUBC    .2      B_b10,      B_norm, B_b11
            SUBC    .2      B_b11,      B_norm, B_b12
            SUBC    .2      B_b12,      B_norm, B_b13
            SUBC    .2      B_b13,      B_norm, B_b14
            SUBC    .2      B_b14,      B_norm, B_b15

            CLR             B_b15,      15, 31, B_bc    ; clear upper bits
 [A_neg]    NEG             B_bc,       B_bc            ; if neg, negate
            STH             B_bc,       *B_rfrac++      ; store fraction

            BDEC            loop,       B_nx

            .endproc

* ========================================================================= *
*   End of file:  dsp_recip16.sa                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
vecsumsq.sa/    1066929506  0     0     0       7867      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.5     Fri Mar 29 20:52:29 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_vecsumsq                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Aug-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           );                                                              *
*                                                                           *
*       This routine returns the sum of squares as its return value.        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The "DSP_vecsumsq" function returns the sum of squares of the       *
*       elements contained in vector "x".                                   *
*                                                                           *
*   C CODE                                                                  *
*       The following C code is a general implementation without            *
*       restrictions.  This implementation may have restrictions, as        *
*       noted under "ASSUMPTIONS" below.                                    *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           )                                                               *
*           {                                                               *
*               int i, sum = 0;                                             *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   sum += x[i] * x[i];                                     *
*                                                                           *
*               return sum;                                                 *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 4 times to enable full memory and multiplier   *
*       bandwidth to be utilized.                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input length is a multiple of 4 and at >= 12.                   *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This function is ENDIAN NEUTRAL.                                    *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .sect ".text:_vecsum_sq"
        .global _DSP_vecsumsq
_DSP_vecsumsq: .cproc  A_x, B_count

             .no_mdep
             .reg   A_reg1:A_reg0, B_reg1
             .reg   A_prod, B_prod, A_sum, B_sum, B_i

             ZERO.1      A_sum
             ZERO.2      B_sum
             SHRU.2      B_count, 2,      B_i
             SUB.2       B_i,     2,      B_i

             .mptr       A_x,     x + 0,  8
LOOP:        .trip 3

             LDNDW.D1T1  *A_x++,  A_reg1:A_reg0
             MV.2x       A_reg1,  B_reg1
             DOTP2.1     A_reg0,  A_reg0, A_prod
             DOTP2.2     B_reg1,  B_reg1, B_prod
             ADD.1       A_sum,   A_prod, A_sum
             ADD.2       B_sum,   B_prod, B_sum
             BDEC.2      LOOP,    B_i

             ADD.1x      A_sum,   B_sum,  A_sum

             .return  A_sum
             .endproc

* ======================================================================= *
*   End of file:  dsp_vecsumsq.sa                                         *
* ----------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ======================================================================= *

w_vec.sa/       1066929506  0     0     0       9312      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Revision 1.04b                                      *;
;*      CVS Revision:   1.6     Fri Mar 29 21:05:03 2002 (UTC)              *;
;*      Snapshot date:  23-Oct-2003                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2003 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_w_vec: Weighted vector sum                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs a weighted vector sum.  The elements         *
*       of the x[] vector are weighted according to the Q15 value 'm',      *
*       and then added to the corresponding elements of the y[] vector.     *
*       The results are written to the r[] vector.                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm.  This       *
*       implementation may have restrictions, as noted under                *
*       "ASSUMPTIONS" below.                                                *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           )                                                               *
*           {                                                               *
*               int i;                                                      *
*                                                                           *
*               for (i = 0; i < nr; i++)                                    *
*                   r[i] = ((m * x[i]) >> 15) + y[i];                       *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       m is not -32768.                                                    *
*       nr >= 8, nr is multiple of eight.                                   *
*       Input and output arrays must be double-word aligned.                *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double words for input data.                               *
*       2.  Use packed data processing to sustain throughput.               *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .sect ".text:_w_vec"
        .global _DSP_w_vec
_DSP_w_vec: .cproc A_x, B_y, A_m, B_r, A_nr
        .no_mdep
        .reg B_x, A_y, A_r, A_i, A_w
        .reg B_x76:B_x54, A_x32:A_x10
        .reg B_y76:B_y54, A_y32:A_y10
        .reg B_r76:B_r54, A_r32:A_r10
        .reg B_wx7:B_wx6, B_wx5:B_wx4, B_wx76, B_wx54
        .reg A_wx3:A_wx2, A_wx1:A_wx0, A_wx32, A_wx10

        ADD2        A_wx10,       A_y10,        A_r10
        SHR.1       A_nr,         3,             A_nr
        SUB.1       A_nr,         1,             A_i

        PACK2.1     A_m,          A_m,           A_w
        ADD.2x      A_x,          8,             B_x
        ADD.1x      B_y,          8,             A_y
        ADD.1x      B_r,          8,             A_r

        .mptr       A_x, x+0, 16
        .mptr       B_x, x+8, 16
        .mptr       A_y, y+8, 16
        .mptr       B_y, y+0, 16
        .mptr       A_r, r+8, 16
        .mptr       B_r, r+0, 16
LOOP:
        LDDW.D2T2   *B_x++[2],    B_x76:B_x54
        LDDW.D1T1   *A_x++[2],    A_x32:A_x10
        LDDW.D1T2   *A_y++[2],    B_y76:B_y54
        LDDW.D2T1   *B_y++[2],    A_y32:A_y10

        SMPY2  .2X  A_w,          B_x76,        B_wx7:B_wx6
        SMPY2  .2X  A_w,          B_x54,        B_wx5:B_wx4
        PACKH2      B_wx7,        B_wx6,        B_wx76
        PACKH2      B_wx5,        B_wx4,        B_wx54
        ADD2        B_wx76,       B_y76,        B_r76
        ADD2        B_wx54,       B_y54,        B_r54

        SMPY2       A_w,          A_x32,        A_wx3:A_wx2
        SMPY2       A_w,          A_x10,        A_wx1:A_wx0
        PACKH2      A_wx3,        A_wx2,        A_wx32
        PACKH2      A_wx1,        A_wx0,        A_wx10
        ADD2        A_wx32,       A_y32,        A_r32
        ADD2        A_wx10,       A_y10,        A_r10

        STDW.D1T2   B_r76:B_r54,  *A_r++[2]
        STDW.D2T1   A_r32:A_r10,  *B_r++[2]

 [A_i]  BDEC.1      LOOP,         A_i
        .endproc

* ========================================================================= *
*   End of file:  dsp_w_vec.sa                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
